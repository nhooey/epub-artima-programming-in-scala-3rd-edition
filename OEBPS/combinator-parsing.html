<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8"/>
    <title>Programming in Scala, 3rd Edition</title>

    <link rel="stylesheet" type="text/css" href="book.css" />
  </head>
<body>
<h2><a id="chap-combinator-parsing">Chapter 33</a></h2>
<h1>Combinator Parsing</h1>


<p>Occasionally, you may need to process a small, special-purpose
language.<a id="i1395246279-1"/>  For example,
you may need to read configuration files for your software, and you want
to make them easier to modify by hand than XML.  Alternatively, maybe
you want to support an input language in your program, such as search
terms with boolean operators (computer, find me a movie "with `space
ships' and without `love stories"').  Whatever the reason, you are
going to need a <em>parser</em>.<a id="i-792967116-1"/>  You need a way to convert the input
language into some data structure your software can process.</p>

<p>Essentially, you have only a few choices.  One choice is to roll your
own parser (and lexical analyzer).  If you are not an expert, this is
hard. If you are an expert, it is still time consuming.</p>

<p>An alternative choice is to use a parser generator.<a id="i-1495136757-1"/>  There exist
quite a few of these generators. Some of the better known are Yacc and
Bison for parsers written in C and ANTLR for parsers written in
Java.<a id="i-606539021-1"/><a id="i2747784-1"/><a id="i64194507-1"/><a id="i62435725-1"/><a id="i-679763866-1"/> You'll probably also need a scanner generator such as Lex, Flex,
or JFlex to go with
it.<a id="i76287-1"/><a id="i2192409-1"/><a id="i70532963-1"/><a id="i-693168286-1"/> This might be the best solution, except for a
couple of inconveniences. You need to learn new tools, including
their&mdash;sometimes obscure&mdash;error messages. You also need to figure out
how to connect the output of these tools to your program. This might
limit the choice of your programming language, and complicate your
tool chain.</p>

<p>This chapter presents a third alternative. Instead of using the
standalone domain specific language of a parser generator, you will
use an <span style="font-style:italic">internal domain specific language</span>, or internal DSL for
short.<a id="i-1137790491-1"/>  The internal DSL will consist of a library of <span style="font-style:italic">parser
combinators</span>&mdash;functions and operators defined in Scala that
will serve as building blocks for parsers.<a id="i-2095840458-1"/> These building blocks will map one to one to the constructions of a context-free grammar, to make them
easy to understand.<a id="i-581215934-1"/></p>

<p>This chapter introduces only one language feature that was not
explained before: <pre class="code">this</pre> aliasing, in
<a href="combinator-parsing.html#sec-this-aliasing">Section 33.6</a>. The chapter does, however, heavily use several
other features that were explained in previous chapters. Among others,
parameterized types, abstract types, functions as objects, operator
overloading, by-name parameters, and implicit conversions all play
important roles. The chapter shows how these language elements can be
combined in the design of a very high-level library.</p>

<p>The concepts explained in this chapter tend to be a bit more advanced
than previous chapters. If you have a good grounding in compiler
construction, you'll profit from it reading this chapter, because it
will help you put things better in perspective. However, the only
prerequisite for understanding this chapter is that you know about
regular and context-free grammars. If you don't, the material in this
chapter can also safely be skipped.</p>

<h3 id="sec-arith">33.1 Example: Arithmetic expressions</h3>


<p>We'll start with an example. Say you want to construct a parser for
arithmetic expressions consisting of floating-point numbers, parentheses, and
the binary operators <pre class="code">+</pre>, <pre class="code">-</pre>, <pre class="code">*</pre>, and <pre class="code">/</pre>. The first step is
always to write down a grammar for the language to be parsed. Here's the grammar for
arithmetic expressions:</p>

<div style="text-align: center">


<table style="border-collapse: collapse">
<tr>
  <td>
    <span style="font-style:italic">expr</span>
  </td>
  <td>
    ::=
  </td>
  <td>
    <span style="font-style:italic">term</span> &nbsp;\{<pre class="code">"+"</pre>&nbsp; <span style="font-style:italic">term</span> &nbsp;|&nbsp; <pre class="code">"-"</pre> &nbsp;<span style="font-style:italic">term</span>\}.
  </td>
</tr>
<tr>
  <td>
    <span style="font-style:italic">term</span>
  </td>
  <td>
    ::=
  </td>
  <td>
    <span style="font-style:italic">factor</span> &nbsp;\{<pre class="code">"*"</pre>&nbsp; <span style="font-style:italic">factor</span> &nbsp;|&nbsp; <pre class="code">"/"</pre> &nbsp;<span style="font-style:italic">factor</span>\}.
  </td>
</tr>
<tr>
  <td>
    <span style="font-style:italic">factor</span>
  </td>
  <td>
    ::=
  </td>
  <td>
    <span style="font-style:italic">floatingPointNumber</span> &nbsp;|&nbsp; <pre class="code">"("</pre>&nbsp; <span style="font-style:italic">expr</span> &nbsp;<pre class="code">")"</pre>.
  </td>
</tr>
</table>


</div>


<p>Here, | denotes alternative productions, and \{ ...  \} denotes
repetition (zero or more times). And although there's no use of it in this example, [ ... ] denotes an optional
occurrence.</p>

<p>This context-free grammar defines formally a language of
arithmetic expressions. Every expression (represented by <em>expr</em>) is a <em>term</em>,
which can be followed by a sequence of <pre class="code">+</pre> or <pre class="code">-</pre> operators and
further <em>term</em>s. A <em>term</em> is a <em>factor</em>, possibly followed by a sequence
of <pre class="code">*</pre> or <pre class="code">/</pre> operators and further <em>factor</em>s.  A <em>factor</em> is
either a numeric literal or an expression in parentheses.  Note that
the grammar already encodes the relative precedence of operators.  For
instance, <pre class="code">*</pre> binds more tightly than <pre class="code">+</pre>, because a <pre class="code">*</pre>
operation gives a <em>term</em>, whereas a <pre class="code">+</pre> operation gives an
<em>expr</em>, and <em>expr</em>s can contain <em>term</em>s but a <em>term</em> can contain
an <em>expr</em> only when the latter is enclosed in parentheses.</p>

<p>Now that you have defined the grammar, what's next? If you use Scala's
combinator parsers, you are basically done! You only need to perform
some systematic text replacements and wrap the parser in a class, as
shown in <a href="combinator-parsing.html#lst-expression-parser">Listing 33.1</a>:
<a id="lst-expression-parser"/></p>

<pre>
  <code class="vem">import</code>&nbsp;scala.util.parsing.combinator._
  <br />  <code class="vem">class</code>&nbsp;<code class="typename">Arith</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">JavaTokenParsers</code>&nbsp;{&nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;expr:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;term<code style="font-size:large">~</code>rep(<code class="quotedstring">"+"</code><code style="font-size:large">~</code>term&nbsp;|&nbsp;<code class="quotedstring">"-"</code><code style="font-size:large">~</code>term)
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;term:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;factor<code style="font-size:large">~</code>rep(<code class="quotedstring">"*"</code><code style="font-size:large">~</code>factor&nbsp;|&nbsp;<code class="quotedstring">"/"</code><code style="font-size:large">~</code>factor)
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;factor:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;floatingPointNumber&nbsp;|&nbsp;<code class="quotedstring">"("</code><code style="font-size:large">~</code>expr<code style="font-size:large">~</code><code class="quotedstring">")"</code>
  }
</pre>


<h5>Listing 33.1 - An arithmetic expression parser.</h5>


<p>The parsers for arithmetic expressions are contained in a class that inherits from
the trait
<pre class="code">JavaTokenParsers</pre>.<a id="i-585361525-1"/> This trait provides the basic machinery
for writing a parser and also provides some primitive parsers that
recognize some word classes: identifiers, string literals and
numbers. In the example in <a href="combinator-parsing.html#lst-expression-parser">Listing 33.1</a> you need only the primitive
<pre class="code">floatingPointNumber</pre> parser, which is inherited from this
trait.<a id="i1891349662-1"/><a id="i-63210921-1"/></p>

<p>The three definitions in class <pre class="code">Arith</pre> represent the productions for
arithmetic expressions.  As you can see, they follow very closely the productions
of the context-free grammar.  In fact, you could generate this part
automatically from the context-free grammar, by performing a number of
simple text replacements:</p>

<ol>


<li>Every production becomes a method, so you need to prefix it 
with <pre class="code">def</pre>.


</li>
<li>
The result type of each method is <pre class="code">Parser[Any]</pre>, so you need
to change the ::= symbol to "<pre class="code">:</pre>&nbsp;<pre class="code">Parser[Any]</pre>&nbsp;<pre class="code">=</pre>".
You'll find out later in this chapter what the type <pre class="code">Parser[Any]</pre> signifies, and also how to make it more precise.


</li>
<li>
In the grammar, sequential composition was implicit, but in the program
it is expressed by an explicit operator: <pre class="code"><pre class="large">~</pre></pre>. So you need to insert a <pre class="code"><pre class="large">~</pre></pre> between
every two consecutive symbols of a production. In the example in <a href="combinator-parsing.html#lst-expression-parser">Listing 33.1</a> we chose not to 
write any spaces around the <pre class="code"><pre class="large">~</pre></pre> operator. That way, the parser code keeps closely to the 
visual appearance of the grammar&mdash;it just replaces spaces by <pre class="code"><pre class="large">~</pre></pre> characters.


</li>
<li>
Repetition is expressed <pre class="code">rep(</pre> ... <pre class="code">)</pre> instead of \{ ... \}. 
Analogously (though  not shown in the example), option is expressed <pre class="code">opt(</pre> ... <pre class="code">)</pre> instead of
[ ... ].


</li>
<li>
The period (.) at the end of each production is omitted&mdash;you can, however, write 
a semicolon (<pre class="code">;</pre>) if you prefer.


</li></ol>


<p>That's all there is to it. The resulting class <pre class="code">Arith</pre> defines three
parsers, <pre class="code">expr</pre>, <pre class="code">term</pre> and <pre class="code">factor</pre>, which can be used to parse arithmetic expressions and their parts.</p>

<h3>33.2 Running your parser</h3>


<p>You can exercise your parser with the following small program:</p>

<pre>
  <code class="vem">object</code>&nbsp;<code class="typename">ParseExpr</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Arith</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;main(args:&nbsp;<code class="typename">Array[String]</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"input&nbsp;:&nbsp;"</code>&nbsp;+&nbsp;args(<code class="literal">0</code>))
  &nbsp;&nbsp;&nbsp;&nbsp;println(parseAll(expr,&nbsp;args(<code class="literal">0</code>)))
  &nbsp;&nbsp;}
  }
</pre>


<p>The <pre class="code">ParseExpr</pre> object defines a <pre class="code">main</pre> method that 
parses the first command-line argument passed to it.
It prints the original input argument, 
and then prints its parsed version. Parsing is done by the expression:</p>

<pre>
  parseAll(expr,&nbsp;input)
</pre>


<p>This expression applies the parser, <pre class="code">expr</pre>, to the given <pre class="code">input</pre>.
It expects that all of the input matches, <i>i.e.</i>, that there are no
characters trailing a parsed expression.  There's also a method
<pre class="code">parse</pre>, which allows you to parse an input prefix, leaving some remainder
unread.</p>

<p>You can run the arithmetic parser with the following command:</p>

<pre>
  $&nbsp;scala&nbsp;ParseExpr&nbsp;"2&nbsp;*&nbsp;(3&nbsp;+&nbsp;7)"
  <code class="output">input:&nbsp;2&nbsp;*&nbsp;(3&nbsp;+&nbsp;7)</code>
  <code class="output">[1.12]&nbsp;parsed:&nbsp;((2<code style="font-size:large">~</code>List((*<code style="font-size:large">~</code>(((<code style="font-size:large">~</code>((3<code style="font-size:large">~</code>List())<code style="font-size:large">~</code>List((+</code>
  <code class="output"><code style="font-size:large">~</code>(7<code style="font-size:large">~</code>List())))))<code style="font-size:large">~</code>)))))<code style="font-size:large">~</code>List())</code>
</pre>


<p>The output tells you that the parser successfully analyzed the input string
up to position [1.12]. That means 
the first line and the twelfth column&mdash;in other words, the whole input string&mdash;was parsed.
Disregard for the moment the result after "<pre class="code">parsed:</pre>".  It is not 
very useful, and you will find out later how to get more specific parser results.</p>

<p>You can also try to introduce some input string that is not a
legal expression. For instance, you could write one closing parenthesis too many:</p>

<pre>
  $&nbsp;scala&nbsp;ParseExpr&nbsp;"2&nbsp;*&nbsp;(3&nbsp;+&nbsp;7))"
  <code class="output">input:&nbsp;2&nbsp;*&nbsp;(3&nbsp;+&nbsp;7))</code>
  <code class="output">[1.12]&nbsp;failure:&nbsp;`-'&nbsp;expected&nbsp;but&nbsp;`)'&nbsp;found</code>
  <code class="output"></code>
  <code class="output">2&nbsp;*&nbsp;(3&nbsp;+&nbsp;7))</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>Here, the <pre class="code">expr</pre> parser parsed everything until the final closing
parenthesis, which does not form part of the
arithmetic expression. The <pre class="code">parseAll</pre> method then issued an error message, which
said that it expected a <pre class="code">-</pre> operator at the point of the closing
parenthesis. You'll find out later in this chapter why it produced this particular error message, 
and how you can improve it.</p>

<h3>33.3 Basic regular expression parsers</h3>


<p>The parser for arithmetic expressions made use of another parser, named 
<pre class="code">floatingPointNumber</pre>. This parser, which was inherited from
<pre class="code">Arith</pre>'s supertrait, <pre class="code">JavaTokenParsers</pre>, recognizes a floating point number in
the format of Java. But what do you do if you need to parse numbers in
a format that's a bit different from Java's?
In this situation, you can use a <em>regular expression
parser</em>.</p>

<p>The idea is that you can use any regular expression as a
parser.<a id="i-2139156663-1"/>
The regular expression parses all strings that it can match.  Its
result is the parsed string. For instance, the regular expression parser
shown in <a href="combinator-parsing.html#lst-regular-expression-parser">Listing 33.2</a> describes Java's identifiers:
<a id="lst-regular-expression-parser"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">MyParsers</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">RegexParsers</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;ident:&nbsp;<code class="typename">Parser[String]</code>&nbsp;=&nbsp;<code class="quotedstring">"""[a-zA-Z_]\w*"""</code>.r
  &nbsp;&nbsp;}
</pre>


<h5>Listing 33.2 - A regular expression parser for Java identifiers.</h5>


<p>The <pre class="code">MyParsers</pre> object of <a href="combinator-parsing.html#lst-regular-expression-parser">Listing 33.2</a> inherits from trait <pre class="code">RegexParsers</pre>, whereas
<pre class="code">Arith</pre> inherited from
<pre class="code">JavaTokenParsers</pre>.<a id="i519257659-1"/> Scala's parsing
combinators are arranged in a hierarchy of traits, which are all
contained in package <pre class="code">scala.util.parsing.combinator</pre>. The top-level
trait is <pre class="code">Parsers</pre>, which defines a very general parsing framework
for all sorts of input. One level below is trait <pre class="code">RegexParsers</pre>, which
requires that the input is a sequence of characters and provides for
regular expression parsing. Even more specialized is trait 
<pre class="code">JavaTokenParsers</pre>, which implements parsers for basic classes of words
(or <span style="font-style:italic">tokens</span>) as they are defined in Java.</p>

<h3>33.4 Another example: JSON</h3>


<p>JSON, the JavaScript Object Notation, is a
popular data interchange format.<a id="i2286824-1"/> In this section, we'll show you how to write a
parser for it. Here's a grammar that describes the syntax of JSON:</p>

<div style="text-align: center">


<table style="border-collapse: collapse">
<tr>
  <td>
    <span style="font-style:italic">value</span>
  </td>
  <td>
    ::=
  </td>
  <td>
    <span style="font-style:italic">obj</span> &nbsp;|&nbsp; <span style="font-style:italic">arr</span> &nbsp;|&nbsp; <span style="font-style:italic">stringLiteral</span> &nbsp;|
  </td>
</tr>
<tr>
  <td>
  </td>
  <td>
  </td>
  <td>
    <span style="font-style:italic">floatingPointNumber</span> &nbsp;|
  </td>
</tr>
<tr>
  <td>
  </td>
  <td>
  </td>
  <td>
    <pre class="code">"null"</pre> &nbsp;|&nbsp; <pre class="code">"true"</pre> &nbsp;|&nbsp; <pre class="code">"false"</pre>.
  </td>
</tr>
<tr>
  <td>
    <span style="font-style:italic">obj</span>
  </td>
  <td>
    ::=
  </td>
  <td>
    <pre class="code">"{"</pre> &nbsp;[<span style="font-style:italic">members</span>]&nbsp; <pre class="code">"}"</pre>.
  </td>
</tr>
<tr>
  <td>
    <span style="font-style:italic">arr</span>
  </td>
  <td>
    ::=
  </td>
  <td>
    <pre class="code">"["</pre> &nbsp;[<span style="font-style:italic">values</span>]&nbsp; <pre class="code">"]"</pre>.
  </td>
</tr>
<tr>
  <td>
    <span style="font-style:italic">members</span>
  </td>
  <td>
    ::=
  </td>
  <td>
    <span style="font-style:italic">member</span> &nbsp;\{<pre class="code">","</pre>&nbsp; <span style="font-style:italic">member</span>\}.
  </td>
</tr>
<tr>
  <td>
    <span style="font-style:italic">member</span>
  </td>
  <td>
    ::=
  </td>
  <td>
    <span style="font-style:italic">stringLiteral</span> &nbsp;<pre class="code">":"</pre>&nbsp; <span style="font-style:italic">value</span>.
  </td>
</tr>
<tr>
  <td>
    <span style="font-style:italic">values</span>
  </td>
  <td>
    ::=
  </td>
  <td>
    <span style="font-style:italic">value</span> &nbsp;\{<pre class="code">","</pre>&nbsp; <span style="font-style:italic">value</span>\}.
  </td>
</tr>
</table>


</div>


<p>A JSON value is an object, array, string, number, or one
of the three reserved words <pre class="code">null</pre>, <pre class="code">true</pre>, or <pre class="code">false</pre>.
A JSON object is a (possibly empty) sequence of members separated by commas 
and enclosed in braces. Each member is a string/value pair where the string and the value are separated by a colon. 
Finally, a JSON array is a sequence of values separated by commas 
and enclosed in square brackets.
As an example, <a href="combinator-parsing.html#lst-JSON-data">Listing 33.3</a> contains an address-book formatted
as a JSON object.
<a id="lst-JSON-data"/></p>

<pre>
  &nbsp;&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"address&nbsp;book"</code>:&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"name"</code>:&nbsp;<code class="quotedstring">"John&nbsp;Smith"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"address"</code>:&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"street"</code>:&nbsp;<code class="quotedstring">"10&nbsp;Market&nbsp;Street"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"city"</code>&nbsp;&nbsp;:&nbsp;<code class="quotedstring">"San&nbsp;Francisco,&nbsp;CA"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"zip"</code>&nbsp;&nbsp;&nbsp;:&nbsp;<code class="literal">94111</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"phone&nbsp;numbers"</code>:&nbsp;[
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"408&nbsp;338-4238"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"408&nbsp;111-6892"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 33.3 - Data in JSON format.</h5>


<p>Parsing such data is straightforward when using Scala's parser combinators.
The complete parser is shown in <a href="combinator-parsing.html#lst-JSON-parser">Listing 33.4</a>.
This parser follows the same structure as the arithmetic expression parser.
It is again a straightforward mapping of the productions of the JSON grammar.  
The productions use one shortcut that simplifies the
grammar: The <pre class="code">repsep</pre> combinator parses a (possibly empty) sequence
of terms that are separated by a given separator string.  For instance, in
the example in <a href="combinator-parsing.html#lst-JSON-parser">Listing 33.4</a>, <pre class="code">repsep(member,</pre>&nbsp;<pre class="code">",")</pre> parses a comma-separated
sequence of <pre class="code">member</pre> terms.  Otherwise, the productions in the parser
correspond exactly to the productions in the grammar, as was
the case for the arithmetic expression parsers.
<a id="lst-JSON-parser"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.util.parsing.combinator._
  <br />  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;JSON&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">JavaTokenParsers</code>&nbsp;{&nbsp;&nbsp;&nbsp;
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;value&nbsp;:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;obj&nbsp;|&nbsp;arr&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringLiteral&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;floatingPointNumber&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"null"</code>&nbsp;|&nbsp;<code class="quotedstring">"true"</code>&nbsp;|&nbsp;<code class="quotedstring">"false"</code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;obj&nbsp;&nbsp;&nbsp;:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;<code class="quotedstring">"{"</code><code style="font-size:large">~</code>repsep(member,&nbsp;<code class="quotedstring">","</code>)<code style="font-size:large">~</code><code class="quotedstring">"}"</code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;arr&nbsp;&nbsp;&nbsp;:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;<code class="quotedstring">"["</code><code style="font-size:large">~</code>repsep(value,&nbsp;<code class="quotedstring">","</code>)<code style="font-size:large">~</code><code class="quotedstring">"]"</code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;member:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;stringLiteral<code style="font-size:large">~</code><code class="quotedstring">":"</code><code style="font-size:large">~</code>value
  &nbsp;&nbsp;}
</pre>


<h5>Listing 33.4 - A simple JSON parser.</h5>


<p>To try out the JSON parsers, we'll change the framework a bit, so that the parser operates on a file instead of on the command line:</p>

<pre>
  <code class="vem">import</code>&nbsp;java.io.FileReader
  <br />  <code class="vem">object</code>&nbsp;<code class="typename">ParseJSON</code>&nbsp;<code class="vem">extends</code>&nbsp;JSON&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;main(args:&nbsp;<code class="typename">Array[String]</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;reader&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">FileReader</code>(args(<code class="literal">0</code>))
  &nbsp;&nbsp;&nbsp;&nbsp;println(parseAll(value,&nbsp;reader))
  &nbsp;&nbsp;}
  }
</pre>


<p>The <pre class="code">main</pre> method in this program first creates a <pre class="code">FileReader</pre>
object.<a id="i1651665815-1"/> It then parses the characters returned by that reader
according to the <pre class="code">value</pre> production of the JSON grammar. Note that
<pre class="code">parseAll</pre> and <pre class="code">parse</pre> exist in overloaded variants: both can take a
character sequence or alternatively an input reader as second
argument.</p>

<p>If you store the "address book" object shown in <a href="combinator-parsing.html#lst-JSON-data">Listing 33.3</a> into a file named 
<pre class="code">address-book.json</pre> and run the <pre class="code">ParseJSON</pre> program on it, you should get:</p>

<pre>
  $&nbsp;scala&nbsp;ParseJSON&nbsp;address-book.json
  <code class="output">[13.4]&nbsp;parsed:&nbsp;(({<code style="font-size:large">~</code>List((("address&nbsp;book"<code style="font-size:large">~</code>:)<code style="font-size:large">~</code>(({<code style="font-size:large">~</code>List(((</code>
  <code class="output">"name"<code style="font-size:large">~</code>:)<code style="font-size:large">~</code>"John&nbsp;Smith"),&nbsp;(("address"<code style="font-size:large">~</code>:)<code style="font-size:large">~</code>(({<code style="font-size:large">~</code>List(((</code>
  <code class="output">"street"<code style="font-size:large">~</code>:)<code style="font-size:large">~</code>"10&nbsp;Market&nbsp;Street"),&nbsp;(("city"<code style="font-size:large">~</code>:)<code style="font-size:large">~</code>"San&nbsp;Francisco</code>
  <code class="output">,CA"),&nbsp;(("zip"<code style="font-size:large">~</code>:)<code style="font-size:large">~</code>94111)))<code style="font-size:large">~</code>})),&nbsp;(("phone&nbsp;numbers"<code style="font-size:large">~</code>:)<code style="font-size:large">~</code>(([<code style="font-size:large">~</code></code>
  <code class="output">List("408&nbsp;338-4238",&nbsp;"408&nbsp;111-6892"))<code style="font-size:large">~</code>]))))<code style="font-size:large">~</code>}))))<code style="font-size:large">~</code>})</code>
</pre>


<h3>33.5 Parser output</h3>


<p>The <pre class="code">ParseJSON</pre> program successfully parsed the JSON address book.  However, the parser output looks strange.  It seems to be a
sequence composed of bits and pieces of the input glued together with
lists and <pre class="code"><pre class="large">~</pre></pre> combinations.  This output is not very
useful. It is less readable for humans than the input, but it
is also too disorganized to be easily analyzable by a computer. It's
time to do something about this.</p>

<p>To figure out what to do, you need to know first what the individual
parsers in the combinator frameworks return as a result (provided they
succeed in parsing the input).  Here are the rules:</p>

<ol>


<li>
Each parser written as a string (such as: <pre class="code">"{"</pre> or <pre class="code">":"</pre> or <pre class="code">"null"</pre>) returns
the parsed string itself.


</li>
<li>
Regular expression parsers such as <pre class="code">"""[a-zA-Z_]\w*""".r</pre>
also return the parsed string itself. The same holds for
regular expression parsers such as <pre class="code">stringLiteral</pre> or <pre class="code">floatingPointNumber</pre>, which
are inherited from trait
<pre class="code">JavaTokenParsers</pre>.<a id="i-826062925-1"/><a id="i1891349662-2"/>


</li>
<li>
A sequential composition <pre class="code">P<pre class="large">~</pre>Q</pre> returns the results of both <pre class="code">P</pre> and of <pre class="code">Q</pre>. These
results are returned in an instance of a case class that is also written <pre class="code"><pre class="large">~</pre></pre>.
So if <pre class="code">P</pre> returns <pre class="code">"true"</pre> and <pre class="code">Q</pre> returns <pre class="code">"?"</pre>, then the sequential composition
<pre class="code">P<pre class="large">~</pre>Q</pre> returns <pre class="code"><pre class="large">~</pre>("true",</pre>&nbsp;<pre class="code">"?")</pre>, which prints as <pre class="code">(true<pre class="large">~</pre>?)</pre>.


</li>
<li>
An alternative composition <pre class="code">P</pre>&nbsp;<pre class="code">|</pre>&nbsp;<pre class="code">Q</pre> returns the result of either <pre class="code">P</pre> or <pre class="code">Q</pre>,
whichever one succeeds.


</li>
<li>
A repetition <pre class="code">rep(P)</pre> or <pre class="code">repsep(P,</pre>&nbsp;<pre class="code">separator)</pre> returns a
list of the results of all runs of <pre class="code">P</pre>.


</li>
<li>
An option <pre class="code">opt(P)</pre> returns an instance of Scala's <pre class="code">Option</pre> type.
It returns <pre class="code">Some(R)</pre> if <pre class="code">P</pre> succeeds with result <pre class="code">R</pre> and <pre class="code">None</pre> if <pre class="code">P</pre> fails.


</li></ol>


<p>With these rules you can now deduce <span style="font-style:italic">why</span> the parser output appeared as it did in the
previous examples. However, the output is still not very
convenient.  It would be much better to map a JSON object
into an internal Scala representation that represents the 
meaning of the JSON value. 
A more natural representation would be as follows:</p>

<ul>


<li>
A JSON object is represented as a Scala map of type <pre class="code">Map[String,</pre> <pre class="code">Any]</pre>.
Every member is represented as a key/value binding in the map.


</li>
<li>
A JSON array is represented as a Scala list of type <pre class="code">List[Any]</pre>.


</li>
<li>
A JSON string is represented as a Scala <pre class="code">String</pre>.


</li>
<li>
A JSON numeric literal is represented as a Scala <pre class="code">Double</pre>.


</li>
<li>
The values <pre class="code">true</pre>, <pre class="code">false</pre>, and <pre class="code">null</pre> are represented as the
Scala values with the same names.


</li></ul>


<p>To produce this representation, you need to make use of one more
combination form for parsers:
<pre class="code">^^</pre>.<a id="i1109178044-1"/></p>

<p>The <pre class="code">^^</pre> operator
 <span style="font-style:italic">transforms</span> the result of a
parser. Expressions using this operator have the form <pre class="code">P</pre>&nbsp;<pre class="code">^^</pre>&nbsp;<pre class="code">f</pre> where
<pre class="code">P</pre> is a parser and <pre class="code">f</pre> is a function.  <pre class="code">P</pre>&nbsp;<pre class="code">^^</pre>&nbsp;<pre class="code">f</pre> parses the same
sentences as just <pre class="code">P</pre>. Whenever <pre class="code">P</pre> returns with some
result <pre class="code">R</pre>, the result of <pre class="code">P</pre>&nbsp;<pre class="code">^^</pre>&nbsp;<pre class="code">f</pre> is <pre class="code">f(R)</pre>.</p>

<p>As an example, here is a parser that 
parses a floating point number and converts it to a Scala value of type <pre class="code">Double</pre>:</p>

<pre>
  floatingPointNumber&nbsp;^^&nbsp;(_.toDouble)
</pre>


<p>And here is a parser that parses the string <pre class="code">"true"</pre> and returns
Scala's boolean <pre class="code">true</pre> value:</p>

<pre>
  <code class="quotedstring">"true"</code>&nbsp;^^&nbsp;(x&nbsp;=&gt;&nbsp;<code class="vem">true</code>)
</pre>


<p>Now for more advanced transformations. Here's a new version of a parser
for JSON objects that returns a Scala <pre class="code">Map</pre>:</p>

<pre>
  <code class="vem">def</code>&nbsp;obj:&nbsp;<code class="typename">Parser[Map[String,&nbsp;Any]]</code>&nbsp;=&nbsp;<code class="comment">//&nbsp;Can&nbsp;be&nbsp;improved</code>
  &nbsp;&nbsp;<code class="quotedstring">"{"</code><code style="font-size:large">~</code>repsep(member,&nbsp;<code class="quotedstring">","</code>)<code style="font-size:large">~</code><code class="quotedstring">"}"</code>&nbsp;^^&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;<code class="quotedstring">"{"</code><code style="font-size:large">~</code>ms<code style="font-size:large">~</code><code class="quotedstring">"}"</code>&nbsp;=&gt;&nbsp;<code class="typename">Map</code>()&nbsp;++&nbsp;ms&nbsp;}
</pre>


<p>Remember that the <pre class="code"><pre class="large">~</pre></pre> operator
produces as its result an instance of a case class with the same name: <pre class="code"><pre class="large">~</pre></pre>. Here's a definition of that class&mdash;it's
an inner class of trait
<pre class="code">Parsers</pre>:<a id="i-1259402311-1"/></p>

<pre>
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code style="font-size:large">~</code>[+A,&nbsp;+B](x:&nbsp;A,&nbsp;y:&nbsp;B)&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;<code class="quotedstring">"("</code>&nbsp;+&nbsp;x&nbsp;+&nbsp;<code class="quotedstring">"<code style="font-size:large">~</code>"</code>&nbsp;+&nbsp;y&nbsp;+&nbsp;<code class="quotedstring">")"</code>
  }
</pre>


<p>The name of the class is intentionally the same as the name of the
sequence combinator method, <pre class="code"><pre class="large">~</pre></pre>.
That way, you can match parser results with patterns that follow the same structure as the
parsers themselves. For instance, the pattern <pre class="code">"{"<pre class="large">~</pre>ms<pre class="large">~</pre>"}"</pre>
matches a result string <pre class="code">"{"</pre> followed by a result variable <pre class="code">ms</pre>, which is followed in turn by a result string <pre class="code">"}"</pre>. This
pattern corresponds exactly to what is returned
by the parser on the left of the <pre class="code">^^</pre>.
In its desugared versions where the <pre class="code"><pre class="large">~</pre></pre> operator comes first, the same pattern reads
<pre class="code"><pre class="large">~</pre>(<pre class="large">~</pre>("{",</pre>&nbsp;<pre class="code">ms),</pre>&nbsp;<pre class="code">"}")</pre>, but this is much less legible.</p>

<p>The purpose of the <pre class="code">"{"<pre class="large">~</pre>ms<pre class="large">~</pre>"}"</pre> pattern is to strip off the braces so 
that you can get at the list of members resulting from the <pre class="code">repsep(member,</pre>&nbsp;<pre class="code">",")</pre> parser.
In cases like these there is also an alternative that avoids
producing unnecessary parser results that are immediately discarded by
the pattern match.  The alternative makes use of the <pre class="code"><pre class="large">~</pre>&gt;</pre> and <pre class="code">&lt;<pre class="large">~</pre></pre>
parser
combinators.<a id="i1302279396-1"/><a id="i1234233109-1"/><a id="i-1808209135-1"/>
Both express sequential composition like
<pre class="code"><pre class="large">~</pre></pre>, but <pre class="code"><pre class="large">~</pre>&gt;</pre> keeps only the result of its right operand, whereas
<pre class="code">&lt;<pre class="large">~</pre></pre> keeps only the result of its left operand. 
Using these combinators, the JSON object parser can be expressed more
succinctly:</p>

<pre>
  <code class="vem">def</code>&nbsp;obj:&nbsp;<code class="typename">Parser[Map[String,&nbsp;Any]]</code>&nbsp;=
  &nbsp;&nbsp;<code class="quotedstring">"{"</code><code style="font-size:large">~</code>&gt;&nbsp;repsep(member,&nbsp;<code class="quotedstring">","</code>)&nbsp;&lt;<code style="font-size:large">~</code><code class="quotedstring">"}"</code>&nbsp;^^&nbsp;(<code class="typename">Map</code>()&nbsp;++&nbsp;_)
</pre>


<p><a href="combinator-parsing.html#lst-JSON1">Listing 33.5</a> shows a full JSON parser that
returns meaningful results.
If you run this parser on the <pre class="code">address-book.json</pre> file, you will get the following result
(after adding some newlines and indentation):</p>

<pre>
  $&nbsp;scala&nbsp;JSON1Test&nbsp;address-book.json
  [14.1]&nbsp;parsed:&nbsp;Map(
  &nbsp;&nbsp;address&nbsp;book&nbsp;-&gt;&nbsp;Map(
  &nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;-&gt;&nbsp;John&nbsp;Smith,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;address&nbsp;-&gt;&nbsp;Map(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;street&nbsp;-&gt;&nbsp;10&nbsp;Market&nbsp;Street,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;city&nbsp;-&gt;&nbsp;San&nbsp;Francisco,&nbsp;CA,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zip&nbsp;-&gt;&nbsp;94111),&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;phone&nbsp;numbers&nbsp;-&gt;&nbsp;List(408&nbsp;338-4238,&nbsp;408&nbsp;111-6892)
  &nbsp;&nbsp;)
  )
</pre>


<p>This is all you need to know in order to get started writing your own
parsers.  As an aide to memory, <a href="combinator-parsing.html#table-parser-combinators">Table 33.1</a> lists the parser
combinators that were discussed so far.</p>

<p><a id="lst-JSON1"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.util.parsing.combinator._
  <br />  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;JSON1&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">JavaTokenParsers</code>&nbsp;{&nbsp;&nbsp;&nbsp;
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;obj:&nbsp;<code class="typename">Parser[Map[String,&nbsp;Any]]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"{"</code><code style="font-size:large">~</code>&gt;&nbsp;repsep(member,&nbsp;<code class="quotedstring">","</code>)&nbsp;&lt;<code style="font-size:large">~</code><code class="quotedstring">"}"</code>&nbsp;^^&nbsp;(<code class="typename">Map</code>()&nbsp;++&nbsp;_)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;arr:&nbsp;<code class="typename">Parser[List[Any]]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"["</code><code style="font-size:large">~</code>&gt;&nbsp;repsep(value,&nbsp;<code class="quotedstring">","</code>)&nbsp;&lt;<code style="font-size:large">~</code><code class="quotedstring">"]"</code>&nbsp;
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;member:&nbsp;<code class="typename">Parser[(String,&nbsp;Any)]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringLiteral<code style="font-size:large">~</code><code class="quotedstring">":"</code><code style="font-size:large">~</code>value&nbsp;^^&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;name<code style="font-size:large">~</code><code class="quotedstring">":"</code><code style="font-size:large">~</code>value&nbsp;=&gt;&nbsp;(name,&nbsp;value)&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;value:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj
  &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;arr&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;stringLiteral
  &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;floatingPointNumber&nbsp;^^&nbsp;(_.toDouble)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<code class="quotedstring">"null"</code>&nbsp;&nbsp;^^&nbsp;(x&nbsp;=&gt;&nbsp;<code class="vem">null</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<code class="quotedstring">"true"</code>&nbsp;&nbsp;^^&nbsp;(x&nbsp;=&gt;&nbsp;<code class="vem">true</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<code class="quotedstring">"false"</code>&nbsp;^^&nbsp;(x&nbsp;=&gt;&nbsp;<code class="vem">false</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 33.5 - A full JSON parser that returns meaningful results.</h5>


<p><a id="table-parser-combinators"/></p>

<h5>Table 33.1 - Summary of parser combinators</h5>


<div style="text-align: center">


<table style="border-collapse: collapse">
<tr class="topline ">
  <td>
    <pre class="code"><pre class="quotedstring">"..."</pre></pre>
  </td>
  <td>
    literal
  </td>
</tr>
<tr>
  <td>
    <pre class="code"><span class="quotedstring">"..."</span>.r</pre>
  </td>
  <td>
    regular expression
  </td>
</tr>
<tr>
  <td>
    <pre class="code">P<pre class="large">~</pre>Q</pre>
  </td>
  <td>
    sequential composition
  </td>
</tr>
<tr>
  <td>
    <pre class="code">P</pre>&nbsp;<pre class="code">&lt;<pre class="large">~</pre></pre>&nbsp;<pre class="code">Q,</pre>&nbsp;<pre class="code">P</pre>&nbsp;<pre class="code"><pre class="large">~</pre>&gt;</pre>&nbsp;<pre class="code">Q</pre>
  </td>
  <td>
    sequential composition; keep left/right only
  </td>
</tr>
<tr>
  <td>
    <pre class="code">P</pre>&nbsp;<pre class="code">|</pre>&nbsp;<pre class="code">Q</pre>
  </td>
  <td>
    alternative
  </td>
</tr>
<tr>
  <td>
    <pre class="code">opt(P)</pre>
  </td>
  <td>
    option
  </td>
</tr>
<tr>
  <td>
    <pre class="code">rep(P)</pre>
  </td>
  <td>
    repetition
  </td>
</tr>
<tr>
  <td>
    <pre class="code">repsep(P,</pre>&nbsp;<pre class="code">Q)</pre>
  </td>
  <td>
    interleaved repetition
  </td>
</tr>
<tr class="bottomline">
  <td>
    <pre class="code">P</pre>&nbsp;<pre class="code">^^</pre>&nbsp;<pre class="code">f</pre>
  </td>
  <td>
    result conversion
  </td>
</tr>
</table>


</div>


<div class="aside">
<h3>Turning off semicolon inference</h3>


<p>Note that the body of the <pre class="code">value</pre> parser 
in <a href="combinator-parsing.html#lst-JSON1">Listing 33.5</a> is enclosed in parentheses. This is a little
trick to disable semicolon inference in parser expressions. You saw in <a href="classes-and-objects.html#sec-semicolon-inf">Section 4.2</a> that Scala assumes there's a
semicolon between any two lines that can be separate statements<a id="i-615670524-1"/><a id="i561868586-1"/>
syntactically, unless the first line ends in an infix operator, or the
two lines are enclosed in parentheses or square brackets. Now, you
could have written the <pre class="code">|</pre> operator at the end of the each alternative 
instead of at the beginning of the following one, like this:</p>

<pre>
  <code class="vem">def</code>&nbsp;value:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;obj&nbsp;|
  &nbsp;&nbsp;arr&nbsp;|
  &nbsp;&nbsp;stringLiteral&nbsp;|
  &nbsp;&nbsp;...
</pre>


<p>In that case, no parentheses around the body of the <pre class="code">value</pre> parser would have been required. 
However, some people prefer to see the <pre class="code">|</pre> operator at the beginning of the 
second alternative rather than at the end of the first. 
Normally, this would lead to an unwanted semicolon between the two 
lines, like this:</p>

<pre>
  &nbsp;&nbsp;obj;&nbsp;&nbsp;<code class="comment">//&nbsp;semicolon&nbsp;implicitly&nbsp;inserted</code>
  |&nbsp;arr
</pre>


<p>The semicolon changes the structure of the code, 
causing it to fail compilation. Putting the whole expression in parentheses
avoids the semicolon and makes the code compile correctly.</p>

</div>


<h4>Symbolic versus alphanumeric names</h4>


<p>Many of the parser combinators in
<a href="combinator-parsing.html#table-parser-combinators">Table 33.1</a> use symbolic names. This has
both advantages and disadvantages.  On the minus side, symbolic names
take time to learn. Users who are unfamiliar with Scala's combinator
parsing libraries are probably mystified what <pre class="code"><pre class="large">~</pre></pre>, <pre class="code"><pre class="large">~</pre>&gt;</pre>, or <pre class="code">^^</pre>
mean.  On the plus side, symbolic names are short, and can be chosen
to have the "right" precedences and associativities. For instance,
the parser combinators <pre class="code"><pre class="large">~</pre></pre>, <pre class="code">^^</pre>, and <pre class="code">|</pre> are chosen intentionally
in decreasing order of precedence. A typical grammar production is
composed of alternatives that have a parsing part and a
transformation part. The parsing part usually contains several
sequential items separated by <pre class="code"><pre class="large">~</pre></pre> operators. 
With the chosen precedences of <pre class="code"><pre class="large">~</pre></pre>, <pre class="code">^^</pre>, and <pre class="code">|</pre> you can write 
such a grammar production without needing any parentheses.</p>

<p>Furthermore, symbolic operators take less visual real estate than
alphabetic ones. That's important for a parser because it lets you
concentrate on the grammar at hand, instead of the combinators
themselves. To see the difference, imagine for a moment that
sequential composition (<pre class="code"><pre class="large">~</pre></pre>) was called <pre class="code">andThen</pre> and alternative (<pre class="code">|</pre>) was
called <pre class="code">orElse</pre>. The arithmetic expression parsers in
<a href="combinator-parsing.html#lst-expression-parser">Listing 33.1</a>  <a href="combinator-parsing.html#lst-expression-parser">here</a> would look
as follows:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">ArithHypothetical</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">JavaTokenParsers</code>&nbsp;{&nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;expr:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;&nbsp;&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;term&nbsp;andThen&nbsp;rep((<code class="quotedstring">"+"</code>&nbsp;andThen&nbsp;term)&nbsp;orElse&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="quotedstring">"-"</code>&nbsp;andThen&nbsp;term))
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;term:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;&nbsp;&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;factor&nbsp;andThen&nbsp;rep((<code class="quotedstring">"*"</code>&nbsp;andThen&nbsp;factor)&nbsp;orElse&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="quotedstring">"/"</code>&nbsp;andThen&nbsp;factor))
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;factor:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;floatingPointNumber&nbsp;orElse&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;(<code class="quotedstring">"("</code>&nbsp;andThen&nbsp;expr&nbsp;andThen&nbsp;<code class="quotedstring">")"</code>)
  }
</pre>


<p>You notice that the code becomes much longer, and that it's hard to
"see" the grammar among all those operators and parentheses. 
On the other hand, somebody new to combinator parsing could probably 
figure out better what the code is supposed to do.</p>

<div class="aside">
<h3>Choosing between symbolic and alphabetic names</h3>


<p>As guidelines for choosing between symbolic and alphabetic names we
recommend the following:<a id="i-252867623-1"/><a id="i760884015-1"/><a id="i27050837-1"/><a id="i-1245815134-1"/></p>

<ul>


<li>
Use symbolic names in cases where they already 
have a universally established meaning. For instance, nobody would
recommend writing <pre class="code">add</pre> instead of <pre class="code">+</pre> for numeric addition.


</li>
<li>
Otherwise, give preference to alphabetic names if you want your code to 
be understandable to casual readers.


</li>
<li>
You can still choose symbolic names for domain-specific libraries, 
if this gives clear advantages in legibility and you do not expect 
anyway that a casual reader without a firm grounding in the domain 
would be able to understand the code immediately.


</li></ul>


<p>In the case of parser combinators we are looking at a highly
domain-specific language, which casual readers may have trouble understanding even
with alphabetic names.  Furthermore, symbolic names give clear advantages
in legibility for the expert.  So we believe their use is
warranted in this application.</p>

</div>


<h3>33.6 Implementing combinator parsers</h3>


<p>The previous sections have shown that Scala's combinator parsers
provide a convenient means for constructing your own parsers. Since
they are nothing more than a Scala library, they fit seamlessly into
your Scala programs. So it's very easy to combine a parser with some
code that processes the results it delivers, or to rig a parser
so that it takes its input from some specific source (say, a file, a
string, or a character array).</p>

<p>How is this achieved? In the rest of this chapter you'll take a look
"under the hood" of the combinator parser library. You'll see what a
parser is, and how the primitive parsers and parser combinators
encountered in previous sections are implemented. You can safely skip
these parts if all you want to do is write some simple combinator parsers.
On the other hand, reading the rest of this chapter should give you a
deeper understanding of combinator parsers in particular, and of the
design principles of a combinator domain-specific language in general.</p>

<p>The core of Scala's combinator parsing framework is contained in the
trait <pre class="code">scala.util.parsing.combinator.Parsers</pre>.<a id="i1073514242-1"/> This trait defines
the <pre class="code">Parser</pre> type as well as all fundamental combinators.  Except
where stated explicitly otherwise, the definitions explained in the
following two subsections all reside in this trait. That is, they are assumed to be 
contained in a trait definition that starts as follows:</p>

<pre>
  <code class="vem">package</code>&nbsp;scala.util.parsing.combinator
  <code class="vem">trait</code>&nbsp;<code class="typename">Parsers</code>&nbsp;{
  &nbsp;&nbsp;...&nbsp;<code class="comment">//&nbsp;code&nbsp;goes&nbsp;here&nbsp;unless&nbsp;otherwise&nbsp;stated</code>
  }
</pre>


<p>A <pre class="code">Parser</pre> is in essence just a function from some input type
to a parse result. As a first approximation, the type could be written as follows:</p>

<pre>
  <code class="vem">type</code>&nbsp;<code class="typename">Parser[T]</code>&nbsp;=&nbsp;<code class="typename">Input</code>&nbsp;=&gt;&nbsp;<code class="typename">ParseResult[T]</code>
</pre>


<h4>Parser input</h4>


<p>Sometimes, a parser reads a stream of tokens instead of a raw sequence of
characters.  A separate lexical analyzer is then used to convert a stream
of raw characters into a stream of tokens.<a id="i262352408-1"/> The type of parser inputs is defined as follows:</p>

<pre>
  <code class="vem">type</code>&nbsp;<code class="typename">Input</code>&nbsp;=&nbsp;<code class="typename">Reader[Elem]</code>&nbsp;&nbsp;&nbsp;
</pre>


<p>The class <pre class="code">Reader</pre> comes from the package
<pre class="code">scala.util.parsing.input</pre>.<a id="i1984859131-1"/>  It is similar to a <pre class="code">Stream</pre>, but also
keeps track of the positions of all the elements it reads. The type
<pre class="code">Elem</pre> represents individual input
elements.<a id="i-2008629102-1"/> It is an abstract type
member of the <pre class="code">Parsers</pre> trait:</p>

<pre>
  <code class="vem">type</code>&nbsp;<code class="typename">Elem</code>
</pre>


<p>This means that subclasses and subtraits of
<pre class="code">Parsers</pre> need to instantiate class <pre class="code">Elem</pre> to the type of input
elements that are being parsed. For instance, <pre class="code">RegexParsers</pre> and
<pre class="code">JavaTokenParsers</pre> fix <pre class="code">Elem</pre> to be equal to <pre class="code">Char</pre>. But it would
also be possible to set <pre class="code">Elem</pre> to some other type, such as the type
of tokens returned from a separate lexer.</p>

<h4>Parser results</h4>


<p>A parser might either succeed or fail on some given input. Consequently class
<pre class="code">ParseResult</pre> has two subclasses for representing success and
failure:<a id="i-27560472-1"/></p>

<pre>
  <code class="vem">sealed</code>&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ParseResult[+T]</code>&nbsp;
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Success[T]</code>(result:&nbsp;T,&nbsp;in:&nbsp;<code class="typename">Input</code>)&nbsp;
  &nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">ParseResult[T]</code>
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Failure</code>(msg:&nbsp;<code class="typename">String</code>,&nbsp;in:&nbsp;<code class="typename">Input</code>)&nbsp;
  &nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">ParseResult[Nothing]</code>
</pre>


<p>The <pre class="code">Success</pre> case carries the result returned from the parser in its
<pre class="code">result</pre> parameter.<a id="i240639739-1"/>  The type of parser results is arbitrary; that's
why <pre class="code">ParseResult</pre>, <pre class="code">Success</pre>, and <pre class="code">Parser</pre> are all parameterized
with a type parameter <pre class="code">T</pre>.  The type parameter represents the kinds of results
returned by a given parser.<a id="i-370701594-1"/> <pre class="code">Success</pre> also takes a second parameter,
<pre class="code">in</pre>, which refers to the input immediately following the part that
the parser consumed.  This field is needed for chaining parsers, so
that one parser can operate after another.  Note that this is a
purely functional approach to parsing.<a id="i-1568373391-1"/> Input is not read as a side
effect, but it is kept in a stream. A parser analyzes some part of
the input stream, and then returns the remaining part in its result.</p>

<p>The other subclass of <pre class="code">ParseResult</pre> is
<pre class="code">Failure</pre>.<a id="i1670336322-1"/> This class takes
as a parameter a message that describes why the parser failed. Like
<pre class="code">Success</pre>, <pre class="code">Failure</pre> also takes the remaining input stream as a
second parameter. This is needed not for chaining (the parser won't
continue after a failure), but to position the error message at the
correct place in the input stream.</p>

<p>Note that parse results are defined to be covariant in the type
parameter <pre class="code">T</pre>. That is, a parser returning <pre class="code">String</pre>s as result, say,
is compatible with a parser returning <pre class="code">AnyRef</pre>s.</p>

<h4>The <pre class="code">Parser</pre> class</h4>


<p>The previous characterization of parsers as functions from
inputs to parse results was a bit oversimplified. The previous examples showed that parsers also implement <span style="font-style:italic">methods</span> such as <pre class="code"><pre class="large">~</pre></pre> for
sequential composition of two parsers and <pre class="code">|</pre> for their alternative
composition. So <pre class="code">Parser</pre> is in reality a class that inherits from
the function type <pre class="code">Input</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">ParseResult[T]</pre> and additionally defines these methods:</p>

<pre>
  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Parser[+T]</code>&nbsp;<code class="vem">extends</code>&nbsp;(<code class="typename">Input</code>&nbsp;=&gt;&nbsp;<code class="typename">ParseResult[T]</code>)&nbsp;
  {&nbsp;p&nbsp;=&gt;
  &nbsp;&nbsp;<code class="comment">//&nbsp;An&nbsp;unspecified&nbsp;method&nbsp;that&nbsp;defines&nbsp;</code>
  &nbsp;&nbsp;<code class="comment">//&nbsp;the&nbsp;behavior&nbsp;of&nbsp;this&nbsp;parser.</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(in:&nbsp;<code class="typename">Input</code>):&nbsp;<code class="typename">ParseResult[T]</code>
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code style="font-size:large">~</code>&nbsp;...
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;|&nbsp;...
  &nbsp;&nbsp;...
  }
</pre>


<p>Since parsers are (<i>i.e.</i>, inherit from) functions, they need to define an
<pre class="code">apply</pre> method. You see an abstract <pre class="code">apply</pre> method in class
<pre class="code">Parser</pre>, but this is just for documentation, as the same method is
in any case inherited from the parent type <pre class="code">Input</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">ParseResult[T]</pre>
(recall that this type is an abbreviation for 
<pre class="code">scala.Function1[Input,</pre>&nbsp;<pre class="code">ParseResult[T]]</pre>).  
The <pre class="code">apply</pre> method still needs to be implemented
in the individual parsers that inherit from the abstract <pre class="code">Parser</pre> class. These parsers
will be discussed after the following section on <pre class="code">this</pre> aliasing.</p>

<h4>Aliasing <pre class="code">this</pre></h4>


<p><a id="sec-this-aliasing"/></p>

<p>The body of the <pre class="code">Parser</pre> class starts with a curious expression:<a id="i-206823911-1"/></p>

<pre>
  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Parser[+T]</code>&nbsp;<code class="vem">extends</code>&nbsp;...&nbsp;{&nbsp;p&nbsp;=&gt;
</pre>


<p>A clause such as "<pre class="code">id</pre>&nbsp;<pre class="code">=&gt;</pre>" immediately after the opening brace of a
class template defines the identifier <pre class="code">id</pre> as an alias<a id="i427194646-1"/><a id="i198894-1"/> for <pre class="code">this</pre> in
the class. It's as if you had written:</p>

<pre>
  <code class="vem">val</code>&nbsp;id&nbsp;=&nbsp;<code class="vem">this</code>
</pre>


<p>in the class body, except that the Scala compiler knows that <pre class="code">id</pre> is
an alias for <pre class="code">this</pre>.  For instance, you could access an
object-private member <pre class="code">m</pre> of the class using either <pre class="code">id.m</pre> or
<pre class="code">this.m</pre>; the two are completely equivalent. The first expression would not compile if 
<pre class="code">id</pre> were just defined as a <pre class="code">val</pre> with <pre class="code">this</pre> as its right hand
side, because in that case the Scala compiler would treat <pre class="code">id</pre> as
a normal identifier.</p>

<p>You saw syntax like this in <a href="modular-programming-using-objects.html#sec-modules-traits">Section 29.4</a>,
where it was used to give a <a href="glossary.html#g-1749196914">self type</a> to a trait.
Aliasing can also be a good abbreviation when you need to access the
<pre class="code">this</pre> of an outer class. Here's an example:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">Outer</code>&nbsp;{&nbsp;outer&nbsp;=&gt;
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Inner</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(Outer.this&nbsp;eq&nbsp;outer)&nbsp;<code class="comment">//&nbsp;prints:&nbsp;true</code>
  &nbsp;&nbsp;}
  }
</pre>


<p>The example defines two nested classes, <pre class="code">Outer</pre> and <pre class="code">Inner</pre>. Inside
<pre class="code">Inner</pre> the <pre class="code">this</pre> value of the <pre class="code">Outer</pre> class is referred to twice,
using different expressions. The first expression shows the Java way
of doing things: You can prefix the reserved word <pre class="code">this</pre> with the
name of an outer class and a period; such an expression then refers to
the <pre class="code">this</pre> of the outer class. The second expression shows the
alternative that Scala gives you. By introducing an alias named
<pre class="code">outer</pre> for <pre class="code">this</pre> in class <pre class="code">Outer</pre>, you can refer to this alias
directly also in inner classes.<a id="i1909060649-1"/> The Scala way is more concise, and can
also improve clarity, if you choose the name of the alias well. 
You'll see examples of this <a href="combinator-parsing.html#sec-parsers-seq">here</a> and <a href="combinator-parsing.html#sec-parsers-alt">here</a>.</p>

<h4>Single-token parsers</h4>


<p>Trait <pre class="code">Parsers</pre> defines a generic parser <pre class="code">elem</pre> that can be used to
parse any single token:</p>

<pre>
  <code class="vem">def</code>&nbsp;elem(kind:&nbsp;<code class="typename">String</code>,&nbsp;p:&nbsp;<code class="typename">Elem</code>&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Parser[Elem]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(in:&nbsp;<code class="typename">Input</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(p(in.first))&nbsp;<code class="typename">Success</code>(in.first,&nbsp;in.rest)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;<code class="typename">Failure</code>(kind&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;expected"</code>,&nbsp;in)
  &nbsp;&nbsp;}
</pre>


<p>This parser takes two parameters: a <pre class="code">kind</pre> string describing what kind
of token should be parsed and a predicate <pre class="code">p</pre> on <pre class="code">Elem</pre>s, which indicates whether
an element fits the class of tokens to be parsed.</p>

<p>When applying the parser <pre class="code">elem(kind,</pre>&nbsp;<pre class="code">p)</pre> to some input <pre class="code">in</pre>, the
first element of the input stream is tested with predicate <pre class="code">p</pre>.  If
<pre class="code">p</pre> returns <pre class="code">true</pre>, the parser succeeds. Its result is the element
itself, and its remaining input is the input stream starting just
after the element that was parsed. On the other hand, if <pre class="code">p</pre> returns
<pre class="code">false</pre>, the parser fails with an error message that indicates what
kind of token was expected.</p>

<h4>Sequential composition</h4>


<p><a id="sec-parsers-seq"/></p>

<p>The <pre class="code">elem</pre> parser only consumes a single element. To parse
more interesting phrases, you can string parsers together with the
sequential composition operator
<pre class="code"><pre class="large">~</pre></pre>.<a id="i-1259402311-2"/> As you have seen before, 
<pre class="code">P<pre class="large">~</pre>Q</pre> is a parser that applies first the <pre class="code">P</pre> parser to a given input string. 
Then, if <pre class="code">P</pre> succeeds, the <pre class="code">Q</pre> parser is applied to the input 
that's left after <pre class="code">P</pre> has done its job.</p>

<p>The <pre class="code"><pre class="large">~</pre></pre> combinator is implemented as a method in class
<pre class="code">Parser</pre>. Its definition is shown in <a href="combinator-parsing.html#lst-tilde-combinator">Listing 33.6</a>.
The method is a member of the <pre class="code">Parser</pre>
class.  Inside this class, <pre class="code">p</pre> is specified by the "<pre class="code">p</pre>&nbsp;<pre class="code">=&gt;</pre>" part as an
alias of <pre class="code">this</pre>, so <pre class="code">p</pre> designates the left operand (or:
receiver) of <pre class="code"><pre class="large">~</pre></pre>. Its right operand is represented by parameter
<pre class="code">q</pre>.  Now, if <pre class="code">p<pre class="large">~</pre>q</pre> is run on some input <pre class="code">in</pre>, first <pre class="code">p</pre> is run
on <pre class="code">in</pre> and the result is analyzed in a pattern match. If <pre class="code">p</pre>
succeeds, <pre class="code">q</pre> is run on the remaining input <pre class="code">in1</pre>. If <pre class="code">q</pre> also
succeeds, the parser as a whole succeeds.  Its result is a <pre class="code"><pre class="large">~</pre></pre> object
containing both the result of <pre class="code">p</pre> (<i>i.e.</i>, <pre class="code">x</pre>) and the result of
<pre class="code">q</pre> (<i>i.e.</i>, <pre class="code">y</pre>). On the other hand, if either <pre class="code">p</pre> or <pre class="code">q</pre> fails the result of <pre class="code">p<pre class="large">~</pre>q</pre> 
is the <pre class="code">Failure</pre> object returned by <pre class="code">p</pre> or <pre class="code">q</pre>.
<a id="lst-tilde-combinator"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Parser[+T]</code>&nbsp;...&nbsp;{&nbsp;p&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;...
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code style="font-size:large">~</code>&nbsp;[U](q:&nbsp;=&gt;&nbsp;<code class="typename">Parser[U]</code>)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Parser[T<code style="font-size:large">~</code>U]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(in:&nbsp;<code class="typename">Input</code>)&nbsp;=&nbsp;p(in)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Success</code>(x,&nbsp;in1)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q(in1)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Success</code>(y,&nbsp;in2)&nbsp;=&gt;&nbsp;<code class="typename">Success</code>(<code class="vem">new</code>&nbsp;<code style="font-size:large">~</code>(x,&nbsp;y),&nbsp;in2)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;failure&nbsp;=&gt;&nbsp;failure
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;failure&nbsp;=&gt;&nbsp;failure
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
</pre>


<h5>Listing 33.6 - The <pre class="large">~</pre> combinator method.</h5>


<p>The result type of <pre class="code"><pre class="large">~</pre></pre> is a parser that returns an instance of
the case class <pre class="code"><pre class="large">~</pre></pre> with elements of types <pre class="code">T</pre> and <pre class="code">U</pre>.  The
type expression <pre class="code">T<pre class="large">~</pre>U</pre> is just a more legible shorthand for the
parameterized type <pre class="code"><pre class="large">~</pre>[T,</pre>&nbsp;<pre class="code">U]</pre>. Generally, Scala always interprets a
binary type operation such as <pre class="code">A</pre>&nbsp;<pre class="code">op</pre>&nbsp;<pre class="code">B</pre>, as the parameterized type
<pre class="code">op[A,</pre>&nbsp;<pre class="code">B]</pre>. This is analogous to the situation for patterns, where
a binary pattern <pre class="code">P</pre>&nbsp;<pre class="code">op</pre>&nbsp;<pre class="code">Q</pre> is also interpreted as an application,
<i>i.e.</i>, <pre class="code">op(P,</pre>&nbsp;<pre class="code">Q)</pre>.</p>

<p>The other two sequential composition operators, <pre class="code">&lt;<pre class="large">~</pre></pre> and <pre class="code"><pre class="large">~</pre>&gt;</pre>, could be
defined just like <pre class="code"><pre class="large">~</pre></pre>,  only with some small adjustment in how
the result is computed.<a id="i1302279396-2"/><a id="i1234233109-2"/> A more elegant technique, though, is 
to define them in terms of <pre class="code"><pre class="large">~</pre></pre> as follows:</p>

<pre>
  <code class="vem">def</code>&nbsp;&lt;<code style="font-size:large">~</code>&nbsp;[U](q:&nbsp;=&gt;&nbsp;<code class="typename">Parser[U]</code>):&nbsp;<code class="typename">Parser[T]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;(p<code style="font-size:large">~</code>q)&nbsp;^^&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;x<code style="font-size:large">~</code>y&nbsp;=&gt;&nbsp;x&nbsp;}
  <code class="vem">def</code>&nbsp;<code style="font-size:large">~</code>&gt;&nbsp;[U](q:&nbsp;=&gt;&nbsp;<code class="typename">Parser[U]</code>):&nbsp;<code class="typename">Parser[U]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;(p<code style="font-size:large">~</code>q)&nbsp;^^&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;x<code style="font-size:large">~</code>y&nbsp;=&gt;&nbsp;y&nbsp;}
</pre>


<h4>Alternative composition</h4>


<p><a id="sec-parsers-alt"/></p>

<p>An alternative composition <pre class="code">P</pre>&nbsp;<pre class="code">|</pre>&nbsp;<pre class="code">Q</pre> applies either <pre class="code">P</pre> or <pre class="code">Q</pre> to a
given input.<a id="i1608533927-1"/> It first tries <pre class="code">P</pre>. If <pre class="code">P</pre> succeeds, the whole parser
succeeds with the result of <pre class="code">P</pre>. Otherwise, if <pre class="code">P</pre> fails, then
<pre class="code">Q</pre> is tried <span style="font-style:italic">on the same input</span> as <pre class="code">P</pre>. The result of <pre class="code">Q</pre>
is then the result of the whole parser.</p>

<p>Here is a definition of <pre class="code">|</pre> as a method of class <pre class="code">Parser</pre>:</p>

<pre>
  <code class="vem">def</code>&nbsp;|&nbsp;(q:&nbsp;=&gt;&nbsp;<code class="typename">Parser[T]</code>)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Parser[T]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(in:&nbsp;<code class="typename">Input</code>)&nbsp;=&nbsp;p(in)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;s1&nbsp;@&nbsp;<code class="typename">Success</code>(_,&nbsp;_)&nbsp;=&gt;&nbsp;s1
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;failure&nbsp;=&gt;&nbsp;q(in)&nbsp;
  &nbsp;&nbsp;}
  }
</pre>


<p>Note that if <pre class="code">P</pre> and <pre class="code">Q</pre> both fail, then the failure message is
determined by <pre class="code">Q</pre>.  This subtle choice is discussed later, in
<a href="combinator-parsing.html#sec-combinator-errors">Section 33.9</a>.</p>

<h4>Dealing with recursion</h4>


<p>Note that the <pre class="code">q</pre> parameter in methods <pre class="code"><pre class="large">~</pre></pre> and 
<pre class="code">|</pre> is by-name&mdash;its type is preceded by <pre class="code">=&gt;</pre>.<a id="i999036029-1"/> This
means that the actual parser argument will be evaluated only when <pre class="code">q</pre>
is needed, which should only be the case after <pre class="code">p</pre> has run.
This makes it possible to write recursive parsers like the following 
one which parses a number enclosed by arbitrarily many parentheses:</p>

<pre>
  <code class="vem">def</code>&nbsp;parens&nbsp;=&nbsp;floatingPointNumber&nbsp;|&nbsp;<code class="quotedstring">"("</code><code style="font-size:large">~</code>parens<code style="font-size:large">~</code><code class="quotedstring">")"</code>&nbsp;
</pre>


<p>If <pre class="code">|</pre> and <pre class="code"><pre class="large">~</pre></pre> took <a href="glossary.html#g-430862780"><em>by-value parameters</em></a>, this definition would<a id="i267370507-1"/><a id="i-471844177-1"/>
immediately cause a stack overflow without reading anything,
because the value of <pre class="code">parens</pre> occurs in the middle of its right-hand side.</p>

<h4>Result conversion</h4>


<p>The last method of class <pre class="code">Parser</pre> converts a parser's result.
The parser <pre class="code">P</pre>&nbsp;<pre class="code">^^</pre>&nbsp;<pre class="code">f</pre> succeeds exactly when
<pre class="code">P</pre> succeeds. In that case it returns <pre class="code">P</pre>'s result converted using
the function <pre class="code">f</pre>. Here is the implementation of this method:</p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;^^&nbsp;[U](f:&nbsp;T&nbsp;=&gt;&nbsp;U):&nbsp;<code class="typename">Parser[U]</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Parser[U]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(in:&nbsp;<code class="typename">Input</code>)&nbsp;=&nbsp;p(in)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Success</code>(x,&nbsp;in1)&nbsp;=&gt;&nbsp;<code class="typename">Success</code>(f(x),&nbsp;in1)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;failure&nbsp;=&gt;&nbsp;failure
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  }&nbsp;<code class="comment">//&nbsp;end&nbsp;Parser</code>
</pre>


<h4>Parsers that don't read any input</h4>


<p>There are also two parsers that do not consume any input: <pre class="code">success</pre> and <pre class="code">failure</pre>.  The
parser <pre class="code">success(result)</pre> always succeeds with the given <pre class="code">result</pre>.
The parser <pre class="code">failure(msg)</pre> always fails with error message <pre class="code">msg</pre>.
Both are implemented as methods in trait <pre class="code">Parsers</pre>, the outer
trait that also contains class <pre class="code">Parser</pre>:</p>

<pre>
  <code class="vem">def</code>&nbsp;success[T](v:&nbsp;T)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Parser[T]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(in:&nbsp;<code class="typename">Input</code>)&nbsp;=&nbsp;<code class="typename">Success</code>(v,&nbsp;in)
  }
  <code class="vem">def</code>&nbsp;failure(msg:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Parser[Nothing]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(in:&nbsp;<code class="typename">Input</code>)&nbsp;=&nbsp;<code class="typename">Failure</code>(msg,&nbsp;in)
  }
</pre>


<h4>Option and repetition</h4>


<p>Also defined in trait <pre class="code">Parsers</pre> are the option and repetition combinators
<pre class="code">opt</pre>, <pre class="code">rep</pre>, and <pre class="code">repsep</pre>.<a id="i1073514242-2"/><a id="i1251140526-1"/><a id="i476382634-1"/><a id="i1315224406-1"/> They are all implemented in terms of 
sequential composition, alternative, and result conversion:</p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;opt[T](p:&nbsp;=&gt;&nbsp;<code class="typename">Parser[T]</code>):&nbsp;<code class="typename">Parser[Option[T]]</code>&nbsp;=&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;^^&nbsp;<code class="typename">Some</code>(_)&nbsp;&nbsp;
  &nbsp;&nbsp;|&nbsp;success(<code class="typename">None</code>)
  &nbsp;&nbsp;)
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;rep[T](p:&nbsp;=&gt;&nbsp;<code class="typename">Parser[T]</code>):&nbsp;<code class="typename">Parser[List[T]]</code>&nbsp;=&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;p<code style="font-size:large">~</code>rep(p)&nbsp;^^&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;x<code style="font-size:large">~</code>xs&nbsp;=&gt;&nbsp;x&nbsp;::&nbsp;xs&nbsp;}&nbsp;&nbsp;
  &nbsp;&nbsp;|&nbsp;success(<code class="typename">List</code>())
  &nbsp;&nbsp;)
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;repsep[T](p:&nbsp;=&gt;&nbsp;<code class="typename">Parser[T]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q:&nbsp;=&gt;&nbsp;<code class="typename">Parser[Any]</code>):&nbsp;<code class="typename">Parser[List[T]]</code>&nbsp;=&nbsp;(
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;p<code style="font-size:large">~</code>rep(q<code style="font-size:large">~</code>&gt;&nbsp;p)&nbsp;^^&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;r<code style="font-size:large">~</code>rs&nbsp;=&gt;&nbsp;r&nbsp;::&nbsp;rs&nbsp;}&nbsp;&nbsp;
  &nbsp;&nbsp;|&nbsp;success(<code class="typename">List</code>())
  &nbsp;&nbsp;)
  <br />  }&nbsp;<code class="comment">//&nbsp;end&nbsp;Parsers</code>
</pre>


<h3>33.7 String literals and regular expressions</h3>


<p>The parsers you saw so far
made use of string literals
and regular expressions to parse single words. The support for these
comes from <pre class="code">RegexParsers</pre>, a subtrait of
<pre class="code">Parsers</pre>:<a id="i519257659-2"/></p>

<pre>
  <code class="vem">trait</code>&nbsp;<code class="typename">RegexParsers</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Parsers</code>&nbsp;{&nbsp;
</pre>


<p>This trait is more specialized than trait <pre class="code">Parsers</pre> in that it only works
for inputs that are sequences of characters:</p>

<pre>
  <code class="vem">type</code>&nbsp;<code class="typename">Elem</code>&nbsp;=&nbsp;<code class="typename">Char</code>
</pre>


<p>It defines two methods, <pre class="code">literal</pre> and <pre class="code">regex</pre>, with the following signatures:</p>

<pre>
  <code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;literal(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Parser[String]</code>&nbsp;=&nbsp;...
  <code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;regex(r:&nbsp;<code class="typename">Regex</code>):&nbsp;<code class="typename">Parser[String]</code>&nbsp;=&nbsp;...
</pre>


<p>Note that both methods have an <pre class="code">implicit</pre> modifier, so they are automatically applied
whenever a <pre class="code">String</pre> or <pre class="code">Regex</pre> is given but a <pre class="code">Parser</pre> is
expected.<a id="i1803313949-1"/><a id="i961731205-1"/> That's
why you can write string literals and regular expressions directly in a grammar, 
without having to wrap them with one of these methods. For instance,
the parser <pre class="code">"("<pre class="large">~</pre>expr<pre class="large">~</pre>")"</pre> will be automatically expanded to
<pre class="code">literal("(")<pre class="large">~</pre>expr<pre class="large">~</pre>literal(")")</pre>.</p>

<p>The <pre class="code">RegexParsers</pre> trait also takes care of handling white space
between symbols.  To do this, it calls a method named
<pre class="code">handleWhiteSpace</pre> before running a <pre class="code">literal</pre> or <pre class="code">regex</pre> parser.
The <pre class="code">handleWhiteSpace</pre> method skips the longest input sequence that conforms to the <pre class="code">whiteSpace</pre>
regular expression, which is defined by default as follows:</p>

<pre>
  &nbsp;&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">val</code>&nbsp;whiteSpace&nbsp;=&nbsp;<code class="quotedstring">"""\s+"""</code>.r
  }&nbsp;<code class="comment">//&nbsp;end&nbsp;RegexParsers</code>
</pre>


<p>If you prefer a different treatment of white space, you can override 
the <pre class="code">whiteSpace</pre> <pre class="code">val</pre>. For instance, if you want white space not to be skipped at all, 
you can override <pre class="code">whiteSpace</pre> with the empty regular expression:</p>

<pre>
  <code class="vem">object</code>&nbsp;<code class="typename">MyParsers</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">RegexParsers</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">val</code>&nbsp;whiteSpace&nbsp;=&nbsp;<code class="quotedstring">""</code>.r
  &nbsp;&nbsp;...
  }
</pre>


<h3>33.8 Lexing and parsing</h3>


<p>The task of syntax analysis is often split into two phases.  The <span style="font-style:italic">
  lexer</span> phase recognizes individual words in the input and classifies
them into some <span style="font-style:italic">token</span> classes. This phase is also called <span style="font-style:italic">
  lexical analysis</span>. This is followed by a <span style="font-style:italic">syntactical analysis</span>
phase that analyzes sequences of tokens.<a id="i1371644930-1"/><a id="i1779690801-1"/> Syntactical analysis is also
sometimes just called parsing, even though this is slightly imprecise,
as lexical analysis can also be regarded as a parsing problem.</p>

<p>The <pre class="code">Parsers</pre> trait as described in the previous section can be used for either phase,
because its input elements are of the abstract type <pre class="code">Elem</pre>. For
lexical analysis, <pre class="code">Elem</pre> would be instantiated to
<pre class="code">Char</pre>, meaning the individual characters that
make up a word are being parsed. The syntactical analyzer would in turn instantiate
<pre class="code">Elem</pre> to the type of token returned by the lexer.</p>

<p>Scala's parsing combinators provide several utility classes for lexical
and syntactic analysis. These are contained in two sub-packages, one for each kind of analysis:</p>

<pre>
  scala.util.parsing.combinator.lexical&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  scala.util.parsing.combinator.syntactical&nbsp;&nbsp;&nbsp;
</pre>


<p>If you want to split your parser into a separate lexer and syntactical
analyzer, you should consult the Scaladoc documentation for these packages.  But
for simple parsers, the regular expression based approach shown previously in this chapter is usually sufficient.</p>

<h3 id="sec-combinator-errors">33.9 Error reporting</h3>


<p>There's one final topic that was not covered yet: how does the parser
issue an error message? Error reporting for parsers is somewhat of a
black art. One problem is that when a parser rejects some input, it
generally has encountered many different failures.<a id="i1725890298-1"/>
Each alternative parse
must have failed, and recursively so at each choice point. Which
of the usually numerous failures should be emitted as error message to
the user?</p>

<p>Scala's parsing library implements a simple heuristic: among all
failures, the one that occurred at the latest position in the input is
chosen. In other words, the parser picks the longest prefix that is
still valid and issues an error message that describes why
parsing the prefix could not be continued further. If there are
several failure points at that latest position, the one that was
visited last is chosen.</p>

<p>For instance, consider running the JSON parser on a faulty address
book which starts with the line:</p>

<pre>
  {&nbsp;<code class="quotedstring">"name"</code>:&nbsp;<code class="typename">John</code>,
</pre>


<p>The longest legal prefix of this phrase is "<pre class="code">{</pre>&nbsp;<pre class="code">"name":</pre>&nbsp;<pre class="code"></pre>".
So the JSON parser will flag the word <pre class="code">John</pre> as an error. 
The JSON parser expects a value at this point, but <pre class="code">John</pre> is
an identifier, which does not count as a value (presumably, the author
of the document had forgotten to enclose the name in quotation marks).
The error message issued by the parser for this document is:</p>

<pre>
  [<code class="literal">1.13</code>]&nbsp;failure:&nbsp;<code class="quotedstring">"false"</code>&nbsp;expected&nbsp;but&nbsp;identifier&nbsp;<code class="typename">John</code>&nbsp;found
  <br />  &nbsp;&nbsp;{&nbsp;<code class="quotedstring">"name"</code>:&nbsp;<code class="typename">John</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
</pre>


<p>The part that "false" was expected comes from the fact that <pre class="code">"false"</pre>
is the last alternative of the production for <pre class="code">value</pre> in the JSON
grammar. So this was the last failure at this point.  Users who know
the JSON grammar in detail
can reconstruct the error message, but
for non-experts this error message is probably surprising and can also
be quite misleading.</p>

<p>A better error message can be engineered by adding a 
"catch-all" failure point as last alternative of a <pre class="code">value</pre>
production:</p>

<pre>
  <code class="vem">def</code>&nbsp;value:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=
  &nbsp;&nbsp;obj&nbsp;|&nbsp;arr&nbsp;|&nbsp;stringLit&nbsp;|&nbsp;floatingPointNumber&nbsp;|&nbsp;<code class="quotedstring">"null"</code>&nbsp;|
  &nbsp;&nbsp;<code class="quotedstring">"true"</code>&nbsp;|&nbsp;<code class="quotedstring">"false"</code>&nbsp;|&nbsp;failure(<code class="quotedstring">"illegal&nbsp;start&nbsp;of&nbsp;value"</code>)
</pre>


<p>This addition does not change the set of inputs that are accepted as valid
documents. What it does is improve the error messages, because now it will
be the explicitly added <pre class="code">failure</pre> that comes as last alternative and therefore 
gets reported:</p>

<pre>
  [<code class="literal">1.13</code>]&nbsp;failure:&nbsp;illegal&nbsp;start&nbsp;of&nbsp;value
  <br />  &nbsp;&nbsp;{&nbsp;<code class="quotedstring">"name"</code>:&nbsp;<code class="typename">John</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
</pre>


<p>The implementation of the "latest possible" scheme of error 
reporting uses a field named <pre class="code">lastFailure</pre>
in trait <pre class="code">Parsers</pre> to mark the failure that occurred at the
latest position in the input:</p>

<pre>
  <code class="vem">var</code>&nbsp;lastFailure:&nbsp;<code class="typename">Option[Failure]</code>&nbsp;=&nbsp;<code class="typename">None</code>
</pre>


<p>The field is initialized to <pre class="code">None</pre>.
It is updated in the constructor of the <pre class="code">Failure</pre> class:</p>

<pre>
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Failure</code>(msg:&nbsp;<code class="typename">String</code>,&nbsp;in:&nbsp;<code class="typename">Input</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">ParseResult[Nothing]</code>&nbsp;{
  <br />  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(lastFailure.isDefined&nbsp;&amp;&amp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastFailure.get.in.pos&nbsp;&lt;=&nbsp;in.pos)
  &nbsp;&nbsp;&nbsp;&nbsp;lastFailure&nbsp;=&nbsp;<code class="typename">Some</code>(<code class="vem">this</code>)
  }
</pre>


<p>The field is read by the <pre class="code">phrase</pre>
method, which emits the final error message if the parser failed.
Here is the implementation of <pre class="code">phrase</pre> in trait <pre class="code">Parsers</pre>:</p>

<pre>
  <code class="vem">def</code>&nbsp;phrase[T](p:&nbsp;<code class="typename">Parser[T]</code>)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Parser[T]</code>&nbsp;{
  &nbsp;&nbsp;lastFailure&nbsp;=&nbsp;<code class="typename">None</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(in:&nbsp;<code class="typename">Input</code>)&nbsp;=&nbsp;p(in)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;s&nbsp;@&nbsp;<code class="typename">Success</code>(out,&nbsp;in1)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(in1.atEnd)&nbsp;s&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;<code class="typename">Failure</code>(<code class="quotedstring">"end&nbsp;of&nbsp;input&nbsp;expected"</code>,&nbsp;in1)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;f&nbsp;:&nbsp;<code class="typename">Failure</code>&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastFailure
  &nbsp;&nbsp;}
  }
</pre>


<p>The <pre class="code">phrase</pre> method runs its argument parser <pre class="code">p</pre>. If <pre class="code">p</pre> succeeds with a
completely consumed input, the success result of <pre class="code">p</pre> is returned.
If <pre class="code">p</pre> succeeds but the input is not read completely, a failure with message
"end of input expected" is returned. If <pre class="code">p</pre> fails, the failure or error
stored in <pre class="code">lastFailure</pre> is returned. Note that the treatment of
<pre class="code">lastFailure</pre> is non-functional; it is updated as a side effect by
the constructor of <pre class="code">Failure</pre> and by the <pre class="code">phrase</pre> method itself. A
functional version of the same scheme would be possible, but it would
require threading the <pre class="code">lastFailure</pre> value through every parser
result, no matter whether this result is a <pre class="code">Success</pre> or a
<pre class="code">Failure</pre>.</p>

<h3>33.10 Backtracking versus LL(1)</h3>


<p>The parser combinators employ <span style="font-style:italic">backtracking</span> to choose between
different parsers in an alternative.<a id="i426003614-1"/> In an expression <pre class="code">P</pre>&nbsp;<pre class="code">|</pre>&nbsp;<pre class="code">Q</pre>, if
<pre class="code">P</pre> fails, then <pre class="code">Q</pre> is run on the same input as <pre class="code">P</pre>.<a id="i-2138187530-1"/> This happens even
if <pre class="code">P</pre> has parsed some tokens before failing. In this case the same
tokens will be parsed again by <pre class="code">Q</pre>.</p>

<p>Backtracking imposes only a few restrictions on how to formulate a
grammar so that it can be parsed. Essentially, you just need to avoid
left-recursive productions. A production such as:</p>

<div style="text-align: center">


<table style="border-collapse: collapse">
<tr>
  <td>
    <span style="font-style:italic">expr</span>
  </td>
  <td>
    ::=
  </td>
  <td>
    <span style="font-style:italic">expr</span> &nbsp;<pre class="code">"+"</pre>&nbsp; <span style="font-style:italic">term</span> &nbsp;|&nbsp; <span style="font-style:italic">term</span>.
  </td>
</tr>
</table>


</div>


<p>will always fail because <pre class="code">expr</pre> immediately calls itself and thus never
progresses any further.<a href="combinator-parsing.html#footnotemain33-1">[1]</a>
On the other hand, backtracking is potentially costly because the same
input can be parsed several times. Consider for instance the
production:</p>

<div style="text-align: center">


<table style="border-collapse: collapse">
<tr>
  <td>
    <span style="font-style:italic">expr</span>
  </td>
  <td>
    ::=
  </td>
  <td>
    <span style="font-style:italic">term</span> &nbsp;<pre class="code">"+"</pre>&nbsp; <span style="font-style:italic">expr</span> &nbsp;|&nbsp; <span style="font-style:italic">term</span>.
  </td>
</tr>
</table>


</div>


<p>What happens if the <pre class="code">expr</pre> parser is applied to an input such as <pre class="code">(1</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">2)</pre>&nbsp;<pre class="code">*</pre>&nbsp;<pre class="code">3</pre>
which constitutes a legal term? The first alternative would be tried,
and would fail when matching the <pre class="code">+</pre> sign. Then the second alternative would be tried 
on the same term and this would succeed. In the end the term ended up
being parsed twice.</p>

<p>It is often possible to modify the grammar so that backtracking can be
avoided. For instance, in the case of arithmetic expressions, either
one of the following productions would work:</p>

<div style="text-align: center">


<table style="border-collapse: collapse">
<tr>
  <td>
    <span style="font-style:italic">expr</span>
  </td>
  <td>
    ::=
  </td>
  <td>
    <span style="font-style:italic">term</span> &nbsp;[<pre class="code">"+"</pre>&nbsp; <span style="font-style:italic">expr</span>].
  </td>
</tr>
<tr>
  <td>
    <span style="font-style:italic">expr</span>
  </td>
  <td>
    ::=
  </td>
  <td>
    <span style="font-style:italic">term</span> &nbsp;\{<pre class="code">"+"</pre>&nbsp; <span style="font-style:italic">term</span>\}.
  </td>
</tr>
</table>


</div>


<p>Many languages admit so-called "LL(1)" grammars.<a href="combinator-parsing.html#footnotemain33-2">[2]</a> When a
combinator parser is formed from such a grammar, it will never
backtrack, <i>i.e.</i>, the input position will never be reset to an earlier
value.
For instance, the grammars for arithmetic expressions and JSON terms earlier
in this chapter are both LL(1), so the backtracking capabilities of
the parser combinator framework are never exercised for inputs from
these languages.</p>

<p>The combinator parsing framework allows you to express the expectation
that a grammar is LL(1) explicitly, using a new operator
<pre class="code"><pre class="large">~</pre>!</pre>.<a id="i1119621308-1"/>
This operator is like sequential composition <pre class="code"><pre class="large">~</pre></pre> but it will never
backtrack to "un-read" input elements that have already been parsed.
Using this operator, the productions in the arithmetic expression parser could
alternatively be written as follows:</p>

<pre>
  <code class="vem">def</code>&nbsp;expr&nbsp;&nbsp;:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;term&nbsp;<code style="font-size:large">~</code>!&nbsp;rep(<code class="quotedstring">"+"</code>&nbsp;<code style="font-size:large">~</code>!&nbsp;term&nbsp;|&nbsp;<code class="quotedstring">"-"</code>&nbsp;<code style="font-size:large">~</code>!&nbsp;term)
  <code class="vem">def</code>&nbsp;term&nbsp;&nbsp;:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;factor&nbsp;<code style="font-size:large">~</code>!&nbsp;rep(<code class="quotedstring">"*"</code>&nbsp;<code style="font-size:large">~</code>!&nbsp;factor&nbsp;|&nbsp;<code class="quotedstring">"/"</code>&nbsp;<code style="font-size:large">~</code>!&nbsp;factor)
  <code class="vem">def</code>&nbsp;factor:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="quotedstring">"("</code>&nbsp;<code style="font-size:large">~</code>!&nbsp;expr&nbsp;<code style="font-size:large">~</code>!&nbsp;<code class="quotedstring">")"</code>&nbsp;|&nbsp;floatingPointNumber
</pre>


<p>One advantage of an LL(1) parser is that it can use a simpler input
technique. Input can be read sequentially, and input elements can be
discarded once they are read. That's another reason why LL(1) parsers
are usually more efficient than backtracking parsers.<a id="i-1119687476-1"/></p>

<h3>33.11 Conclusion</h3>


<p>You have now seen all the essential elements of Scala's combinator parsing
framework. It's surprisingly little code for something that's genuinely
useful. With the framework you can construct parsers for a large class
of context-free grammars. The framework lets you get started
quickly, but it is also customizable to new kinds of grammars and input
methods. Being a Scala library, it integrates seamlessly with the rest
of the language. So it's easy to integrate a combinator parser in a
larger Scala program.</p>

<p>One downside of combinator parsers is that they are not very
efficient, at least not when compared with parsers generated from special purpose
tools such as Yacc or Bison. There are two reasons for this. First,
the backtracking method used by combinator parsing is itself not very
efficient. Depending on the grammar and the parse input, it might
yield an exponential slow-down due to repeated backtracking. This can
be fixed by making the grammar LL(1) and by using the committed sequential
composition operator, <pre class="code"><pre class="large">~</pre>!</pre>.</p>

<p>The second problem affecting the performance of combinator parsers is
that they mix parser construction and input analysis in the same set
of operations. In effect, a parser is generated anew for each input
that's parsed.</p>

<p>This problem can be overcome, but it requires a different
implementation of the parser combinator framework. In an optimizing
framework, a parser would no longer be represented as a function from
inputs to parse results. Instead, it would be represented as a tree,
where every construction step was represented as a case class. For
instance, sequential composition could be represented by a case class
<pre class="code">Seq</pre>, alternative by <pre class="code">Alt</pre>, and so on. The "outermost" parser
method, <pre class="code">phrase</pre>, could then take this symbolic representation of a
parser and convert it to highly efficient parsing tables, using
standard parser generator algorithms.</p>

<p>What's nice about all this is that from a user perspective nothing
changes compared to plain combinator parsers. Users still write
parsers in terms of <pre class="code">ident</pre>, <pre class="code">floatingPointNumber</pre>, <pre class="code"><pre class="large">~</pre></pre>, <pre class="code">|</pre>, and so on.
They need not be aware that these methods generate a
symbolic representation of a parser instead of a parser function.
Since the <pre class="code">phrase</pre> combinator converts these representations into real parsers,
everything works as before.</p>

<p>The advantage of this scheme with respect to performance is two-fold.
First, you can now factor out parser construction from input analysis.
If you were to write:</p>

<pre>
  <code class="vem">val</code>&nbsp;jsonParser&nbsp;=&nbsp;phrase(value)
</pre>


<p>and then apply <pre class="code">jsonParser</pre> to several different inputs, the 
<pre class="code">jsonParser</pre> would be constructed only once, not every time an input is read.</p>

<p>Second, the parser generation can use efficient parsing algorithms
such as LALR(1).<a id="i-572333127-1"/><a href="combinator-parsing.html#footnotemain33-3">[3]</a> These algorithms usually lead to much
faster parsers than parsers that operate with
backtracking.</p>

<p>At present, such an optimizing parser generator has not yet been
written for Scala. But it would be perfectly possible to do so.  If
someone contributes such a generator, it will be easy to integrate
into the standard Scala library.
Even postulating that such a generator will exist at some point in the
future, however, there are reasons for keeping the current parser
combinator framework around. It is much easier to understand
and to adapt than a parser generator, and the difference in
speed would often not matter in practice, unless you want to parse
very large inputs.</p>

<hr/>
<h4>Footnotes for Chapter 33:</h4>


<p><a id="footnotemain33-1"/>[1] There are ways to avoid stack overflows
even in the presence of left-recursion, but this requires 
a more refined parsing combinator framework, which to date has
not been implemented.</p>

<p><a id="footnotemain33-2"/>[2] Aho, <i>et. al.</i>,
<em>Compilers: Principles, Techniques, and Tools</em>.
 <a href="bibliography.html#aho-sethi-ullman">[Aho86]</a><a id="i1109104818-2"/></p>

<p><a id="footnotemain33-3"/>[3] Aho, <i>et. al.</i>, <em>Compilers: Principles, Techniques, and Tools</em>.  <a href="bibliography.html#aho-sethi-ullman">[Aho86]</a><a id="i-1383802058-1"/></p>

<div style="page-break-after:always"/>


<div style="page-break-after:always"/>

</body>
</html>
