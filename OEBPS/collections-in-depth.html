<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8"/>
    <title>Programming in Scala, 3rd Edition</title>

    <link rel="stylesheet" type="text/css" href="book.css" />
  </head>
<body>
<h2><a id="chap-collections-in-depth">Chapter 24</a></h2>
<h1>Collections in Depth</h1>


<p>Scala includes an elegant and powerful collection library.
Even though the collections API is subtle at first glance,
the changes it can provoke in your programming style can be
profound.  Quite often it's as if you work on a higher level
with the basic building blocks of a program being whole collections
instead of their elements. This new style of programming requires some
adaptation. Fortunately, the adaptation is helped by several nice
properties of Scala collections. They are easy to use,
concise, safe, fast, and universal.
<a id="i1077226165-1"/></p>

<ul>


<li><b>Easy to use:</b> A small vocabulary of twenty to fifty methods is
enough to solve most collection problems in a couple of operations. No
need to wrap your head around complicated looping structures or
recursions. Persistent collections and side-effect-free operations mean
that you need not worry about accidentally corrupting existing
collections with new data.  Interference between iterators and
collection updates is eliminated.


</li>
<li><b>Concise:</b> You can achieve with a single word what used to
take one or several loops. You can express functional operations with
lightweight syntax and combine operations effortlessly, so that the result
feels like a custom algebra.  


</li>
<li><b>Safe:</b> This one has to be experienced to sink in. The
statically typed and functional nature of Scala's collections means
that the overwhelming majority of errors you might make are caught at
compile-time. The reason is that (1) the collection operations
themselves are heavily used and therefore well
tested. (2) the usages of the collection operation make inputs and
output explicit as function parameters and results. (3) These explicit
inputs and outputs are subject to static type checking. The bottom line
is that the large majority of misuses will manifest themselves as type
errors. It's not at all uncommon to have programs of several hundred
lines run at first try.


</li>
<li><b>Fast:</b> Collection operations are tuned and optimized in the
libraries. As a result, using collections is typically quite
efficient. You might be able to do a little bit better with carefully
hand-tuned data structures and operations, but you might also do a lot
worse by making some suboptimal implementation decisions along the
way.  What's more, collections are have been adapted to parallel<a id="i-1874383620-2"/><a id="i-1964267956-2"/>
execution on multi-cores. Parallel collections support the same
operations as sequential ones, so no new operations need to be learned
and no code needs to be rewritten. You can turn a sequential collection into a
parallel one simply by invoking the <span class="code">par</span> method.


</li>
<li><b>Universal:</b> Collections provide the same operations on
any type where it makes sense to do so. So you can achieve a lot with
a fairly small vocabulary of operations. For instance, a string is
conceptually a sequence of characters. Consequently, in Scala
collections, strings support all sequence operations. The same holds
for arrays.


</li></ul>


<p>This chapter describes in depth the APIs of the Scala collection
classes from a user perspective.
You've already seen a quick tour of the collections library, in
<a href="working-with-other-collections.html">Chapter 17</a>.
This chapter takes you on a more detailed tour, showing
all the collection classes and all the methods they define,
so it includes everything you need to know to use
Scala  collections.
Looking ahead, <a href="the-architecture-of-scala-collections.html">Chapter 25</a> will concentrate on the
architecture and extensibility aspects of the library, for people
implementing new collection types.</p>

<h3>24.1 Mutable and immutable collections</h3>


<p>As is now familiar to you,
Scala collections systematically distinguish between mutable and
immutable collections. A mutable collection can be updated or extended
in place. This means you can change, add, or remove elements of a
collection as a side effect. Immutable collections, by contrast, never
change. You still have operations that simulate additions, removals,
or updates, but those operations will in each case return a new
collection and leave the old collection unchanged.</p>

<p>All collection classes are found in the package <span class="code">scala.collection</span> or
one of its subpackages: <span class="code">mutable</span>, <span class="code">immutable</span>, and <span class="code">generic</span>.  Most
collection classes needed by client code exist in three variants, each 
of which has different characteristics with respect to mutability. The 
three variants are located in packages <span class="code">scala.collection</span>,
<span class="code">scala.collection.immutable</span>, and <span class="code">scala.collection.mutable</span>.</p>

<p>A collection in package <span class="code">scala.collection.immutable</span> is guaranteed to
be immutable for everyone. Such a collection will never change after
it is created.  Therefore, you can rely on the fact that accessing the
same collection value repeatedly at different points in time will
always yield a collection with the same elements.</p>

<p>A collection in package <span class="code">scala.collection.mutable</span> is known to have
some operations that change the collection in place. These operations
let you write code to mutate the collection yourself. However, you must be careful
to understand and defend against any updates performed by other parts of
the code base.</p>

<p>A collection in package <span class="code">scala.collection</span> can be either mutable or
immutable. For instance, <span class="code">scala.collection.IndexedSeq[T]</span> is a supertrait of
both <span class="code">scala.collection.immutable.IndexedSeq[T]</span> and its mutable sibling
<span class="code">scala.collection.mutable.IndexedSeq[T]</span>. Generally, the root collections in
package <span class="code">scala.collection</span> define the same interface as the immutable
collections. And typically, the mutable collections in package
<span class="code">scala.collection.mutable</span> add some side-effecting
modification operations to this immutable interface.</p>

<p>The difference between root collections and immutable collections is
that clients of an immutable collection have a guarantee that nobody
can mutate the collection, whereas clients of a root collection only
know that they can't change the collection themselves.
Even though the static
type of such a collection provides no operations for modifying the
collection, it might still be possible that the run-time type is a
mutable collection that can be changed by other clients.</p>

<p>By default, Scala always picks immutable collections. For instance, if
you just write <span class="code">Set</span> without any prefix or without having imported
anything, you get an immutable set, and if you write <span class="code">Iterable</span> you
get an immutable iterable,
because these are the default bindings
imported from the <span class="code">scala</span> package. To get the mutable default
versions, you need to write explicitly <span class="code">collection.mutable.Set</span>, or
<span class="code">collection.mutable.Iterable</span>.</p>

<p>The last package in the collection hierarchy is <span class="code">collection.generic</span>. This
package contains building blocks for implementing
collections. Typically, collection classes defer the implementations
of some of their operations to classes in <span class="code">generic</span>. Everyday users of the
collection framework on the other hand should need to refer to
classes in <span class="code">generic</span> only in exceptional circumstances.</p>

<p><a id="fig-coll-hierarchy"/></p>

<pre>
  Traversable
      Iterable
          Seq
              IndexedSeq
                  Vector
                  ResizableArray
                  GenericArray
              LinearSeq
                  MutableList
                  List
                  Stream
              Buffer
                  ListBuffer
                  ArrayBuffer
          Set
              SortedSet
                  TreeSet
              HashSet (mutable)
              LinkedHashSet
              HashSet (immutable)
              BitSet
              EmptySet, Set1, Set2, Set3, Set4
          Map
              SortedMap
                  TreeMap
              HashMap (mutable)
              LinkedHashMap (mutable)
              HashMap (immutable)
              EmptyMap, Map1, Map2, Map3, Map4
</pre>


<h5>Collection hierarchy.</h5>


<h3>24.2 Collections consistency</h3>


<p>The most important collection classes are shown in
<a href="collections-in-depth.html#fig-coll-hierarchy">Figure 24.1</a>.  There is quite a bit of commonality
shared by all these classes. For instance, every kind of collection can be created by the same
uniform syntax, writing the collection class name followed by its elements:</p>

<pre>
  <code class="typename">Traversable</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="typename">Iterable</code>(<code class="quotedstring">"x"</code>,&nbsp;<code class="quotedstring">"y"</code>,&nbsp;<code class="quotedstring">"z"</code>)
  <code class="typename">Map</code>(<code class="quotedstring">"x"</code>&nbsp;-&gt;&nbsp;<code class="literal">24</code>,&nbsp;<code class="quotedstring">"y"</code>&nbsp;-&gt;&nbsp;<code class="literal">25</code>,&nbsp;<code class="quotedstring">"z"</code>&nbsp;-&gt;&nbsp;<code class="literal">26</code>)
  <code class="typename">Set</code>(<code class="typename">Color.Red</code>,&nbsp;<code class="typename">Color.Green</code>,&nbsp;<code class="typename">Color.Blue</code>)
  <code class="typename">SortedSet</code>(<code class="quotedstring">"hello"</code>,&nbsp;<code class="quotedstring">"world"</code>)
  <code class="typename">Buffer</code>(x,&nbsp;y,&nbsp;z)
  <code class="typename">IndexedSeq</code>(<code class="literal">1.0</code>,&nbsp;<code class="literal">2.0</code>)
  <code class="typename">LinearSeq</code>(a,&nbsp;b,&nbsp;c)
</pre>


<p>The same principle also applies for specific collection implementations:</p>

<pre>
  <code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="typename">HashMap</code>(<code class="quotedstring">"x"</code>&nbsp;-&gt;&nbsp;<code class="literal">24</code>,&nbsp;<code class="quotedstring">"y"</code>&nbsp;-&gt;&nbsp;<code class="literal">25</code>,&nbsp;<code class="quotedstring">"z"</code>&nbsp;-&gt;&nbsp;<code class="literal">26</code>)
</pre>


<p>The <span class="code">toString</span> methods for all collections produce output written as above,
with a type name followed by the elements of the collection in parentheses.
All collections support the API provided by
<span class="code">Traversable</span>, but their methods all return their own class
rather than the root class <span class="code">Traversable</span>.
For instance, the <span class="code">map</span> method on <span class="code">List</span> has a return type of <span class="code">List</span>,
whereas the <span class="code">map</span> method on <span class="code">Set</span> has a return type of <span class="code">Set</span>.
Thus the static return type of these methods is fairly precise:</p>

<div style="page-break-after:always"/>


<pre>
  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;map&nbsp;(_&nbsp;+&nbsp;<code class="literal">1</code>)
  <code class="output">res0:&nbsp;List[Int]&nbsp;=&nbsp;List(2,&nbsp;3,&nbsp;4)</code>
  <br />  scala&gt;&nbsp;<code class="typename">Set</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;map&nbsp;(_&nbsp;*&nbsp;<code class="literal">2</code>)
  <code class="output">res1:&nbsp;scala.collection.immutable.Set[Int]&nbsp;=&nbsp;Set(2,&nbsp;4,&nbsp;6)</code>
</pre>


<p>Equality is also organized uniformly for all collection classes; more
on this in <a href="collections-in-depth.html#sec-coll-arch-eq">Section 24.13</a>.</p>

<p>Most of the classes in <a href="collections-in-depth.html#fig-coll-hierarchy">Figure 24.1</a> exist in three
variants: root, mutable, and immutable. The only exception is the
<span class="code">Buffer</span> trait, which only exists as a mutable collection.</p>

<p>In the remainder of this chapter, we will review these classes one by one.</p>

<h3>24.3 Trait <span class="code">Traversable</span></h3>


<p>At the top of the collection hierarchy is trait <span class="code">Traversable</span>. Its only
abstract operation is <span class="code">foreach</span>:</p>

<pre>
  <code class="vem">def</code>&nbsp;foreach[U](f:&nbsp;<code class="typename">Elem</code>&nbsp;=&gt;&nbsp;U)&nbsp;
</pre>


<p>Collection classes implementing <span class="code">Traversable</span> just need to define this method; all other
methods can be inherited from <span class="code">Traversable</span>.</p>

<p>The <span class="code">foreach</span> method is meant to traverse all elements of the collection, and
apply the given operation, <span class="code">f</span>, to each element. The type of the
operation is <span class="code">Elem</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">U</span>, where <span class="code">Elem</span> is the type of the
collection's elements and <span class="code">U</span> is an arbitrary result type.  The
invocation of <span class="code">f</span> is done for its side effect only; in fact any
function result of <span class="code">f</span> is discarded by <span class="code">foreach</span>.</p>

<p><span class="code">Traversable</span> also defines many concrete methods, which are all listed
in <a href="collections-in-depth.html#tab-traversableops">Table 24.1</a>  <a href="collections-in-depth.html#tab-traversableops">here</a>. These methods
fall into the following categories:</p>

<ul>


<li><b><span style="font-style:italic">Addition</span></b> <span class="code">++</span>, which appends two traversables
  together, or appends all elements of an iterator to a traversable.


</li>
<li><b><span style="font-style:italic">Map</span> <em>operations</em></b> <span class="code">map</span>, <span class="code">flatMap</span>, and <span class="code">collect</span>,
  which produce a new collection by applying some function to
  collection elements.


</li>
<li><b><span style="font-style:italic">Conversions</span></b> <span class="code">toIndexedSeq</span>, <span class="code">toIterable</span>, <span class="code">toStream</span>, <span class="code">toArray</span>, <span class="code">toList</span>, <span class="code">toSeq</span>,
  <span class="code">toSet</span>, and <span class="code">toMap</span>, which turn a
  <span class="code">Traversable</span> collection into a more specific collection. All these
  conversions return the receiver object if it
  already matches the demanded collection type. For instance, applying
  <span class="code">toList</span> to a list will yield the list itself.<a id="i595962916-2"/>


</li>
<li><b><span style="font-style:italic">Copying operations</span></b> <span class="code">copyToBuffer</span> and <span class="code">copyToArray</span>.
  As their names imply, these copy collection elements to a buffer or
   array, respectively.


</li>
<li><b><span style="font-style:italic">Size operations</span></b> <span class="code">isEmpty</span>, <span class="code">nonEmpty</span>, <span class="code">size</span>, and
  <span class="code">hasDefiniteSize</span>. Collections that are traversable can be finite or infinite. An example of an
  infinite traversable collection is the stream of natural numbers
  <span class="code">Stream.from(0)</span>. The method <span class="code">hasDefiniteSize</span> indicates whether a
  collection is possibly infinite. If <span class="code">hasDefiniteSize</span> returns true,
  the collection is certainly finite. If it returns false, the
  collection might be infinite, in which case <span class="code">size</span> will emit an
  error or not return.


</li>
<li><b><span style="font-style:italic">Element retrieval operations</span></b> <span class="code">head</span>, <span class="code">last</span>,
  <span class="code">headOption</span>, <span class="code">lastOption</span>, and <span class="code">find</span>. These select the first or
  last element of a collection, or else the first element matching a
  condition. Note, however, that not all collections have a
  well-defined meaning of what "first" and "last" means. For
  instance, a hash set might store elements according to their hash
  keys, which might change from run to run. In that case, the
  "first" element of a hash set could also be different for different runs of a program. A collection is <span style="font-style:italic">ordered</span> if it always yields
  its elements in the same order. Most collections are ordered, but
  some (such as hash sets) are not&mdash;dropping the ordering provides a
  little bit of extra efficiency. Ordering is often essential to
  give reproducible tests and help in debugging. That's why Scala
  collections provide ordered alternatives for all collection types. For
  instance, the ordered alternative for <span class="code">HashSet</span> is
  <span class="code">LinkedHashSet</span>.


</li>
<li><b><span style="font-style:italic">Subcollection retrieval</span> <em>operations</em></b> <span class="code">takeWhile</span>, <span class="code">tail</span>, <span class="code">init</span>,
  <span class="code">slice</span>, <span class="code">take</span>, <span class="code">drop</span>, <span class="code">filter</span>, <span class="code">dropWhile</span>, 
  <span class="code">filterNot</span>, and <span class="code">withFilter</span>. These all return some subcollection identified by an
  index range or a predicate.


</li>
<li><b><span style="font-style:italic">Subdivision</span> <em>operations</em></b> <span class="code">splitAt</span>, <span class="code">span</span>, <span class="code">partition</span>,
  and <span class="code">groupBy</span>, which split the elements of this collection into
  several subcollections.


</li>
<li><b><span style="font-style:italic">Element tests</span></b> <span class="code">exists</span>, <span class="code">forall</span>, and <span class="code">count</span>, which
  test collection elements with a given predicate.


</li>
<li><b><span style="font-style:italic">Folds</span></b> <span class="code">foldLeft</span>, <span class="code">foldRight</span>, <span class="code">/:</span>, <span class="code">:\</span>,
  <span class="code">reduceLeft</span>, <span class="code">reduceRight</span>, which apply a binary operation to
  successive elements.


</li>
<li><b><span style="font-style:italic">Specific folds</span></b> <span class="code">sum</span>, <span class="code">product</span>, <span class="code">min</span>, and <span class="code">max</span>, which
  work on collections of specific types (numeric or comparable).


</li>
<li><b><span style="font-style:italic">String operations</span></b> <span class="code">mkString</span>, <span class="code">addString</span>,
  and <span class="code">stringPrefix</span>, which provide alternative ways of converting
  a collection to a string.


</li>
<li><b><span style="font-style:italic">View operations</span></b> consisting of two overloaded variants of
  the <span class="code">view</span> method. A view is a collection that's evaluated
  lazily. You'll learn more about views in <a href="collections-in-depth.html#sec-views">Section 24.14</a>.


</li></ul>


<p><a id="tab-traversableops"/></p>

<h5>Operations in trait <span class="code">Traversable</span></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Abstract method:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">foreach</span>&nbsp;<span class="code">f</span>
  </td>
  <td>
    Executes function <span class="code">f</span> for every element of
<span class="code">xs</span>.<a id="i-55657802-1"/><a id="i-1261160032-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Addition:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">++</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    A collection consisting of the elements of both
                   <span class="code">xs</span> and <span class="code">ys</span>. <span class="code">ys</span> is a <span class="code">TraversableOnce</span>
                   collection, <i>i.e.</i>, either a <span class="code">Traversable</span> or an
                   <span class="code">Iterator</span>.<a id="i-1450927830-1"/><a id="i422597625-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Maps:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">map</span>&nbsp;<span class="code">f</span>
  </td>
  <td>
    The collection obtained from applying the function <span class="code">f</span> to every
                   element in <span class="code">xs</span>.<a id="i1930914020-1"/><a id="i1892128690-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">flatMap</span>&nbsp;<span class="code">f</span>
  </td>
  <td>
    The collection obtained from applying the
                   collection-valued function <span class="code">f</span> to every element in <span class="code">xs</span> and
                   concatenating the results.<a id="i1974841698-1"/><a id="i-1362319751-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">collect</span>&nbsp;<span class="code">f</span>
  </td>
  <td>
    The collection obtained from applying the partial function <span class="code">f</span> to every
                   element in <span class="code">xs</span> for which it is defined and
                   collecting the results.<a id="i-890132522-1"/><a id="i365967488-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Conversions:<!-- \hfill -->  </span>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.toArray</span>
  </td>
  <td>
    Converts the collection to an array.<a id="i-170007326-1"/><a id="i-1765859340-1"/><a id="i595962916-3"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.toList</span>
  </td>
  <td>
    Converts the collection to a list.<a id="i1148184999-1"/><a id="i1467376547-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.toIterable</span>
  </td>
  <td>
    Converts the collection to an iterable.<a id="i-2134643757-1"/><a id="i519335159-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.toSeq</span>
  </td>
  <td>
    Converts the collection to a sequence.<a id="i896539484-1"/><a id="i1571361978-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.toIndexedSeq</span>
  </td>
  <td>
    Converts the collection to an indexed sequence.<a id="i-1715666217-1"/><a id="i-909761293-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.toStream</span>
  </td>
  <td>
    Converts the collection to a stream (a lazily computed sequence).<a id="i-1816039227-1"/><a id="i1610110277-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.toSet</span>
  </td>
  <td>
    Converts the collection to a set.<a id="i930487865-1"/><a id="i1571361981-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.toMap</span>
  </td>
  <td>
    Converts a collection of key/value pairs to a map.<a id="i-1342255233-1"/><a id="i1571356087-1"/>
  </td>
</tr>
<tr>
  <td>


<span style="font-weight:bold">Copying:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">copyToBuffer</span>&nbsp;<span class="code">buf</span>
  </td>
  <td>
    Copies all elements of the collection to buffer <span class="code">buf</span>.<a id="i-1728300656-1"/><a id="i348365722-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">copyToArray(arr,</span>&nbsp;<span class="code">s,</span>&nbsp;<span class="code">len)</span>
  </td>
  <td>
    Copies at most <span class="code">len</span> elements of
                    <span class="code">arr</span>, starting at index <span class="code">s</span>. The last two
                    arguments are optional.<a id="i406691112-1"/><a id="i-266858561-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Size info:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.isEmpty</span>
  </td>
  <td>
    Tests whether the collection is empty.<a id="i-1900529315-1"/><a id="i1474562457-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.nonEmpty</span>
  </td>
  <td>
    Tests whether the collection contains elements.<a id="i-1206604224-1"/><a id="i472626666-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.size</span>
  </td>
  <td>
    The number of elements in the collection.<a id="i-577762209-1"/><a id="i-1473365909-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.hasDefiniteSize</span>
  </td>
  <td>
    True if <span class="code">xs</span> is known to have finite size.<a id="i357541973-1"/><a id="i-1206976095-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Element retrieval:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.head</span>
  </td>
  <td>
    The first element of the collection (or, some
                     element, if no order is defined).<a id="i1226948320-1"/><a id="i-1473698230-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.headOption</span>
  </td>
  <td>
    The first element of <span class="code">xs</span> in an option value, or
                     <span class="code">None</span> if <span class="code">xs</span> is empty.<a id="i-544762261-1"/><a id="i703675231-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.last</span>
  </td>
  <td>
    The last element of the collection (or, some
                     element, if no order is defined).<a id="i-1561821718-1"/><a id="i-1473582336-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.lastOption</span>
  </td>
  <td>
    The last element of <span class="code">xs</span> in an option value, or
                     <span class="code">None</span> if <span class="code">xs</span> is empty.<a id="i604071413-1"/><a id="i1178476437-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">find</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    An option containing the first element in <span class="code">xs</span>
                    that satisfies <span class="code">p</span>, or <span class="code">None</span> if no element
                    qualifies.<a id="i1562452856-1"/><a id="i-1473753565-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Subcollections:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.tail</span>
  </td>
  <td>
    The rest of the collection except
                     <span class="code">xs.head</span>.<a id="i-1154929040-1"/><a id="i-1473344326-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.init</span>
  </td>
  <td>
    The rest of the collection except
                     <span class="code">xs.last</span>.<a id="i1119663536-1"/><a id="i-1473659526-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">slice</span>&nbsp;<span class="code">(from,</span>&nbsp;<span class="code">to)</span>
  </td>
  <td>
    A collection consisting of elements in some
                     index range of <span class="code">xs</span> (from <span class="code">from</span>, up to and excluding <span class="code">to</span>).<a id="i17106030-1"/><a id="i1570370152-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">take</span>&nbsp;<span class="code">n</span>
  </td>
  <td>
    A collection consisting of the first <span class="code">n</span>
                     elements of <span class="code">xs</span> (or, some
                     arbitrary <span class="code">n</span> elements, if no order is
                     defined).<a id="i-1414646842-1"/><a id="i-1473344271-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">drop</span>&nbsp;<span class="code">n</span>
  </td>
  <td>
    The rest of the collection except 
                     <span class="code">xs</span>&nbsp;<span class="code">take</span>&nbsp;<span class="code">n</span>.<a id="i1762200625-1"/><a id="i-1473804455-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">takeWhile</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    The longest prefix of elements in the collection
                     that all satisfy <span class="code">p</span>.<a id="i793978345-1"/><a id="i-884753216-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">dropWhile</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    The collection without the longest prefix
                     of elements that all satisfy <span class="code">p</span>.<a id="i-361174399-1"/><a id="i1397687128-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">filter</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    The collection consisting of those elements of
                   <span class="code">xs</span> that satisfy the predicate <span class="code">p</span>.<a id="i-1530083256-1"/><a id="i1061990754-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">withFilter</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    A non-strict filter of this collection. All operations
                    on the resulting filter will only apply to those elements
                    of <span class="code">xs</span> for which the condition <span class="code">p</span> is true.<a id="i1170520482-1"/><a id="i1155407048-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">filterNot</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    The collection consisting of those elements of
                   <span class="code">xs</span> that do not satisfy the predicate <span class="code">p</span>.<a id="i-1075168667-1"/><a id="i1037528593-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Subdivisions:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">splitAt</span>&nbsp;<span class="code">n</span>
  </td>
  <td>
    Splits <span class="code">xs</span> at a position, 
                     giving the pair of collections <span class="code">(xs</span>&nbsp;<span class="code">take</span>&nbsp;<span class="code">n,</span>&nbsp;<span class="code">xs</span>&nbsp;<span class="code">drop</span>&nbsp;<span class="code">n)</span>.<a id="i-2145528916-1"/><a id="i1709677635-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">span</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    Splits <span class="code">xs</span> according to a predicate,
                     giving the pair of collections <span class="code">(xs</span>&nbsp;<span class="code">takeWhile</span>&nbsp;<span class="code">p,</span> <span class="code">xs.dropWhile</span>&nbsp;<span class="code">p)</span>.<a id="i743977545-1"/><a id="i-1473359948-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">partition</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    Splits <span class="code">xs</span> into a pair of collections; 
                     one with elements that satisfy the predicate <span class="code">p</span>, 
                     the other with elements that do not, giving the 
                     pair of collections <span class="code">(xs</span>&nbsp;<span class="code">filter</span>&nbsp;<span class="code">p,</span>&nbsp;<span class="code">xs.filterNot</span>&nbsp;<span class="code">p)</span>.<a id="i-960178711-1"/><a id="i119106752-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">groupBy</span>&nbsp;<span class="code">f</span>
  </td>
  <td>
    Partitions <span class="code">xs</span> into a map of collections according
                    to a discriminator function <span class="code">f</span>.<a id="i534640970-1"/><a id="i-290049396-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Element conditions:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">forall</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    A boolean indicating whether the predicate <span class="code">p</span> holds for
                    all elements of <span class="code">xs</span>.<a id="i2035711880-1"/><a id="i1067692578-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">exists</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    A boolean indicating whether the predicate <span class="code">p</span> holds for
                    some element in <span class="code">xs</span>.<a id="i191461860-1"/><a id="i1047124550-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">count</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    The number of elements in <span class="code">xs</span> that satisfy the
                    predicate <span class="code">p</span>.<a id="i-84828655-1"/><a id="i1555695077-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Folds:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">(z</span>&nbsp;<span class="code">/:</span>&nbsp;<span class="code">xs)(op)</span>
  </td>
  <td>
    Applies binary operation <span class="code">op</span> between successive
                    elements of <span class="code">xs</span>, going left to right, 
                    starting with <span class="code">z</span>.<a id="i943006250-1"/><a id="i1779314560-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">(xs</span>&nbsp;<span class="code">:\</span>&nbsp;<span class="code">z)(op)</span>
  </td>
  <td>
    Applies binary operation <span class="code">op</span> between successive
                    elements of <span class="code">xs</span>, going right to left,
                    starting with <span class="code">z</span>.<a id="i-1539896954-1"/><a id="i16104711-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.foldLeft(z)(op)</span>
  </td>
  <td>
    Same as <span class="code">(z</span>&nbsp;<span class="code">/:</span>&nbsp;<span class="code">xs)(op)</span>.<a id="i161789991-1"/><a id="i-614577390-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.foldRight(z)(op)</span>
  </td>
  <td>
    Same as <span class="code">(xs</span>&nbsp;<span class="code">:\</span>&nbsp;<span class="code">z)(op)</span>.<a id="i-1873963302-1"/><a id="i-1866368911-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">reduceLeft</span>&nbsp;<span class="code">op</span>
  </td>
  <td>
    Applies binary operation <span class="code">op</span> between successive
                    elements of non-empty collection <span class="code">xs</span>, going left
                    to right.<a id="i-1485439668-1"/><a id="i-1859074185-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">reduceRight</span>&nbsp;<span class="code">op</span>
  </td>
  <td>
    Applies binary operation <span class="code">op</span> between successive
                    elements of non-empty collection <span class="code">xs</span>, going
                    right to left.<a id="i-1454040022-1"/><a id="i-1791063892-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Specific folds:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.sum</span>
  </td>
  <td>
    The sum of the numeric element values of collection <span class="code">xs</span>.<a id="i1147308629-1"/><a id="i1892135073-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.product</span>
  </td>
  <td>
    The product of the numeric element values of collection <span class="code">xs</span>.<a id="i844574257-1"/><a id="i-892951483-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.min</span>
  </td>
  <td>
    The minimum of the ordered element values of collection <span class="code">xs</span>.<a id="i419713966-1"/><a id="i1892128936-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.max</span>
  </td>
  <td>
    The maximum of the ordered element values of collection <span class="code">xs</span>.<a id="i2021443036-1"/><a id="i1892128698-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Strings:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">addString</span>&nbsp;<span class="code">(b,</span>&nbsp;<span class="code">start,</span>
  </td>
</tr>
<tr>
  <td>
    <span class="code">sep,</span>&nbsp;<span class="code">end)</span>
  </td>
  <td>
    Adds a string to <span class="code">StringBuilder</span> <span class="code">b</span> that shows all elements of <span class="code">xs</span>
                      between separators <span class="code">sep</span> enclosed in strings
                      <span class="code">start</span> and <span class="code">end</span>. <span class="code">start</span>, <span class="code">sep</span>, and <span class="code">end</span> are
                      all optional.<a id="i-1321009903-1"/><a id="i1919771112-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">mkString</span>&nbsp;<span class="code">(start,</span>
  </td>
</tr>
<tr>
  <td>
    <span class="code">sep,</span>&nbsp;<span class="code">end)</span>
  </td>
  <td>
    Converts the collection to a string that shows all elements of <span class="code">xs</span>
                      between separators <span class="code">sep</span> enclosed in strings
                      <span class="code">start</span> and <span class="code">end</span>. <span class="code">start</span>, <span class="code">sep</span>, and <span class="code">end</span> are
                      all optional.<a id="i1706355665-2"/><a id="i-1254670663-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.stringPrefix</span>
  </td>
  <td>
    The collection name at the beginning of the string returned from <span class="code">xs.toString</span>.<a id="i-1294920291-1"/><a id="i436681837-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Views:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.view</span>
  </td>
  <td>
    Produces a view over <span class="code">xs</span>.<a id="i-1406999493-1"/><a id="i-1473277169-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">view</span>&nbsp;<span class="code">(from,</span>&nbsp;<span class="code">to)</span>
  </td>
  <td>
    Produces a view that represents the elements in some
                     index range of <span class="code">xs</span>.
  </td>
</tr>
</table>


<h3>24.4 Trait <span class="code">Iterable</span></h3>


<p>The next trait from the top in <a href="collections-in-depth.html#fig-coll-hierarchy">Figure 24.1</a> is
<span class="code">Iterable</span>.  All methods in this trait are defined in terms of an
abstract method, <span class="code">iterator</span>, which yields the collection's elements one
by one. The abstract <span class="code">foreach</span> method inherited from trait <span class="code">Traversable</span> is implemented
in <span class="code">Iterable</span> in terms of <span class="code">iterator</span>. Here is the actual implementation:</p>

<pre>
  <code class="vem">def</code>&nbsp;foreach[U](f:&nbsp;<code class="typename">Elem</code>&nbsp;=&gt;&nbsp;U):&nbsp;<code class="typename">Unit</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;it&nbsp;=&nbsp;iterator
  &nbsp;&nbsp;<code class="vem">while</code>&nbsp;(it.hasNext)&nbsp;f(it.next())
  }&nbsp;
</pre>


<p>Quite a few subclasses of <span class="code">Iterable</span> override this standard 
implementation of <span class="code">foreach</span> in <span class="code">Iterable</span>, because they
can provide a more efficient implementation. Remember that <span class="code">foreach</span>
is the basis of the implementation of all operations in <span class="code">Traversable</span>,
so its performance matters.</p>

<p>Two more methods exist in <span class="code">Iterable</span> that return iterators:
<span class="code">grouped</span> and <span class="code">sliding</span>. These iterators, however, do not return
single elements but whole subsequences of elements of the original
collection. The maximal size of these subsequences is given as an
argument to these methods. The <span class="code">grouped</span> method chunks its
elements into increments, whereas <span class="code">sliding</span> yields a sliding
window over the elements.
The difference between the two should
become clear by looking at the following interpreter interaction:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;xs&nbsp;=&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">5</code>)
  <code class="output">xs:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;git&nbsp;=&nbsp;xs&nbsp;grouped&nbsp;<code class="literal">3</code>
  <code class="output">git:&nbsp;Iterator[List[Int]]&nbsp;=&nbsp;non-empty&nbsp;iterator</code>
  <br />  scala&gt;&nbsp;git.next()
  <code class="output">res2:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;git.next()
  <code class="output">res3:&nbsp;List[Int]&nbsp;=&nbsp;List(4,&nbsp;5)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;sit&nbsp;=&nbsp;xs&nbsp;sliding&nbsp;<code class="literal">3</code>
  <code class="output">sit:&nbsp;Iterator[List[Int]]&nbsp;=&nbsp;non-empty&nbsp;iterator</code>
  <br />  scala&gt;&nbsp;sit.next()
  <code class="output">res4:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;sit.next()
  <code class="output">res5:&nbsp;List[Int]&nbsp;=&nbsp;List(2,&nbsp;3,&nbsp;4)</code>
  <br />  scala&gt;&nbsp;sit.next()
  <code class="output">res6:&nbsp;List[Int]&nbsp;=&nbsp;List(3,&nbsp;4,&nbsp;5)</code>
</pre>


<p>Trait <span class="code">Iterable</span> also adds some other methods to <span class="code">Traversable</span> that 
can be implemented efficiently only if an iterator is available. 
They are
summarized in <a href="collections-in-depth.html#tab-iterableops">Table 24.2</a>:</p>

<p><a id="tab-iterableops"/></p>

<h5>Operations in trait <span class="code">Iterable</span> <a id="i-930863599-1"/></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Abstract method:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.iterator</span>
  </td>
  <td>
    An iterator that yields every element in <span class="code">xs</span>,
                    in the same order as <span class="code">foreach</span> traverses elements<a id="i1960545726-1"/><a id="i-2123398051-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Other iterators:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">grouped</span>&nbsp;<span class="code">size</span>
  </td>
  <td>
    An iterator that yields fixed-sized "chunks" of 
                   this collection<a id="i1434663977-1"/><a id="i-1891423857-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">sliding</span>&nbsp;<span class="code">size</span>
  </td>
  <td>
    An iterator that yields a sliding fixed-sized window of 
                   elements in this collection<a id="i-2085639431-1"/><a id="i-9143201-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Subcollections:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">takeRight</span>&nbsp;<span class="code">n</span>
  </td>
  <td>
    A collection consisting of the last <span class="code">n</span>
                     elements of <span class="code">xs</span> (or, some
                     arbitrary <span class="code">n</span> elements, if no order is
                     defined)<a id="i-1293058080-1"/><a id="i2082036678-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">dropRight</span>&nbsp;<span class="code">n</span>
  </td>
  <td>
    The rest of the collection except
                    <span class="code">xs</span>&nbsp;<span class="code">takeRight</span>&nbsp;<span class="code">n</span><a id="i636434552-1"/><a id="i69509726-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Zippers:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">zip</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    An iterable of pairs of corresponding elements from <span class="code">xs</span> and <span class="code">ys</span><a id="i-1097812436-1"/><a id="i-379690542-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">zipAll</span>&nbsp;<span class="code">(ys,</span>&nbsp;<span class="code">x,</span>&nbsp;<span class="code">y)</span>
  </td>
  <td>
    An iterable of pairs of corresponding elements from <span class="code">xs</span> and <span class="code">ys</span>,
                  where the shorter sequence is extended to match the longer one
                  by appending elements <span class="code">x</span> or <span class="code">y</span><a id="i1056526603-1"/><a id="i1582986863-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.zipWithIndex</span>
  </td>
  <td>
    An iterable of pairs of elements from <span class="code">xs</span> with their indicies<a id="i628301846-1"/><a id="i-1524777478-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Comparison:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">sameElements</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    Tests whether <span class="code">xs</span> and <span class="code">ys</span> contain the same
                    elements in the same order<a id="i-2017721464-1"/><a id="i-1057289236-1"/>
  </td>
</tr>
</table>


<h4>Why have both <span class="code">Traversable</span> and <span class="code">Iterable</span>?</h4>


<p>You might wonder why the extra trait <span class="code">Traversable</span> is above
<span class="code">Iterable</span>. Can we not do everything with an <span class="code">iterator</span>? So what's
the point of having a more abstract trait that defines its methods in
terms of <span class="code">foreach</span> instead of <span class="code">iterator</span>? One reason for having
<span class="code">Traversable</span> is that sometimes it is easier or more efficient to
provide an implementation of <span class="code">foreach</span> than to provide an
implementation of <span class="code">iterator</span>. Here's a simple example. Let's say you
want a class hierarchy for binary trees that have integer elements
at the leaves. You might design this hierarchy like this:</p>

<pre>
  <code class="vem">sealed</code>&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Tree</code>
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Branch</code>(left:&nbsp;<code class="typename">Tree</code>,&nbsp;right:&nbsp;<code class="typename">Tree</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Tree</code>
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Node</code>(elem:&nbsp;<code class="typename">Int</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Tree</code>
</pre>


<p>Now assume you want to make trees traversable. To do this, have
<span class="code">Tree</span> inherit from <span class="code">Traversable[Int]</span> and define a <span class="code">foreach</span> method like this:</p>

<pre>
  <code class="vem">sealed</code>&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Tree</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Traversable[Int]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;foreach[U](f:&nbsp;<code class="typename">Int</code>&nbsp;=&gt;&nbsp;U)&nbsp;=&nbsp;<code class="vem">this</code>&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Node</code>(elem)&nbsp;=&gt;&nbsp;f(elem)
  &nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Branch</code>(l,&nbsp;r)&nbsp;=&gt;&nbsp;l&nbsp;foreach&nbsp;f;&nbsp;r&nbsp;foreach&nbsp;f
  &nbsp;&nbsp;}
  }
</pre>


<p>That's not too hard, and it is also very efficient&mdash;traversing a
balanced tree takes time proportional to the number of elements in the
tree.  To see this, consider that for a balanced tree with <span class="code">N</span> leaves
you will have <span class="code">N</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">1</span> interior nodes of class <span class="code">Branch</span>. So the total
number of steps to traverse the tree is <span class="code">N</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">N</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">1</span>.</p>

<p>Now, compare this with making trees iterable. To do this, have <span class="code">Tree</span> inherit
from <span class="code">Iterable[Int]</span> and define an <span class="code">iterator</span> method like this:</p>

<pre>
  <code class="vem">sealed</code>&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Tree</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Iterable[Int]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;iterator:&nbsp;<code class="typename">Iterator[Int]</code>&nbsp;=&nbsp;<code class="vem">this</code>&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Node</code>(elem)&nbsp;=&gt;&nbsp;Iterator.single(elem)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Branch</code>(l,&nbsp;r)&nbsp;=&gt;&nbsp;l.iterator&nbsp;++&nbsp;r.iterator
  &nbsp;&nbsp;}
  }
</pre>


<p>At first glance, this looks no harder than the <span class="code">foreach</span> solution. However, there's 
an efficiency problem that has to do with the implementation of the 
iterator concatenation method, <span class="code">++</span>. Every time an element
is produced by a concatenated iterator such as
<span class="code">l.iterator</span>&nbsp;<span class="code">++</span>&nbsp;<span class="code">r.iterator</span>, the computation needs to follow one indirection
to get at the right iterator (either <span class="code">l.iterator</span>, or <span class="code">r.iterator</span>).
Overall, that makes \<i>log</i>(<i>N</i>) indirections to get at a leaf of a balanced
tree with <span class="code">N</span> leaves. So the cost of visiting all elements of a tree
went up from about <span class="code">2N</span> for the <span class="code">foreach</span> traversal method to
<span class="code">N</span>&nbsp;<span class="code">\<i>log</i>(N)</span> for the traversal with <span class="code">iterator</span>. If the tree has a 
million elements that means about two million steps for <span class="code">foreach</span> and 
about twenty million steps for <span class="code">iterator</span>. 
So the <span class="code">foreach</span> solution has a clear advantage.</p>

<h4>Subcategories of <span class="code">Iterable</span></h4>


<p>In the inheritance hierarchy below <span class="code">Iterable</span> you find three traits:
<span class="code">Seq</span>, <span class="code">Set</span>, and <span class="code">Map</span>. A common aspect of these three traits is
that they all implement the <span class="code">PartialFunction</span> trait<a href="collections-in-depth.html#footnotemain24-1">[1]</a> with its
<span class="code">apply</span> and <span class="code">isDefinedAt</span> methods. However, the way each trait implements 
<span class="code">PartialFunction</span> differs.</p>

<p>For sequences, <span class="code">apply</span> is positional indexing, where elements are
always numbered from <span class="code">0</span>.  That is, <span class="code">Seq(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)(1)</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">2</span>.
For
sets, <span class="code">apply</span> is a membership test. For instance, <span class="code">Set('a',</span>&nbsp;<span class="code">'b',</span>&nbsp;<span class="code">'c')('b')</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">true</span> whereas <span class="code">Set()('a')</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">false</span>. Finally for maps,
<span class="code">apply</span> is a selection. For instance, <span class="code">Map('a'</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">1,</span>&nbsp;<span class="code">'b'</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">10,</span>&nbsp;<span class="code">'c'</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">100)('b')</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">10</span>.</p>

<p>In the following three sections, we will explain each of the three kinds of
collections in more detail.</p>

<h3>24.5 The sequence traits <span class="code">Seq</span>, <span class="code">IndexedSeq</span>, and
<span class="code">LinearSeq</span></h3>


<p>The <span class="code">Seq</span> trait represents sequences. A sequence is a kind of
iterable that has a <span class="code">length</span> and whose elements have fixed index
positions, starting from <span class="code">0</span>.</p>

<p>The operations on sequences, summarized in
<a href="collections-in-depth.html#tab-seqops">Figure 24.3</a>, fall into the following categories:</p>

<ul>


<li><b><span style="font-style:italic">Indexing and length operations</span></b> <span class="code">apply</span>, <span class="code">isDefinedAt</span>,
  <span class="code">length</span>, <span class="code">indices</span>, and <span class="code">lengthCompare</span>. For a <span class="code">Seq</span>, the <span class="code">apply</span> operation
means indexing; hence a sequence of type <span class="code">Seq[T]</span> is a partial
function that takes an <span class="code">Int</span> argument (an index) and yields a
sequence element of type <span class="code">T</span>. In other words <span class="code">Seq[T]</span> extends
<span class="code">PartialFunction[Int,</span>&nbsp;<span class="code">T]</span>. The elements of a sequence are indexed
from zero up to the <span class="code">length</span> of the sequence minus
one. The <span class="code">length</span> method on sequences is an alias
of the <span class="code">size</span> method of general collections. The <span class="code">lengthCompare</span> method
allows you to compare the lengths of two sequences even if one of the sequences
has infinite length.


</li>
<li><b><span style="font-style:italic">Index search</span> <em>operations</em></b> <span class="code">indexOf</span>, <span class="code">lastIndexOf</span>, <span class="code">indexOfSlice</span>,
<span class="code">lastIn</span>- <span class="code">dexOfSlice</span>, <span class="code">indexWhere</span>, <span class="code">lastIndexWhere</span>, <span class="code">segmentLength</span>, and <span class="code">prefixLength</span>,
which return the index of an element equal to a given value or matching some predicate.


</li>
<li><b><span style="font-style:italic">Addition</span> <em>operations</em></b> <span class="code">+:</span>, <span class="code">:+</span>, and <span class="code">padTo</span>, which
return new sequences obtained by adding elements at the front or the end of a sequence.


</li>
<li><b><span style="font-style:italic">Update operations</span></b> <span class="code">updated</span> and <span class="code">patch</span>, which return a new
  sequence obtained by replacing some elements of the original sequence.


</li>
<li><b><span style="font-style:italic">Sorting operations</span></b> <span class="code">sorted</span>, <span class="code">sortWith</span>, and <span class="code">sortBy</span>, which sort sequence
elements according to various criteria.


</li>
<li><b><span style="font-style:italic">Reversal operations</span></b> <span class="code">reverse</span>, <span class="code">reverseIterator</span>, and <span class="code">reverseMap</span>, 
which yield or process sequence elements in reverse order, from last
to first.


</li>
<li><b><span style="font-style:italic">Comparison operations</span></b> <span class="code">startsWith</span>, <span class="code">endsWith</span>, <span class="code">contains</span>, <span class="code">corresponds</span>, and <span class="code">containsSlice</span>, 
which relate two sequences or search an element in a sequence.


</li>
<li><b><span style="font-style:italic">Multiset operations</span></b> <span class="code">intersect</span>, <span class="code">diff</span>, <span class="code">union</span>, and <span class="code">distinct</span>,
which perform set-like operations on the elements of two sequences or remove
duplicates.


</li></ul>


<p>If a sequence is mutable, it offers in addition a side-effecting
<span class="code">update</span> method, which lets sequence elements be updated. Recall from
<a href="next-steps-in-scala.html">Chapter 3</a> that syntax like <span class="code">seq(idx)</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">elem</span> is just a shorthand for
<span class="code">seq.update(idx,</span>&nbsp;<span class="code">elem)</span>. Note the difference between <span class="code">update</span> and
<span class="code">updated</span>. The <span class="code">update</span> method changes a sequence element in place, and is only
available for mutable sequences. The <span class="code">updated</span> method is available for all
sequences and always returns a new sequence instead of modifying the
original.</p>

<div style="page-break-after:always"/>


<p><a id="tab-seqops"/></p>

<h5>Operations in trait <span class="code">Seq</span> <a id="i2004738302-1"/></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Indexing and length:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs(i)</span>
  </td>
  <td>
    (or, written out, <span class="code">xs</span>&nbsp;<span class="code">apply</span>&nbsp;<span class="code">i</span>) The element
                  of <span class="code">xs</span> at index <span class="code">i</span>.<a id="i972576416-1"/><a id="i540215378-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">isDefinedAt</span>&nbsp;<span class="code">i</span>
  </td>
  <td>
    Tests whether <span class="code">i</span> is contained in <span class="code">xs.indices</span>.
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.length</span>
  </td>
  <td>
    The length of the sequence (same as <span class="code">size</span>).<a id="i-315498884-1"/><a id="i251040758-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.lengthCompare</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    Returns <span class="code">-1</span> if <span class="code">xs</span> is shorter than <span class="code">ys</span>, <span class="code">+1</span> if it is
                  longer, and <span class="code">0</span> is they have the same length. 
                  Works even if one of the sequences is infinite.<a id="i473798543-1"/><a id="i-1000272893-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.indices</span>
  </td>
  <td>
    The index range of <span class="code">xs</span>, extending from 0 to <span class="code">xs.length</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">1</span>.<a id="i-1361723020-1"/><a id="i-2102417525-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Index search:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">indexOf</span>&nbsp;<span class="code">x</span>
  </td>
  <td>
    The index of the first element in <span class="code">xs</span> equal to <span class="code">x</span>
                  (several variants exist).<a id="i1954773669-1"/><a id="i-2102517203-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">lastIndexOf</span>&nbsp;<span class="code">x</span>
  </td>
  <td>
    The index of the last element in <span class="code">xs</span> equal to <span class="code">x</span>
                  (several variants exist).<a id="i-1061813157-1"/><a id="i-115105609-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">indexOfSlice</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    The first index of <span class="code">xs</span> such that successive elements starting
                  from that index form the sequence <span class="code">ys</span>.<a id="i580863013-1"/><a id="i1348829029-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">lastIndexOfSlice</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    The last index of <span class="code">xs</span> such that successive elements starting
                  from that index form the sequence <span class="code">ys</span>.<a id="i-1540596689-1"/><a id="i-1993636069-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">indexWhere</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    The index of the first element in <span class="code">xs</span> that satisfies <span class="code">p</span>
                  (several variants exist).<a id="i1308063033-1"/><a id="i1720598737-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">segmentLength</span>&nbsp;<span class="code">(p,</span>&nbsp;<span class="code">i)</span>
  </td>
  <td>
    The length of the longest uninterrupted segment of 
                  elements in <span class="code">xs</span>, starting with <span class="code">xs(i)</span>, that
                  all satisfy the predicate <span class="code">p</span>.<a id="i-1262494987-1"/><a id="i-1801931555-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">prefixLength</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    The length of the longest prefix of 
                  elements in <span class="code">xs</span> that
                  all satisfy the predicate <span class="code">p</span>.<a id="i-806509514-1"/><a id="i-1716513100-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Additions:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">x</span>&nbsp;<span class="code">+:</span>&nbsp;<span class="code">xs</span>
  </td>
  <td>
    A new sequence consisting of <span class="code">x</span> prepended to <span class="code">xs</span>.<a id="i-1215087300-1"/><a id="i-110359634-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">:+</span>&nbsp;<span class="code">x</span>
  </td>
  <td>
    A new sequence that consists of <span class="code">x</span> append to <span class="code">xs</span>.<a id="i-1421606018-1"/><a id="i1838792986-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">padTo</span>&nbsp;<span class="code">(len,</span>&nbsp;<span class="code">x)</span>
  </td>
  <td>
    The sequence resulting from appending the value <span class="code">x</span>
                  to <span class="code">xs</span> until length <span class="code">len</span> is reached.<a id="i-1863493728-1"/><a id="i553609042-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Updates:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">patch</span>&nbsp;<span class="code">(i,</span>&nbsp;<span class="code">ys,</span>&nbsp;<span class="code">r)</span>
  </td>
  <td>
    The sequence resulting from replacing <span class="code">r</span> elements
                  of <span class="code">xs</span> starting with <span class="code">i</span> by the patch <span class="code">ys</span>.<a id="i-62511610-1"/><a id="i553624876-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">updated</span>&nbsp;<span class="code">(i,</span>&nbsp;<span class="code">x)</span>
  </td>
  <td>
    A copy of <span class="code">xs</span> with the element at index <span class="code">i</span> replaced by <span class="code">x</span>.<a id="i-2090714253-1"/><a id="i14728351-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs(i)</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">x</span>
  </td>
  <td>
    (or, written out, <span class="code">xs.update(i,</span>&nbsp;<span class="code">x)</span>, only available
                  for <span class="code">mutable.Seq</span>s) Changes the element of <span class="code">xs</span>
                  at index <span class="code">i</span> to <span class="code">y</span>.<a id="i1619007525-1"/><a id="i139022437-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Sorting:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.sorted</span>
  </td>
  <td>
    A new sequence obtained by sorting the elements of
                    <span class="code">xs</span> using the standard ordering of the element
                    type of <span class="code">xs</span>.<a id="i-78070095-1"/><a id="i81275481-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">sortWith</span>&nbsp;<span class="code">lessThan</span>
  </td>
  <td>
    A new sequence obtained by sorting the elements of
                    <span class="code">xs</span>, using <span class="code">lessThan</span> as comparison operation.<a id="i1923205194-1"/><a id="i795917344-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">sortBy</span>&nbsp;<span class="code">f</span>
  </td>
  <td>
    A new sequence obtained by sorting the elements of
                    <span class="code">xs</span>. Comparison between two elements proceeds
                    by mapping the function <span class="code">f</span> over both and
                    comparing the results.<a id="i-544663079-1"/><a id="i81274417-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Reversals:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.reverse</span>
  </td>
  <td>
    A sequence with the elements of <span class="code">xs</span> in reverse order.<a id="i162887596-1"/><a id="i1349004998-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.reverseIterator</span>
  </td>
  <td>
    An iterator yielding all the elements of <span class="code">xs</span> in
                  reverse order.<a id="i-1214590498-1"/><a id="i-1415678636-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">reverseMap</span>&nbsp;<span class="code">f</span>
  </td>
  <td>
    A sequence obtained by mapping <span class="code">f</span> over the elements
                 of <span class="code">xs</span> in reverse order.<a id="i1968096884-1"/><a id="i198983862-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Comparisons:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">startsWith</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    Tests whether <span class="code">xs</span> starts with sequence <span class="code">ys</span> 
                  (several variants exist).<a id="i-2129701641-1"/><a id="i-574339501-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">endsWith</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    Tests whether <span class="code">xs</span> ends with sequence <span class="code">ys</span>
                  (several variants exist).<a id="i455738416-1"/><a id="i877141114-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">contains</span>&nbsp;<span class="code">x</span>
  </td>
  <td>
    Tests whether <span class="code">xs</span> has an element equal to <span class="code">x</span>.<a id="i752331919-1"/><a id="i-1433463109-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">containsSlice</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    Tests whether <span class="code">xs</span> has a contiguous subsequence equal to <span class="code">ys</span>.<a id="i-1416645509-1"/><a id="i1699558295-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">(xs</span>&nbsp;<span class="code">corresponds</span>&nbsp;<span class="code">ys)(p)</span>
  </td>
  <td>
    Tests whether corresponding elements of <span class="code">xs</span> and <span class="code">ys</span> 
                  satisfy the binary predicate <span class="code">p</span>.<a id="i-1866218038-1"/><a id="i-2021984280-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Multiset operations:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">intersect</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    The multi-set intersection of sequences <span class="code">xs</span> and <span class="code">ys</span> that
                  preserves the order of elements in <span class="code">xs</span>.<a id="i-1738203761-1"/><a id="i-573712381-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">diff</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    The multi-set difference of sequences <span class="code">xs</span> and <span class="code">ys</span> that
                  preserves the order of elements in <span class="code">xs</span>.<a id="i-1220877719-1"/><a id="i433150625-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">union</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    Multiset union; same as <span class="code">xs</span>&nbsp;<span class="code">++</span>&nbsp;<span class="code">ys</span>.<a id="i-1990387233-1"/><a id="i558619571-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.distinct</span>
  </td>
  <td>
    A subsequence of <span class="code">xs</span> that contains no duplicated
element.<a id="i868552658-1"/><a id="i-577319016-1"/>
  </td>
</tr>
</table>


<p>Each <span class="code">Seq</span> trait has two subtraits, <span class="code">LinearSeq</span> and
<span class="code">IndexedSeq</span>. These do not add any new operations, but each offers
different performance characteristics. A linear sequence has efficient
<span class="code">head</span> and <span class="code">tail</span> operations, whereas an indexed sequence has
efficient <span class="code">apply</span>, <span class="code">length</span>, and (if mutable) <span class="code">update</span>
operations. <span class="code">List</span> is a frequently used linear sequence, as is 
<span class="code">Stream</span>.<a id="i-1334114643-1"/>  Two frequently used indexed sequences are <span class="code">Array</span> and <span class="code">ArrayBuffer</span>.
The <span class="code">Vector</span> class provides an
interesting compromise between indexed and linear access.  It has both
effectively constant time indexing overhead and constant time linear access
overhead.  Because of this, vectors are a good foundation for mixed
access patterns where both indexed and linear accesses are used. More
on vectors in <a href="collections-in-depth.html#sec-collections-api-vectors">Section 24.8</a>.</p>

<h4>Buffers</h4>


<p>An important sub-category of mutable sequences is buffers. Buffers
allow not only updates of existing elements but also element
insertions, element removals, and efficient additions of new elements
at the end of the buffer.  The principal new methods supported by a
buffer are <span class="code">+=</span> and <span class="code">++=</span>, for element addition at
the end, <span class="code">+=:</span> and <span class="code">++=:</span> for addition at the
front, <span class="code">insert</span> and <span class="code">insertAll</span> for element insertions, as well as
<span class="code">remove</span> and <span class="code">-=</span> for element removal. These operations are
summarized in <a href="collections-in-depth.html#tab-bufferops">Table 24.4</a>.</p>

<p>Two <span class="code">Buffer</span> implementations that are commonly used are <span class="code">ListBuffer</span> and 
<span class="code">ArrayBuffer</span>. As the name implies, a
<span class="code">ListBuffer</span> is backed by a <span class="code">List</span> and supports efficient
conversion of its elements to a <span class="code">List</span>, whereas an <span class="code">ArrayBuffer</span> is
backed by an array, and can be quickly converted into one.
You saw a glimpse of the implementation of <span class="code">ListBuffer</span> in 
<a href="implementing-lists.html#sec-the-listbuffer-class">Section 22.2</a>.</p>

<p><a id="tab-bufferops"/></p>

<h5>Operations in trait <span class="code">Buffer</span> <a id="i95832031-1"/></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Additions:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">buf</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">x</span>
  </td>
  <td>
    Appends element <span class="code">x</span> to buffer <span class="code">buf</span>, and returns <span class="code">buf</span> itself as result<a id="i1747820940-1"/><a id="i-2090973295-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">buf</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">(x,</span>&nbsp;<span class="code">y,</span>&nbsp;<span class="code">z)</span>
  </td>
  <td>
    Appends given elements to buffer
  </td>
</tr>
<tr>
  <td>
    <span class="code">buf</span>&nbsp;<span class="code">++=</span>&nbsp;<span class="code">xs</span>
  </td>
  <td>
    Appends all elements in <span class="code">xs</span> to buffer<a id="i-1480460839-1"/><a id="i121740146-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">x</span>&nbsp;<span class="code">+=:</span>&nbsp;<span class="code">buf</span>
  </td>
  <td>
    Prepends element <span class="code">x</span> to buffer<a id="i-1505564645-1"/><a id="i-52217715-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">++=:</span>&nbsp;<span class="code">buf</span>
  </td>
  <td>
    Prepends all elements in <span class="code">xs</span> to buffer<a id="i-2007284108-1"/><a id="i356587566-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">buf</span>&nbsp;<span class="code">insert</span>&nbsp;<span class="code">(i,</span>&nbsp;<span class="code">x)</span>
  </td>
  <td>
    Inserts element <span class="code">x</span> at index <span class="code">i</span> in buffer<a id="i-1767492769-1"/><a id="i-1775835603-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">buf</span>&nbsp;<span class="code">insertAll</span>&nbsp;<span class="code">(i,</span>&nbsp;<span class="code">xs)</span>
  </td>
  <td>
    Inserts all elements in <span class="code">xs</span> at index <span class="code">i</span> in
buffer<a id="i1499228240-1"/><a id="i1488769076-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Removals:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">buf</span>&nbsp;<span class="code">-=</span>&nbsp;<span class="code">x</span>
  </td>
  <td>
    Removes element <span class="code">x</span> from buffer<a id="i2053756078-1"/><a id="i703208191-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">buf</span>&nbsp;<span class="code">remove</span>&nbsp;<span class="code">i</span>
  </td>
  <td>
    Removes element at index <span class="code">i</span> from buffer<a id="i-1233111692-1"/><a id="i-1526653960-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">buf</span>&nbsp;<span class="code">remove</span>&nbsp;<span class="code">(i,</span>&nbsp;<span class="code">n)</span>
  </td>
  <td>
    Removes <span class="code">n</span> elements starting at index <span class="code">i</span> from buffer
  </td>
</tr>
<tr>
  <td>
    <span class="code">buf</span>&nbsp;<span class="code">trimStart</span>&nbsp;<span class="code">n</span>
  </td>
  <td>
    Removes first <span class="code">n</span> elements from buffer<a id="i-1528855016-1"/><a id="i1378245996-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">buf</span>&nbsp;<span class="code">trimEnd</span>&nbsp;<span class="code">n</span>
  </td>
  <td>
    Removes last <span class="code">n</span> elements from buffer<a id="i1472686271-1"/><a id="i2061753445-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">buf.clear()</span>
  </td>
  <td>
    Removes all elements from buffer<a id="i-240297909-1"/><a id="i-2002561959-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Cloning:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">buf.clone</span>
  </td>
  <td>
    A new buffer with the same elements as <span class="code">buf</span><a id="i1251822395-1"/><a id="i-2002551959-1"/>
  </td>
</tr>
</table>


<h3>24.6 Sets</h3>


<p><span class="code">Set</span>s are <span class="code">Iterable</span>s that contain no duplicate elements. The
operations on sets are summarized in <a href="collections-in-depth.html#tab-setops">Table 24.5</a> for 
general sets and <a href="collections-in-depth.html#tab-mutsetops">Table 24.6</a> for mutable sets. 
They fall into the following categories:</p>

<ul>


<li><b><span style="font-style:italic">Tests</span></b> <span class="code">contains</span>, <span class="code">apply</span>, and <span class="code">subsetOf</span>. 
The <span class="code">contains</span> method indicates whether a set contains a given
element. The <span class="code">apply</span> method for a set is the same as <span class="code">contains</span>, so
<span class="code">set(elem)</span> is the same as <span class="code">set</span>&nbsp;<span class="code">contains</span> <span class="code">elem</span>. That means sets can also be used as test
functions that return true for the elements they contain. For example:


<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fruit&nbsp;=&nbsp;<code class="typename">Set</code>(<code class="quotedstring">"apple"</code>,&nbsp;<code class="quotedstring">"orange"</code>,&nbsp;<code class="quotedstring">"peach"</code>,&nbsp;<code class="quotedstring">"banana"</code>)
  <code class="output">fruit:&nbsp;scala.collection.immutable.Set[String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;Set(apple,&nbsp;orange,&nbsp;peach,&nbsp;banana)</code>
  <br />  scala&gt;&nbsp;fruit(<code class="quotedstring">"peach"</code>)
  <code class="output">res7:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br />  scala&gt;&nbsp;fruit(<code class="quotedstring">"potato"</code>)
  <code class="output">res8:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>


</li>
<li><b><span style="font-style:italic">Additions</span></b> <span class="code">+</span> and <span class="code">++</span>, which add one or more elements to a set, yielding a new set as a result.


</li>
<li><b><span style="font-style:italic">Removals</span></b> <span class="code">-</span> and <span class="code">--</span>, which remove one or more elements from a set, 
yielding a new set. 


</li>
<li><b><span style="font-style:italic">Set operations</span></b> for union, intersection, and set difference. These set operations exist in two 
forms: alphabetic and symbolic. The alphabetic versions are <span class="code">intersect</span>, <span class="code">union</span>, and <span class="code">diff</span>, 
whereas the symbolic versions are <span class="code">&amp;</span>, <span class="code">|</span>, and <span class="code">&amp;<span style="font-size:large">~</span></span>. The <span class="code">++</span> that <span class="code">Set</span> inherits
from <span class="code">Traversable</span> can be seen
as yet another alias of <span class="code">union</span> or <span class="code">|</span>, except that <span class="code">++</span> takes a
<span class="code">Traversable</span> argument whereas <span class="code">union</span> and <span class="code">|</span> take sets.


</li></ul>


<p><a id="tab-setops"/></p>

<h5>Operations in trait <span class="code">Set</span> <a id="i877342209-1"/></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Tests:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">contains</span>&nbsp;<span class="code">x</span>
  </td>
  <td>
    Tests whether <span class="code">x</span> is an element of <span class="code">xs</span><a id="i1685795628-2"/><a id="i924843454-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs(x)</span>
  </td>
  <td>
    Same as <span class="code">xs</span>&nbsp;<span class="code">contains</span>&nbsp;<span class="code">x</span>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">subsetOf</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    Tests whether <span class="code">xs</span> is a subset of <span class="code">ys</span><a id="i12573170-1"/><a id="i-569252040-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Additions:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">x</span>
  </td>
  <td>
    The set containing all elements of <span class="code">xs</span> as well as <span class="code">x</span><a id="i-457936727-3"/><a id="i1858879238-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">(x,</span>&nbsp;<span class="code">y,</span>&nbsp;<span class="code">z)</span>
  </td>
  <td>
    The set containing all elements of <span class="code">xs</span> as well as the given additional elements
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">++</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    The set containing all elements of <span class="code">xs</span> as well as
all elements of <span class="code">ys</span><a id="i758428245-2"/><a id="i872660526-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Removals:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">x</span>
  </td>
  <td>
    The set containing all elements of <span class="code">xs</span> except <span class="code">x</span><a id="i-1092228898-2"/><a id="i-1593467087-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">(x,</span>&nbsp;<span class="code">y,</span>&nbsp;<span class="code">z)</span>
  </td>
  <td>
    The set containing all elements of <span class="code">xs</span> except the given elements
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">--</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    The set containing all elements of <span class="code">xs</span> except the elements of <span class="code">ys</span><a id="i-726788280-2"/><a id="i640851374-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.empty</span>
  </td>
  <td>
    An empty set of the same class as <span class="code">xs</span><a id="i1039994046-1"/><a id="i-1275381234-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Binary operations:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">&amp;</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    The set intersection of <span class="code">xs</span> and <span class="code">ys</span><a id="i617863161-2"/><a id="i1830753682-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">intersect</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    Same as <span class="code">xs</span>&nbsp;<span class="code">&amp;</span>&nbsp;<span class="code">ys</span><a id="i-804740052-1"/><a id="i-480652960-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">|</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    The set union of <span class="code">xs</span> and <span class="code">ys</span><a id="i1836511958-1"/><a id="i562147141-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">union</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    Same as <span class="code">xs</span>&nbsp;<span class="code">|</span>&nbsp;<span class="code">ys</span><a id="i-1056923524-1"/><a id="i-1260582000-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">&amp;<span style="font-size:large">~</span></span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    The set difference of <span class="code">xs</span> and <span class="code">ys</span><a id="i2003546905-1"/><a id="i-1861524116-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">diff</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    Same as <span class="code">xs</span>&nbsp;<span class="code">&amp;<span style="font-size:large">~</span></span>&nbsp;<span class="code">ys</span><a id="i-287414010-1"/><a id="i1067203364-1"/>
  </td>
</tr>
</table>


<p>Mutable sets have methods that add, remove, or update
elements, which are summarized in <a href="collections-in-depth.html#tab-mutsetops">Table 24.6</a>:</p>

<p><a id="tab-mutsetops"/></p>

<h5>Operations in trait <span class="code">mutable.Set</span></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Additions:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">x</span>
  </td>
  <td>
    Adds element <span class="code">x</span> to set <span class="code">xs</span> as a side effect and returns <span class="code">xs</span> itself<a id="i1314992430-2"/><a id="i-1209846120-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">(x,</span>&nbsp;<span class="code">y,</span>&nbsp;<span class="code">z)</span>
  </td>
  <td>
    Adds the given elements to set <span class="code">xs</span> as a side effect and returns <span class="code">xs</span> itself
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">++=</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    Adds all elements in <span class="code">ys</span> to set <span class="code">xs</span> as a side effect and returns <span class="code">xs</span> itself<a id="i-1693046362-2"/><a id="i-1254892180-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">add</span>&nbsp;<span class="code">x</span>
  </td>
  <td>
    Adds element <span class="code">x</span> to <span class="code">xs</span> and returns <span class="code">true</span> if <span class="code">x</span> was 
                not previously contained in the set, <span class="code">false</span> if it was previously contained<a id="i381468769-1"/><a id="i-1766692446-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Removals:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">-=</span>&nbsp;<span class="code">x</span>
  </td>
  <td>
    Removes element <span class="code">x</span> from set <span class="code">xs</span> as a side effect and returns <span class="code">xs</span> itself<a id="i1816671796-2"/><a id="i-282687116-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">-=</span>&nbsp;<span class="code">(x,</span>&nbsp;<span class="code">y,</span>&nbsp;<span class="code">z)</span>
  </td>
  <td>
    Removes the given elements from set <span class="code">xs</span> as a side effect and returns <span class="code">xs</span> itself
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">--=</span>&nbsp;<span class="code">ys</span>
  </td>
  <td>
    Removes all elements in <span class="code">ys</span> from set <span class="code">xs</span> as a side effect and returns <span class="code">xs</span> itself<a id="i-610143062-2"/><a id="i-1485797315-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">remove</span>&nbsp;<span class="code">x</span>
  </td>
  <td>
    Removes element <span class="code">x</span> from <span class="code">xs</span> and returns <span class="code">true</span> if <span class="code">x</span> was
                previously contained in the set, <span class="code">false</span> if it was not previously contained<a id="i1270439364-1"/><a id="i-517415965-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">retain</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    Keeps only those elements in <span class="code">xs</span> that satisfy predicate <span class="code">p</span> <a id="i1264220869-1"/><a id="i-517221276-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.clear()</span>
  </td>
  <td>
    Removes all elements from <span class="code">xs</span><a id="i-914291699-2"/><a id="i-1277269234-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Update:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs(x)</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">b</span>
  </td>
  <td>
    (or, written out, <span class="code">xs.update(x,</span>&nbsp;<span class="code">b)</span>) If boolean argument <span class="code">b</span> is
                <span class="code">true</span>, adds <span class="code">x</span> to <span class="code">xs</span>, otherwise removes <span class="code">x</span> from <span class="code">xs</span><a id="i2073506953-1"/><a id="i-421651416-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Cloning:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs.clone</span>
  </td>
  <td>
    A new mutable set with the same elements as <span class="code">xs</span><a id="i-1974537443-1"/><a id="i-1277259234-1"/>
  </td>
</tr>
</table>


<p>Just like an immutable set, a mutable set offers the <span class="code">+</span> and <span class="code">++</span>
operations for element additions and the <span class="code">-</span> and <span class="code">--</span> operations for
element removals.  But these are less often used for mutable sets
since they involve copying the set. As a more efficient alternative,
mutable sets offer the update methods <span class="code">+=</span> and <span class="code">-=</span>. The operation
<span class="code">s</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">elem</span> adds <span class="code">elem</span> to the set <span class="code">s</span> as a side effect, and
returns the mutated set as a result. Likewise, <span class="code">s</span>&nbsp;<span class="code">-=</span>&nbsp;<span class="code">elem</span> removes
<span class="code">elem</span> from the set, and returns the mutated set as a result.
Besides <span class="code">+=</span> and <span class="code">-=</span> there are also the bulk operations <span class="code">++=</span> and
<span class="code">--=</span>, which add or remove all elements of a traversable or an
iterator.</p>

<p>The choice of the method names <span class="code">+=</span> and <span class="code">-=</span> means that very similar code 
can work with either mutable or immutable sets.
Consider first the following interpreter dialogue that uses an immutable set <span class="code">s</span>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">var</code>&nbsp;s&nbsp;=&nbsp;<code class="typename">Set</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">s:&nbsp;scala.collection.immutable.Set[Int]&nbsp;=&nbsp;Set(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;s&nbsp;+=&nbsp;<code class="literal">4</code>;&nbsp;s&nbsp;-=&nbsp;<code class="literal">2</code>
  <br />  scala&gt;&nbsp;s
  <code class="output">res10:&nbsp;scala.collection.immutable.Set[Int]&nbsp;=&nbsp;Set(1,&nbsp;3,&nbsp;4)</code>
</pre>


<p>In this example, we used <span class="code">+=</span> and <span class="code">-=</span> on a <span class="code">var</span> of type <span class="code">immutable.Set</span>. 
As was explained in <a href="next-steps-in-scala.html#step10">Step 10</a> in <a href="next-steps-in-scala.html">Chapter 3</a>, a statement such as 
<span class="code">s</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">4</span> is an abbreviation for <span class="code">s</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">s</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">4</span>. So this invokes the 
addition method <span class="code">+</span> on the set <span class="code">s</span> and then assigns the result back to the <span class="code">s</span> variable.
Consider now an analogous interaction with a mutable set:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;s&nbsp;=&nbsp;<code class="typename">collection.mutable.Set</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">s:&nbsp;scala.collection.mutable.Set[Int]&nbsp;=&nbsp;Set(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;s&nbsp;+=&nbsp;<code class="literal">4</code>
  <code class="output">res11:&nbsp;s.type&nbsp;=&nbsp;Set(1,&nbsp;2,&nbsp;3,&nbsp;4)</code>
  <br />  scala&gt;&nbsp;s&nbsp;-=&nbsp;<code class="literal">2</code>
  <code class="output">res12:&nbsp;s.type&nbsp;=&nbsp;Set(1,&nbsp;3,&nbsp;4)</code>
</pre>


<p>The end effect is very similar to the previous interaction; we start
with a <span class="code">Set(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span> and end up with a <span class="code">Set(1,</span>&nbsp;<span class="code">3,</span>&nbsp;<span class="code">4)</span>.  However,
even though the statements look the same as before, they do something
different.  The <span class="code">s</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">4</span> statement now invokes the <span class="code">+=</span> method on the mutable set
value <span class="code">s</span>, changing the set in place. Likewise, the <span class="code">s</span>&nbsp;<span class="code">-=</span>&nbsp;<span class="code">2</span> statement now invokes
the <span class="code">-=</span> method on the same set.</p>

<p>Comparing the two interactions
shows an important principle. You often can replace a
mutable collection stored in a <span class="code">val</span> by an immutable collection stored
in a <span class="code">var</span>, and <span style="font-style:italic">vice versa</span>. This works at least as long as there are no 
alias references to the collection through which you can observe
whether it was updated in place or a new collection was created.</p>

<p>Mutable sets also provide <span class="code">add</span> and <span class="code">remove</span> as variants of <span class="code">+=</span>
and <span class="code">-=</span>. The difference is that <span class="code">add</span> and <span class="code">remove</span> return a
boolean result indicating whether the operation had an effect on
the set.</p>

<p>The current default implementation of a mutable set uses a hash table
to store the set's elements. The default implementation of an
immutable set uses a representation that adapts to the number of
elements of the set.
An empty set is represented by just a singleton
object. Sets of sizes up to four are represented by a single object
that stores all elements as fields. Beyond that size, immutable sets
are implemented as hash tries.<a href="collections-in-depth.html#footnotemain24-2">[2]</a></p>

<p>A consequence of these representation choices is that for sets of
small sizes, up to about four, immutable sets are more compact and
more efficient than mutable sets. So if you expect the size of a
set to be small, try to make it immutable.</p>

<h3>24.7 Maps</h3>


<p><span class="code">Map</span>s are <span class="code">Iterable</span>s of pairs of keys and values (also named
<span style="font-style:italic">mappings</span> or <span style="font-style:italic">associations</span>). As explained in <a href="implicit-conversions-and-parameters.html#sec-simulating-new-syntax">Section 21.4</a>,
Scala's <span class="code">Predef</span> class offers an implicit conversion
that lets you write <span class="code">key</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">value</span> as an alternate syntax for the
pair <span class="code">(key,</span>&nbsp;<span class="code">value)</span>.   
Therefore, <span class="code">Map("x"</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">24,</span>&nbsp;<span class="code">"y"</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">25,</span>&nbsp;<span class="code">"z"</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">26)</span> 
means exactly the same as 
<span class="code">Map(("x",</span>&nbsp;<span class="code">24),</span>&nbsp;<span class="code">("y",</span>&nbsp;<span class="code">25),</span>&nbsp;<span class="code">("z",</span>&nbsp;<span class="code">26))</span>, but reads better.</p>

<p>The fundamental operations on maps, summarized in <a href="collections-in-depth.html#tab-mapops">Table 24.7</a>,
are similar to those on sets.
Mutable maps additionally support the operations shown in <a href="collections-in-depth.html#tab-mutmapops">Table 24.8</a>.
Map operations fall into the following
categories:</p>

<ul>


<li><b><span style="font-style:italic">Lookups</span></b> <span class="code">apply</span>, <span class="code">get</span>, <span class="code">getOrElse</span>,
  <span class="code">contains</span>, and <span class="code">isDefinedAt</span>. These operations turn maps into partial
  functions from keys to values. The fundamental lookup method for a map is:


<pre>
  <code class="vem">def</code>&nbsp;get(key):&nbsp;<code class="typename">Option[Value]</code>&nbsp;
</pre>


<p>The operation "<span class="code">m</span>&nbsp;<span class="code">get</span>&nbsp;<span class="code">key</span>" tests whether the map
contains an association for the given <span class="code">key</span>. If so, it returns the
associated value in a <span class="code">Some</span>. If no <span class="code">key</span> is defined in the map,
<span class="code">get</span> returns <span class="code">None</span>. 
Maps also define an <span class="code">apply</span> method that returns 
the value associated
with a given key directly, without wrapping it in an <span class="code">Option</span>. If the
key is not defined in the map, an exception is raised.</p>

</li>
<li><b><span style="font-style:italic">Additions and updates</span></b> <span class="code">+</span>, <span class="code">++</span>, and <span class="code">updated</span>, which let you
  add new bindings to a map or change existing bindings.


</li>
<li><b><span style="font-style:italic">Removals</span></b> <span class="code">-</span> and <span class="code">--</span>, which remove bindings
  from a map.


</li>
<li><b><span style="font-style:italic">Subcollection producers</span></b> <span class="code">keys</span>, <span class="code">keySet</span>,
  <span class="code">keysIterator</span>, <span class="code">valuesIterator</span>, and <span class="code">values</span>, which return a map's
  keys and values separately in various forms.


</li>
<li><b><span style="font-style:italic">Transformations</span></b> <span class="code">filterKeys</span> and <span class="code">mapValues</span>, which
  produce a new map by filtering and transforming bindings of an existing map.


</li></ul>


<p><a id="tab-mapops"/></p>

<h5>Operations in trait <span class="code">Map</span> <a id="i-1799914245-1"/></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Lookups:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">get</span>&nbsp;<span class="code">k</span>
  </td>
  <td>
    The value associated with key <span class="code">k</span> in map <span class="code">ms</span> as an option, or <span class="code">None</span> if not found<a id="i-1160987621-1"/><a id="i-1633357539-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms(k)</span>
  </td>
  <td>
    (or, written out, <span class="code">ms</span>&nbsp;<span class="code">apply</span>&nbsp;<span class="code">k</span>)
                 The value associated with key <span class="code">k</span> in map <span class="code">ms</span>, or a thrown exception if not found<a id="i648989597-3"/><a id="i-1998745739-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">getOrElse</span>&nbsp;<span class="code">(k,</span>&nbsp;<span class="code">d)</span>
  </td>
  <td>
    The value associated with key <span class="code">k</span> in map <span class="code">ms</span>, or the default value <span class="code">d</span> if not found<a id="i-1472564161-1"/><a id="i1555511609-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">contains</span>&nbsp;<span class="code">k</span>
  </td>
  <td>
    Tests whether <span class="code">ms</span> contains a mapping for key <span class="code">k</span><a id="i-1171514126-2"/><a id="i-955049800-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">isDefinedAt</span>&nbsp;<span class="code">k</span>
  </td>
  <td>
    Same as <span class="code">contains</span><a id="i2055622367-1"/><a id="i1960441049-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Additions and updates:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">(k</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">v)</span>
  </td>
  <td>
    The map containing all mappings of <span class="code">ms</span> as well as the mapping <span class="code">k</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">v</span> from key <span class="code">k</span> to value <span class="code">v</span><a id="i979720815-2"/><a id="i1877298566-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">(k</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">v,</span>&nbsp;<span class="code">l</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">w)</span>
  </td>
  <td>
    The map containing all mappings of <span class="code">ms</span> as well as the given key/value pairs
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">++</span>&nbsp;<span class="code">kvs</span>
  </td>
  <td>
    The map containing all mappings of <span class="code">ms</span> as well as all key/value pairs of <span class="code">kvs</span><a id="i-2098881509-2"/><a id="i-1132988814-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">updated</span>&nbsp;<span class="code">(k,</span>&nbsp;<span class="code">v)</span>
  </td>
  <td>
    Same as <span class="code">ms</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">(k</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">v)</span><a id="i280406998-1"/><a id="i-385480958-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Removals:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">k</span>
  </td>
  <td>
    The map containing all mappings of <span class="code">ms</span> except for any mapping of key <span class="code">k</span><a id="i345428644-2"/><a id="i-191488371-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">(k,</span>&nbsp;<span class="code">l,</span>&nbsp;<span class="code">m)</span>
  </td>
  <td>
    The map containing all mappings of <span class="code">ms</span> except for any mapping with the given keys
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">--</span>&nbsp;<span class="code">ks</span>
  </td>
  <td>
    The map containing all mappings of <span class="code">ms</span> except for any mapping with a key in <span class="code">ks</span><a id="i710869262-2"/><a id="i2074410039-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Subcollections:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms.keys</span>
  </td>
  <td>
    An iterable containing each key in <span class="code">ms</span><a id="i1213467709-2"/><a id="i905643277-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms.keySet</span>
  </td>
  <td>
    A set containing each key in <span class="code">ms</span><a id="i891405326-2"/><a id="i-1555199396-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms.keysIterator</span>
  </td>
  <td>
    An iterator yielding each key in <span class="code">ms</span><a id="i1344362607-1"/><a id="i854987931-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms.values</span>
  </td>
  <td>
    An iterable containing each value associated with a key in <span class="code">ms</span><a id="i-546077233-2"/><a id="i-1244327429-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms.valuesIterator</span>
  </td>
  <td>
    An iterator yielding each value associated
with a key in <span class="code">ms</span><a id="i1069490177-1"/><a id="i1168331657-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Transformation:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">filterKeys</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    A map view containing only those mappings in <span class="code">ms</span> where the key
                satisfies predicate <span class="code">p</span><a id="i1510668197-1"/><a id="i-378449435-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">mapValues</span>&nbsp;<span class="code">f</span>
  </td>
  <td>
    A map view resulting from applying function <span class="code">f</span> to each value
                associated with a key in <span class="code">ms</span><a id="i26169043-1"/><a id="i1850239525-1"/>
  </td>
</tr>
</table>


<p><a id="tab-mutmapops"/></p>

<h5>Operations in trait <span class="code">mutable.Map</span></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Additions and updates:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms(k)</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">v</span>
  </td>
  <td>
    (or, written out, <span class="code">ms.update(k,</span>&nbsp;<span class="code">v)</span>) Adds mapping from key <span class="code">k</span> to value <span class="code">v</span> to map <span class="code">ms</span> as a side effect, overwriting
                any previous mapping of <span class="code">k</span><a id="i2073501059-1"/><a id="i-1259360862-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">(k</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">v)</span>
  </td>
  <td>
    Adds mapping from key <span class="code">k</span> to value <span class="code">v</span> to map <span class="code">ms</span> as a side effect and returns <span class="code">ms</span> itself<a id="i1314809716-2"/><a id="i2003257106-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">(k</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">v,</span>&nbsp;<span class="code">l</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">w)</span>
  </td>
  <td>
    Adds the given mappings to <span class="code">ms</span> as a side effect and returns <span class="code">ms</span> itself
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">++=</span>&nbsp;<span class="code">kvs</span>
  </td>
  <td>
    Adds all mappings in <span class="code">kvs</span> to <span class="code">ms</span> as a side effect and returns <span class="code">ms</span> itself<a id="i-1693229076-2"/><a id="i-1544177818-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">put</span>&nbsp;<span class="code">(k,</span>&nbsp;<span class="code">v)</span>
  </td>
  <td>
    Adds mapping from key <span class="code">k</span> to value <span class="code">v</span> to <span class="code">ms</span> and returns any value
                     previously associated with <span class="code">k</span> as an option<a id="i-254405943-1"/><a id="i-1633348394-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">getOrElseUpdate</span>&nbsp;<span class="code">(k,</span>&nbsp;<span class="code">d)</span>
  </td>
  <td>
    If key <span class="code">k</span> is defined in map <span class="code">ms</span>, returns its associated value. Otherwise,
                updates <span class="code">ms</span> with the mapping <span class="code">k</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">d</span> and returns <span class="code">d</span><a id="i1864005077-1"/><a id="i1498468194-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Removals:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">-=</span>&nbsp;<span class="code">k</span>
  </td>
  <td>
    Removes mapping with key <span class="code">k</span> from <span class="code">ms</span> as a side effect and returns <span class="code">ms</span> itself<a id="i1816489082-2"/><a id="i1608234298-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">-=</span>&nbsp;<span class="code">(k,</span>&nbsp;<span class="code">l,</span>&nbsp;<span class="code">m)</span>
  </td>
  <td>
    Removes mappings with the given keys from <span class="code">ms</span> as a side effect and returns <span class="code">ms</span> itself
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">--=</span>&nbsp;<span class="code">ks</span>
  </td>
  <td>
    Removes all keys in <span class="code">ks</span> from <span class="code">ms</span> as a side effect and returns <span class="code">ms</span> itself<a id="i-610325776-2"/><a id="i-1837007177-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">remove</span>&nbsp;<span class="code">k</span>
  </td>
  <td>
    Removes any mapping with key <span class="code">k</span> from <span class="code">ms</span> and returns  any value
                     previously associated with <span class="code">k</span> as an option<a id="i1270433470-1"/><a id="i-1355125411-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">retain</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    Keeps only those mappings in <span class="code">ms</span> that have a key satisfying predicate <span class="code">p</span>.<a id="i1264214975-1"/><a id="i-1354930722-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms.clear()</span>
  </td>
  <td>
    Removes all mappings from <span class="code">ms</span><a id="i-914297593-1"/><a id="i-1997028780-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Transformation and cloning:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms</span>&nbsp;<span class="code">transform</span>&nbsp;<span class="code">f</span>
  </td>
  <td>
    Transforms all associated values in map <span class="code">ms</span> with function <span class="code">f</span>
  </td>
</tr>
<tr>
  <td>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">ms.clone</span>
  </td>
  <td>
    Returns a new mutable map with the same mappings as <span class="code">ms</span><a id="i-1974543337-1"/><a id="i-1997018780-1"/>
  </td>
</tr>
</table>


<p>The addition and removal operations for maps mirror those for sets.
As for sets, mutable maps also support the non-destructive
addition operations <span class="code">+</span>, <span class="code">-</span>, and <span class="code">updated</span>, but they are used less
frequently because they involve a copying of the mutable map. 
Instead, a mutable map <span class="code">m</span> is usually updated "in place," using
the two variants <span class="code">m(key)</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">value</span> or <span class="code">m</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">(key</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">value)</span>. There is also the variant <span class="code">m</span>&nbsp;<span class="code">put</span>&nbsp;<span class="code">(key,</span>&nbsp;<span class="code">value)</span>, which
returns an <span class="code">Option</span> value that contains the value 
previously associated with <span class="code">key</span>, or <span class="code">None</span> if the <span class="code">key</span> did not
exist in the map before.</p>

<p>The <span class="code">getOrElseUpdate</span> is useful for accessing maps that act as
caches. Say you have an expensive computation triggered by invoking
a function <span class="code">f</span>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;f(x:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"taking&nbsp;my&nbsp;time."</code>);&nbsp;Thread.sleep(<code class="literal">100</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.reverse&nbsp;}
  <code class="output">f:&nbsp;(x:&nbsp;String)String</code>
</pre>


<p>Assume further that <span class="code">f</span> has no side-effects, so invoking it again
with the same argument will always yield the same result. In that case
you could save time by storing previously computed bindings of
argument and results of <span class="code">f</span> in a map, and only computing the result of
<span class="code">f</span> if a result of an argument was not found there. You could say the map is a
<span style="font-style:italic">cache</span> for the computations of the function <span class="code">f</span>.</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;cache&nbsp;=&nbsp;<code class="typename">collection.mutable.Map[String,&nbsp;String]</code>()
  <code class="output">cache:&nbsp;scala.collection.mutable.Map[String,String]&nbsp;=&nbsp;Map()</code>
</pre>


<p>You can now create a more efficient caching version of the <span class="code">f</span>
function:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;cachedF(s:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;cache.getOrElseUpdate(s,&nbsp;f(s))
  <code class="output">cachedF:&nbsp;(s:&nbsp;String)String</code>
  <br />  scala&gt;&nbsp;cachedF(<code class="quotedstring">"abc"</code>)
  <code class="output">taking&nbsp;my&nbsp;time.</code>
  <code class="output">res16:&nbsp;String&nbsp;=&nbsp;cba</code>
  <br />  scala&gt;&nbsp;cachedF(<code class="quotedstring">"abc"</code>)
  <code class="output">res17:&nbsp;String&nbsp;=&nbsp;cba</code>
</pre>


<p>Note that the second argument to <span class="code">getOrElseUpdate</span> is "by-name,"
so the computation of <span class="code">f("abc")</span> above is only performed if
<span class="code">getOrElseUpdate</span> requires the value of its second argument, which is
precisely if its first argument is not found in the <span class="code">cache</span> map.
You could also have implemented <span class="code">cachedF</span> directly, using just basic
map operations, but it would have have taken more code to do so:</p>

<pre>
  <code class="vem">def</code>&nbsp;cachedF(arg:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;cache&nbsp;get&nbsp;arg&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Some</code>(result)&nbsp;=&gt;&nbsp;result
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">None</code>&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;result&nbsp;=&nbsp;f(arg)
  &nbsp;&nbsp;&nbsp;&nbsp;cache(arg)&nbsp;=&nbsp;result
  &nbsp;&nbsp;&nbsp;&nbsp;result
  }
</pre>


<h3>24.8 Concrete immutable collection classes</h3>


<p>Scala provides many concrete immutable collection classes for you to
choose from.  They differ in the traits they implement (maps, sets,
sequences), whether they can be infinite, and the speed of
various operations.  We'll start by reviewing the most
common immutable collection types.</p>

<h4>Lists</h4>


<p>Lists are finite immutable sequences.  They provide constant-time
access to their first element as well as the rest of the list, and
they have a constant-time cons operation for adding a new element to
the front of the list.  Many other operations take linear time.  See
<a href="working-with-lists.html">Chapters 16</a> and<a href="implementing-lists.html"> 22</a>
for extensive discussions about lists.</p>

<h4>Streams</h4>


<p>A stream is like a list except that its elements are computed lazily.<a id="i-1334114643-2"/>
Because of this, a stream can be infinitely long.  Only those elements
requested will be computed.  Otherwise, streams have the same performance
characteristics as lists.</p>

<p>Whereas lists are constructed with the <span class="code">::</span> operator, streams are
constructed with the similar-looking <span class="code">#::</span>.  Here is a simple example
of a stream containing the integers 1, 2, and 3:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;str&nbsp;=&nbsp;<code class="literal">1</code>&nbsp;#::&nbsp;<code class="literal">2</code>&nbsp;#::&nbsp;<code class="literal">3</code>&nbsp;#::&nbsp;Stream.empty
  <code class="output">str:&nbsp;scala.collection.immutable.Stream[Int]&nbsp;=&nbsp;Stream(1,&nbsp;?)</code>
</pre>


<p>The head of this stream is 1, and the tail of it has 2 and 3.  The
tail is not printed here, though, because it hasn't been computed yet!
Streams are required to compute lazily, and the <span class="code">toString</span> method of a
stream is careful not to force any extra evaluation.</p>

<p>Below is a more complex example.  It computes a stream that contains a
Fibonacci sequence starting with the given two numbers.  A Fibonacci
sequence is one where each element is the sum of the previous two
elements in the series:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;fibFrom(a:&nbsp;<code class="typename">Int</code>,&nbsp;b:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Stream[Int]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;#::&nbsp;fibFrom(b,&nbsp;a&nbsp;+&nbsp;b)
  <code class="output">fibFrom:&nbsp;(a:&nbsp;Int,&nbsp;b:&nbsp;Int)Stream[Int]</code>
</pre>


<p>This function is deceptively simple.  The first element of the
sequence is clearly <span class="code">a</span>, and the rest of the sequence is the
Fibonacci sequence starting with <span class="code">b</span> followed by <span class="code">a</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">b</span>.  The tricky
part is computing this sequence without causing an infinite recursion.
If the function used <span class="code">::</span> instead of <span class="code">#::</span>, then every call to the
function would result in another call, thus causing an infinite
recursion.  Since it uses <span class="code">#::</span>, though, the right-hand side is not
evaluated until it is requested.</p>

<p>Here are the first few elements of the Fibonacci sequence starting
with two ones:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fibs&nbsp;=&nbsp;fibFrom(<code class="literal">1</code>,&nbsp;<code class="literal">1</code>).take(<code class="literal">7</code>)
  <code class="output">fibs:&nbsp;scala.collection.immutable.Stream[Int]&nbsp;=&nbsp;Stream(1,&nbsp;?)</code>
  <br />  scala&gt;&nbsp;fibs.toList
  <code class="output">res23:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;5,&nbsp;8,&nbsp;13)</code>
</pre>


<h4>Vectors</h4>


<p><a id="sec-collections-api-vectors"/></p>

<p>Lists are very efficient when the algorithm processing them is careful
to only process their heads.  Accessing, adding, and removing the head
of a list takes only constant time, whereas accessing or modifying
elements later in the list takes time linear in the depth into the
list.</p>

<p>Vectors are a collection type that give
efficient access to elements beyond the head.
Access to any elements of a vector take only "effectively constant time,"
as defined below.
It's a larger constant than for access to
the head of a list or for reading an element of an array, but it's a
constant nonetheless. As a result, algorithms using vectors do not
have to be careful about accessing just the head of the
sequence. They can access and modify elements at arbitrary
locations, and thus they can be much more convenient to write.</p>

<p>Vectors are built and modified just like any other sequence:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;vec&nbsp;=&nbsp;scala.collection.immutable.Vector.empty
  <code class="output">vec:&nbsp;scala.collection.immutable.Vector[Nothing]&nbsp;=&nbsp;Vector()</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;vec2&nbsp;=&nbsp;vec&nbsp;:+&nbsp;<code class="literal">1</code>&nbsp;:+&nbsp;<code class="literal">2</code>
  <code class="output">vec2:&nbsp;scala.collection.immutable.Vector[Int]&nbsp;=&nbsp;Vector(1,&nbsp;2)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;vec3&nbsp;=&nbsp;<code class="literal">100</code>&nbsp;+:&nbsp;vec2
  <code class="output">vec3:&nbsp;scala.collection.immutable.Vector[Int]</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;Vector(100,&nbsp;1,&nbsp;2)</code>
  <br />  scala&gt;&nbsp;vec3(<code class="literal">0</code>)
  <code class="output">res24:&nbsp;Int&nbsp;=&nbsp;100</code>
</pre>


<p>Vectors are represented as broad, shallow trees. Every
tree node contains up to 32 elements of the vector or contains up to
32 other tree nodes. Vectors with up to 32 elements can be represented
in a single node. Vectors with up to <span class="code">32</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">32</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">1024</span> elements can be
represented with a single indirection. Two hops from the root of the
tree to the final element node are sufficient for vectors with up to
2<sup>15</sup> elements, three hops for vectors with 2<sup>20</sup>, four hops for
vectors with 2<sup>25</sup> elements and five hops for vectors with up to
2<sup>30</sup> elements. So for all vectors of reasonable size, an element
selection involves up to five primitive array selections. This is what we
meant when we wrote that element access is "effectively constant
time."</p>

<p>Vectors are immutable, so you cannot change an element of a vector in place.
However, with the <span class="code">updated</span> method you can
create a new vector that differs from a given vector only
in a single element:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;vec&nbsp;=&nbsp;<code class="typename">Vector</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">vec:&nbsp;scala.collection.immutable.Vector[Int]&nbsp;=&nbsp;Vector(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;vec&nbsp;updated&nbsp;(<code class="literal">2</code>,&nbsp;<code class="literal">4</code>)
  <code class="output">res25:&nbsp;scala.collection.immutable.Vector[Int]&nbsp;=&nbsp;Vector(1,&nbsp;2,&nbsp;4)</code>
  <br />  scala&gt;&nbsp;vec
  <code class="output">res26:&nbsp;scala.collection.immutable.Vector[Int]&nbsp;=&nbsp;Vector(1,&nbsp;2,&nbsp;3)</code>
</pre>


<p>As the last line above shows, a call to <span class="code">updated</span> has no effect on
the original vector <span class="code">vec</span>. Like selection, functional vector updates
are also "effectively constant time." Updating an element in the
middle of a vector can be done by copying the node that contains the
element, and every node that points to it, starting from the root of
the tree.  This means that a functional update creates between one and
five nodes that each contain up to 32 elements or subtrees. This is 
certainly more expensive than an in-place update in a mutable array, but 
still a lot cheaper than copying the whole vector.</p>

<p>Because vectors strike a good balance between fast random selections and 
fast random functional updates, they are currently the default implementation of
immutable indexed sequences:</p>

<pre>
  scala&gt;&nbsp;<code class="typename">collection.immutable.IndexedSeq</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res27:&nbsp;scala.collection.immutable.IndexedSeq[Int]</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;Vector(1,&nbsp;2,&nbsp;3)</code>
</pre>


<h4>Immutable stacks</h4>


<p>If you need a last-in-first-out sequence, you can use a
<span class="code">Stack</span><a id="i-1444208192-1"/>.  You push an element
onto a stack with <span class="code">push</span><a id="i-995193675-1"/>, pop an element with <span class="code">pop</span><a id="i14430026-1"/>, and peek at the top of the stack without
removing it with <span class="code">top</span><a id="i-361766182-1"/>.  All of these operations are constant time.</p>

<p>Here are some simple operations performed on a stack:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;stack&nbsp;=&nbsp;scala.collection.immutable.Stack.empty
  <code class="output">stack:&nbsp;scala.collection.immutable.Stack[Nothing]&nbsp;=&nbsp;Stack()</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;hasOne&nbsp;=&nbsp;stack.push(<code class="literal">1</code>)
  <code class="output">hasOne:&nbsp;scala.collection.immutable.Stack[Int]&nbsp;=&nbsp;Stack(1)</code>
  <br />  scala&gt;&nbsp;stack
  <code class="output">res28:&nbsp;scala.collection.immutable.Stack[Nothing]&nbsp;=&nbsp;Stack()</code>
  <br />  scala&gt;&nbsp;hasOne.top
  <code class="output">res29:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br />  scala&gt;&nbsp;hasOne.pop
  <code class="output">res30:&nbsp;scala.collection.immutable.Stack[Int]&nbsp;=&nbsp;Stack()</code>
</pre>


<p>Immutable stacks are used rarely in Scala programs because their
functionality is subsumed by lists: A <span class="code">push</span> on an immutable stack is
the same as a <span class="code">::</span> on a list, and a <span class="code">pop</span> on a stack is the same a
<span class="code">tail</span> on a list.</p>

<h4>Immutable queues</h4>


<p>A queue is just like a stack except that it is first-in-first-out
rather than last-in-first-out<a id="i-705909367-1"/>. A simplified implementation of immutable queues was discussed in
<a href="type-parameterization.html">Chapter 19</a>. Here's how you can create an empty immutable queue:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;empty&nbsp;=&nbsp;<code class="typename">scala.collection.immutable.Queue[Int]</code>()
  <code class="output">empty:&nbsp;scala.collection.immutable.Queue[Int]&nbsp;=&nbsp;Queue()</code>
</pre>


<p>You can append an element to an immutable queue with 
<span class="code">enqueue</span><a id="i432237508-1"/>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;has1&nbsp;=&nbsp;empty.enqueue(<code class="literal">1</code>)
  <code class="output">has1:&nbsp;scala.collection.immutable.Queue[Int]&nbsp;=&nbsp;Queue(1)</code>
</pre>


<p>To append multiple elements to a queue, call <span class="code">enqueue</span>
with a collection as its argument:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;has123&nbsp;=&nbsp;has1.enqueue(<code class="typename">List</code>(<code class="literal">2</code>,&nbsp;<code class="literal">3</code>))
  <code class="output">has123:&nbsp;scala.collection.immutable.Queue[Int]&nbsp;=&nbsp;Queue(1,&nbsp;2,&nbsp;</code>
  <code class="output">3)</code>
</pre>


<p>To remove an element from the head of the queue, use
<span class="code">dequeue</span><a id="i2031764716-1"/>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;(element,&nbsp;has23)&nbsp;=&nbsp;has123.dequeue
  <code class="output">element:&nbsp;Int&nbsp;=&nbsp;1</code>
  <code class="output">has23:&nbsp;scala.collection.immutable.Queue[Int]&nbsp;=&nbsp;Queue(2,&nbsp;3)</code>
</pre>


<p>Note that <span class="code">dequeue</span> returns a pair consisting of the element
removed and the rest of the queue.</p>

<h4>Ranges</h4>


<p>A range is an ordered sequence of integers that are equally spaced
apart.  For example, "1, 2, 3" is a range, as is "5, 8, 11, 14."
To create a range in Scala, use the predefined methods <span class="code">to</span> and
<span class="code">by</span>. Here are some examples:</p>

<pre>
  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">3</code>
  <code class="output">res31:&nbsp;scala.collection.immutable.Range.Inclusive</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;Range(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;<code class="literal">5</code>&nbsp;to&nbsp;<code class="literal">14</code>&nbsp;by&nbsp;<code class="literal">3</code>
  <code class="output">res32:&nbsp;scala.collection.immutable.Range&nbsp;=&nbsp;Range(5,&nbsp;8,&nbsp;11,&nbsp;14)</code>
</pre>


<p>If you want to create a range that is exclusive of its upper limit,
 use the convenience method <span class="code">until</span> instead of <span class="code">to</span>:</p>

<pre>
  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;until&nbsp;<code class="literal">3</code>
  <code class="output">res33:&nbsp;scala.collection.immutable.Range&nbsp;=&nbsp;Range(1,&nbsp;2)</code>
</pre>


<p>Ranges are represented in constant space, because they can be defined
by just three numbers: their start, their end, and the stepping value.
Because of this representation, most operations on ranges are
extremely fast.</p>

<h4>Hash tries</h4>


<p><a id="sec-hash-tries"/></p>

<p>Hash tries<a href="collections-in-depth.html#footnotemain24-3">[3]</a> are a standard way to implement immutable sets and maps efficiently.  Their representation is similar to vectors in that they
are also trees where every node has 32 elements or 32 subtrees, but selection is done based on a hash code.
For instance, to find a given key in a map, you use the lowest five bits of the hash code of the key to
select the first subtree, the next five bits the next subtree, and so on.
Selection stops once all elements stored in a node have hash codes
that differ from each other in the bits that are selected so far.
Thus, not all the bits of the hash code are necessarily used.</p>

<p>Hash tries strike a nice balance between reasonably fast lookups and
reasonably efficient functional insertions <span class="code">(+)</span> and deletions
<span class="code">(-)</span>.  That's why they underlie Scala's default implementations of
immutable maps and sets. In fact, Scala has a further optimization for
immutable sets and maps that contain less than five elements.  Sets
and maps with one to four elements are stored as single objects that
just contain the elements (or key/value pairs in the case of a map) as
fields. The empty immutable set and empty immutable map is in each
case a singleton object&mdash;there's no need to duplicate storage for those
because an empty immutable set or map will always stay empty.</p>

<h4>Red-black trees</h4>


<p>Red-black trees are a form of balanced binary trees where some nodes
are designated "red" and others "black."  Like any
balanced binary tree, operations on them reliably complete in time
logarithmic to the size of the tree.</p>

<p>Scala provides implementations of sets and maps that use a red-black
tree internally. You access them under the names <span class="code">TreeSet</span> and <span class="code">TreeMap</span>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;set&nbsp;=&nbsp;collection.immutable.TreeSet.empty[<code class="typename">Int</code>]
  <code class="output">set:&nbsp;scala.collection.immutable.TreeSet[Int]&nbsp;=&nbsp;TreeSet()</code>
  <br />  scala&gt;&nbsp;set&nbsp;+&nbsp;<code class="literal">1</code>&nbsp;+&nbsp;<code class="literal">3</code>&nbsp;+&nbsp;<code class="literal">3</code>
  <code class="output">res34:&nbsp;scala.collection.immutable.TreeSet[Int]&nbsp;=&nbsp;TreeSet(1,&nbsp;3)</code>
</pre>


<p>Red-black trees are also the standard implementation of <span class="code">SortedSet</span> 
in Scala, because they provide an efficient iterator that returns
all elements of the set in sorted order.</p>

<h4>Immutable bit sets</h4>


<p>A bit set represents a collection of small integers as the bits of a
larger integer. For example, the bit set containing 3, 2, and 0 would
be represented as the integer 1101 in binary, which is 13 in decimal.</p>

<p>Internally, bit sets use an array of 64-bit <span class="code">Long</span>s.  The first
<span class="code">Long</span> in the array is for integers 0 through 63, the second is for
64 through 127, and so on.  Thus, bit sets are very compact so long as
the largest integer in the set is less than a few hundred or so.</p>

<p>Operations on bit sets are very fast.  Testing for inclusion takes
constant time.  Adding an item to the set takes time proportional to
the number of <span class="code">Long</span>s in the bit set's array, which is typically a
small number.  Here are some simple examples of the use of a bit set:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bits&nbsp;=&nbsp;scala.collection.immutable.BitSet.empty
  <code class="output">bits:&nbsp;scala.collection.immutable.BitSet&nbsp;=&nbsp;BitSet()</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;moreBits&nbsp;=&nbsp;bits&nbsp;+&nbsp;<code class="literal">3</code>&nbsp;+&nbsp;<code class="literal">4</code>&nbsp;+&nbsp;<code class="literal">4</code>
  <code class="output">moreBits:&nbsp;scala.collection.immutable.BitSet&nbsp;=&nbsp;BitSet(3,&nbsp;4)</code>
  <br />  scala&gt;&nbsp;moreBits(<code class="literal">3</code>)
  <code class="output">res35:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br />  scala&gt;&nbsp;moreBits(<code class="literal">0</code>)
  <code class="output">res36:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>


<h4>List maps</h4>


<p>A list map represents a map as a linked list of key-value pairs. In
general, operations on a list map might have to iterate through the
entire list. Thus, operations on a list map take time linear in the
size of the map. In fact there is little usage for list maps in Scala
because standard immutable maps are almost always faster. The only
possible difference is if the map is for some reason constructed in
such a way that the first elements in the list are selected much more
often than the other elements.</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;map&nbsp;=&nbsp;<code class="typename">collection.immutable.ListMap</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">1</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"one"</code>,&nbsp;<code class="literal">2</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"two"</code>)
  <code class="output">map:&nbsp;scala.collection.immutable.ListMap[Int,String]&nbsp;=&nbsp;Map(1&nbsp;</code>
  <code class="output">-&gt;&nbsp;one,&nbsp;2&nbsp;-&gt;&nbsp;two)</code>
  <br />  scala&gt;&nbsp;map(<code class="literal">2</code>)
  <code class="output">res37:&nbsp;String&nbsp;=&nbsp;"two"</code>
</pre>


<h3>24.9 Concrete mutable collection classes</h3>


<p>Now that you've seen the most commonly used immutable collection classes
that Scala provides in its standard library, take a look at 
the mutable collection classes.</p>

<h4>Array buffers</h4>


<p>You've already seen array buffers in
<a href="working-with-other-collections.html#sec-collections-arraybuf">Section 17.1</a>. An array buffer holds an
array and a size. Most operations on an array buffer have the same
speed as an array, because the operations simply access and modify the
underlying array. Additionally, array buffers can have data
efficiently added to the end. Appending an item to an array buffer
takes amortized constant time.
Thus, array buffers are useful for
efficiently building up a large collection whenever the new items are
always added to the end. Here are some examples:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;collection.mutable.ArrayBuffer.empty[<code class="typename">Int</code>]
  <code class="output">buf:&nbsp;scala.collection.mutable.ArrayBuffer[Int]</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;ArrayBuffer()</code>
  <br />  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">1</code>
  <code class="output">res38:&nbsp;buf.type&nbsp;=&nbsp;ArrayBuffer(1)</code>
  <br />  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">10</code>
  <code class="output">res39:&nbsp;buf.type&nbsp;=&nbsp;ArrayBuffer(1,&nbsp;10)</code>
  <br />  scala&gt;&nbsp;buf.toArray
  <code class="output">res40:&nbsp;Array[Int]&nbsp;=&nbsp;Array(1,&nbsp;10)</code>
</pre>


<h4>List buffers</h4>


<p>You've also already seen list buffers in
<a href="working-with-other-collections.html#sec-collections-listbuf">Section 17.1</a>.  A list buffer is like an
array buffer except that it uses a linked list internally instead of
an array. If you plan to convert the buffer to a list once it is built
up, use a list buffer instead of an array buffer. Here's an example:<a href="collections-in-depth.html#footnotemain24-4">[4]</a></p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;collection.mutable.ListBuffer.empty[<code class="typename">Int</code>]
  <code class="output">buf:&nbsp;scala.collection.mutable.ListBuffer[Int]</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;ListBuffer()</code>
  <br />  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">1</code>
  <code class="output">res41:&nbsp;buf.type&nbsp;=&nbsp;ListBuffer(1)</code>
  <br />  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">10</code>
  <code class="output">res42:&nbsp;buf.type&nbsp;=&nbsp;ListBuffer(1,&nbsp;10)</code>
  <br />  scala&gt;&nbsp;buf.toList
  <code class="output">res43:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;10)</code>
</pre>


<h4>String builders</h4>


<p>Just like an array buffer is useful for building arrays, and a list
buffer is useful for building lists, a string builder is useful for
building strings. String builders are so commonly used that they
are already imported into the default namespace. Create them with
a simple <span class="code">new</span>&nbsp;<span class="code">StringBuilder</span>, like this:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">StringBuilder</code>
  <code class="output">buf:&nbsp;StringBuilder&nbsp;=</code>
  <br />  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="quotedstring">'a'</code>
  <code class="output">res44:&nbsp;buf.type&nbsp;=&nbsp;a</code>
  <br />  scala&gt;&nbsp;buf&nbsp;++=&nbsp;<code class="quotedstring">"bcdef"</code>
  <code class="output">res45:&nbsp;buf.type&nbsp;=&nbsp;abcdef</code>
  <br />  scala&gt;&nbsp;buf.toString
  <code class="output">res46:&nbsp;String&nbsp;=&nbsp;abcdef</code>
</pre>


<h4>Linked lists</h4>


<p>Linked lists are mutable sequences that consist of nodes that are
linked with <span class="code">next</span> pointers. In most languages <span class="code">null</span> would be
picked as the empty linked list. That does not work for Scala
collections, because even empty sequences must support all sequence
methods. <span class="code">LinkedList.empty.isEmpty</span>, in particular, should return
<span class="code">true</span> and not throw a <span class="code">NullPointerException</span>. Empty linked lists
are encoded instead in a special way: Their <span class="code">next</span> field points back
to the node itself.</p>

<p>Like their immutable cousins, linked lists are best operated on
sequentially.  In addition, linked lists make it easy to insert an
element or linked list into another linked list.</p>

<h4>Double linked lists</h4>


<p><span class="code">DoubleLinkedList</span>s are like the single linked lists described in the
previous subsection, except besides <span class="code">next</span>, they have another
mutable field, <span class="code">prev</span>, that points to the element preceding the current
node. The main benefit of that additional link is that it makes
element removal very fast.</p>

<h4>Mutable lists</h4>


<p>A <span class="code">MutableList</span> consists of a single linked list together with a
pointer that refers to the terminal empty node of that list.  This
makes list append a constant time operation because it avoids having
to traverse the list in search for its terminal node. <span class="code">MutableList</span>
is currently the standard implementation of <span class="code">mutable.LinearSeq</span> in Scala.</p>

<h4>Queues</h4>


<p>Scala provides mutable queues in addition to immutable ones.  You use
a mutable queue similarly to the way you use an immutable one, but instead
of <span class="code">enqueue</span>, you use the <span class="code">+=</span> and <span class="code">++=</span> operators to append. Also,
on a mutable queue, the <span class="code">dequeue</span> method will just remove the head
element from the queue and return it. Here's an example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;queue&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">scala.collection.mutable.Queue[String]</code>
  <code class="output">queue:&nbsp;scala.collection.mutable.Queue[String]&nbsp;=&nbsp;Queue()</code>
  <br />  scala&gt;&nbsp;queue&nbsp;+=&nbsp;<code class="quotedstring">"a"</code>
  <code class="output">res47:&nbsp;queue.type&nbsp;=&nbsp;Queue(a)</code>
  <br />  scala&gt;&nbsp;queue&nbsp;++=&nbsp;<code class="typename">List</code>(<code class="quotedstring">"b"</code>,&nbsp;<code class="quotedstring">"c"</code>)
  <code class="output">res48:&nbsp;queue.type&nbsp;=&nbsp;Queue(a,&nbsp;b,&nbsp;c)</code>
  <br />  scala&gt;&nbsp;queue
  <code class="output">res49:&nbsp;scala.collection.mutable.Queue[String]&nbsp;=&nbsp;Queue(a,&nbsp;b,&nbsp;c)</code>
  <br />  scala&gt;&nbsp;queue.dequeue
  <code class="output">res50:&nbsp;String&nbsp;=&nbsp;a</code>
  <br />  scala&gt;&nbsp;queue
  <code class="output">res51:&nbsp;scala.collection.mutable.Queue[String]&nbsp;=&nbsp;Queue(b,&nbsp;c)</code>
</pre>


<h4>Array sequences</h4>


<p>Array sequences are mutable sequences of fixed size that store their
elements internally in an <span class="code">Array[AnyRef]</span>. They are implemented in
Scala by class <span class="code">ArraySeq</span>.</p>

<p>You would typically use an <span class="code">ArraySeq</span> if you want an array for its
performance characteristics, but you also want to create generic
instances of the sequence where you do not know the type of the
elements and do not have a <span class="code">ClassTag</span> to provide it at
run-time. You will find out about these issues with arrays shortly,
in <a href="collections-in-depth.html#sec-arrays">Section 24.10</a>.</p>

<h4>Stacks</h4>


<p>You saw immutable stacks earlier.  There is also a mutable version.
It works exactly the same as the immutable version except that
modifications happen in place. Here's an example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;stack&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">scala.collection.mutable.Stack[Int]</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">stack:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack()</code>
  <br />  scala&gt;&nbsp;stack.push(<code class="literal">1</code>)
  <code class="output">res52:&nbsp;stack.type&nbsp;=&nbsp;Stack(1)</code>
  <br />  scala&gt;&nbsp;stack
  <code class="output">res53:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack(1)</code>
  <br />  scala&gt;&nbsp;stack.push(<code class="literal">2</code>)
  <code class="output">res54:&nbsp;stack.type&nbsp;=&nbsp;Stack(2,&nbsp;1)</code>
  <br />  scala&gt;&nbsp;stack
  <code class="output">res55:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack(2,&nbsp;1)</code>
  <br />  scala&gt;&nbsp;stack.top
  <code class="output">res56:&nbsp;Int&nbsp;=&nbsp;2</code>
  <br />  scala&gt;&nbsp;stack
  <code class="output">res57:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack(2,&nbsp;1)</code>
  <br />  scala&gt;&nbsp;stack.pop
  <code class="output">res58:&nbsp;Int&nbsp;=&nbsp;2</code>
  <br />  scala&gt;&nbsp;stack&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">res59:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack(1)</code>
</pre>


<h4>Array stacks</h4>


<p><span class="code">ArrayStack</span> is an alternative implementation of a mutable stack,
which is backed by an <span class="code">Array</span> that gets resized as needed. It
provides fast indexing and is generally slightly more efficient for
most operations than a normal mutable stack.</p>

<h4>Hash tables</h4>


<p>A hash table stores its elements in an underlying array, placing each
item at a position in the array determined by the hash code of that
item. Adding an element to a hash table takes only constant time, so
long as there isn't already another element in the array that has the
same hash code. Hash tables are thus very fast so long as the objects
placed in them have a good distribution of hash codes. As a result,
the default mutable map and set types in Scala are based on hash
tables.</p>

<p>Hash sets and maps are used just like any other set or map. Here are
some simple examples:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;map&nbsp;=&nbsp;collection.mutable.HashMap.empty[<code class="typename">Int</code>,<code class="typename">String</code>]
  <code class="output">map:&nbsp;scala.collection.mutable.HashMap[Int,String]&nbsp;=&nbsp;Map()</code>
  <br />  scala&gt;&nbsp;map&nbsp;+=&nbsp;(<code class="literal">1</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"make&nbsp;a&nbsp;web&nbsp;site"</code>)
  <code class="output">res60:&nbsp;map.type&nbsp;=&nbsp;Map(1&nbsp;-&gt;&nbsp;make&nbsp;a&nbsp;web&nbsp;site)</code>
  <br />  scala&gt;&nbsp;map&nbsp;+=&nbsp;(<code class="literal">3</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"profit!"</code>)
  <code class="output">res61:&nbsp;map.type&nbsp;=&nbsp;Map(1&nbsp;-&gt;&nbsp;make&nbsp;a&nbsp;web&nbsp;site,&nbsp;3&nbsp;-&gt;&nbsp;profit!)</code>
  <br />  scala&gt;&nbsp;map(<code class="literal">1</code>)
  <code class="output">res62:&nbsp;String&nbsp;=&nbsp;make&nbsp;a&nbsp;web&nbsp;site</code>
  <br />  scala&gt;&nbsp;map&nbsp;contains&nbsp;<code class="literal">2</code>
  <code class="output">res63:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>


<p>Iteration over a hash table is not guaranteed to occur in any
particular order. Iteration simply proceeds through the underlying
array in whichever order it happens to be. To get a guaranteed
iteration order, use a <em>linked</em> hash map or set instead of
a regular one.  A linked hash map or set is just like a
regular hash map or set except that it also includes a linked
list of the elements in the order they were added. Iteration over
such a collection is always in the same order that the elements
were initially added.</p>

<h4>Weak hash maps</h4>


<p>A weak hash map<a id="i-707232831-1"/> is a special kind of hash map in which the garbage
collector does not follow links from the map to the keys stored in
it. This means that a key and its associated value will disappear from
the map if there is no other reference to that key. Weak hash maps are
useful for tasks such as caching, where you want to re-use an
expensive function's result if the function is called again on the
same key. If keys and function results are stored in a regular hash
map, the map could grow without bounds, and no key would ever become
garbage. Using a weak hash map avoids this problem. As soon as a key
object becomes unreachable, it's entry is removed from the weak
hash map. Weak hash maps in Scala are implemented as a wrapper of an
underlying Java implementation, <span class="code">java.util.WeakHashMap</span>.</p>

<h4>Concurrent Maps</h4>


<p>A concurrent map can be accessed by several threads at once. In
addition to the usual <span class="code">Map</span> operations, it provides the following
atomic operations:</p>

<p><a id="tab-cmapops"/></p>

<h5>Operations in trait <span class="code">ConcurrentMap</span> <a id="i-1337741596-1"/></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span class="code">m</span>&nbsp;<span class="code">putIfAbsent(k,</span>&nbsp;<span class="code">v)</span>
  </td>
  <td>
    Adds key/value binding <span class="code">k</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">m</span> unless <span class="code">k</span> is
                            already defined in <span class="code">m</span><a id="i-432133008-1"/><a id="i-1114573962-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">m</span>&nbsp;<span class="code">remove</span>&nbsp;<span class="code">(k,</span>&nbsp;<span class="code">v)</span>
  </td>
  <td>
    Removes entry for <span class="code">k</span> if it is currently
                            mapped to <span class="code">v</span><a id="i-573548081-1"/><a id="i-218120845-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">m</span>&nbsp;<span class="code">replace</span>&nbsp;<span class="code">(k,</span>&nbsp;<span class="code">old,</span>&nbsp;<span class="code">new)</span>
  </td>
  <td>
    Replaces value associated with key <span class="code">k</span> to
                            <span class="code">new</span>, if it was previously bound to
                            <span class="code">old</span><a id="i-400154625-1"/><a id="i1830849445-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">m</span>&nbsp;<span class="code">replace</span>&nbsp;<span class="code">(k,</span>&nbsp;<span class="code">v)</span>
  </td>
  <td>
    Replaces value associated with key <span class="code">k</span> to
                            <span class="code">v</span>, if it was previously bound to some value
  </td>
</tr>
</table>


<p><span class="code">ConcurrentMap</span> is a trait in the Scala collections library.
Currently, its only implementation is Java's
<span class="code">java.util.concurrent.ConcurrentMap</span>, which can be converted
automatically into a Scala map using the 
standard Java/Scala collection conversions, which will be described
in <a href="collections-in-depth.html#sec-javaconversions">Section 24.17</a>.</p>

<h4>Mutable bit sets</h4>


<p>A mutable bit set is just like an immutable one, except that it can be
modified in place. Mutable bit sets are slightly more efficient at
updating than immutable ones, because they don't have to copy around
<span class="code">Long</span>s that haven't changed. Here is an example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bits&nbsp;=&nbsp;scala.collection.mutable.BitSet.empty
  <code class="output">bits:&nbsp;scala.collection.mutable.BitSet&nbsp;=&nbsp;BitSet()</code>
  <br />  scala&gt;&nbsp;bits&nbsp;+=&nbsp;<code class="literal">1</code>
  <code class="output">res64:&nbsp;bits.type&nbsp;=&nbsp;BitSet(1)</code>
  <br />  scala&gt;&nbsp;bits&nbsp;+=&nbsp;<code class="literal">3</code>
  <code class="output">res65:&nbsp;bits.type&nbsp;=&nbsp;BitSet(1,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;bits
  <code class="output">res66:&nbsp;scala.collection.mutable.BitSet&nbsp;=&nbsp;BitSet(1,&nbsp;3)</code>
</pre>


<h3 id="sec-arrays">24.10 Arrays</h3>


<p>Arrays are a special kind of collection in Scala. One the one hand,
Scala arrays correspond one-to-one to Java arrays. That is, a Scala
array <span class="code">Array[Int]</span> is represented as a Java <span class="code">int[]</span>, an
<span class="code">Array[Double]</span> is represented as a Java <span class="code">double[]</span> and an
<span class="code">Array[String]</span> is represented as a Java <span class="code">String[]</span>.  But at the
same time, Scala arrays offer much more their Java analogues.  First,
Scala arrays can be <span style="font-style:italic">generic</span>. That is, you can have an
<span class="code">Array[T]</span>, where <span class="code">T</span> is a type parameter or abstract type. 
Second, Scala arrays are compatible with Scala sequences&mdash;you can pass an
<span class="code">Array[T]</span> where a <span class="code">Seq[T]</span> is required. Finally, Scala arrays also support all
sequence operations. Here's an example of this in action:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a1&nbsp;=&nbsp;<code class="typename">Array</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">a1:&nbsp;Array[Int]&nbsp;=&nbsp;Array(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a2&nbsp;=&nbsp;a1&nbsp;map&nbsp;(_&nbsp;*&nbsp;<code class="literal">3</code>)
  <code class="output">a2:&nbsp;Array[Int]&nbsp;=&nbsp;Array(3,&nbsp;6,&nbsp;9)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a3&nbsp;=&nbsp;a2&nbsp;filter&nbsp;(_&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">2</code>&nbsp;!=&nbsp;<code class="literal">0</code>)
  <code class="output">a3:&nbsp;Array[Int]&nbsp;=&nbsp;Array(3,&nbsp;9)</code>
  <br />  scala&gt;&nbsp;a3.reverse
  <code class="output">res1:&nbsp;Array[Int]&nbsp;=&nbsp;Array(9,&nbsp;3)</code>
</pre>


<p>Given that Scala arrays are represented just like Java arrays, how can
these additional features be supported in Scala?</p>

<p>The answer lies in systematic use of implicit conversions. An array
cannot pretend to <span style="font-style:italic">be</span> a sequence, because the data type
representation of a native array is not a subtype of <span class="code">Seq</span>. Instead,
whenever an array would be used as a <span class="code">Seq</span>, implicitly wrap it in
a subclass of <span class="code">Seq</span>. The name of that subclass is
<span class="code">scala.collection.mutable.WrappedArray</span>. Here you see it in action:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;seq:&nbsp;<code class="typename">Seq[Int]</code>&nbsp;=&nbsp;a1
  seq:&nbsp;<code class="typename">Seq[Int]</code>&nbsp;=&nbsp;<code class="typename">WrappedArray</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a4:&nbsp;<code class="typename">Array[Int]</code>&nbsp;=&nbsp;seq.toArray
  a4:&nbsp;<code class="typename">Array[Int]</code>&nbsp;=&nbsp;<code class="typename">Array</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <br />  scala&gt;&nbsp;a1&nbsp;eq&nbsp;a4
  res2:&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;<code class="vem">true</code>
</pre>


<p>This interaction demonstrates that arrays are compatible with sequences, because
there's an implicit conversion from <span class="code">Array</span> to <span class="code">WrappedArray</span>. To go the other way, from
a <span class="code">WrappedArray</span> to an <span class="code">Array</span>, you can use the <span class="code">toArray</span> method defined in <span class="code">Traversable</span>. 
The last interpreter line above shows that wrapping then unwrapping with <span class="code">toArray</span> gives you back
the same array you started with.</p>

<p>There is yet another implicit conversion that gets applied to arrays. This conversion
simply "adds" all sequence methods to arrays but does not turn the array itself 
into a sequence. "Adding" means that the array is wrapped in another object of type <span class="code">ArrayOps</span>, which
supports all sequence methods. Typically, this <span class="code">ArrayOps</span> object is short-lived; it will
usually be inaccessible after the call to the sequence method and its storage can be recycled.
Modern VMs often avoid creating this object entirely.</p>

<p>The difference between the two implicit conversions on arrays is demonstrated here:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;seq:&nbsp;<code class="typename">Seq[Int]</code>&nbsp;=&nbsp;a1
  <code class="output">seq:&nbsp;Seq[Int]&nbsp;=&nbsp;WrappedArray(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;seq.reverse
  <code class="output">res2:&nbsp;Seq[Int]&nbsp;=&nbsp;WrappedArray(3,&nbsp;2,&nbsp;1)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;ops:&nbsp;<code class="typename">collection.mutable.ArrayOps[Int]</code>&nbsp;=&nbsp;a1
  <code class="output">ops:&nbsp;scala.collection.mutable.ArrayOps[Int]&nbsp;=&nbsp;[I(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;ops.reverse
  <code class="output">res3:&nbsp;Array[Int]&nbsp;=&nbsp;Array(3,&nbsp;2,&nbsp;1)</code>
</pre>


<p>You see that calling <span class="code">reverse</span> on <span class="code">seq</span>, which is a <span class="code">WrappedArray</span>, will give again a 
<span class="code">WrappedArray</span>. That's logical, because wrapped arrays are <span class="code">Seq</span>s, and calling <span class="code">reverse</span>
on any <span class="code">Seq</span> will give again a <span class="code">Seq</span>. On the other hand, calling <span class="code">reverse</span> on the 
<span class="code">ops</span> value of class <span class="code">ArrayOps</span> will result in an <span class="code">Array</span>, not a <span class="code">Seq</span>.</p>

<p>The <span class="code">ArrayOps</span> example above was quite artificial, intended only to show the difference
to <span class="code">WrappedArray</span>. Normally, you'd never define a value of class <span class="code">ArrayOps</span>. You'd 
just call a <span class="code">Seq</span> method on an array:</p>

<pre>
  scala&gt;&nbsp;a1.reverse
  <code class="output">res4:&nbsp;Array[Int]&nbsp;=&nbsp;Array(3,&nbsp;2,&nbsp;1)</code>
</pre>


<p>The <span class="code">ArrayOps</span> object gets inserted automatically by the implicit conversion. So the
line above is equivalent to the following line, 
where <span class="code">intArrayOps</span> was the conversion that was implicitly inserted previously:</p>

<pre>
  scala&gt;&nbsp;intArrayOps(a1).reverse
  <code class="output">res5:&nbsp;Array[Int]&nbsp;=&nbsp;Array(3,&nbsp;2,&nbsp;1)</code>
</pre>


<p>This raises the question how the compiler picked
<span class="code">intArrayOps</span> over the other implicit conversion to <span class="code">WrappedArray</span>
in the line above. After all, both conversions map an array to a type
that supports a <span class="code">reverse</span> method, which is what the input specified.
The answer to that question is that the two implicit conversions are
prioritized.  The <span class="code">ArrayOps</span> conversion has a higher priority than
the <span class="code">WrappedArray</span> conversion.  The first is defined in the <span class="code">Predef</span>
object whereas the second is defined in a class
<span class="code">scala.LowPriorityImplicits</span>, which is a superclass of
<span class="code">Predef</span>. Implicits in subclasses and subobjects take precedence over
implicits in base classes. So if both conversions are applicable, the
one in <span class="code">Predef</span> is chosen. A very similar scheme, which was
described in <a href="implicit-conversions-and-parameters.html#sec-when-multiple-conversions-apply">Section 21.7</a>, works for strings.</p>

<p>So now you know how arrays can be compatible with sequences and how
they can support all sequence operations. What about genericity?  In
Java you cannot write a <span class="code">T[]</span> where <span class="code">T</span> is a type parameter.  How
then is Scala's <span class="code">Array[T]</span> represented? In fact a generic array<a id="i953627543-1"/><a id="i337692579-1"/> like
<span class="code">Array[T]</span> could be at run time any of Java's eight primitive array
types <span class="code">byte[]</span>, <span class="code">short[]</span>, <span class="code">char[]</span>, <span class="code">int[]</span>, <span class="code">long[]</span>, <span class="code">float[]</span>,
<span class="code">double[]</span>, <span class="code">boolean[]</span>, or it could be an array of objects. The
only common run-time type encompassing all of these types is <span class="code">AnyRef</span>
(or, equivalently <span class="code">java.lang.Object</span>), so that's the type to which
the Scala compiler maps <span class="code">Array[T]</span>.  At run-time, when an element of
an array of type <span class="code">Array[T]</span> is accessed or updated there is a
sequence of type tests that determine the actual array type, followed
by the correct array operation on the Java array. These type tests
slow down array operations somewhat. You can expect accesses to
generic arrays to be three to four times slower than accesses to
primitive or object arrays. This means that if you need maximal
performance, you should prefer concrete over generic arrays.</p>

<p>Representing the generic array type is not enough, however, there must
also be a way to <span style="font-style:italic">create</span> generic arrays. This is an even harder
problem, which requires a little bit of help from you. To illustrate
the problem, consider the following attempt to write a generic method that creates an array:</p>

<div style="page-break-after:always"/>


<pre>
  <code class="comment">//&nbsp;This&nbsp;is&nbsp;wrong!</code>
  <code class="vem">def</code>&nbsp;evenElems[T](xs:&nbsp;<code class="typename">Vector[T]</code>):&nbsp;<code class="typename">Array[T]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;arr&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[T]</code>((xs.length&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;/&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;xs.length&nbsp;by&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;arr(i&nbsp;/&nbsp;<code class="literal">2</code>)&nbsp;=&nbsp;xs(i)
  &nbsp;&nbsp;arr
  }
</pre>


<p>The <span class="code">evenElems</span> method returns a new array that consists of all elements
of the argument vector <span class="code">xs</span> that are at even positions in the vector.
The first line of the body of <span class="code">evenElems</span> creates the result array, which 
has the same element type as the argument. So depending on the actual type parameter 
for <span class="code">T</span>, this could be an <span class="code">Array[Int]</span>, or an <span class="code">Array[Boolean]</span>, or an array of some 
of the other primitive types in Java, or an array of some reference type. 
But these types all have different runtime representations, so how is the Scala runtime 
going to pick the correct one? In fact, it can't do that based on the information it is given,
because the actual type that corresponds to the type parameter <span class="code">T</span> is erased at runtime.
That's why you will get the following error message if you attempt to compile the code above:</p>

<pre>
  error:&nbsp;cannot&nbsp;find&nbsp;<code class="vem">class</code>&nbsp;tag&nbsp;<code class="vem">for</code>&nbsp;element&nbsp;<code class="vem">type</code>&nbsp;T
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;arr&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[T]</code>((arr.length&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;/&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
</pre>


<p>What's required here is that you help the compiler by providing a
runtime hint of what the actual type parameter of <span class="code">evenElems</span>
is. This runtime hint takes the form of a <span style="font-style:italic">class tag</span> of type
<span class="code">scala.reflect.ClassTag</span>. A class tag describes the <em>erased type</em>
of a given type, which is all the information needed to construct an
array of that type.</p>

<p>In many cases the compiler can generate a class tag on its own.  Such
is the case for a concrete type like <span class="code">Int</span> or <span class="code">String</span>. It's also
the case for certain generic types, like <span class="code">List[T]</span>, where enough
information is known to predict the erased type; in this example the
erased type would be <span class="code">List</span>.</p>

<p>For fully generic cases, the usual idiom is to pass the class tag
using a context bound, as discussed in
<a href="implicit-conversions-and-parameters.html#sec-context-bounds">Section 21.6</a>. Here is how the above definition
could be fixed by using a context bound:</p>

<pre>
  <code class="comment">//&nbsp;This&nbsp;works</code>
  <code class="vem">import</code>&nbsp;scala.reflect.ClassTag
  <code class="vem">def</code>&nbsp;evenElems[T:&nbsp;<code class="typename">ClassTag</code>](xs:&nbsp;<code class="typename">Vector[T]</code>):&nbsp;<code class="typename">Array[T]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;arr&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[T]</code>((xs.length&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;/&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;xs.length&nbsp;by&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;arr(i&nbsp;/&nbsp;<code class="literal">2</code>)&nbsp;=&nbsp;xs(i)
  &nbsp;&nbsp;arr
  }
</pre>


<p>In this new definition, when the <span class="code">Array[T]</span> is created, the compiler
looks for a class tag for the type parameter <span class="code">T</span>, that is, it will
look for an implicit value of type <span class="code">ClassTag[T]</span>. If such a value is
found, the class tag is used to construct the right kind of
array. Otherwise, you'll see an error message like the one shown
previously.</p>

<p>Here is an interpreter interaction that uses the <span class="code">evenElems</span> method:</p>

<pre>
  scala&gt;&nbsp;evenElems(<code class="typename">Vector</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">5</code>))
  <code class="output">res6:&nbsp;Array[Int]&nbsp;=&nbsp;Array(1,&nbsp;3,&nbsp;5)</code>
  <br />  scala&gt;&nbsp;evenElems(<code class="typename">Vector</code>(<code class="quotedstring">"this"</code>,&nbsp;<code class="quotedstring">"is"</code>,&nbsp;<code class="quotedstring">"a"</code>,&nbsp;<code class="quotedstring">"test"</code>,&nbsp;<code class="quotedstring">"run"</code>))
  <code class="output">res7:&nbsp;Array[java.lang.String]&nbsp;=&nbsp;Array(this,&nbsp;a,&nbsp;run)</code>
</pre>


<p>In both cases, the Scala compiler automatically constructed a class tag for the element type
(first <span class="code">Int</span>, then <span class="code">String</span>) and passed it to the implicit parameter of the <span class="code">evenElems</span> method.
The compiler can do that for all concrete types, but not if the argument is itself another
type parameter without its class tag. For instance, the following fails:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;wrap[U](xs:&nbsp;<code class="typename">Vector[U]</code>)&nbsp;=&nbsp;evenElems(xs)
  <code class="output">&lt;console&gt;:9:&nbsp;error:&nbsp;No&nbsp;ClassTag&nbsp;available&nbsp;for&nbsp;U</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;wrap[U](xs:&nbsp;Vector[U])&nbsp;=&nbsp;evenElems(xs)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>What happened here is that the <span class="code">evenElems</span> demands a class tag for the type parameter <span class="code">U</span>, 
but none was found. The solution in this case is, of course, to demand another implicit class tag for <span class="code">U</span>.
So the following works:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;wrap[U:&nbsp;<code class="typename">ClassTag</code>](xs:&nbsp;<code class="typename">Vector[U]</code>)&nbsp;=&nbsp;evenElems(xs)
  <code class="output">wrap:&nbsp;[U](xs:&nbsp;Vector[U])(implicit&nbsp;evidence$1:</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scala.reflect.ClassTag[U])Array[U]</code>
</pre>


<p>This example also shows that the context bound in the definition of <span class="code">U</span> is just a shorthand
for an implicit parameter named here <span class="code">evidence$1</span> of type <span class="code">ClassTag[U]</span>.</p>

<h3>24.11 Strings</h3>


<p>Like arrays, strings are not directly sequences, but they can be
converted to them, and they also support all sequence operations.
Here are some examples of operations you can invoke on strings:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;str&nbsp;=&nbsp;<code class="quotedstring">"hello"</code>
  <code class="output">str:&nbsp;java.lang.String&nbsp;=&nbsp;hello</code>
  <br />  scala&gt;&nbsp;str.reverse
  <code class="output">res6:&nbsp;String&nbsp;=&nbsp;olleh</code>
  <br />  scala&gt;&nbsp;str.map(_.toUpper)
  <code class="output">res7:&nbsp;String&nbsp;=&nbsp;HELLO</code>
  <br />  scala&gt;&nbsp;str&nbsp;drop&nbsp;<code class="literal">3</code>&nbsp;
  <code class="output">res8:&nbsp;String&nbsp;=&nbsp;lo</code>
  <br />  scala&gt;&nbsp;str&nbsp;slice&nbsp;(<code class="literal">1</code>,&nbsp;<code class="literal">4</code>)
  <code class="output">res9:&nbsp;String&nbsp;=&nbsp;ell</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;s:&nbsp;<code class="typename">Seq[Char]</code>&nbsp;=&nbsp;str
  <code class="output">s:&nbsp;Seq[Char]&nbsp;=&nbsp;WrappedString(h,&nbsp;e,&nbsp;l,&nbsp;l,&nbsp;o)</code>
</pre>


<p>These operations are supported by two implicit conversions, which were
explained in
<a href="implicit-conversions-and-parameters.html#sec-when-multiple-conversions-apply">Section 21.7</a>.  The first,
low-priority conversion maps a <span class="code">String</span> to a <span class="code">WrappedString</span>, which
is a subclass of <span class="code">immutable.IndexedSeq</span>. This conversion was applied
in the last line of the previous example in which a string was converted into a <span class="code">Seq</span>. The
other, high-priority conversion maps a string to a <span class="code">StringOps</span>
object, which adds all methods on immutable sequences to strings.
This conversion was implicitly inserted in the method calls of
<span class="code">reverse</span>, <span class="code">map</span>, <span class="code">drop</span>, and <span class="code">slice</span> in the previous example.</p>

<h3>24.12 Performance characteristics</h3>


<p>As the previous explanations have shown, different collection
types have different performance characteristics.<a id="i1597641046-1"/> That's often the
primary reason for picking one collection type over another. You can
see the performance characteristics of some common operations on
collections summarized in two tables, <a href="collections-in-depth.html#tab-seq-perf">Table 24.12</a> and
<a href="collections-in-depth.html#tab-setmap-perf">Table 24.12</a>.</p>

<p><a id="tab-seq-perf"/></p>

<table style="border-collapse: collapse">
<tr>
  <td>
  </td>
  <td>
    <span style="font-size:small">head</span>
  </td>
  <td>
    <span style="font-size:small">tail</span>
  </td>
  <td>
    <span style="font-size:small">apply</span>
  </td>
  <td>
    <span style="font-size:small">update</span>
  </td>
  <td>
    <span style="font-size:small">prepend</span>
  </td>
  <td>
    <span style="font-size:small">append</span>
  </td>
  <td>
    <span style="font-size:small">insert</span>
  </td>
</tr>
<tr class="topline ">
  <td>
    <span style="font-weight:bold">immutable</span>
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">List</span>
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    -
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">Stream</span>
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    -
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">Vector</span>
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    -
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">Stack</span>
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    -
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">Queue</span>
  </td>
  <td>
    aC
  </td>
  <td>
    aC
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    -
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">Range</span>
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    -
  </td>
  <td>
    -
  </td>
  <td>
    -
  </td>
  <td>
    -
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">String</span>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    -
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">mutable</span>
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">ArrayBuffer</span>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    aC
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">ListBuffer</span>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">StringBuilder</span>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    aC
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">MutableList</span>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">Queue</span>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">ArraySeq</span>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    -
  </td>
  <td>
    -
  </td>
  <td>
    -
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">Stack</span>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">ArrayStack</span>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    aC
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">Array</span>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    -
  </td>
  <td>
    -
  </td>
  <td>
    -
  </td>
</tr>
</table>


<h5>Performance characteristics of sequence types</h5>


<p><a id="tab-setmap-perf"/></p>

<table style="border-collapse: collapse">
<tr>
  <td>
  </td>
  <td>
    <span style="font-size:small">lookup</span>
  </td>
  <td>
    <span style="font-size:small">add</span>
  </td>
  <td>
    <span style="font-size:small">remove</span>
  </td>
  <td>
    <span style="font-size:small">min</span>
  </td>
</tr>
<tr class="topline ">
  <td>
    <span style="font-weight:bold">immutable</span>
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">HashSet/HashMap</span>
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">TreeSet/TreeMap</span>
  </td>
  <td>
    Log
  </td>
  <td>
    Log
  </td>
  <td>
    Log
  </td>
  <td>
    Log
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">BitSet</span>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    eC<a href="collections-in-depth.html#footnotemain24-5">[5]</a>
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">ListMap</span>
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">mutable</span>
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">HashSet/HashMap</span>
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">WeakHashMap</span>
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">BitSet</span>
  </td>
  <td>
    C
  </td>
  <td>
    aC
  </td>
  <td>
    C
  </td>
  <td>
    eC[5] 
  </td>
</tr>
</table>


<h5>Performance characteristics of set and map types</h5>


<div style="page-break-after:always"/>


<p>The entries in these two tables are explained as follows:</p>

<table style="border-collapse: collapse">
<tr>
  <td>
    C
  </td>
  <td>
    The operation takes (fast) constant time.
  </td>
</tr>
<tr>
  <td>
    eC
  </td>
  <td>
    The operation takes effectively constant time, 
     but this might depend on some assumptions such as 
     the maximum length of a vector or the distribution of hash keys.
  </td>
</tr>
<tr>
  <td>
    aC
  </td>
  <td>
    The operation takes amortized constant time. Some invocations of the operation
     might take longer, but if many operations are performed
     on average only constant time per operation is taken.
  </td>
</tr>
<tr>
  <td>
    Log
  </td>
  <td>
    The operation takes time proportional to the logarithm of the collection size.
  </td>
</tr>
<tr>
  <td>
    L
  </td>
  <td>
    The operation is linear, that is it takes time proportional to the collection size.
  </td>
</tr>
<tr>
  <td>
    -
  </td>
  <td>
    The operation is not supported.
  </td>
</tr>
</table>           


<p><a href="collections-in-depth.html#tab-seq-perf">Table 24.12</a> treats sequence types&mdash;both immutable and
mutable&mdash;with the following operations:</p>

<table style="border-collapse: collapse">
<tr>
  <td>
    head
  </td>
  <td>
    Selecting the first element of the sequence.
  </td>
</tr>
<tr>
  <td>
    tail
  </td>
  <td>
    Producing a new sequence that consists of all elements
           except the first one.
  </td>
</tr>
<tr>
  <td>
    apply
  </td>
  <td>
    Indexing.
  </td>
</tr>
<tr>
  <td>
    update
  </td>
  <td>
    Functional update (with <span class="code">updated</span>) for immutable sequences,
        side-effecting update (with <span class="code">update</span>) for mutable sequences.
  </td>
</tr>
<tr>
  <td>
    prepend
  </td>
  <td>
    Adding an element to the front of the sequence.
          For immutable sequences, this produces a new sequence.
          For mutable sequences it modifies the existing sequence.
  </td>
</tr>
<tr>
  <td>
    append
  </td>
  <td>
    Adding an element at the end of the sequence.
          For immutable sequences, this produces a new sequence.
          For mutable sequences it modifies the existing sequence.
  </td>
</tr>
<tr>
  <td>
    insert
  </td>
  <td>
    Inserting an element at an arbitrary position in the sequence.
         This is only supported directly for mutable sequences.
  </td>
</tr>
</table>


<p><a href="collections-in-depth.html#tab-setmap-perf">Table 24.12</a> treats mutable and immutable sets and
maps with the following operations:</p>

<table style="border-collapse: collapse">
<tr>
  <td>
    lookup
  </td>
  <td>
    Testing whether an element is contained in set, 
         or selecting a value associated with a key.
  </td>
</tr>
<tr>
  <td>
    add
  </td>
  <td>
    Adding a new element to a set or a new key/value pair to a map.
  </td>
</tr>
<tr>
  <td>
    remove
  </td>
  <td>
    Removing an element from a set or a key from a map.
  </td>
</tr>
<tr>
  <td>
    min
  </td>
  <td>
    The smallest element of the set, or the smallest key of a map.
  </td>
</tr>
</table>


<h3 id="sec-coll-arch-eq">24.13 Equality</h3>


<p>The collection libraries have a uniform approach to equality and
hashing. The idea is, first, to divide collections into sets, maps,
and sequences. Collections in different categories are always
unequal. For instance, <span class="code">Set(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span> is unequal to <span class="code">List(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span>
even though they contain the same elements.  On the other hand, within
the same category, collections are equal if and only if they have the
same elements (for sequences: the same elements in the same order). For
example, <span class="code">List(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">Vector(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span>, and 
<span class="code">HashSet(1,</span>&nbsp;<span class="code">2)</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">TreeSet(2,</span>&nbsp;<span class="code">1)</span>.</p>

<p>It does not matter for the equality check whether a collection is
mutable or immutable. For a mutable collection, equality simply
depends on the current elements at
the time the equality test is performed. This
means that a mutable collection might be equal to different
collections at different times, depending what elements are added or
removed. This is a potential trap when using a mutable collection as
a key in a hash map. For example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;collection.mutable.{<code class="typename">HashMap</code>,&nbsp;<code class="typename">ArrayBuffer</code>}
  <code class="output">import&nbsp;collection.mutable.{HashMap,&nbsp;ArrayBuffer}</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;<code class="typename">ArrayBuffer</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">buf:&nbsp;scala.collection.mutable.ArrayBuffer[Int]&nbsp;=&nbsp;</code>
  <code class="output">ArrayBuffer(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;map&nbsp;=&nbsp;<code class="typename">HashMap</code>(buf&nbsp;-&gt;&nbsp;<code class="literal">3</code>)
  <code class="output">map:&nbsp;scala.collection.mutable.HashMap[scala.collection.</code>
  <code class="output">mutable.ArrayBuffer[Int],Int]&nbsp;=&nbsp;Map((ArrayBuffer(1,&nbsp;2,&nbsp;3),3))</code>
</pre>


<pre>
  scala&gt;&nbsp;map(buf)
  <code class="output">res13:&nbsp;Int&nbsp;=&nbsp;3</code>
  <br />  scala&gt;&nbsp;buf(<code class="literal">0</code>)&nbsp;+=&nbsp;<code class="literal">1</code>
  <br />  scala&gt;&nbsp;map(buf)
  <code class="output">java.util.NoSuchElementException:&nbsp;key&nbsp;not&nbsp;found:&nbsp;</code>
  <code class="output">&nbsp;&nbsp;ArrayBuffer(2,&nbsp;2,&nbsp;3)&nbsp;</code>
</pre>


<p>In this example, the selection in the last line will most likely fail
because the hash code of the array <span class="code">xs</span> has changed in the
second-to-last line. Therefore, the hash-code-based lookup will look at
a different place than the one in which <span class="code">xs</span> was stored.</p>

<h3 id="sec-views">24.14 Views</h3>


<p>Collections have quite a few methods that construct new collections.<a id="i112204398-1"/><a id="i-1938971378-1"/>
Some examples are <span class="code">map</span>, <span class="code">filter</span>, and <span class="code">++</span>. We call such methods <span style="font-style:italic">transformers</span><a id="i-1856481670-1"/>
because they take at least one collection as their receiver object and produce 
another collection in their result.</p>

<p>Transformers can be implemented in two principal ways: strict and non-strict (or lazy). A strict transformer constructs a new collection with all of its elements. A non-strict, or lazy, transformer constructs only a proxy for the result collection, and its elements are constructed on demand.</p>

<p>As an example of a non-strict transformer, consider the following implementation
of a lazy map operation:</p>

<pre>
  <code class="vem">def</code>&nbsp;lazyMap[T,&nbsp;U](coll:&nbsp;<code class="typename">Iterable[T]</code>,&nbsp;f:&nbsp;T&nbsp;=&gt;&nbsp;U)&nbsp;=
  &nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Iterable[U]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;iterator&nbsp;=&nbsp;coll.iterator&nbsp;map&nbsp;f
  &nbsp;&nbsp;}
</pre>


<p>Note that <span class="code">lazyMap</span> constructs a new <span class="code">Iterable</span> without stepping through all 
elements of the given collection <span class="code">coll</span>. The given function <span class="code">f</span> is instead applied
to the elements of the new collection's <span class="code">iterator</span> as they are demanded.</p>

<p>Scala collections are by default strict in all their transformers,
except for <span class="code">Stream</span>, which implements all its transformer methods
lazily. However, there is a systematic way to turn every collection
into a lazy one and <span style="font-style:italic">vice versa</span>, which is based on collection
views. A <span style="font-style:italic">view</span> is a special kind of collection that represents
some base collection, but implements all of its transformers lazily.</p>

<p>To go from a collection to its view, you can use the <span class="code">view</span> method on
the collection. If <span class="code">xs</span> is some collection, then <span class="code">xs.view</span><a id="i-1406999493-2"/><a id="i-1473277169-2"/> is the
same collection, but with all transformers implemented lazily.  To get
back from a view to a strict collection, you can use the <span class="code">force</span> method.<a id="i1012198449-1"/></p>

<p>As an example, say you have a vector of <span class="code">Int</span>s over which you want to
map two functions in succession:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;v&nbsp;=&nbsp;<code class="typename">Vector</code>(<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">10</code>:&nbsp;_*)
  <code class="output">v:&nbsp;scala.collection.immutable.Vector[Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;Vector(1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9,&nbsp;10)</code>
  <br />  scala&gt;&nbsp;v&nbsp;map&nbsp;(_&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;map&nbsp;(_&nbsp;*&nbsp;<code class="literal">2</code>)
  <code class="output">res5:&nbsp;scala.collection.immutable.Vector[Int]&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;Vector(4,&nbsp;6,&nbsp;8,&nbsp;10,&nbsp;12,&nbsp;14,&nbsp;16,&nbsp;18,&nbsp;20,&nbsp;22)</code>
</pre>


<p>In the last statement, the expression <span class="code">v</span>&nbsp;<span class="code">map</span>&nbsp;<span class="code">(_</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1)</span> constructs a
new vector that is then transformed into a third vector by the second
call to <span class="code">map</span>&nbsp;<span class="code">(_</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">2)</span>. In many
situations, constructing the intermediate result from the first call to
<span class="code">map</span> is a bit wasteful.  In the pseudo example, it would be faster to do
a single <span class="code">map</span> with the composition of the two functions <span class="code">(_</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1)</span>
and <span class="code">(_</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">2)</span>. If you have the two functions available in the same
place you can do this by hand. But quite often, successive
transformations of a data structure are done in different program
modules. Fusing those transformations would then undermine modularity.
A more general way to avoid the intermediate results
is by turning the vector first into a view, applying all transformations to the view,
and finally forcing the view to a vector:</p>

<pre>
  scala&gt;&nbsp;(v.view&nbsp;map&nbsp;(_&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;map&nbsp;(_&nbsp;*&nbsp;<code class="literal">2</code>)).force
  <code class="output">res12:&nbsp;Seq[Int]&nbsp;=&nbsp;Vector(4,&nbsp;6,&nbsp;8,&nbsp;10,&nbsp;12,&nbsp;14,&nbsp;16,&nbsp;18,&nbsp;20,&nbsp;22)&nbsp;&nbsp;</code>
</pre>


<p>We'll do this sequence of operations again, one by one:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;vv&nbsp;=&nbsp;v.view
  <code class="output">vv:&nbsp;scala.collection.SeqView[Int,Vector[Int]]&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;SeqView(1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9,&nbsp;10)</code>
</pre>


<p>The application <span class="code">v.view</span> gives you a <span class="code">SeqView</span>, <i>i.e.</i>, a lazily evaluated <span class="code">Seq</span>.
The type <span class="code">SeqView</span> has two type parameters. The first, <span class="code">Int</span>, shows the type
of the view's elements. The second, <span class="code">Vector[Int]</span>, shows you the type constructor
you get back when forcing the view.</p>

<p>Applying the first <span class="code">map</span> to the view gives you:</p>

<pre>
  scala&gt;&nbsp;vv&nbsp;map&nbsp;(_&nbsp;+&nbsp;<code class="literal">1</code>)
  <code class="output">res13:&nbsp;scala.collection.SeqView[Int,Seq[_]]&nbsp;=&nbsp;SeqViewM(...)</code>
</pre>


<p>The result of the <span class="code">map</span> is a value that prints <span class="code">SeqViewM(...)</span>.
This is in essence a wrapper that records the fact that a <span class="code">map</span> with function
<span class="code">(_</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1)</span> needs to be applied on the vector <span class="code">v</span>. It does not apply that map
until the view is <span class="code">force</span>d, however. The "<span class="code">M</span>" after <span class="code">SeqView</span> is an indication
that the view encapsulates a <span class="code">map</span> operation. Other letters indicate other delayed operations. 
For instance "<span class="code">S</span>" indicates a delayed <span class="code">slice</span> operation, and "<span class="code">R</span>" indicates a <span class="code">reverse</span>.
We'll now apply the second <span class="code">map</span> to the last result.</p>

<pre>
  scala&gt;&nbsp;res13&nbsp;map&nbsp;(_&nbsp;*&nbsp;<code class="literal">2</code>)
  <code class="output">res14:&nbsp;scala.collection.SeqView[Int,Seq[_]]&nbsp;=&nbsp;SeqViewMM(...)</code>
</pre>


<p>You now get a <span class="code">SeqView</span> that contains two map operations, so it prints with a double "<span class="code">M</span>":
<span class="code">SeqViewMM(...)</span>. Finally, forcing the last result gives:</p>

<pre>
  scala&gt;&nbsp;res14.force
  <code class="output">res15:&nbsp;Seq[Int]&nbsp;=&nbsp;Vector(4,&nbsp;6,&nbsp;8,&nbsp;10,&nbsp;12,&nbsp;14,&nbsp;16,&nbsp;18,&nbsp;20,&nbsp;22)</code>
</pre>


<p>Both stored functions get applied as part of the execution of the <span class="code">force</span> operation and 
a new vector is constructed. That way, no intermediate data structure is needed.</p>

<p>One detail to note is that the static type of the final result is a
<span class="code">Seq</span>, not a <span class="code">Vector</span>. Tracing the types back we see that as soon as
the first delayed map was applied, the result had static type
<span class="code">SeqViewM[Int,</span>&nbsp;<span class="code">Seq[_]]</span>. That is, the "knowledge" that the view was
applied to the specific sequence type <span class="code">Vector</span> got lost. The implementation of a view
for any particular class requires quite a bit of code, so the Scala collection libraries provide views
mostly only for general collection types, not for specific
implementations.<a href="collections-in-depth.html#footnotemain24-6">[6]</a></p>

<p>There are two reasons why you might want to consider using views. The
first is performance. You have seen that by switching a collection to a 
view the construction of intermediate results can be avoided. 
These savings can be quite important. As another example, consider the problem
of finding the first palindrome in a list of words. A palindrome is a word that reads backwards
the same as forwards. Here are the necessary definitions:</p>

<pre>
  <code class="vem">def</code>&nbsp;isPalindrome(x:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;x&nbsp;==&nbsp;x.reverse
  <code class="vem">def</code>&nbsp;findPalindrome(s:&nbsp;<code class="typename">Seq[String]</code>)&nbsp;=&nbsp;s&nbsp;find&nbsp;isPalindrome
</pre>


<p>Now, assume you have a very long sequence <span class="code">words</span> 
and you want to find a palindrome in the first million words of that sequence. Can you re-use the definition of <span class="code">findPalindrome</span>?
Of course, you could write:</p>

<pre>
  findPalindrome(words&nbsp;take&nbsp;<code class="literal">1000000</code>)
</pre>


<p>This nicely separates the two aspects of taking the first million words of a sequence and finding
a palindrome in it. But the downside is that it always constructs an intermediary sequence 
consisting of one million words, even if the first word of that sequence is already a palindrome.
So potentially, 999,999 words are copied into the intermediary result without being 
inspected at all afterwards. Many programmers would give up here and write their own
specialized version of finding palindromes in some given prefix of an argument sequence.
But with views, you don't have to. Simply write:</p>

<pre>
  findPalindrome(words.view&nbsp;take&nbsp;<code class="literal">1000000</code>)
</pre>


<p>This has the same nice separation of concerns, but instead of a
sequence of a million elements it will only construct a single
lightweight view object. This way, you do not need to choose between
performance and modularity.</p>

<p>The second use case applies to views over mutable sequences.  Many
transformer functions on such views provide a window into the original
sequence that can then be used to update selectively some elements of that sequence.
To see this in an example, suppose you have an array <span class="code">arr</span>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;arr&nbsp;=&nbsp;(<code class="literal">0</code>&nbsp;to&nbsp;<code class="literal">9</code>).toArray
  <code class="output">arr:&nbsp;Array[Int]&nbsp;=&nbsp;Array(0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9)</code>
</pre>


<p>You can create a subwindow into that array by creating a slice of a view of the array:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;subarr&nbsp;=&nbsp;arr.view.slice(<code class="literal">3</code>,&nbsp;<code class="literal">6</code>)
  <code class="output">subarr:&nbsp;scala.collection.mutable.IndexedSeqView[</code>
  <code class="output">&nbsp;&nbsp;Int,Array[Int]]&nbsp;=&nbsp;IndexedSeqViewS(...)</code>
</pre>


<p>This gives a view, <span class="code">subarr</span>, which refers to the elements at positions 3 through 5 of
the array <span class="code">arr</span>. The view does not copy these elements,  it just provides a reference to them.
Now, assume you have a method that modifies some elements of a sequence. For instance,
the following <span class="code">negate</span> method would negate all elements of the sequence of integers it's given:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;negate(xs:&nbsp;<code class="typename">collection.mutable.Seq[Int]</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;xs.length)&nbsp;xs(i)&nbsp;=&nbsp;-xs(i)
  <code class="output">negate:&nbsp;(xs:&nbsp;scala.collection.mutable.Seq[Int])Unit</code>
</pre>


<p>Assume now you want to negate elements at positions three through five of the array <span class="code">arr</span>.
Can you use <span class="code">negate</span> for this? Using a view, this is simple:</p>

<pre>
  scala&gt;&nbsp;negate(subarr)
  <br />  scala&gt;&nbsp;arr
  <code class="output">res4:&nbsp;Array[Int]&nbsp;=&nbsp;Array(0,&nbsp;1,&nbsp;2,&nbsp;-3,&nbsp;-4,&nbsp;-5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9)</code>
</pre>


<p>What happened here is that <span class="code">negate</span> changed all elements of <span class="code">subarr</span>, which
were a slice of the elements of <span class="code">arr</span>. Again, you see that views help in keeping things modular.
The code above nicely separated the question of what index range to apply a method to
from the question what method to apply.</p>

<p>After having seen all these nifty uses of views you might wonder why
have strict collections at all? One reason is that performance
comparisons do not always favor lazy over strict collections. For
smaller collection sizes the added overhead of forming and applying
closures in views is often greater than the gain from avoiding the
intermediary data structures. A possibly more important reason is that
evaluation in views can be very confusing if the delayed
operations have side effects.</p>

<p>Here's an example that bit a few users of versions of Scala before 2.8.
In these versions the <span class="code">Range</span> type was lazy, so it behaved in effect like a view.
People were trying to create a number of actors<a href="collections-in-depth.html#footnotemain24-7">[7]</a>
like this:</p>

<pre>
  <code class="vem">val</code>&nbsp;actors&nbsp;=&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">10</code>)&nbsp;<code class="vem">yield</code>&nbsp;actor&nbsp;{&nbsp;...&nbsp;}
</pre>


<p>They were surprised that none of the actors were executing afterwards, even though the 
<span class="code">actor</span> method should create and start an actor from the code that's enclosed in the braces following it.
To explain why nothing happened, remember that the <span class="code">for</span> expression above is equivalent to an application of the <span class="code">map</span> method:</p>

<pre>
  <code class="vem">val</code>&nbsp;actors&nbsp;=&nbsp;(<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">10</code>)&nbsp;map&nbsp;(i&nbsp;=&gt;&nbsp;actor&nbsp;{&nbsp;...&nbsp;})
</pre>


<p>Since previously the range produced by <span class="code">(1</span>&nbsp;<span class="code">to</span>&nbsp;<span class="code">10)</span> behaved like a view, the result of the <span class="code">map</span>
was again a view. That is, no element was computed, and, consequently, no actor was created!
Actors would have been created by forcing the range of the whole expression, but it's far from
obvious that this is what was required to make the actors do their work.</p>

<p>To avoid surprises like this, the Scala collections gained more regular
rules in version 2.8. All collections except streams and views are
strict. The only way to go from a strict to a lazy collection is via the
<span class="code">view</span> method. The only way to go back is via <span class="code">force</span>.
So the <span class="code">actors</span> definition above would behave as expected in Scala 2.8 in that
it would create and start ten actors. To get back the surprising previous behavior, 
you'd have to add an explicit <span class="code">view</span> method call:</p>

<pre>
  <code class="vem">val</code>&nbsp;actors&nbsp;=&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;(<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">10</code>).view)&nbsp;<code class="vem">yield</code>&nbsp;actor&nbsp;{&nbsp;...&nbsp;}
</pre>


<p>In summary, views are a powerful tool to reconcile concerns of
efficiency with concerns of modularity. But in order not to be
entangled in aspects of delayed evaluation, you should restrict views
to two scenarios. Either you apply views in purely functional code
where collection transformations do not have side effects. Or you
apply them over mutable collections where all modifications are done
explicitly.  What's best avoided is a mixture of views and operations
that create new collections while also having side effects.</p>

<h3>24.15 Iterators</h3>


<p>An iterator is not a collection, but rather a way to access the
elements of a collection one by one. The two basic operations on an
iterator <span class="code">it</span> are <span class="code">next</span> and <span class="code">hasNext</span>. A call to <span class="code">it.next()</span> will
return the next element of the iterator and advance the state of the
iterator. Calling <span class="code">next</span> again on the same iterator will then yield
the element one beyond the one returned previously. If there are no
more elements to return, a call to <span class="code">next</span> will throw a
<span class="code">NoSuchElementException</span>. You can find out whether there are more
elements to return using <span class="code">Iterator</span>'s <span class="code">hasNext</span> method.</p>

<p>The most straightforward way to "step through" all the elements
returned by an iterator is to use a <span class="code">while</span> loop:</p>

<div style="page-break-after:always"/>


<pre>
  <code class="vem">while</code>&nbsp;(it.hasNext)&nbsp;
  &nbsp;&nbsp;println(it.next())
</pre>


<p>Iterators in Scala also provide analogues of most of the methods that
you find in the <span class="code">Traversable</span>, <span class="code">Iterable</span>, and <span class="code">Seq</span> traits. For instance, they provide a
<span class="code">foreach</span> method that executes a given procedure on each element returned by an iterator.
Using <span class="code">foreach</span>, the loop above could be abbreviated to:</p>

<pre>
  it&nbsp;foreach&nbsp;println
</pre>


<p>As always, <span class="code">for</span> expressions can be used as an alternate syntax for expressions involving
<span class="code">foreach</span>, <span class="code">map</span>, <span class="code">filter</span>, and <span class="code">flatMap</span>, so yet another way to print
all elements returned by an iterator would be:</p>

<pre>
  <code class="vem">for</code>&nbsp;(elem&nbsp;&lt;-&nbsp;it)&nbsp;println(elem)
</pre>


<p>There's an important difference between the <span class="code">foreach</span> method on
iterators and the same method on traversable collections: When called
on an iterator, <span class="code">foreach</span> will leave the iterator at its end when it
is done. So calling <span class="code">next</span> again on the same iterator will fail with
a <span class="code">NoSuchElementException</span>. By contrast, when called on a
collection, <span class="code">foreach</span> leaves the number of elements in the collection
unchanged (unless the passed function adds or removes elements, but
this is discouraged, because it can easily lead to surprising results).</p>

<p>The other operations that <span class="code">Iterator</span> has in common with
<span class="code">Traversable</span> have the same property of leaving the iterator at its end when done. For instance, iterators provide
a <span class="code">map</span> method, which returns a new iterator:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;it&nbsp;=&nbsp;<code class="typename">Iterator</code>(<code class="quotedstring">"a"</code>,&nbsp;<code class="quotedstring">"number"</code>,&nbsp;<code class="quotedstring">"of"</code>,&nbsp;<code class="quotedstring">"words"</code>)
  <code class="output">it:&nbsp;Iterator[java.lang.String]&nbsp;=&nbsp;non-empty&nbsp;iterator</code>
  <br />  scala&gt;&nbsp;it.map(_.length)
  <code class="output">res1:&nbsp;Iterator[Int]&nbsp;=&nbsp;non-empty&nbsp;iterator</code>
  <br />  scala&gt;&nbsp;res1&nbsp;foreach&nbsp;println
  <code class="output">1</code>
  <code class="output">6</code>
  <code class="output">2</code>
  <code class="output">5</code>
  <br />  scala&gt;&nbsp;it.next()
  <code class="output">java.util.NoSuchElementException:&nbsp;next&nbsp;on&nbsp;empty&nbsp;iterator</code>
</pre>


<p>As you can see, after the call to <span class="code">map</span>, the <span class="code">it</span> iterator has advanced to its end.</p>

<p>Another example is the <span class="code">dropWhile</span> method, which can be used to find the first element
of an iterator that has a certain property. For instance, to find the first 
word in the iterator shown previously that has at least two characters, you could write:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;it&nbsp;=&nbsp;<code class="typename">Iterator</code>(<code class="quotedstring">"a"</code>,&nbsp;<code class="quotedstring">"number"</code>,&nbsp;<code class="quotedstring">"of"</code>,&nbsp;<code class="quotedstring">"words"</code>)
  <code class="output">it:&nbsp;Iterator[java.lang.String]&nbsp;=&nbsp;non-empty&nbsp;iterator</code>
  <br />  scala&gt;&nbsp;it&nbsp;dropWhile&nbsp;(_.length&nbsp;&lt;&nbsp;<code class="literal">2</code>)
  <code class="output">res4:&nbsp;Iterator[java.lang.String]&nbsp;=&nbsp;non-empty&nbsp;iterator</code>
  <br />  scala&gt;&nbsp;it.next()
  <code class="output">res5:&nbsp;java.lang.String&nbsp;=&nbsp;number</code>
</pre>


<p>Note again that <span class="code">it</span> has changed by the call to <span class="code">dropWhile</span>: it now points to the 
second word "number" in the list. In fact, <span class="code">it</span> and the result <span class="code">res4</span> returned
by <span class="code">dropWhile</span> will return exactly the same sequence of elements.</p>

<p>There is only one standard operation, <span class="code">duplicate</span>, which allows you to re-use the same iterator:</p>

<pre>
  <code class="vem">val</code>&nbsp;(it1,&nbsp;it2)&nbsp;=&nbsp;it.duplicate
</pre>


<p>The call to duplicate gives you <span style="font-style:italic">two</span> iterators, which each return exactly the same elements as the iterator <span class="code">it</span>. The two iterators work independently; advancing one does not affect the other.
By contrast the original iterator, <span class="code">it</span>, is advanced to its end by <span class="code">duplicate</span> and is 
thus rendered unusable.</p>

<p>In summary, iterators behave like collections <span style="font-style:italic">if you never
  access an iterator again after invoking a method on it</span>. The Scala
  collection libraries make this explicit with an abstraction called
  <span class="code">TraversableOnce</span>, which is a common supertrait of <span class="code">Traversable</span> and
  <span class="code">Iterator</span>. As the name implies, <span class="code">TraversableOnce</span> objects can be
  traversed using <span class="code">foreach</span>, but the state of that object after the
  traversal is not specified. If the <span class="code">TraversableOnce</span> object is in fact an <span class="code">Iterator</span>,
  it will be at its end after the traversal, but if it is a <span class="code">Traversable</span>, it
  will still exist as before. A common use case of <span class="code">TraversableOnce</span> is as an argument
  type for methods that can take either an iterator or traversable as argument.
  An example is the appending method <span class="code">++</span> in trait <span class="code">Traversable</span>. 
  It takes a <span class="code">TraversableOnce</span> parameter, so you can append elements coming
  from either an iterator or a traversable collection.</p>

<p>All operations on iterators are summarized in <a href="collections-in-depth.html#tab-iteratorops">Table 24.12</a>.</p>

<p><a id="tab-iteratorops"/></p>

<h5>Operations in trait <span class="code">Iterator</span> <a id="i-1527861747-1"/></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Abstract methods:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.next()</span>
  </td>
  <td>
    Returns the next element in the iterator and advances past <span class="code">it</span>.<a id="i569433333-1"/><a id="i314774649-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.hasNext</span>
  </td>
  <td>
    Returns <span class="code">true</span> if <span class="code">it</span> can return another element.<a id="i-2058143621-1"/><a id="i387741031-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Variations:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.buffered</span>
  </td>
  <td>
    A buffered iterator returning all elements of <span class="code">it</span>.<a id="i-1907025783-1"/><a id="i1783293797-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">grouped</span>&nbsp;<span class="code">size</span>
  </td>
  <td>
    An iterator that yields the elements returned by <span class="code">it</span>
                   in fixed-sized sequence "chunks."<a id="i-1552726294-1"/><a id="i-15589352-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">xs</span>&nbsp;<span class="code">sliding</span>&nbsp;<span class="code">size</span>
  </td>
  <td>
    An iterator that yields the elements returned by <span class="code">it</span>
                   in sequences representing a sliding fixed-sized window.<a id="i966114842-1"/><a id="i1866691304-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Copying:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">copyToBuffer</span>&nbsp;<span class="code">buf</span>
  </td>
  <td>
    Copies all elements returned by <span class="code">it</span> to buffer <span class="code">buf</span>.<a id="i1918312792-1"/><a id="i1226176694-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">copyToArray(arr,</span>&nbsp;<span class="code">s,</span>&nbsp;<span class="code">l)</span>
  </td>
  <td>
    Copies at most <span class="code">l</span> elements returned by <span class="code">it</span> to array
                    <span class="code">arr</span> starting at index <span class="code">s</span>. The last two
                    arguments are optional.<a id="i172626160-1"/><a id="i869836579-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Duplication:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.duplicate</span>
  </td>
  <td>
    A pair of iterators that each independently return all elements
                   of <span class="code">it</span>.<a id="i-1453185571-1"/><a id="i587712325-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Additions:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">++</span>&nbsp;<span class="code">jt</span>
  </td>
  <td>
    An iterator returning all elements returned by iterator <span class="code">it</span>,
                   followed by all elements returned by iterator <span class="code">jt</span>.<a id="i-387881431-1"/><a id="i-456055993-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">padTo</span>&nbsp;<span class="code">(len,</span>&nbsp;<span class="code">x)</span>
  </td>
  <td>
    The iterator that returns all elements of <span class="code">it</span> 
                  followed by copies of <span class="code">x</span>
                  until length <span class="code">len</span> elements are returned overall.<a id="i1257723354-1"/><a id="i1169787304-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Maps:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">map</span>&nbsp;<span class="code">f</span>
  </td>
  <td>
    The iterator obtained from applying the function <span class="code">f</span> to every
                   element returned from <span class="code">it</span>.<a id="i-1166599508-1"/><a id="i1949815574-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">flatMap</span>&nbsp;<span class="code">f</span>
  </td>
  <td>
    The iterator obtained from applying the
                   iterator-valued function <span class="code">f</span> to every element in <span class="code">it</span> and
                   appending the results.<a id="i1343836714-1"/><a id="i-1087860771-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">collect</span>&nbsp;<span class="code">f</span>
  </td>
  <td>
    The iterator obtained from applying the partial function <span class="code">f</span> to every
                   element in <span class="code">it</span> for which it is defined and
                   collecting the results.<a id="i538616478-1"/><a id="i640426468-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Conversions:<!-- \hfill -->  </span>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.toArray</span>
  </td>
  <td>
    Collects the elements returned by <span class="code">it</span> in an array.<a id="i-681097814-1"/><a id="i-1491400360-1"/><a id="i595962916-4"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.toList</span>
  </td>
  <td>
    Collects the elements returned by <span class="code">it</span> in a list.<a id="i240940271-1"/><a id="i2030419391-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.toIterable</span>
  </td>
  <td>
    Collects the elements returned by <span class="code">it</span> in an iterable.<a id="i-1426035429-1"/><a id="i-690923245-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.toSeq</span>
  </td>
  <td>
    Collects the elements returned by <span class="code">it</span> in a sequence.<a id="i1681639716-1"/><a id="i1173882654-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.toIndexedSeq</span>
  </td>
  <td>
    Collects the elements returned by <span class="code">it</span> in an indexed sequence.<a id="i721790495-1"/><a id="i-31950321-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.toStream</span>
  </td>
  <td>
    Collects the elements returned by <span class="code">it</span> in a stream.<a id="i-1134937331-1"/><a id="i1528404065-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.toSet</span>
  </td>
  <td>
    Collects the elements returned by <span class="code">it</span> in a set.<a id="i1774699137-1"/><a id="i1173882657-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.toMap</span>
  </td>
  <td>
    Collects the key/value pairs returned by <span class="code">it</span> in a map.<a id="i-667416889-1"/><a id="i1173876763-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Size info:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.isEmpty</span>
  </td>
  <td>
    Tests whether the iterator is empty (opposite of <span class="code">hasNext</span>).<a id="i-461566043-1"/><a id="i1749021437-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.nonEmpty</span>
  </td>
  <td>
    Tests whether the collection contains elements (alias of <span class="code">hasNext</span>).<a id="i-1077580280-1"/><a id="i390920454-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.size</span>
  </td>
  <td>
    The number of elements returned by <span class="code">it</span>. Note: <span class="code">it</span> will
                   be at its end after this operation!<a id="i178959271-1"/><a id="i314927495-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.length</span>
  </td>
  <td>
    Same as <span class="code">it.size</span>.<a id="i510850146-1"/><a id="i1793161964-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.hasDefiniteSize</span>
  </td>
  <td>
    Returns true if <span class="code">it</span> is known to return finitely many elements
                   (by default the same as <span class="code">isEmpty</span>).<a id="i-195904867-1"/><a id="i1898792709-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Element retrieval index search:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">find</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    An option containing the first element returned by <span class="code">it</span>
                    that satisfies <span class="code">p</span>, or <span class="code">None</span> if no element
                    qualifies. Note: The iterator advances to just after the
                    element, or, if none is found, to the end.<a id="i1544372032-1"/><a id="i314539839-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">indexOf</span>&nbsp;<span class="code">x</span>
  </td>
  <td>
    The index of the first element returned by <span class="code">it</span> that equals <span class="code">x</span>. Note:
                  The iterator advances past the position of this element.<a id="i1628073567-1"/><a id="i1634273027-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">indexWhere</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    The index of the first element returned by <span class="code">it</span> that satisfies <span class="code">p</span>. Note:
                  The iterator advances past the position of this element.<a id="i337051379-1"/><a id="i-1113971653-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Subiterators:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">take</span>&nbsp;<span class="code">n</span>
  </td>
  <td>
    An iterator returning of the first <span class="code">n</span>
                     elements of <span class="code">it</span>. Note: <span class="code">it</span> will advance to the position
                     after the <span class="code">n</span>'th element, or to its end, if it contains
                     less than <span class="code">n</span> elements.<a id="i1767548558-1"/><a id="i314949133-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">drop</span>&nbsp;<span class="code">n</span>
  </td>
  <td>
    The iterator that starts with the <span class="code">(n</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1)</span>'th element of <span class="code">it</span>.
                     Note: <span class="code">it</span> will advance to the same position.<a id="i-1271894919-1"/><a id="i314488949-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">slice</span>&nbsp;<span class="code">(m,</span>&nbsp;<span class="code">n)</span>
  </td>
  <td>
    The iterator that returns a slice of the elements returned
                     from <span class="code">it</span>, starting with the <span class="code">m</span>'th element and ending
                     before the <span class="code">n</span>'th element.<a id="i281283382-1"/><a id="i1172890828-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">takeWhile</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    An iterator returning elements from <span class="code">it</span> as long as 
                     condition <span class="code">p</span> is true.<a id="i-147054031-1"/><a id="i877321508-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">dropWhile</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    An iterator skipping elements from <span class="code">it</span> as long as 
                     condition <span class="code">p</span> is true, and returning the remainder.<a id="i1718350537-1"/><a id="i-1135205444-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">filter</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    An iterator returning all elements from <span class="code">it</span> that
                     satisfy the condition <span class="code">p</span>.<a id="i1114360848-1"/><a id="i1625033598-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">withFilter</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    Same as <span class="code">it</span>&nbsp;<span class="code">filter</span>&nbsp;<span class="code">p</span>. Needed so that iterators
                     can be used in <span class="code">for</span> expressions.<a id="i-545883542-1"/><a id="i-54851356-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">filterNot</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    An iterator returning all elements from <span class="code">it</span> that
                     do not satisfy the condition <span class="code">p</span>.<a id="i1252578477-1"/><a id="i-1495363979-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Subdivisions:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">partition</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    Splits <span class="code">it</span> into a pair of two iterators; 
                     one returning all elements from <span class="code">it</span> that satisfy the predicate <span class="code">p</span>, 
                     the other returning all elements from <span class="code">it</span> that do not.<a id="i-351940047-1"/><a id="i1881181476-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Element conditions:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">forall</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    A boolean indicating whether the predicate <span class="code">p</span> holds for
                    all elements returned by <span class="code">it</span>.<a id="i-453827760-1"/><a id="i1630735422-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">exists</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    A boolean indicating whether the predicate <span class="code">p</span> holds for
                    some element in <span class="code">it</span>.<a id="i679062444-1"/><a id="i1610167394-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">count</span>&nbsp;<span class="code">p</span>
  </td>
  <td>
    The number of elements in <span class="code">it</span> that satisfy the
                    predicate <span class="code">p</span>.<a id="i1575808601-1"/><a id="i1158215753-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Folds:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">(z</span>&nbsp;<span class="code">/:</span>&nbsp;<span class="code">it)(op)</span>
  </td>
  <td>
    Applies binary operation <span class="code">op</span> between successive
                    elements returned by <span class="code">it</span>, going left to right,
                    starting with <span class="code">z</span>.<a id="i-650090766-1"/><a id="i-752898660-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">(it</span>&nbsp;<span class="code">:\</span>&nbsp;<span class="code">z)(op)</span>
  </td>
  <td>
    Applies binary operation <span class="code">op</span> between successive
                    elements returned by <span class="code">it</span>, going right to left,
                    starting with <span class="code">z</span>.<a id="i-181117874-1"/><a id="i-1970120157-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.foldLeft(z)(op)</span>
  </td>
  <td>
    Same as <span class="code">(z</span>&nbsp;<span class="code">/:</span>&nbsp;<span class="code">it)(op)</span>.<a id="i2000454511-1"/><a id="i-696283602-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.foldRight(z)(op)</span>
  </td>
  <td>
    Same as <span class="code">(it</span>&nbsp;<span class="code">:\</span>&nbsp;<span class="code">z)(op)</span>.<a id="i-542198878-1"/><a id="i-104294187-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">reduceLeft</span>&nbsp;<span class="code">op</span>
  </td>
  <td>
    Applies binary operation <span class="code">op</span> between successive
                    elements returned by non-empty iterator <span class="code">it</span>, going left
                    to right.<a id="i-723508460-1"/><a id="i1225634707-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">reduceRight</span>&nbsp;<span class="code">op</span>
  </td>
  <td>
    Applies binary operation <span class="code">op</span> between successive
                    elements returned by non-empty iterator <span class="code">it</span>, going
                    right to left.<a id="i2104320242-1"/><a id="i-654368752-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Specific folds:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.sum</span>
  </td>
  <td>
    The sum of the numeric element values returned by iterator <span class="code">it</span>.<a id="i-735667043-1"/><a id="i1949821957-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.product</span>
  </td>
  <td>
    The product of the numeric element values returned by iterator <span class="code">it</span>.<a id="i232754809-1"/><a id="i-618492503-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.min</span>
  </td>
  <td>
    The minimum of the ordered element values returned by iterator <span class="code">it</span>.<a id="i-2125661578-1"/><a id="i1949815820-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.max</span>
  </td>
  <td>
    The maximum of the ordered element values returned by iterator <span class="code">it</span>.<a id="i-918441052-1"/><a id="i1949815582-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Zippers:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">zip</span>&nbsp;<span class="code">jt</span>
  </td>
  <td>
    An iterator of pairs of corresponding elements returned from iterators <span class="code">it</span> and <span class="code">jt</span>.<a id="i-1080229753-1"/><a id="i1949828315-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">zipAll</span>&nbsp;<span class="code">(jt,</span>&nbsp;<span class="code">x,</span>&nbsp;<span class="code">y)</span>
  </td>
  <td>
    An iterator of pairs of corresponding elements returned from iterators <span class="code">it</span> and <span class="code">jt</span>,
                  where the shorter iterator is extended to match the longer one
                  by appending elements <span class="code">x</span> or <span class="code">y</span>.<a id="i374738376-1"/><a id="i-2097280314-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it.zipWithIndex</span>
  </td>
  <td>
    An iterator of pairs of elements returned from <span class="code">it</span> with their indicies.<a id="i-886001315-1"/><a id="i-1744800495-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Update:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">patch</span>&nbsp;<span class="code">(i,</span>&nbsp;<span class="code">jt,</span>&nbsp;<span class="code">r)</span>
  </td>
  <td>
    The iterator resulting from <span class="code">it</span> by replacing <span class="code">r</span> elements
                  starting with <span class="code">i</span> by the patch iterator <span class="code">jt</span>.<a id="i-1495891648-1"/><a id="i1169803138-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Comparison:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">sameElements</span>&nbsp;<span class="code">jt</span>
  </td>
  <td>
    A test whether iterators <span class="code">it</span> and <span class="code">jt</span> return the same
                    elements in the same order. Note: At least one of <span class="code">it</span> and <span class="code">jt</span> will
                    be at its end after this operation.<a id="i-278620245-1"/><a id="i-1277312253-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Strings:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">addString</span> (b, start,
  </td>
</tr>
<tr>
  <td>
    <span class="code">sep,</span>&nbsp;<span class="code">end)</span>
  </td>
  <td>
    Adds a string to <span class="code">StringBuilder</span> <span class="code">b</span> that shows all elements returned by <span class="code">it</span>
                      between separators <span class="code">sep</span> enclosed in strings
                      <span class="code">start</span> and <span class="code">end</span>. <span class="code">start</span>,<span class="code">sep</span>, and <span class="code">end</span> are
                      all optional.<a id="i2043006297-1"/><a id="i-613121460-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">it</span>&nbsp;<span class="code">mkString</span> (start,
  </td>
</tr>
<tr>
  <td>
    <span class="code">sep,</span>&nbsp;<span class="code">end)</span>
  </td>
  <td>
    Converts the iterator to a string that shows all elements returned by <span class="code">it</span>
                      between separators <span class="code">sep</span> enclosed in strings
                      <span class="code">start</span> and <span class="code">end</span>. <span class="code">start</span>,<span class="code">sep</span>, and <span class="code">end</span> are
                      all optional.<a id="i-872604647-1"/><a id="i-1336376875-1"/>
  </td>
</tr>
</table>


<h4>Buffered iterators</h4>


<p>Sometimes you want an iterator that can "look ahead" so that you
can inspect the next element to be returned without advancing past
that element. Consider, for instance, the task to skip leading empty
strings from an iterator that returns a sequence of strings. You might 
be tempted to write something like the following method:</p>

<pre>
  <code class="comment">//&nbsp;This&nbsp;won't&nbsp;work</code>
  <code class="vem">def</code>&nbsp;skipEmptyWordsNOT(it:&nbsp;<code class="typename">Iterator[String]</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">while</code>&nbsp;(it.next().isEmpty)&nbsp;{}
  }
</pre>


<p>But looking at this code more closely, it's clear that this is wrong: the code
will indeed skip leading empty strings, but it will also advance <span class="code">it</span> past the 
first non-empty string!</p>

<p>The solution to this problem is to use a buffered
iterator, an instance of trait <span class="code">BufferedIterator</span>. <span class="code">BufferedIterator</span> is a subtrait of <span class="code">Iterator</span>, which
provides one extra method, <span class="code">head</span>. Calling <span class="code">head</span> on a buffered
iterator will return its first element, but will not advance the
iterator. Using a buffered iterator, skipping empty words can be written like this:</p>

<pre>
  <code class="vem">def</code>&nbsp;skipEmptyWords(it:&nbsp;<code class="typename">BufferedIterator[String]</code>)&nbsp;=
  &nbsp;&nbsp;<code class="vem">while</code>&nbsp;(it.head.isEmpty)&nbsp;{&nbsp;it.next()&nbsp;}
</pre>


<p>Every iterator can be converted to a buffered iterator by calling its <span class="code">buffered</span> method.
Here's an example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;it&nbsp;=&nbsp;<code class="typename">Iterator</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">4</code>)
  <code class="output">it:&nbsp;Iterator[Int]&nbsp;=&nbsp;non-empty&nbsp;iterator</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bit&nbsp;=&nbsp;it.buffered
  <code class="output">bit:&nbsp;java.lang.Object&nbsp;with&nbsp;scala.collection.</code>
  <code class="output">&nbsp;&nbsp;BufferedIterator[Int]&nbsp;=&nbsp;non-empty&nbsp;iterator</code>
  <br />  scala&gt;&nbsp;bit.head
  <code class="output">res10:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br />  scala&gt;&nbsp;bit.next()
  <code class="output">res11:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br />  scala&gt;&nbsp;bit.next()
  <code class="output">res11:&nbsp;Int&nbsp;=&nbsp;2</code>
</pre>


<p>Note that calling <span class="code">head</span> on the buffered iterator, <span class="code">bit</span>, did not advance it. 
Therefore, the subsequent call, <span class="code">bit.next()</span>, returned again the same value as <span class="code">bit.head</span>.</p>

<h3>24.16 Creating collections from scratch</h3>


<p>You have already seen syntax like <span class="code">List(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span>, which creates a list of three integers,
and <span class="code">Map('A'</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">1,</span>&nbsp;<span class="code">'C'</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">2)</span>, which creates a map with two bindings. This
is actually a universal feature of Scala collections. You can take any
collection name and follow it by a list of elements in
parentheses. The result will be a new collection with the given
elements. Here are some more examples:</p>

<pre>
  <code class="typename">Traversable</code>()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;An&nbsp;empty&nbsp;traversable&nbsp;object</code>
  <code class="typename">List</code>()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;The&nbsp;empty&nbsp;list</code>
  <code class="typename">List</code>(<code class="literal">1.0</code>,&nbsp;<code class="literal">2.0</code>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;A&nbsp;list&nbsp;with&nbsp;elements&nbsp;1.0,&nbsp;2.0</code>
  <code class="typename">Vector</code>(<code class="literal">1.0</code>,&nbsp;<code class="literal">2.0</code>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;A&nbsp;vector&nbsp;with&nbsp;elements&nbsp;1.0,&nbsp;2.0</code>
  <code class="typename">Iterator</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;An&nbsp;iterator&nbsp;returning&nbsp;three&nbsp;integers.</code>
  <code class="typename">Set</code>(dog,&nbsp;cat,&nbsp;bird)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;A&nbsp;set&nbsp;of&nbsp;three&nbsp;animals</code>
  <code class="typename">HashSet</code>(dog,&nbsp;cat,&nbsp;bird)&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;A&nbsp;hash&nbsp;set&nbsp;of&nbsp;the&nbsp;same&nbsp;animals</code>
  <code class="typename">Map</code>(<code class="quotedstring">'a'</code>&nbsp;-&gt;&nbsp;<code class="literal">7</code>,&nbsp;<code class="quotedstring">'b'</code>&nbsp;-&gt;&nbsp;<code class="literal">0</code>)&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;A&nbsp;map&nbsp;from&nbsp;characters&nbsp;to&nbsp;integers</code>
</pre>


<p>"Under the covers" each of the above lines 
is a call to the <span class="code">apply</span> method of some object. 
For instance, the third line above expands to:</p>

<pre>
  List.apply(<code class="literal">1.0</code>,&nbsp;<code class="literal">2.0</code>)
</pre>


<p>So this is a call to the <span class="code">apply</span> method of the companion object of
the <span class="code">List</span> class. That method takes an arbitrary number of arguments
and constructs a list from them. Every collection class in the Scala
library has a companion object with such an <span class="code">apply</span> method. It does
not matter whether the collection class represents a concrete
implementation, like <span class="code">List</span>, <span class="code">Stream</span>, or <span class="code">Vector</span>, or
whether it is an trait such as <span class="code">Seq</span>, <span class="code">Set</span>, or
<span class="code">Traversable</span>. In the latter case, calling <span class="code">apply</span> will produce some
default implementation of the trait. Here are some examples:</p>

<pre>
  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res17:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;<code class="typename">Traversable</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res18:&nbsp;Traversable[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;<code class="typename">mutable.Traversable</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res19:&nbsp;scala.collection.mutable.Traversable[Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;ArrayBuffer(1,&nbsp;2,&nbsp;3)</code>
</pre>


<p>Besides <span class="code">apply</span>, every collection companion object also defines a
member <span class="code">empty</span>, which returns an empty collection. So instead of
<span class="code">List()</span> you could write <span class="code">List.empty</span>, instead of <span class="code">Map()</span>,
<span class="code">Map.empty</span>, and so on.</p>

<p>Descendants of <span class="code">Seq</span> traits also provide other factory operations
in their companion objects. These are summarized in
<a href="collections-in-depth.html#tab-seqfac">Table 24.13</a>. In short, there's:</p>

<ul>


<li><b></b> <span class="code">concat</span>, which concatenates an arbitrary number of traversables
together, 


</li>
<li><b></b> <span class="code">fill</span> and <span class="code">tabulate</span>, which generate single or 
multi-dimensional sequences of given dimensions initialized by some expression
or tabulating function,  


</li>
<li><b></b> <span class="code">range</span>, which generates integer sequences 
with some constant step length, and


</li>
<li><b></b> <span class="code">iterate</span>, which generates the sequence
resulting from repeated application of a function to a start element. 


</li></ul>


<p><a id="tab-seqfac"/></p>

<h5>Factory methods for sequences <a id="i-36026129-1"/></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span class="code">S.empty</span>
  </td>
  <td>
    The empty sequence<a id="i-1584968040-1"/><a id="i-117561730-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">S(x,</span>&nbsp;<span class="code">y,</span>&nbsp;<span class="code">z)</span>
  </td>
  <td>
    A sequence consisting of elements <span class="code">x</span>, <span class="code">y</span>, and <span class="code">z</span><a id="i-507343367-1"/><a id="i-121166689-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">S.concat(xs,</span>&nbsp;<span class="code">ys,</span>&nbsp;<span class="code">zs)</span>
  </td>
  <td>
    The sequence obtained by concatenating the elements
                 of <span class="code">xs</span>, <span class="code">ys</span>, and <span class="code">zs</span><a id="i-396825960-1"/><a id="i595065859-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">S.fill(n)(e)</span>
  </td>
  <td>
    A sequence of length <span class="code">n</span> where each element is computed by
                 expression <span class="code">e</span><a id="i853270601-1"/><a id="i827517490-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">S.fill(m,</span>&nbsp;<span class="code">n)(e)</span>
  </td>
  <td>
    A sequence of sequences of dimension <span class="code">m</span>  <span style="font-family:sans-serif">x</span>  <span class="code">n</span> 
                 where each element is computed by expression <span class="code">e</span>
                 (exists also in higher dimensions)
  </td>
</tr>
<tr>
  <td>
    <span class="code">S.tabulate(n)(f)</span>
  </td>
  <td>
    A sequence of length <span class="code">n</span> where the element at each index 
                 <i>i</i> is computed by <span class="code">f(<i>i</i>)</span><a id="i-2126047930-1"/><a id="i323881813-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">S.tabulate(m,</span>&nbsp;<span class="code">n)(f)</span>
  </td>
  <td>
    A sequence of sequences of dimension <span class="code">m</span> <span style="font-family:sans-serif">x</span> <span class="code">n</span> 
                 where the element at each index 
                 (<i>i</i>, <i>j</i>) is computed by <span class="code">f(<i>i</i>,</span>&nbsp;<span class="code"><i>j</i>)</span>
                 (exists also in higher dimensions)
  </td>
</tr>
<tr>
  <td>
    <span class="code">S.range(start,</span>&nbsp;<span class="code">end)</span>
  </td>
  <td>
    The sequence of integers <span class="code">start</span> ... <span class="code">end</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">1</span><a id="i-736072056-1"/><a id="i-105915794-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">S.range(start,</span>&nbsp;<span class="code">end,</span>&nbsp;<span class="code">step)</span>
  </td>
  <td>
    The sequence of integers starting with <span class="code">start</span> and 
                 progressing by <span class="code">step</span> increments up to, and excluding, the 
                 <span class="code">end</span> value
  </td>
</tr>
<tr>
  <td>
    <span class="code">S.iterate(x,</span>&nbsp;<span class="code">n)(f)</span>
  </td>
  <td>
    The sequence of length <span class="code">n</span> with elements 
                 <span class="code">x</span>, <span class="code">f(x)</span>, <span class="code">f(f(x))</span>, ...<a id="i814580229-1"/><a id="i-1862459029-1"/>
  </td>
</tr>
</table>


<h3 id="sec-javaconversions">24.17 Conversions between Java and Scala collections</h3>


<p>Like Scala, Java has a rich collections library. There are many<a id="i-1787774928-1"/><a id="i884164092-1"/><a id="i1284266897-1"/>
similarities between the two. For instance, both libraries know
iterators, iterables, sets, maps, and sequences. But there are also
important differences. In particular, the Scala libraries put much
more emphasis on immutable collections, and provide many more
operations that transform a collection into a new one.</p>

<p>Sometimes you might need to convert from one collection framework to the
other. For instance, you might want to access to an existing Java
collection, as if it were a Scala collection. Or you might want to pass
one of Scala's collections to a Java method that expects the Java
counterpart. It is quite easy to do this, because Scala offers
implicit conversions between all the major collection types in the
<span class="code">JavaConversions</span> object.<a id="i-1559392124-1"/> In particular, you will find bidirectional
conversions between the following types:</p>

<pre>
  <code class="typename">Iterator</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hArr;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Iterator</code>
  <code class="typename">Iterator</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hArr;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Enumeration</code>
  <code class="typename">Iterable</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hArr;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.lang.Iterable</code>
  <code class="typename">Iterable</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hArr;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Collection</code>
  <code class="typename">mutable.Buffer</code>&nbsp;&nbsp;&nbsp;&hArr;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.List</code>
  <code class="typename">mutable.Set</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hArr;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Set</code>
  <code class="typename">mutable.Map</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hArr;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Map</code>
</pre>


<p>To enable these conversions, simply import like this:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;collection.JavaConversions._
  <code class="vem">import</code>&nbsp;collection.JavaConversions._
</pre>


<p>You have now automatic conversions between Scala collections and 
their corresponding Java collections.</p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;collection.mutable._
  <code class="output">import&nbsp;collection.mutable._</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;jul:&nbsp;<code class="typename">java.util.List[Int]</code>&nbsp;=&nbsp;<code class="typename">ArrayBuffer</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">jul:&nbsp;java.util.List[Int]&nbsp;=&nbsp;[1,&nbsp;2,&nbsp;3]</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf:&nbsp;<code class="typename">Seq[Int]</code>&nbsp;=&nbsp;jul
  <code class="output">buf:&nbsp;scala.collection.mutable.Seq[Int]&nbsp;=&nbsp;ArrayBuffer(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;m:&nbsp;<code class="typename">java.util.Map[String,&nbsp;Int]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">HashMap</code>(<code class="quotedstring">"abc"</code>&nbsp;-&gt;&nbsp;<code class="literal">1</code>,&nbsp;<code class="quotedstring">"hello"</code>&nbsp;-&gt;&nbsp;<code class="literal">2</code>)
  <code class="output">m:&nbsp;java.util.Map[String,Int]&nbsp;=&nbsp;{hello=2,&nbsp;abc=1}</code>
</pre>


<p>Internally, these conversion work by setting up a "wrapper" object
that forwards all operations to the underlying collection object. So
collections are never copied when converting between Java and Scala.
An interesting property is that if you do a round-trip conversion
from, say, a Java type to its corresponding Scala type, and back to the
same Java type, you end up with the identical collection object you
started with.</p>

<p>Some other common Scala collections exist that can also be converted
to Java types, but for which no corresponding conversion exists in the
other direction. These are:</p>

<div style="page-break-after:always"/>


<pre>
  <code class="typename">Seq</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.List</code>&nbsp;
  <code class="typename">mutable.Seq</code>&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.List</code>
  <code class="typename">Set</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Set</code>&nbsp;
  <code class="typename">Map</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Map</code>&nbsp;
</pre>


<p>Because Java does not distinguish between
mutable and immutable collections in their type, a conversion from, say,
<span class="code">collection.immutable.List</span> will yield a <span class="code">java.util.List</span>, on which all attempted mutation
operations will throw an <span class="code">UnsupportedOperationException</span>. Here's an example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;jul:&nbsp;<code class="typename">java.util.List[Int]</code>&nbsp;=&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">jul:&nbsp;java.util.List[Int]&nbsp;=&nbsp;[1,&nbsp;2,&nbsp;3]</code>
  <br />  scala&gt;&nbsp;jul.add(<code class="literal">7</code>)
  <code class="output">java.lang.UnsupportedOperationException</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;java.util.AbstractList.add(AbstractList.java:131)</code>
</pre>


<h3>24.18 Conclusion</h3>


<p>You've now seen how to use Scala's collection in great detail. Scala's
collections take the approach of giving you powerful building blocks
rather than a number of ad hoc utility methods. Putting together two
or three such building blocks allows you to express an enormous number
of useful computations. This style of library is especially effective
due to Scala having a light syntax for function literals, and due to
it providing many collection types that are persistent and immutable.</p>

<p>This chapter has shown collections from the point of view of a
programmer using the collection library. The next chapter will show
you how the collections are built and how you can add your own
collection types.</p>

<hr/>
<h4>Footnotes for Chapter 24:</h4>


<p><a id="footnotemain24-1"/>[1] Partial functions were described in <a href="case-classes-and-pattern-matching.html#sec-partial-functions">Section 15.7</a>.</p>

<p><a id="footnotemain24-2"/>[2] Hash tries are described in <a href="collections-in-depth.html#sec-hash-tries">Section 24.8</a>.</p>

<p><a id="footnotemain24-3"/>[3] "Trie" comes from the word "re<em>trie</em>val" and is pronounced <em>tree</em> or <em>try</em>.</p>

<p><a id="footnotemain24-4"/>[4] The "<span class="code">buf.type</span>" that appears in
the interpreter responses in this and several other examples in this section is a <em>singleton type</em>.<a id="i-108236764-1"/> As will be
explained in <a href="modular-programming-using-objects.html#sec-tracking-module-instances">Section 29.6</a>, <span class="code">buf.type</span>
means the variable holds exactly the object referred to by <span class="code">buf</span>.</p>

<p><a id="footnotemain24-5"/>[5] Assuming bits are densely packed.</p>

<p><a id="footnotemain24-6"/>[6] An exception to this is arrays: applying delayed operations
on arrays will again give results with static type <span class="code">Array</span>.</p>

<p><a id="footnotemain24-7"/>[7] The Scala actors library has been deprecated, but this historical example is still relevant.</p>

<div style="page-break-after:always"/>


<div style="page-break-after:always"/>

</body>
</html>
