<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8"/>
    <title>Programming in Scala, 3rd Edition</title>

    <link rel="stylesheet" type="text/css" href="book.css" />
  </head>
<body>
<h2><a id="chap-collections-in-depth">Chapter 24</a></h2>
<h1>Collections in Depth</h1>


<p>Scala includes an elegant and powerful collection library.
Even though the collections API is subtle at first glance,
the changes it can provoke in your programming style can be
profound.  Quite often it's as if you work on a higher level
with the basic building blocks of a program being whole collections
instead of their elements. This new style of programming requires some
adaptation. Fortunately, the adaptation is helped by several nice
properties of Scala collections. They are easy to use,
concise, safe, fast, and universal.
<a id="i1077226165-1"/></p>

<ul>


<li><b>Easy to use:</b> A small vocabulary of twenty to fifty methods is
enough to solve most collection problems in a couple of operations. No
need to wrap your head around complicated looping structures or
recursions. Persistent collections and side-effect-free operations mean
that you need not worry about accidentally corrupting existing
collections with new data.  Interference between iterators and
collection updates is eliminated.


</li>
<li><b>Concise:</b> You can achieve with a single word what used to
take one or several loops. You can express functional operations with
lightweight syntax and combine operations effortlessly, so that the result
feels like a custom algebra.  


</li>
<li><b>Safe:</b> This one has to be experienced to sink in. The
statically typed and functional nature of Scala's collections means
that the overwhelming majority of errors you might make are caught at
compile-time. The reason is that (1) the collection operations
themselves are heavily used and therefore well
tested. (2) the usages of the collection operation make inputs and
output explicit as function parameters and results. (3) These explicit
inputs and outputs are subject to static type checking. The bottom line
is that the large majority of misuses will manifest themselves as type
errors. It's not at all uncommon to have programs of several hundred
lines run at first try.


</li>
<li><b>Fast:</b> Collection operations are tuned and optimized in the
libraries. As a result, using collections is typically quite
efficient. You might be able to do a little bit better with carefully
hand-tuned data structures and operations, but you might also do a lot
worse by making some suboptimal implementation decisions along the
way.  What's more, collections are have been adapted to parallel<a id="i-1874383620-2"/><a id="i-1964267956-2"/>
execution on multi-cores. Parallel collections support the same
operations as sequential ones, so no new operations need to be learned
and no code needs to be rewritten. You can turn a sequential collection into a
parallel one simply by invoking the <pre class="code">par</pre> method.


</li>
<li><b>Universal:</b> Collections provide the same operations on
any type where it makes sense to do so. So you can achieve a lot with
a fairly small vocabulary of operations. For instance, a string is
conceptually a sequence of characters. Consequently, in Scala
collections, strings support all sequence operations. The same holds
for arrays.


</li></ul>


<p>This chapter describes in depth the APIs of the Scala collection
classes from a user perspective.
You've already seen a quick tour of the collections library, in
<a href="working-with-other-collections.html">Chapter 17</a>.
This chapter takes you on a more detailed tour, showing
all the collection classes and all the methods they define,
so it includes everything you need to know to use
Scala  collections.
Looking ahead, <a href="the-architecture-of-scala-collections.html">Chapter 25</a> will concentrate on the
architecture and extensibility aspects of the library, for people
implementing new collection types.</p>

<h3>24.1 Mutable and immutable collections</h3>


<p>As is now familiar to you,
Scala collections systematically distinguish between mutable and
immutable collections. A mutable collection can be updated or extended
in place. This means you can change, add, or remove elements of a
collection as a side effect. Immutable collections, by contrast, never
change. You still have operations that simulate additions, removals,
or updates, but those operations will in each case return a new
collection and leave the old collection unchanged.</p>

<p>All collection classes are found in the package <pre class="code">scala.collection</pre> or
one of its subpackages: <pre class="code">mutable</pre>, <pre class="code">immutable</pre>, and <pre class="code">generic</pre>.  Most
collection classes needed by client code exist in three variants, each 
of which has different characteristics with respect to mutability. The 
three variants are located in packages <pre class="code">scala.collection</pre>,
<pre class="code">scala.collection.immutable</pre>, and <pre class="code">scala.collection.mutable</pre>.</p>

<p>A collection in package <pre class="code">scala.collection.immutable</pre> is guaranteed to
be immutable for everyone. Such a collection will never change after
it is created.  Therefore, you can rely on the fact that accessing the
same collection value repeatedly at different points in time will
always yield a collection with the same elements.</p>

<p>A collection in package <pre class="code">scala.collection.mutable</pre> is known to have
some operations that change the collection in place. These operations
let you write code to mutate the collection yourself. However, you must be careful
to understand and defend against any updates performed by other parts of
the code base.</p>

<p>A collection in package <pre class="code">scala.collection</pre> can be either mutable or
immutable. For instance, <pre class="code">scala.collection.IndexedSeq[T]</pre> is a supertrait of
both <pre class="code">scala.collection.immutable.IndexedSeq[T]</pre> and its mutable sibling
<pre class="code">scala.collection.mutable.IndexedSeq[T]</pre>. Generally, the root collections in
package <pre class="code">scala.collection</pre> define the same interface as the immutable
collections. And typically, the mutable collections in package
<pre class="code">scala.collection.mutable</pre> add some side-effecting
modification operations to this immutable interface.</p>

<p>The difference between root collections and immutable collections is
that clients of an immutable collection have a guarantee that nobody
can mutate the collection, whereas clients of a root collection only
know that they can't change the collection themselves.
Even though the static
type of such a collection provides no operations for modifying the
collection, it might still be possible that the run-time type is a
mutable collection that can be changed by other clients.</p>

<p>By default, Scala always picks immutable collections. For instance, if
you just write <pre class="code">Set</pre> without any prefix or without having imported
anything, you get an immutable set, and if you write <pre class="code">Iterable</pre> you
get an immutable iterable,
because these are the default bindings
imported from the <pre class="code">scala</pre> package. To get the mutable default
versions, you need to write explicitly <pre class="code">collection.mutable.Set</pre>, or
<pre class="code">collection.mutable.Iterable</pre>.</p>

<p>The last package in the collection hierarchy is <pre class="code">collection.generic</pre>. This
package contains building blocks for implementing
collections. Typically, collection classes defer the implementations
of some of their operations to classes in <pre class="code">generic</pre>. Everyday users of the
collection framework on the other hand should need to refer to
classes in <pre class="code">generic</pre> only in exceptional circumstances.</p>

<p><a id="fig-coll-hierarchy"/></p>

<pre>
  Traversable
      Iterable
          Seq
              IndexedSeq
                  Vector
                  ResizableArray
                  GenericArray
              LinearSeq
                  MutableList
                  List
                  Stream
              Buffer
                  ListBuffer
                  ArrayBuffer
          Set
              SortedSet
                  TreeSet
              HashSet (mutable)
              LinkedHashSet
              HashSet (immutable)
              BitSet
              EmptySet, Set1, Set2, Set3, Set4
          Map
              SortedMap
                  TreeMap
              HashMap (mutable)
              LinkedHashMap (mutable)
              HashMap (immutable)
              EmptyMap, Map1, Map2, Map3, Map4
</pre>


<h5>Collection hierarchy.</h5>


<h3>24.2 Collections consistency</h3>


<p>The most important collection classes are shown in
<a href="collections-in-depth.html#fig-coll-hierarchy">Figure 24.1</a>.  There is quite a bit of commonality
shared by all these classes. For instance, every kind of collection can be created by the same
uniform syntax, writing the collection class name followed by its elements:</p>

<pre>
  <code class="typename">Traversable</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="typename">Iterable</code>(<code class="quotedstring">"x"</code>,&nbsp;<code class="quotedstring">"y"</code>,&nbsp;<code class="quotedstring">"z"</code>)
  <code class="typename">Map</code>(<code class="quotedstring">"x"</code>&nbsp;-&gt;&nbsp;<code class="literal">24</code>,&nbsp;<code class="quotedstring">"y"</code>&nbsp;-&gt;&nbsp;<code class="literal">25</code>,&nbsp;<code class="quotedstring">"z"</code>&nbsp;-&gt;&nbsp;<code class="literal">26</code>)
  <code class="typename">Set</code>(<code class="typename">Color.Red</code>,&nbsp;<code class="typename">Color.Green</code>,&nbsp;<code class="typename">Color.Blue</code>)
  <code class="typename">SortedSet</code>(<code class="quotedstring">"hello"</code>,&nbsp;<code class="quotedstring">"world"</code>)
  <code class="typename">Buffer</code>(x,&nbsp;y,&nbsp;z)
  <code class="typename">IndexedSeq</code>(<code class="literal">1.0</code>,&nbsp;<code class="literal">2.0</code>)
  <code class="typename">LinearSeq</code>(a,&nbsp;b,&nbsp;c)
</pre>


<p>The same principle also applies for specific collection implementations:</p>

<pre>
  <code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="typename">HashMap</code>(<code class="quotedstring">"x"</code>&nbsp;-&gt;&nbsp;<code class="literal">24</code>,&nbsp;<code class="quotedstring">"y"</code>&nbsp;-&gt;&nbsp;<code class="literal">25</code>,&nbsp;<code class="quotedstring">"z"</code>&nbsp;-&gt;&nbsp;<code class="literal">26</code>)
</pre>


<p>The <pre class="code">toString</pre> methods for all collections produce output written as above,
with a type name followed by the elements of the collection in parentheses.
All collections support the API provided by
<pre class="code">Traversable</pre>, but their methods all return their own class
rather than the root class <pre class="code">Traversable</pre>.
For instance, the <pre class="code">map</pre> method on <pre class="code">List</pre> has a return type of <pre class="code">List</pre>,
whereas the <pre class="code">map</pre> method on <pre class="code">Set</pre> has a return type of <pre class="code">Set</pre>.
Thus the static return type of these methods is fairly precise:</p>

<div style="page-break-after:always"/>


<pre>
  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;map&nbsp;(_&nbsp;+&nbsp;<code class="literal">1</code>)
  <code class="output">res0:&nbsp;List[Int]&nbsp;=&nbsp;List(2,&nbsp;3,&nbsp;4)</code>
  <br />  scala&gt;&nbsp;<code class="typename">Set</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;map&nbsp;(_&nbsp;*&nbsp;<code class="literal">2</code>)
  <code class="output">res1:&nbsp;scala.collection.immutable.Set[Int]&nbsp;=&nbsp;Set(2,&nbsp;4,&nbsp;6)</code>
</pre>


<p>Equality is also organized uniformly for all collection classes; more
on this in <a href="collections-in-depth.html#sec-coll-arch-eq">Section 24.13</a>.</p>

<p>Most of the classes in <a href="collections-in-depth.html#fig-coll-hierarchy">Figure 24.1</a> exist in three
variants: root, mutable, and immutable. The only exception is the
<pre class="code">Buffer</pre> trait, which only exists as a mutable collection.</p>

<p>In the remainder of this chapter, we will review these classes one by one.</p>

<h3>24.3 Trait <pre class="code">Traversable</pre></h3>


<p>At the top of the collection hierarchy is trait <pre class="code">Traversable</pre>. Its only
abstract operation is <pre class="code">foreach</pre>:</p>

<pre>
  <code class="vem">def</code>&nbsp;foreach[U](f:&nbsp;<code class="typename">Elem</code>&nbsp;=&gt;&nbsp;U)&nbsp;
</pre>


<p>Collection classes implementing <pre class="code">Traversable</pre> just need to define this method; all other
methods can be inherited from <pre class="code">Traversable</pre>.</p>

<p>The <pre class="code">foreach</pre> method is meant to traverse all elements of the collection, and
apply the given operation, <pre class="code">f</pre>, to each element. The type of the
operation is <pre class="code">Elem</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">U</pre>, where <pre class="code">Elem</pre> is the type of the
collection's elements and <pre class="code">U</pre> is an arbitrary result type.  The
invocation of <pre class="code">f</pre> is done for its side effect only; in fact any
function result of <pre class="code">f</pre> is discarded by <pre class="code">foreach</pre>.</p>

<p><pre class="code">Traversable</pre> also defines many concrete methods, which are all listed
in <a href="collections-in-depth.html#tab-traversableops">Table 24.1</a>  <a href="collections-in-depth.html#tab-traversableops">here</a>. These methods
fall into the following categories:</p>

<ul>


<li><b><span style="font-style:italic">Addition</span></b> <pre class="code">++</pre>, which appends two traversables
  together, or appends all elements of an iterator to a traversable.


</li>
<li><b><span style="font-style:italic">Map</span> <em>operations</em></b> <pre class="code">map</pre>, <pre class="code">flatMap</pre>, and <pre class="code">collect</pre>,
  which produce a new collection by applying some function to
  collection elements.


</li>
<li><b><span style="font-style:italic">Conversions</span></b> <pre class="code">toIndexedSeq</pre>, <pre class="code">toIterable</pre>, <pre class="code">toStream</pre>, <pre class="code">toArray</pre>, <pre class="code">toList</pre>, <pre class="code">toSeq</pre>,
  <pre class="code">toSet</pre>, and <pre class="code">toMap</pre>, which turn a
  <pre class="code">Traversable</pre> collection into a more specific collection. All these
  conversions return the receiver object if it
  already matches the demanded collection type. For instance, applying
  <pre class="code">toList</pre> to a list will yield the list itself.<a id="i595962916-2"/>


</li>
<li><b><span style="font-style:italic">Copying operations</span></b> <pre class="code">copyToBuffer</pre> and <pre class="code">copyToArray</pre>.
  As their names imply, these copy collection elements to a buffer or
   array, respectively.


</li>
<li><b><span style="font-style:italic">Size operations</span></b> <pre class="code">isEmpty</pre>, <pre class="code">nonEmpty</pre>, <pre class="code">size</pre>, and
  <pre class="code">hasDefiniteSize</pre>. Collections that are traversable can be finite or infinite. An example of an
  infinite traversable collection is the stream of natural numbers
  <pre class="code">Stream.from(0)</pre>. The method <pre class="code">hasDefiniteSize</pre> indicates whether a
  collection is possibly infinite. If <pre class="code">hasDefiniteSize</pre> returns true,
  the collection is certainly finite. If it returns false, the
  collection might be infinite, in which case <pre class="code">size</pre> will emit an
  error or not return.


</li>
<li><b><span style="font-style:italic">Element retrieval operations</span></b> <pre class="code">head</pre>, <pre class="code">last</pre>,
  <pre class="code">headOption</pre>, <pre class="code">lastOption</pre>, and <pre class="code">find</pre>. These select the first or
  last element of a collection, or else the first element matching a
  condition. Note, however, that not all collections have a
  well-defined meaning of what "first" and "last" means. For
  instance, a hash set might store elements according to their hash
  keys, which might change from run to run. In that case, the
  "first" element of a hash set could also be different for different runs of a program. A collection is <span style="font-style:italic">ordered</span> if it always yields
  its elements in the same order. Most collections are ordered, but
  some (such as hash sets) are not&mdash;dropping the ordering provides a
  little bit of extra efficiency. Ordering is often essential to
  give reproducible tests and help in debugging. That's why Scala
  collections provide ordered alternatives for all collection types. For
  instance, the ordered alternative for <pre class="code">HashSet</pre> is
  <pre class="code">LinkedHashSet</pre>.


</li>
<li><b><span style="font-style:italic">Subcollection retrieval</span> <em>operations</em></b> <pre class="code">takeWhile</pre>, <pre class="code">tail</pre>, <pre class="code">init</pre>,
  <pre class="code">slice</pre>, <pre class="code">take</pre>, <pre class="code">drop</pre>, <pre class="code">filter</pre>, <pre class="code">dropWhile</pre>, 
  <pre class="code">filterNot</pre>, and <pre class="code">withFilter</pre>. These all return some subcollection identified by an
  index range or a predicate.


</li>
<li><b><span style="font-style:italic">Subdivision</span> <em>operations</em></b> <pre class="code">splitAt</pre>, <pre class="code">span</pre>, <pre class="code">partition</pre>,
  and <pre class="code">groupBy</pre>, which split the elements of this collection into
  several subcollections.


</li>
<li><b><span style="font-style:italic">Element tests</span></b> <pre class="code">exists</pre>, <pre class="code">forall</pre>, and <pre class="code">count</pre>, which
  test collection elements with a given predicate.


</li>
<li><b><span style="font-style:italic">Folds</span></b> <pre class="code">foldLeft</pre>, <pre class="code">foldRight</pre>, <pre class="code">/:</pre>, <pre class="code">:\</pre>,
  <pre class="code">reduceLeft</pre>, <pre class="code">reduceRight</pre>, which apply a binary operation to
  successive elements.


</li>
<li><b><span style="font-style:italic">Specific folds</span></b> <pre class="code">sum</pre>, <pre class="code">product</pre>, <pre class="code">min</pre>, and <pre class="code">max</pre>, which
  work on collections of specific types (numeric or comparable).


</li>
<li><b><span style="font-style:italic">String operations</span></b> <pre class="code">mkString</pre>, <pre class="code">addString</pre>,
  and <pre class="code">stringPrefix</pre>, which provide alternative ways of converting
  a collection to a string.


</li>
<li><b><span style="font-style:italic">View operations</span></b> consisting of two overloaded variants of
  the <pre class="code">view</pre> method. A view is a collection that's evaluated
  lazily. You'll learn more about views in <a href="collections-in-depth.html#sec-views">Section 24.14</a>.


</li></ul>


<p><a id="tab-traversableops"/></p>

<h5>Operations in trait <pre class="code">Traversable</pre></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Abstract method:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">foreach</pre>&nbsp;<pre class="code">f</pre>
  </td>
  <td>
    Executes function <pre class="code">f</pre> for every element of
<pre class="code">xs</pre>.<a id="i-55657802-1"/><a id="i-1261160032-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Addition:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">++</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    A collection consisting of the elements of both
                   <pre class="code">xs</pre> and <pre class="code">ys</pre>. <pre class="code">ys</pre> is a <pre class="code">TraversableOnce</pre>
                   collection, <i>i.e.</i>, either a <pre class="code">Traversable</pre> or an
                   <pre class="code">Iterator</pre>.<a id="i-1450927830-1"/><a id="i422597625-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Maps:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">map</pre>&nbsp;<pre class="code">f</pre>
  </td>
  <td>
    The collection obtained from applying the function <pre class="code">f</pre> to every
                   element in <pre class="code">xs</pre>.<a id="i1930914020-1"/><a id="i1892128690-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">flatMap</pre>&nbsp;<pre class="code">f</pre>
  </td>
  <td>
    The collection obtained from applying the
                   collection-valued function <pre class="code">f</pre> to every element in <pre class="code">xs</pre> and
                   concatenating the results.<a id="i1974841698-1"/><a id="i-1362319751-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">collect</pre>&nbsp;<pre class="code">f</pre>
  </td>
  <td>
    The collection obtained from applying the partial function <pre class="code">f</pre> to every
                   element in <pre class="code">xs</pre> for which it is defined and
                   collecting the results.<a id="i-890132522-1"/><a id="i365967488-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Conversions:<!-- \hfill -->  </span>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.toArray</pre>
  </td>
  <td>
    Converts the collection to an array.<a id="i-170007326-1"/><a id="i-1765859340-1"/><a id="i595962916-3"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.toList</pre>
  </td>
  <td>
    Converts the collection to a list.<a id="i1148184999-1"/><a id="i1467376547-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.toIterable</pre>
  </td>
  <td>
    Converts the collection to an iterable.<a id="i-2134643757-1"/><a id="i519335159-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.toSeq</pre>
  </td>
  <td>
    Converts the collection to a sequence.<a id="i896539484-1"/><a id="i1571361978-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.toIndexedSeq</pre>
  </td>
  <td>
    Converts the collection to an indexed sequence.<a id="i-1715666217-1"/><a id="i-909761293-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.toStream</pre>
  </td>
  <td>
    Converts the collection to a stream (a lazily computed sequence).<a id="i-1816039227-1"/><a id="i1610110277-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.toSet</pre>
  </td>
  <td>
    Converts the collection to a set.<a id="i930487865-1"/><a id="i1571361981-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.toMap</pre>
  </td>
  <td>
    Converts a collection of key/value pairs to a map.<a id="i-1342255233-1"/><a id="i1571356087-1"/>
  </td>
</tr>
<tr>
  <td>


<span style="font-weight:bold">Copying:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">copyToBuffer</pre>&nbsp;<pre class="code">buf</pre>
  </td>
  <td>
    Copies all elements of the collection to buffer <pre class="code">buf</pre>.<a id="i-1728300656-1"/><a id="i348365722-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">copyToArray(arr,</pre>&nbsp;<pre class="code">s,</pre>&nbsp;<pre class="code">len)</pre>
  </td>
  <td>
    Copies at most <pre class="code">len</pre> elements of
                    <pre class="code">arr</pre>, starting at index <pre class="code">s</pre>. The last two
                    arguments are optional.<a id="i406691112-1"/><a id="i-266858561-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Size info:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.isEmpty</pre>
  </td>
  <td>
    Tests whether the collection is empty.<a id="i-1900529315-1"/><a id="i1474562457-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.nonEmpty</pre>
  </td>
  <td>
    Tests whether the collection contains elements.<a id="i-1206604224-1"/><a id="i472626666-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.size</pre>
  </td>
  <td>
    The number of elements in the collection.<a id="i-577762209-1"/><a id="i-1473365909-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.hasDefiniteSize</pre>
  </td>
  <td>
    True if <pre class="code">xs</pre> is known to have finite size.<a id="i357541973-1"/><a id="i-1206976095-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Element retrieval:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.head</pre>
  </td>
  <td>
    The first element of the collection (or, some
                     element, if no order is defined).<a id="i1226948320-1"/><a id="i-1473698230-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.headOption</pre>
  </td>
  <td>
    The first element of <pre class="code">xs</pre> in an option value, or
                     <pre class="code">None</pre> if <pre class="code">xs</pre> is empty.<a id="i-544762261-1"/><a id="i703675231-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.last</pre>
  </td>
  <td>
    The last element of the collection (or, some
                     element, if no order is defined).<a id="i-1561821718-1"/><a id="i-1473582336-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.lastOption</pre>
  </td>
  <td>
    The last element of <pre class="code">xs</pre> in an option value, or
                     <pre class="code">None</pre> if <pre class="code">xs</pre> is empty.<a id="i604071413-1"/><a id="i1178476437-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">find</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    An option containing the first element in <pre class="code">xs</pre>
                    that satisfies <pre class="code">p</pre>, or <pre class="code">None</pre> if no element
                    qualifies.<a id="i1562452856-1"/><a id="i-1473753565-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Subcollections:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.tail</pre>
  </td>
  <td>
    The rest of the collection except
                     <pre class="code">xs.head</pre>.<a id="i-1154929040-1"/><a id="i-1473344326-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.init</pre>
  </td>
  <td>
    The rest of the collection except
                     <pre class="code">xs.last</pre>.<a id="i1119663536-1"/><a id="i-1473659526-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">slice</pre>&nbsp;<pre class="code">(from,</pre>&nbsp;<pre class="code">to)</pre>
  </td>
  <td>
    A collection consisting of elements in some
                     index range of <pre class="code">xs</pre> (from <pre class="code">from</pre>, up to and excluding <pre class="code">to</pre>).<a id="i17106030-1"/><a id="i1570370152-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">take</pre>&nbsp;<pre class="code">n</pre>
  </td>
  <td>
    A collection consisting of the first <pre class="code">n</pre>
                     elements of <pre class="code">xs</pre> (or, some
                     arbitrary <pre class="code">n</pre> elements, if no order is
                     defined).<a id="i-1414646842-1"/><a id="i-1473344271-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">drop</pre>&nbsp;<pre class="code">n</pre>
  </td>
  <td>
    The rest of the collection except 
                     <pre class="code">xs</pre>&nbsp;<pre class="code">take</pre>&nbsp;<pre class="code">n</pre>.<a id="i1762200625-1"/><a id="i-1473804455-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">takeWhile</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    The longest prefix of elements in the collection
                     that all satisfy <pre class="code">p</pre>.<a id="i793978345-1"/><a id="i-884753216-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">dropWhile</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    The collection without the longest prefix
                     of elements that all satisfy <pre class="code">p</pre>.<a id="i-361174399-1"/><a id="i1397687128-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">filter</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    The collection consisting of those elements of
                   <pre class="code">xs</pre> that satisfy the predicate <pre class="code">p</pre>.<a id="i-1530083256-1"/><a id="i1061990754-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">withFilter</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    A non-strict filter of this collection. All operations
                    on the resulting filter will only apply to those elements
                    of <pre class="code">xs</pre> for which the condition <pre class="code">p</pre> is true.<a id="i1170520482-1"/><a id="i1155407048-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">filterNot</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    The collection consisting of those elements of
                   <pre class="code">xs</pre> that do not satisfy the predicate <pre class="code">p</pre>.<a id="i-1075168667-1"/><a id="i1037528593-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Subdivisions:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">splitAt</pre>&nbsp;<pre class="code">n</pre>
  </td>
  <td>
    Splits <pre class="code">xs</pre> at a position, 
                     giving the pair of collections <pre class="code">(xs</pre>&nbsp;<pre class="code">take</pre>&nbsp;<pre class="code">n,</pre>&nbsp;<pre class="code">xs</pre>&nbsp;<pre class="code">drop</pre>&nbsp;<pre class="code">n)</pre>.<a id="i-2145528916-1"/><a id="i1709677635-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">span</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    Splits <pre class="code">xs</pre> according to a predicate,
                     giving the pair of collections <pre class="code">(xs</pre>&nbsp;<pre class="code">takeWhile</pre>&nbsp;<pre class="code">p,</pre> <pre class="code">xs.dropWhile</pre>&nbsp;<pre class="code">p)</pre>.<a id="i743977545-1"/><a id="i-1473359948-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">partition</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    Splits <pre class="code">xs</pre> into a pair of collections; 
                     one with elements that satisfy the predicate <pre class="code">p</pre>, 
                     the other with elements that do not, giving the 
                     pair of collections <pre class="code">(xs</pre>&nbsp;<pre class="code">filter</pre>&nbsp;<pre class="code">p,</pre>&nbsp;<pre class="code">xs.filterNot</pre>&nbsp;<pre class="code">p)</pre>.<a id="i-960178711-1"/><a id="i119106752-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">groupBy</pre>&nbsp;<pre class="code">f</pre>
  </td>
  <td>
    Partitions <pre class="code">xs</pre> into a map of collections according
                    to a discriminator function <pre class="code">f</pre>.<a id="i534640970-1"/><a id="i-290049396-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Element conditions:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">forall</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    A boolean indicating whether the predicate <pre class="code">p</pre> holds for
                    all elements of <pre class="code">xs</pre>.<a id="i2035711880-1"/><a id="i1067692578-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">exists</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    A boolean indicating whether the predicate <pre class="code">p</pre> holds for
                    some element in <pre class="code">xs</pre>.<a id="i191461860-1"/><a id="i1047124550-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">count</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    The number of elements in <pre class="code">xs</pre> that satisfy the
                    predicate <pre class="code">p</pre>.<a id="i-84828655-1"/><a id="i1555695077-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Folds:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">(z</pre>&nbsp;<pre class="code">/:</pre>&nbsp;<pre class="code">xs)(op)</pre>
  </td>
  <td>
    Applies binary operation <pre class="code">op</pre> between successive
                    elements of <pre class="code">xs</pre>, going left to right, 
                    starting with <pre class="code">z</pre>.<a id="i943006250-1"/><a id="i1779314560-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">(xs</pre>&nbsp;<pre class="code">:\</pre>&nbsp;<pre class="code">z)(op)</pre>
  </td>
  <td>
    Applies binary operation <pre class="code">op</pre> between successive
                    elements of <pre class="code">xs</pre>, going right to left,
                    starting with <pre class="code">z</pre>.<a id="i-1539896954-1"/><a id="i16104711-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.foldLeft(z)(op)</pre>
  </td>
  <td>
    Same as <pre class="code">(z</pre>&nbsp;<pre class="code">/:</pre>&nbsp;<pre class="code">xs)(op)</pre>.<a id="i161789991-1"/><a id="i-614577390-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.foldRight(z)(op)</pre>
  </td>
  <td>
    Same as <pre class="code">(xs</pre>&nbsp;<pre class="code">:\</pre>&nbsp;<pre class="code">z)(op)</pre>.<a id="i-1873963302-1"/><a id="i-1866368911-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">reduceLeft</pre>&nbsp;<pre class="code">op</pre>
  </td>
  <td>
    Applies binary operation <pre class="code">op</pre> between successive
                    elements of non-empty collection <pre class="code">xs</pre>, going left
                    to right.<a id="i-1485439668-1"/><a id="i-1859074185-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">reduceRight</pre>&nbsp;<pre class="code">op</pre>
  </td>
  <td>
    Applies binary operation <pre class="code">op</pre> between successive
                    elements of non-empty collection <pre class="code">xs</pre>, going
                    right to left.<a id="i-1454040022-1"/><a id="i-1791063892-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Specific folds:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.sum</pre>
  </td>
  <td>
    The sum of the numeric element values of collection <pre class="code">xs</pre>.<a id="i1147308629-1"/><a id="i1892135073-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.product</pre>
  </td>
  <td>
    The product of the numeric element values of collection <pre class="code">xs</pre>.<a id="i844574257-1"/><a id="i-892951483-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.min</pre>
  </td>
  <td>
    The minimum of the ordered element values of collection <pre class="code">xs</pre>.<a id="i419713966-1"/><a id="i1892128936-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.max</pre>
  </td>
  <td>
    The maximum of the ordered element values of collection <pre class="code">xs</pre>.<a id="i2021443036-1"/><a id="i1892128698-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Strings:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">addString</pre>&nbsp;<pre class="code">(b,</pre>&nbsp;<pre class="code">start,</pre>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">sep,</pre>&nbsp;<pre class="code">end)</pre>
  </td>
  <td>
    Adds a string to <pre class="code">StringBuilder</pre> <pre class="code">b</pre> that shows all elements of <pre class="code">xs</pre>
                      between separators <pre class="code">sep</pre> enclosed in strings
                      <pre class="code">start</pre> and <pre class="code">end</pre>. <pre class="code">start</pre>, <pre class="code">sep</pre>, and <pre class="code">end</pre> are
                      all optional.<a id="i-1321009903-1"/><a id="i1919771112-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">mkString</pre>&nbsp;<pre class="code">(start,</pre>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">sep,</pre>&nbsp;<pre class="code">end)</pre>
  </td>
  <td>
    Converts the collection to a string that shows all elements of <pre class="code">xs</pre>
                      between separators <pre class="code">sep</pre> enclosed in strings
                      <pre class="code">start</pre> and <pre class="code">end</pre>. <pre class="code">start</pre>, <pre class="code">sep</pre>, and <pre class="code">end</pre> are
                      all optional.<a id="i1706355665-2"/><a id="i-1254670663-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.stringPrefix</pre>
  </td>
  <td>
    The collection name at the beginning of the string returned from <pre class="code">xs.toString</pre>.<a id="i-1294920291-1"/><a id="i436681837-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Views:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.view</pre>
  </td>
  <td>
    Produces a view over <pre class="code">xs</pre>.<a id="i-1406999493-1"/><a id="i-1473277169-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">view</pre>&nbsp;<pre class="code">(from,</pre>&nbsp;<pre class="code">to)</pre>
  </td>
  <td>
    Produces a view that represents the elements in some
                     index range of <pre class="code">xs</pre>.
  </td>
</tr>
</table>


<h3>24.4 Trait <pre class="code">Iterable</pre></h3>


<p>The next trait from the top in <a href="collections-in-depth.html#fig-coll-hierarchy">Figure 24.1</a> is
<pre class="code">Iterable</pre>.  All methods in this trait are defined in terms of an
abstract method, <pre class="code">iterator</pre>, which yields the collection's elements one
by one. The abstract <pre class="code">foreach</pre> method inherited from trait <pre class="code">Traversable</pre> is implemented
in <pre class="code">Iterable</pre> in terms of <pre class="code">iterator</pre>. Here is the actual implementation:</p>

<pre>
  <code class="vem">def</code>&nbsp;foreach[U](f:&nbsp;<code class="typename">Elem</code>&nbsp;=&gt;&nbsp;U):&nbsp;<code class="typename">Unit</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;it&nbsp;=&nbsp;iterator
  &nbsp;&nbsp;<code class="vem">while</code>&nbsp;(it.hasNext)&nbsp;f(it.next())
  }&nbsp;
</pre>


<p>Quite a few subclasses of <pre class="code">Iterable</pre> override this standard 
implementation of <pre class="code">foreach</pre> in <pre class="code">Iterable</pre>, because they
can provide a more efficient implementation. Remember that <pre class="code">foreach</pre>
is the basis of the implementation of all operations in <pre class="code">Traversable</pre>,
so its performance matters.</p>

<p>Two more methods exist in <pre class="code">Iterable</pre> that return iterators:
<pre class="code">grouped</pre> and <pre class="code">sliding</pre>. These iterators, however, do not return
single elements but whole subsequences of elements of the original
collection. The maximal size of these subsequences is given as an
argument to these methods. The <pre class="code">grouped</pre> method chunks its
elements into increments, whereas <pre class="code">sliding</pre> yields a sliding
window over the elements.
The difference between the two should
become clear by looking at the following interpreter interaction:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;xs&nbsp;=&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">5</code>)
  <code class="output">xs:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;git&nbsp;=&nbsp;xs&nbsp;grouped&nbsp;<code class="literal">3</code>
  <code class="output">git:&nbsp;Iterator[List[Int]]&nbsp;=&nbsp;non-empty&nbsp;iterator</code>
  <br />  scala&gt;&nbsp;git.next()
  <code class="output">res2:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;git.next()
  <code class="output">res3:&nbsp;List[Int]&nbsp;=&nbsp;List(4,&nbsp;5)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;sit&nbsp;=&nbsp;xs&nbsp;sliding&nbsp;<code class="literal">3</code>
  <code class="output">sit:&nbsp;Iterator[List[Int]]&nbsp;=&nbsp;non-empty&nbsp;iterator</code>
  <br />  scala&gt;&nbsp;sit.next()
  <code class="output">res4:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;sit.next()
  <code class="output">res5:&nbsp;List[Int]&nbsp;=&nbsp;List(2,&nbsp;3,&nbsp;4)</code>
  <br />  scala&gt;&nbsp;sit.next()
  <code class="output">res6:&nbsp;List[Int]&nbsp;=&nbsp;List(3,&nbsp;4,&nbsp;5)</code>
</pre>


<p>Trait <pre class="code">Iterable</pre> also adds some other methods to <pre class="code">Traversable</pre> that 
can be implemented efficiently only if an iterator is available. 
They are
summarized in <a href="collections-in-depth.html#tab-iterableops">Table 24.2</a>:</p>

<p><a id="tab-iterableops"/></p>

<h5>Operations in trait <pre class="code">Iterable</pre> <a id="i-930863599-1"/></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Abstract method:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.iterator</pre>
  </td>
  <td>
    An iterator that yields every element in <pre class="code">xs</pre>,
                    in the same order as <pre class="code">foreach</pre> traverses elements<a id="i1960545726-1"/><a id="i-2123398051-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Other iterators:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">grouped</pre>&nbsp;<pre class="code">size</pre>
  </td>
  <td>
    An iterator that yields fixed-sized "chunks" of 
                   this collection<a id="i1434663977-1"/><a id="i-1891423857-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">sliding</pre>&nbsp;<pre class="code">size</pre>
  </td>
  <td>
    An iterator that yields a sliding fixed-sized window of 
                   elements in this collection<a id="i-2085639431-1"/><a id="i-9143201-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Subcollections:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">takeRight</pre>&nbsp;<pre class="code">n</pre>
  </td>
  <td>
    A collection consisting of the last <pre class="code">n</pre>
                     elements of <pre class="code">xs</pre> (or, some
                     arbitrary <pre class="code">n</pre> elements, if no order is
                     defined)<a id="i-1293058080-1"/><a id="i2082036678-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">dropRight</pre>&nbsp;<pre class="code">n</pre>
  </td>
  <td>
    The rest of the collection except
                    <pre class="code">xs</pre>&nbsp;<pre class="code">takeRight</pre>&nbsp;<pre class="code">n</pre><a id="i636434552-1"/><a id="i69509726-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Zippers:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">zip</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    An iterable of pairs of corresponding elements from <pre class="code">xs</pre> and <pre class="code">ys</pre><a id="i-1097812436-1"/><a id="i-379690542-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">zipAll</pre>&nbsp;<pre class="code">(ys,</pre>&nbsp;<pre class="code">x,</pre>&nbsp;<pre class="code">y)</pre>
  </td>
  <td>
    An iterable of pairs of corresponding elements from <pre class="code">xs</pre> and <pre class="code">ys</pre>,
                  where the shorter sequence is extended to match the longer one
                  by appending elements <pre class="code">x</pre> or <pre class="code">y</pre><a id="i1056526603-1"/><a id="i1582986863-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.zipWithIndex</pre>
  </td>
  <td>
    An iterable of pairs of elements from <pre class="code">xs</pre> with their indicies<a id="i628301846-1"/><a id="i-1524777478-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Comparison:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">sameElements</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    Tests whether <pre class="code">xs</pre> and <pre class="code">ys</pre> contain the same
                    elements in the same order<a id="i-2017721464-1"/><a id="i-1057289236-1"/>
  </td>
</tr>
</table>


<h4>Why have both <pre class="code">Traversable</pre> and <pre class="code">Iterable</pre>?</h4>


<p>You might wonder why the extra trait <pre class="code">Traversable</pre> is above
<pre class="code">Iterable</pre>. Can we not do everything with an <pre class="code">iterator</pre>? So what's
the point of having a more abstract trait that defines its methods in
terms of <pre class="code">foreach</pre> instead of <pre class="code">iterator</pre>? One reason for having
<pre class="code">Traversable</pre> is that sometimes it is easier or more efficient to
provide an implementation of <pre class="code">foreach</pre> than to provide an
implementation of <pre class="code">iterator</pre>. Here's a simple example. Let's say you
want a class hierarchy for binary trees that have integer elements
at the leaves. You might design this hierarchy like this:</p>

<pre>
  <code class="vem">sealed</code>&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Tree</code>
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Branch</code>(left:&nbsp;<code class="typename">Tree</code>,&nbsp;right:&nbsp;<code class="typename">Tree</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Tree</code>
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Node</code>(elem:&nbsp;<code class="typename">Int</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Tree</code>
</pre>


<p>Now assume you want to make trees traversable. To do this, have
<pre class="code">Tree</pre> inherit from <pre class="code">Traversable[Int]</pre> and define a <pre class="code">foreach</pre> method like this:</p>

<pre>
  <code class="vem">sealed</code>&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Tree</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Traversable[Int]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;foreach[U](f:&nbsp;<code class="typename">Int</code>&nbsp;=&gt;&nbsp;U)&nbsp;=&nbsp;<code class="vem">this</code>&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Node</code>(elem)&nbsp;=&gt;&nbsp;f(elem)
  &nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Branch</code>(l,&nbsp;r)&nbsp;=&gt;&nbsp;l&nbsp;foreach&nbsp;f;&nbsp;r&nbsp;foreach&nbsp;f
  &nbsp;&nbsp;}
  }
</pre>


<p>That's not too hard, and it is also very efficient&mdash;traversing a
balanced tree takes time proportional to the number of elements in the
tree.  To see this, consider that for a balanced tree with <pre class="code">N</pre> leaves
you will have <pre class="code">N</pre>&nbsp;<pre class="code">-</pre>&nbsp;<pre class="code">1</pre> interior nodes of class <pre class="code">Branch</pre>. So the total
number of steps to traverse the tree is <pre class="code">N</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">N</pre>&nbsp;<pre class="code">-</pre>&nbsp;<pre class="code">1</pre>.</p>

<p>Now, compare this with making trees iterable. To do this, have <pre class="code">Tree</pre> inherit
from <pre class="code">Iterable[Int]</pre> and define an <pre class="code">iterator</pre> method like this:</p>

<pre>
  <code class="vem">sealed</code>&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Tree</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Iterable[Int]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;iterator:&nbsp;<code class="typename">Iterator[Int]</code>&nbsp;=&nbsp;<code class="vem">this</code>&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Node</code>(elem)&nbsp;=&gt;&nbsp;Iterator.single(elem)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Branch</code>(l,&nbsp;r)&nbsp;=&gt;&nbsp;l.iterator&nbsp;++&nbsp;r.iterator
  &nbsp;&nbsp;}
  }
</pre>


<p>At first glance, this looks no harder than the <pre class="code">foreach</pre> solution. However, there's 
an efficiency problem that has to do with the implementation of the 
iterator concatenation method, <pre class="code">++</pre>. Every time an element
is produced by a concatenated iterator such as
<pre class="code">l.iterator</pre>&nbsp;<pre class="code">++</pre>&nbsp;<pre class="code">r.iterator</pre>, the computation needs to follow one indirection
to get at the right iterator (either <pre class="code">l.iterator</pre>, or <pre class="code">r.iterator</pre>).
Overall, that makes \<i>log</i>(<i>N</i>) indirections to get at a leaf of a balanced
tree with <pre class="code">N</pre> leaves. So the cost of visiting all elements of a tree
went up from about <pre class="code">2N</pre> for the <pre class="code">foreach</pre> traversal method to
<pre class="code">N</pre>&nbsp;<span class="code">\<i>log</i>(N)</span> for the traversal with <pre class="code">iterator</pre>. If the tree has a 
million elements that means about two million steps for <pre class="code">foreach</pre> and 
about twenty million steps for <pre class="code">iterator</pre>. 
So the <pre class="code">foreach</pre> solution has a clear advantage.</p>

<h4>Subcategories of <pre class="code">Iterable</pre></h4>


<p>In the inheritance hierarchy below <pre class="code">Iterable</pre> you find three traits:
<pre class="code">Seq</pre>, <pre class="code">Set</pre>, and <pre class="code">Map</pre>. A common aspect of these three traits is
that they all implement the <pre class="code">PartialFunction</pre> trait<a href="collections-in-depth.html#footnotemain24-1">[1]</a> with its
<pre class="code">apply</pre> and <pre class="code">isDefinedAt</pre> methods. However, the way each trait implements 
<pre class="code">PartialFunction</pre> differs.</p>

<p>For sequences, <pre class="code">apply</pre> is positional indexing, where elements are
always numbered from <pre class="code">0</pre>.  That is, <pre class="code">Seq(1,</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">3)(1)</pre>&nbsp;<pre class="code">==</pre>&nbsp;<pre class="code">2</pre>.
For
sets, <pre class="code">apply</pre> is a membership test. For instance, <pre class="code">Set('a',</pre>&nbsp;<pre class="code">'b',</pre>&nbsp;<pre class="code">'c')('b')</pre>&nbsp;<pre class="code">==</pre>&nbsp;<pre class="code">true</pre> whereas <pre class="code">Set()('a')</pre>&nbsp;<pre class="code">==</pre>&nbsp;<pre class="code">false</pre>. Finally for maps,
<pre class="code">apply</pre> is a selection. For instance, <pre class="code">Map('a'</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">1,</pre>&nbsp;<pre class="code">'b'</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">10,</pre>&nbsp;<pre class="code">'c'</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">100)('b')</pre>&nbsp;<pre class="code">==</pre>&nbsp;<pre class="code">10</pre>.</p>

<p>In the following three sections, we will explain each of the three kinds of
collections in more detail.</p>

<h3>24.5 The sequence traits <pre class="code">Seq</pre>, <pre class="code">IndexedSeq</pre>, and
<pre class="code">LinearSeq</pre></h3>


<p>The <pre class="code">Seq</pre> trait represents sequences. A sequence is a kind of
iterable that has a <pre class="code">length</pre> and whose elements have fixed index
positions, starting from <pre class="code">0</pre>.</p>

<p>The operations on sequences, summarized in
<a href="collections-in-depth.html#tab-seqops">Figure 24.3</a>, fall into the following categories:</p>

<ul>


<li><b><span style="font-style:italic">Indexing and length operations</span></b> <pre class="code">apply</pre>, <pre class="code">isDefinedAt</pre>,
  <pre class="code">length</pre>, <pre class="code">indices</pre>, and <pre class="code">lengthCompare</pre>. For a <pre class="code">Seq</pre>, the <pre class="code">apply</pre> operation
means indexing; hence a sequence of type <pre class="code">Seq[T]</pre> is a partial
function that takes an <pre class="code">Int</pre> argument (an index) and yields a
sequence element of type <pre class="code">T</pre>. In other words <pre class="code">Seq[T]</pre> extends
<pre class="code">PartialFunction[Int,</pre>&nbsp;<pre class="code">T]</pre>. The elements of a sequence are indexed
from zero up to the <pre class="code">length</pre> of the sequence minus
one. The <pre class="code">length</pre> method on sequences is an alias
of the <pre class="code">size</pre> method of general collections. The <pre class="code">lengthCompare</pre> method
allows you to compare the lengths of two sequences even if one of the sequences
has infinite length.


</li>
<li><b><span style="font-style:italic">Index search</span> <em>operations</em></b> <pre class="code">indexOf</pre>, <pre class="code">lastIndexOf</pre>, <pre class="code">indexOfSlice</pre>,
<pre class="code">lastIn</pre>- <pre class="code">dexOfSlice</pre>, <pre class="code">indexWhere</pre>, <pre class="code">lastIndexWhere</pre>, <pre class="code">segmentLength</pre>, and <pre class="code">prefixLength</pre>,
which return the index of an element equal to a given value or matching some predicate.


</li>
<li><b><span style="font-style:italic">Addition</span> <em>operations</em></b> <pre class="code">+:</pre>, <pre class="code">:+</pre>, and <pre class="code">padTo</pre>, which
return new sequences obtained by adding elements at the front or the end of a sequence.


</li>
<li><b><span style="font-style:italic">Update operations</span></b> <pre class="code">updated</pre> and <pre class="code">patch</pre>, which return a new
  sequence obtained by replacing some elements of the original sequence.


</li>
<li><b><span style="font-style:italic">Sorting operations</span></b> <pre class="code">sorted</pre>, <pre class="code">sortWith</pre>, and <pre class="code">sortBy</pre>, which sort sequence
elements according to various criteria.


</li>
<li><b><span style="font-style:italic">Reversal operations</span></b> <pre class="code">reverse</pre>, <pre class="code">reverseIterator</pre>, and <pre class="code">reverseMap</pre>, 
which yield or process sequence elements in reverse order, from last
to first.


</li>
<li><b><span style="font-style:italic">Comparison operations</span></b> <pre class="code">startsWith</pre>, <pre class="code">endsWith</pre>, <pre class="code">contains</pre>, <pre class="code">corresponds</pre>, and <pre class="code">containsSlice</pre>, 
which relate two sequences or search an element in a sequence.


</li>
<li><b><span style="font-style:italic">Multiset operations</span></b> <pre class="code">intersect</pre>, <pre class="code">diff</pre>, <pre class="code">union</pre>, and <pre class="code">distinct</pre>,
which perform set-like operations on the elements of two sequences or remove
duplicates.


</li></ul>


<p>If a sequence is mutable, it offers in addition a side-effecting
<pre class="code">update</pre> method, which lets sequence elements be updated. Recall from
<a href="next-steps-in-scala.html">Chapter 3</a> that syntax like <pre class="code">seq(idx)</pre>&nbsp;<pre class="code">=</pre>&nbsp;<pre class="code">elem</pre> is just a shorthand for
<pre class="code">seq.update(idx,</pre>&nbsp;<pre class="code">elem)</pre>. Note the difference between <pre class="code">update</pre> and
<pre class="code">updated</pre>. The <pre class="code">update</pre> method changes a sequence element in place, and is only
available for mutable sequences. The <pre class="code">updated</pre> method is available for all
sequences and always returns a new sequence instead of modifying the
original.</p>

<div style="page-break-after:always"/>


<p><a id="tab-seqops"/></p>

<h5>Operations in trait <pre class="code">Seq</pre> <a id="i2004738302-1"/></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Indexing and length:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs(i)</pre>
  </td>
  <td>
    (or, written out, <pre class="code">xs</pre>&nbsp;<pre class="code">apply</pre>&nbsp;<pre class="code">i</pre>) The element
                  of <pre class="code">xs</pre> at index <pre class="code">i</pre>.<a id="i972576416-1"/><a id="i540215378-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">isDefinedAt</pre>&nbsp;<pre class="code">i</pre>
  </td>
  <td>
    Tests whether <pre class="code">i</pre> is contained in <pre class="code">xs.indices</pre>.
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.length</pre>
  </td>
  <td>
    The length of the sequence (same as <pre class="code">size</pre>).<a id="i-315498884-1"/><a id="i251040758-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.lengthCompare</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    Returns <pre class="code">-1</pre> if <pre class="code">xs</pre> is shorter than <pre class="code">ys</pre>, <pre class="code">+1</pre> if it is
                  longer, and <pre class="code">0</pre> is they have the same length. 
                  Works even if one of the sequences is infinite.<a id="i473798543-1"/><a id="i-1000272893-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.indices</pre>
  </td>
  <td>
    The index range of <pre class="code">xs</pre>, extending from 0 to <pre class="code">xs.length</pre>&nbsp;<pre class="code">-</pre>&nbsp;<pre class="code">1</pre>.<a id="i-1361723020-1"/><a id="i-2102417525-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Index search:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">indexOf</pre>&nbsp;<pre class="code">x</pre>
  </td>
  <td>
    The index of the first element in <pre class="code">xs</pre> equal to <pre class="code">x</pre>
                  (several variants exist).<a id="i1954773669-1"/><a id="i-2102517203-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">lastIndexOf</pre>&nbsp;<pre class="code">x</pre>
  </td>
  <td>
    The index of the last element in <pre class="code">xs</pre> equal to <pre class="code">x</pre>
                  (several variants exist).<a id="i-1061813157-1"/><a id="i-115105609-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">indexOfSlice</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    The first index of <pre class="code">xs</pre> such that successive elements starting
                  from that index form the sequence <pre class="code">ys</pre>.<a id="i580863013-1"/><a id="i1348829029-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">lastIndexOfSlice</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    The last index of <pre class="code">xs</pre> such that successive elements starting
                  from that index form the sequence <pre class="code">ys</pre>.<a id="i-1540596689-1"/><a id="i-1993636069-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">indexWhere</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    The index of the first element in <pre class="code">xs</pre> that satisfies <pre class="code">p</pre>
                  (several variants exist).<a id="i1308063033-1"/><a id="i1720598737-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">segmentLength</pre>&nbsp;<pre class="code">(p,</pre>&nbsp;<pre class="code">i)</pre>
  </td>
  <td>
    The length of the longest uninterrupted segment of 
                  elements in <pre class="code">xs</pre>, starting with <pre class="code">xs(i)</pre>, that
                  all satisfy the predicate <pre class="code">p</pre>.<a id="i-1262494987-1"/><a id="i-1801931555-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">prefixLength</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    The length of the longest prefix of 
                  elements in <pre class="code">xs</pre> that
                  all satisfy the predicate <pre class="code">p</pre>.<a id="i-806509514-1"/><a id="i-1716513100-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Additions:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">x</pre>&nbsp;<pre class="code">+:</pre>&nbsp;<pre class="code">xs</pre>
  </td>
  <td>
    A new sequence consisting of <pre class="code">x</pre> prepended to <pre class="code">xs</pre>.<a id="i-1215087300-1"/><a id="i-110359634-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">:+</pre>&nbsp;<pre class="code">x</pre>
  </td>
  <td>
    A new sequence that consists of <pre class="code">x</pre> append to <pre class="code">xs</pre>.<a id="i-1421606018-1"/><a id="i1838792986-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">padTo</pre>&nbsp;<pre class="code">(len,</pre>&nbsp;<pre class="code">x)</pre>
  </td>
  <td>
    The sequence resulting from appending the value <pre class="code">x</pre>
                  to <pre class="code">xs</pre> until length <pre class="code">len</pre> is reached.<a id="i-1863493728-1"/><a id="i553609042-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Updates:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">patch</pre>&nbsp;<pre class="code">(i,</pre>&nbsp;<pre class="code">ys,</pre>&nbsp;<pre class="code">r)</pre>
  </td>
  <td>
    The sequence resulting from replacing <pre class="code">r</pre> elements
                  of <pre class="code">xs</pre> starting with <pre class="code">i</pre> by the patch <pre class="code">ys</pre>.<a id="i-62511610-1"/><a id="i553624876-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">updated</pre>&nbsp;<pre class="code">(i,</pre>&nbsp;<pre class="code">x)</pre>
  </td>
  <td>
    A copy of <pre class="code">xs</pre> with the element at index <pre class="code">i</pre> replaced by <pre class="code">x</pre>.<a id="i-2090714253-1"/><a id="i14728351-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs(i)</pre>&nbsp;<pre class="code">=</pre>&nbsp;<pre class="code">x</pre>
  </td>
  <td>
    (or, written out, <pre class="code">xs.update(i,</pre>&nbsp;<pre class="code">x)</pre>, only available
                  for <pre class="code">mutable.Seq</pre>s) Changes the element of <pre class="code">xs</pre>
                  at index <pre class="code">i</pre> to <pre class="code">y</pre>.<a id="i1619007525-1"/><a id="i139022437-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Sorting:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.sorted</pre>
  </td>
  <td>
    A new sequence obtained by sorting the elements of
                    <pre class="code">xs</pre> using the standard ordering of the element
                    type of <pre class="code">xs</pre>.<a id="i-78070095-1"/><a id="i81275481-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">sortWith</pre>&nbsp;<pre class="code">lessThan</pre>
  </td>
  <td>
    A new sequence obtained by sorting the elements of
                    <pre class="code">xs</pre>, using <pre class="code">lessThan</pre> as comparison operation.<a id="i1923205194-1"/><a id="i795917344-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">sortBy</pre>&nbsp;<pre class="code">f</pre>
  </td>
  <td>
    A new sequence obtained by sorting the elements of
                    <pre class="code">xs</pre>. Comparison between two elements proceeds
                    by mapping the function <pre class="code">f</pre> over both and
                    comparing the results.<a id="i-544663079-1"/><a id="i81274417-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Reversals:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.reverse</pre>
  </td>
  <td>
    A sequence with the elements of <pre class="code">xs</pre> in reverse order.<a id="i162887596-1"/><a id="i1349004998-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.reverseIterator</pre>
  </td>
  <td>
    An iterator yielding all the elements of <pre class="code">xs</pre> in
                  reverse order.<a id="i-1214590498-1"/><a id="i-1415678636-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">reverseMap</pre>&nbsp;<pre class="code">f</pre>
  </td>
  <td>
    A sequence obtained by mapping <pre class="code">f</pre> over the elements
                 of <pre class="code">xs</pre> in reverse order.<a id="i1968096884-1"/><a id="i198983862-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Comparisons:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">startsWith</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    Tests whether <pre class="code">xs</pre> starts with sequence <pre class="code">ys</pre> 
                  (several variants exist).<a id="i-2129701641-1"/><a id="i-574339501-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">endsWith</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    Tests whether <pre class="code">xs</pre> ends with sequence <pre class="code">ys</pre>
                  (several variants exist).<a id="i455738416-1"/><a id="i877141114-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">contains</pre>&nbsp;<pre class="code">x</pre>
  </td>
  <td>
    Tests whether <pre class="code">xs</pre> has an element equal to <pre class="code">x</pre>.<a id="i752331919-1"/><a id="i-1433463109-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">containsSlice</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    Tests whether <pre class="code">xs</pre> has a contiguous subsequence equal to <pre class="code">ys</pre>.<a id="i-1416645509-1"/><a id="i1699558295-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">(xs</pre>&nbsp;<pre class="code">corresponds</pre>&nbsp;<pre class="code">ys)(p)</pre>
  </td>
  <td>
    Tests whether corresponding elements of <pre class="code">xs</pre> and <pre class="code">ys</pre> 
                  satisfy the binary predicate <pre class="code">p</pre>.<a id="i-1866218038-1"/><a id="i-2021984280-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Multiset operations:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">intersect</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    The multi-set intersection of sequences <pre class="code">xs</pre> and <pre class="code">ys</pre> that
                  preserves the order of elements in <pre class="code">xs</pre>.<a id="i-1738203761-1"/><a id="i-573712381-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">diff</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    The multi-set difference of sequences <pre class="code">xs</pre> and <pre class="code">ys</pre> that
                  preserves the order of elements in <pre class="code">xs</pre>.<a id="i-1220877719-1"/><a id="i433150625-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">union</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    Multiset union; same as <pre class="code">xs</pre>&nbsp;<pre class="code">++</pre>&nbsp;<pre class="code">ys</pre>.<a id="i-1990387233-1"/><a id="i558619571-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.distinct</pre>
  </td>
  <td>
    A subsequence of <pre class="code">xs</pre> that contains no duplicated
element.<a id="i868552658-1"/><a id="i-577319016-1"/>
  </td>
</tr>
</table>


<p>Each <pre class="code">Seq</pre> trait has two subtraits, <pre class="code">LinearSeq</pre> and
<pre class="code">IndexedSeq</pre>. These do not add any new operations, but each offers
different performance characteristics. A linear sequence has efficient
<pre class="code">head</pre> and <pre class="code">tail</pre> operations, whereas an indexed sequence has
efficient <pre class="code">apply</pre>, <pre class="code">length</pre>, and (if mutable) <pre class="code">update</pre>
operations. <pre class="code">List</pre> is a frequently used linear sequence, as is 
<pre class="code">Stream</pre>.<a id="i-1334114643-1"/>  Two frequently used indexed sequences are <pre class="code">Array</pre> and <pre class="code">ArrayBuffer</pre>.
The <pre class="code">Vector</pre> class provides an
interesting compromise between indexed and linear access.  It has both
effectively constant time indexing overhead and constant time linear access
overhead.  Because of this, vectors are a good foundation for mixed
access patterns where both indexed and linear accesses are used. More
on vectors in <a href="collections-in-depth.html#sec-collections-api-vectors">Section 24.8</a>.</p>

<h4>Buffers</h4>


<p>An important sub-category of mutable sequences is buffers. Buffers
allow not only updates of existing elements but also element
insertions, element removals, and efficient additions of new elements
at the end of the buffer.  The principal new methods supported by a
buffer are <pre class="code">+=</pre> and <pre class="code">++=</pre>, for element addition at
the end, <pre class="code">+=:</pre> and <pre class="code">++=:</pre> for addition at the
front, <pre class="code">insert</pre> and <pre class="code">insertAll</pre> for element insertions, as well as
<pre class="code">remove</pre> and <pre class="code">-=</pre> for element removal. These operations are
summarized in <a href="collections-in-depth.html#tab-bufferops">Table 24.4</a>.</p>

<p>Two <pre class="code">Buffer</pre> implementations that are commonly used are <pre class="code">ListBuffer</pre> and 
<pre class="code">ArrayBuffer</pre>. As the name implies, a
<pre class="code">ListBuffer</pre> is backed by a <pre class="code">List</pre> and supports efficient
conversion of its elements to a <pre class="code">List</pre>, whereas an <pre class="code">ArrayBuffer</pre> is
backed by an array, and can be quickly converted into one.
You saw a glimpse of the implementation of <pre class="code">ListBuffer</pre> in 
<a href="implementing-lists.html#sec-the-listbuffer-class">Section 22.2</a>.</p>

<p><a id="tab-bufferops"/></p>

<h5>Operations in trait <pre class="code">Buffer</pre> <a id="i95832031-1"/></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Additions:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">buf</pre>&nbsp;<pre class="code">+=</pre>&nbsp;<pre class="code">x</pre>
  </td>
  <td>
    Appends element <pre class="code">x</pre> to buffer <pre class="code">buf</pre>, and returns <pre class="code">buf</pre> itself as result<a id="i1747820940-1"/><a id="i-2090973295-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">buf</pre>&nbsp;<pre class="code">+=</pre>&nbsp;<pre class="code">(x,</pre>&nbsp;<pre class="code">y,</pre>&nbsp;<pre class="code">z)</pre>
  </td>
  <td>
    Appends given elements to buffer
  </td>
</tr>
<tr>
  <td>
    <pre class="code">buf</pre>&nbsp;<pre class="code">++=</pre>&nbsp;<pre class="code">xs</pre>
  </td>
  <td>
    Appends all elements in <pre class="code">xs</pre> to buffer<a id="i-1480460839-1"/><a id="i121740146-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">x</pre>&nbsp;<pre class="code">+=:</pre>&nbsp;<pre class="code">buf</pre>
  </td>
  <td>
    Prepends element <pre class="code">x</pre> to buffer<a id="i-1505564645-1"/><a id="i-52217715-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">++=:</pre>&nbsp;<pre class="code">buf</pre>
  </td>
  <td>
    Prepends all elements in <pre class="code">xs</pre> to buffer<a id="i-2007284108-1"/><a id="i356587566-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">buf</pre>&nbsp;<pre class="code">insert</pre>&nbsp;<pre class="code">(i,</pre>&nbsp;<pre class="code">x)</pre>
  </td>
  <td>
    Inserts element <pre class="code">x</pre> at index <pre class="code">i</pre> in buffer<a id="i-1767492769-1"/><a id="i-1775835603-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">buf</pre>&nbsp;<pre class="code">insertAll</pre>&nbsp;<pre class="code">(i,</pre>&nbsp;<pre class="code">xs)</pre>
  </td>
  <td>
    Inserts all elements in <pre class="code">xs</pre> at index <pre class="code">i</pre> in
buffer<a id="i1499228240-1"/><a id="i1488769076-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Removals:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">buf</pre>&nbsp;<pre class="code">-=</pre>&nbsp;<pre class="code">x</pre>
  </td>
  <td>
    Removes element <pre class="code">x</pre> from buffer<a id="i2053756078-1"/><a id="i703208191-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">buf</pre>&nbsp;<pre class="code">remove</pre>&nbsp;<pre class="code">i</pre>
  </td>
  <td>
    Removes element at index <pre class="code">i</pre> from buffer<a id="i-1233111692-1"/><a id="i-1526653960-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">buf</pre>&nbsp;<pre class="code">remove</pre>&nbsp;<pre class="code">(i,</pre>&nbsp;<pre class="code">n)</pre>
  </td>
  <td>
    Removes <pre class="code">n</pre> elements starting at index <pre class="code">i</pre> from buffer
  </td>
</tr>
<tr>
  <td>
    <pre class="code">buf</pre>&nbsp;<pre class="code">trimStart</pre>&nbsp;<pre class="code">n</pre>
  </td>
  <td>
    Removes first <pre class="code">n</pre> elements from buffer<a id="i-1528855016-1"/><a id="i1378245996-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">buf</pre>&nbsp;<pre class="code">trimEnd</pre>&nbsp;<pre class="code">n</pre>
  </td>
  <td>
    Removes last <pre class="code">n</pre> elements from buffer<a id="i1472686271-1"/><a id="i2061753445-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">buf.clear()</pre>
  </td>
  <td>
    Removes all elements from buffer<a id="i-240297909-1"/><a id="i-2002561959-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Cloning:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">buf.clone</pre>
  </td>
  <td>
    A new buffer with the same elements as <pre class="code">buf</pre><a id="i1251822395-1"/><a id="i-2002551959-1"/>
  </td>
</tr>
</table>


<h3>24.6 Sets</h3>


<p><pre class="code">Set</pre>s are <pre class="code">Iterable</pre>s that contain no duplicate elements. The
operations on sets are summarized in <a href="collections-in-depth.html#tab-setops">Table 24.5</a> for 
general sets and <a href="collections-in-depth.html#tab-mutsetops">Table 24.6</a> for mutable sets. 
They fall into the following categories:</p>

<ul>


<li><b><span style="font-style:italic">Tests</span></b> <pre class="code">contains</pre>, <pre class="code">apply</pre>, and <pre class="code">subsetOf</pre>. 
The <pre class="code">contains</pre> method indicates whether a set contains a given
element. The <pre class="code">apply</pre> method for a set is the same as <pre class="code">contains</pre>, so
<pre class="code">set(elem)</pre> is the same as <pre class="code">set</pre>&nbsp;<pre class="code">contains</pre> <pre class="code">elem</pre>. That means sets can also be used as test
functions that return true for the elements they contain. For example:


<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fruit&nbsp;=&nbsp;<code class="typename">Set</code>(<code class="quotedstring">"apple"</code>,&nbsp;<code class="quotedstring">"orange"</code>,&nbsp;<code class="quotedstring">"peach"</code>,&nbsp;<code class="quotedstring">"banana"</code>)
  <code class="output">fruit:&nbsp;scala.collection.immutable.Set[String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;Set(apple,&nbsp;orange,&nbsp;peach,&nbsp;banana)</code>
  <br />  scala&gt;&nbsp;fruit(<code class="quotedstring">"peach"</code>)
  <code class="output">res7:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br />  scala&gt;&nbsp;fruit(<code class="quotedstring">"potato"</code>)
  <code class="output">res8:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>


</li>
<li><b><span style="font-style:italic">Additions</span></b> <pre class="code">+</pre> and <pre class="code">++</pre>, which add one or more elements to a set, yielding a new set as a result.


</li>
<li><b><span style="font-style:italic">Removals</span></b> <pre class="code">-</pre> and <pre class="code">--</pre>, which remove one or more elements from a set, 
yielding a new set. 


</li>
<li><b><span style="font-style:italic">Set operations</span></b> for union, intersection, and set difference. These set operations exist in two 
forms: alphabetic and symbolic. The alphabetic versions are <pre class="code">intersect</pre>, <pre class="code">union</pre>, and <pre class="code">diff</pre>, 
whereas the symbolic versions are <pre class="code">&amp;</pre>, <pre class="code">|</pre>, and <span class="code">&amp;<pre class="large">~</pre></span>. The <pre class="code">++</pre> that <pre class="code">Set</pre> inherits
from <pre class="code">Traversable</pre> can be seen
as yet another alias of <pre class="code">union</pre> or <pre class="code">|</pre>, except that <pre class="code">++</pre> takes a
<pre class="code">Traversable</pre> argument whereas <pre class="code">union</pre> and <pre class="code">|</pre> take sets.


</li></ul>


<p><a id="tab-setops"/></p>

<h5>Operations in trait <pre class="code">Set</pre> <a id="i877342209-1"/></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Tests:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">contains</pre>&nbsp;<pre class="code">x</pre>
  </td>
  <td>
    Tests whether <pre class="code">x</pre> is an element of <pre class="code">xs</pre><a id="i1685795628-2"/><a id="i924843454-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs(x)</pre>
  </td>
  <td>
    Same as <pre class="code">xs</pre>&nbsp;<pre class="code">contains</pre>&nbsp;<pre class="code">x</pre>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">subsetOf</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    Tests whether <pre class="code">xs</pre> is a subset of <pre class="code">ys</pre><a id="i12573170-1"/><a id="i-569252040-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Additions:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">x</pre>
  </td>
  <td>
    The set containing all elements of <pre class="code">xs</pre> as well as <pre class="code">x</pre><a id="i-457936727-3"/><a id="i1858879238-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">(x,</pre>&nbsp;<pre class="code">y,</pre>&nbsp;<pre class="code">z)</pre>
  </td>
  <td>
    The set containing all elements of <pre class="code">xs</pre> as well as the given additional elements
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">++</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    The set containing all elements of <pre class="code">xs</pre> as well as
all elements of <pre class="code">ys</pre><a id="i758428245-2"/><a id="i872660526-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Removals:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">-</pre>&nbsp;<pre class="code">x</pre>
  </td>
  <td>
    The set containing all elements of <pre class="code">xs</pre> except <pre class="code">x</pre><a id="i-1092228898-2"/><a id="i-1593467087-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">-</pre>&nbsp;<pre class="code">(x,</pre>&nbsp;<pre class="code">y,</pre>&nbsp;<pre class="code">z)</pre>
  </td>
  <td>
    The set containing all elements of <pre class="code">xs</pre> except the given elements
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">--</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    The set containing all elements of <pre class="code">xs</pre> except the elements of <pre class="code">ys</pre><a id="i-726788280-2"/><a id="i640851374-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.empty</pre>
  </td>
  <td>
    An empty set of the same class as <pre class="code">xs</pre><a id="i1039994046-1"/><a id="i-1275381234-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Binary operations:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">&amp;</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    The set intersection of <pre class="code">xs</pre> and <pre class="code">ys</pre><a id="i617863161-2"/><a id="i1830753682-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">intersect</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    Same as <pre class="code">xs</pre>&nbsp;<pre class="code">&amp;</pre>&nbsp;<pre class="code">ys</pre><a id="i-804740052-1"/><a id="i-480652960-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">|</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    The set union of <pre class="code">xs</pre> and <pre class="code">ys</pre><a id="i1836511958-1"/><a id="i562147141-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">union</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    Same as <pre class="code">xs</pre>&nbsp;<pre class="code">|</pre>&nbsp;<pre class="code">ys</pre><a id="i-1056923524-1"/><a id="i-1260582000-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<span class="code">&amp;<pre class="large">~</pre></span>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    The set difference of <pre class="code">xs</pre> and <pre class="code">ys</pre><a id="i2003546905-1"/><a id="i-1861524116-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">diff</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    Same as <pre class="code">xs</pre>&nbsp;<span class="code">&amp;<pre class="large">~</pre></span>&nbsp;<pre class="code">ys</pre><a id="i-287414010-1"/><a id="i1067203364-1"/>
  </td>
</tr>
</table>


<p>Mutable sets have methods that add, remove, or update
elements, which are summarized in <a href="collections-in-depth.html#tab-mutsetops">Table 24.6</a>:</p>

<p><a id="tab-mutsetops"/></p>

<h5>Operations in trait <pre class="code">mutable.Set</pre></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Additions:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">+=</pre>&nbsp;<pre class="code">x</pre>
  </td>
  <td>
    Adds element <pre class="code">x</pre> to set <pre class="code">xs</pre> as a side effect and returns <pre class="code">xs</pre> itself<a id="i1314992430-2"/><a id="i-1209846120-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">+=</pre>&nbsp;<pre class="code">(x,</pre>&nbsp;<pre class="code">y,</pre>&nbsp;<pre class="code">z)</pre>
  </td>
  <td>
    Adds the given elements to set <pre class="code">xs</pre> as a side effect and returns <pre class="code">xs</pre> itself
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">++=</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    Adds all elements in <pre class="code">ys</pre> to set <pre class="code">xs</pre> as a side effect and returns <pre class="code">xs</pre> itself<a id="i-1693046362-2"/><a id="i-1254892180-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">add</pre>&nbsp;<pre class="code">x</pre>
  </td>
  <td>
    Adds element <pre class="code">x</pre> to <pre class="code">xs</pre> and returns <pre class="code">true</pre> if <pre class="code">x</pre> was 
                not previously contained in the set, <pre class="code">false</pre> if it was previously contained<a id="i381468769-1"/><a id="i-1766692446-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Removals:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">-=</pre>&nbsp;<pre class="code">x</pre>
  </td>
  <td>
    Removes element <pre class="code">x</pre> from set <pre class="code">xs</pre> as a side effect and returns <pre class="code">xs</pre> itself<a id="i1816671796-2"/><a id="i-282687116-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">-=</pre>&nbsp;<pre class="code">(x,</pre>&nbsp;<pre class="code">y,</pre>&nbsp;<pre class="code">z)</pre>
  </td>
  <td>
    Removes the given elements from set <pre class="code">xs</pre> as a side effect and returns <pre class="code">xs</pre> itself
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">--=</pre>&nbsp;<pre class="code">ys</pre>
  </td>
  <td>
    Removes all elements in <pre class="code">ys</pre> from set <pre class="code">xs</pre> as a side effect and returns <pre class="code">xs</pre> itself<a id="i-610143062-2"/><a id="i-1485797315-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">remove</pre>&nbsp;<pre class="code">x</pre>
  </td>
  <td>
    Removes element <pre class="code">x</pre> from <pre class="code">xs</pre> and returns <pre class="code">true</pre> if <pre class="code">x</pre> was
                previously contained in the set, <pre class="code">false</pre> if it was not previously contained<a id="i1270439364-1"/><a id="i-517415965-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">retain</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    Keeps only those elements in <pre class="code">xs</pre> that satisfy predicate <pre class="code">p</pre> <a id="i1264220869-1"/><a id="i-517221276-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.clear()</pre>
  </td>
  <td>
    Removes all elements from <pre class="code">xs</pre><a id="i-914291699-2"/><a id="i-1277269234-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Update:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs(x)</pre>&nbsp;<pre class="code">=</pre>&nbsp;<pre class="code">b</pre>
  </td>
  <td>
    (or, written out, <pre class="code">xs.update(x,</pre>&nbsp;<pre class="code">b)</pre>) If boolean argument <pre class="code">b</pre> is
                <pre class="code">true</pre>, adds <pre class="code">x</pre> to <pre class="code">xs</pre>, otherwise removes <pre class="code">x</pre> from <pre class="code">xs</pre><a id="i2073506953-1"/><a id="i-421651416-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Cloning:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs.clone</pre>
  </td>
  <td>
    A new mutable set with the same elements as <pre class="code">xs</pre><a id="i-1974537443-1"/><a id="i-1277259234-1"/>
  </td>
</tr>
</table>


<p>Just like an immutable set, a mutable set offers the <pre class="code">+</pre> and <pre class="code">++</pre>
operations for element additions and the <pre class="code">-</pre> and <pre class="code">--</pre> operations for
element removals.  But these are less often used for mutable sets
since they involve copying the set. As a more efficient alternative,
mutable sets offer the update methods <pre class="code">+=</pre> and <pre class="code">-=</pre>. The operation
<pre class="code">s</pre>&nbsp;<pre class="code">+=</pre>&nbsp;<pre class="code">elem</pre> adds <pre class="code">elem</pre> to the set <pre class="code">s</pre> as a side effect, and
returns the mutated set as a result. Likewise, <pre class="code">s</pre>&nbsp;<pre class="code">-=</pre>&nbsp;<pre class="code">elem</pre> removes
<pre class="code">elem</pre> from the set, and returns the mutated set as a result.
Besides <pre class="code">+=</pre> and <pre class="code">-=</pre> there are also the bulk operations <pre class="code">++=</pre> and
<pre class="code">--=</pre>, which add or remove all elements of a traversable or an
iterator.</p>

<p>The choice of the method names <pre class="code">+=</pre> and <pre class="code">-=</pre> means that very similar code 
can work with either mutable or immutable sets.
Consider first the following interpreter dialogue that uses an immutable set <pre class="code">s</pre>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">var</code>&nbsp;s&nbsp;=&nbsp;<code class="typename">Set</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">s:&nbsp;scala.collection.immutable.Set[Int]&nbsp;=&nbsp;Set(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;s&nbsp;+=&nbsp;<code class="literal">4</code>;&nbsp;s&nbsp;-=&nbsp;<code class="literal">2</code>
  <br />  scala&gt;&nbsp;s
  <code class="output">res10:&nbsp;scala.collection.immutable.Set[Int]&nbsp;=&nbsp;Set(1,&nbsp;3,&nbsp;4)</code>
</pre>


<p>In this example, we used <pre class="code">+=</pre> and <pre class="code">-=</pre> on a <pre class="code">var</pre> of type <pre class="code">immutable.Set</pre>. 
As was explained in <a href="next-steps-in-scala.html#step10">Step 10</a> in <a href="next-steps-in-scala.html">Chapter 3</a>, a statement such as 
<pre class="code">s</pre>&nbsp;<pre class="code">+=</pre>&nbsp;<pre class="code">4</pre> is an abbreviation for <pre class="code">s</pre>&nbsp;<pre class="code">=</pre>&nbsp;<pre class="code">s</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">4</pre>. So this invokes the 
addition method <pre class="code">+</pre> on the set <pre class="code">s</pre> and then assigns the result back to the <pre class="code">s</pre> variable.
Consider now an analogous interaction with a mutable set:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;s&nbsp;=&nbsp;<code class="typename">collection.mutable.Set</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">s:&nbsp;scala.collection.mutable.Set[Int]&nbsp;=&nbsp;Set(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;s&nbsp;+=&nbsp;<code class="literal">4</code>
  <code class="output">res11:&nbsp;s.type&nbsp;=&nbsp;Set(1,&nbsp;2,&nbsp;3,&nbsp;4)</code>
  <br />  scala&gt;&nbsp;s&nbsp;-=&nbsp;<code class="literal">2</code>
  <code class="output">res12:&nbsp;s.type&nbsp;=&nbsp;Set(1,&nbsp;3,&nbsp;4)</code>
</pre>


<p>The end effect is very similar to the previous interaction; we start
with a <pre class="code">Set(1,</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">3)</pre> and end up with a <pre class="code">Set(1,</pre>&nbsp;<pre class="code">3,</pre>&nbsp;<pre class="code">4)</pre>.  However,
even though the statements look the same as before, they do something
different.  The <pre class="code">s</pre>&nbsp;<pre class="code">+=</pre>&nbsp;<pre class="code">4</pre> statement now invokes the <pre class="code">+=</pre> method on the mutable set
value <pre class="code">s</pre>, changing the set in place. Likewise, the <pre class="code">s</pre>&nbsp;<pre class="code">-=</pre>&nbsp;<pre class="code">2</pre> statement now invokes
the <pre class="code">-=</pre> method on the same set.</p>

<p>Comparing the two interactions
shows an important principle. You often can replace a
mutable collection stored in a <pre class="code">val</pre> by an immutable collection stored
in a <pre class="code">var</pre>, and <span style="font-style:italic">vice versa</span>. This works at least as long as there are no 
alias references to the collection through which you can observe
whether it was updated in place or a new collection was created.</p>

<p>Mutable sets also provide <pre class="code">add</pre> and <pre class="code">remove</pre> as variants of <pre class="code">+=</pre>
and <pre class="code">-=</pre>. The difference is that <pre class="code">add</pre> and <pre class="code">remove</pre> return a
boolean result indicating whether the operation had an effect on
the set.</p>

<p>The current default implementation of a mutable set uses a hash table
to store the set's elements. The default implementation of an
immutable set uses a representation that adapts to the number of
elements of the set.
An empty set is represented by just a singleton
object. Sets of sizes up to four are represented by a single object
that stores all elements as fields. Beyond that size, immutable sets
are implemented as hash tries.<a href="collections-in-depth.html#footnotemain24-2">[2]</a></p>

<p>A consequence of these representation choices is that for sets of
small sizes, up to about four, immutable sets are more compact and
more efficient than mutable sets. So if you expect the size of a
set to be small, try to make it immutable.</p>

<h3>24.7 Maps</h3>


<p><pre class="code">Map</pre>s are <pre class="code">Iterable</pre>s of pairs of keys and values (also named
<span style="font-style:italic">mappings</span> or <span style="font-style:italic">associations</span>). As explained in <a href="implicit-conversions-and-parameters.html#sec-simulating-new-syntax">Section 21.4</a>,
Scala's <pre class="code">Predef</pre> class offers an implicit conversion
that lets you write <pre class="code">key</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">value</pre> as an alternate syntax for the
pair <pre class="code">(key,</pre>&nbsp;<pre class="code">value)</pre>.   
Therefore, <pre class="code">Map("x"</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">24,</pre>&nbsp;<pre class="code">"y"</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">25,</pre>&nbsp;<pre class="code">"z"</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">26)</pre> 
means exactly the same as 
<pre class="code">Map(("x",</pre>&nbsp;<pre class="code">24),</pre>&nbsp;<pre class="code">("y",</pre>&nbsp;<pre class="code">25),</pre>&nbsp;<pre class="code">("z",</pre>&nbsp;<pre class="code">26))</pre>, but reads better.</p>

<p>The fundamental operations on maps, summarized in <a href="collections-in-depth.html#tab-mapops">Table 24.7</a>,
are similar to those on sets.
Mutable maps additionally support the operations shown in <a href="collections-in-depth.html#tab-mutmapops">Table 24.8</a>.
Map operations fall into the following
categories:</p>

<ul>


<li><b><span style="font-style:italic">Lookups</span></b> <pre class="code">apply</pre>, <pre class="code">get</pre>, <pre class="code">getOrElse</pre>,
  <pre class="code">contains</pre>, and <pre class="code">isDefinedAt</pre>. These operations turn maps into partial
  functions from keys to values. The fundamental lookup method for a map is:


<pre>
  <code class="vem">def</code>&nbsp;get(key):&nbsp;<code class="typename">Option[Value]</code>&nbsp;
</pre>


<p>The operation "<pre class="code">m</pre>&nbsp;<pre class="code">get</pre>&nbsp;<pre class="code">key</pre>" tests whether the map
contains an association for the given <pre class="code">key</pre>. If so, it returns the
associated value in a <pre class="code">Some</pre>. If no <pre class="code">key</pre> is defined in the map,
<pre class="code">get</pre> returns <pre class="code">None</pre>. 
Maps also define an <pre class="code">apply</pre> method that returns 
the value associated
with a given key directly, without wrapping it in an <pre class="code">Option</pre>. If the
key is not defined in the map, an exception is raised.</p>

</li>
<li><b><span style="font-style:italic">Additions and updates</span></b> <pre class="code">+</pre>, <pre class="code">++</pre>, and <pre class="code">updated</pre>, which let you
  add new bindings to a map or change existing bindings.


</li>
<li><b><span style="font-style:italic">Removals</span></b> <pre class="code">-</pre> and <pre class="code">--</pre>, which remove bindings
  from a map.


</li>
<li><b><span style="font-style:italic">Subcollection producers</span></b> <pre class="code">keys</pre>, <pre class="code">keySet</pre>,
  <pre class="code">keysIterator</pre>, <pre class="code">valuesIterator</pre>, and <pre class="code">values</pre>, which return a map's
  keys and values separately in various forms.


</li>
<li><b><span style="font-style:italic">Transformations</span></b> <pre class="code">filterKeys</pre> and <pre class="code">mapValues</pre>, which
  produce a new map by filtering and transforming bindings of an existing map.


</li></ul>


<p><a id="tab-mapops"/></p>

<h5>Operations in trait <pre class="code">Map</pre> <a id="i-1799914245-1"/></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Lookups:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">get</pre>&nbsp;<pre class="code">k</pre>
  </td>
  <td>
    The value associated with key <pre class="code">k</pre> in map <pre class="code">ms</pre> as an option, or <pre class="code">None</pre> if not found<a id="i-1160987621-1"/><a id="i-1633357539-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms(k)</pre>
  </td>
  <td>
    (or, written out, <pre class="code">ms</pre>&nbsp;<pre class="code">apply</pre>&nbsp;<pre class="code">k</pre>)
                 The value associated with key <pre class="code">k</pre> in map <pre class="code">ms</pre>, or a thrown exception if not found<a id="i648989597-3"/><a id="i-1998745739-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">getOrElse</pre>&nbsp;<pre class="code">(k,</pre>&nbsp;<pre class="code">d)</pre>
  </td>
  <td>
    The value associated with key <pre class="code">k</pre> in map <pre class="code">ms</pre>, or the default value <pre class="code">d</pre> if not found<a id="i-1472564161-1"/><a id="i1555511609-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">contains</pre>&nbsp;<pre class="code">k</pre>
  </td>
  <td>
    Tests whether <pre class="code">ms</pre> contains a mapping for key <pre class="code">k</pre><a id="i-1171514126-2"/><a id="i-955049800-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">isDefinedAt</pre>&nbsp;<pre class="code">k</pre>
  </td>
  <td>
    Same as <pre class="code">contains</pre><a id="i2055622367-1"/><a id="i1960441049-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Additions and updates:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">(k</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">v)</pre>
  </td>
  <td>
    The map containing all mappings of <pre class="code">ms</pre> as well as the mapping <pre class="code">k</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">v</pre> from key <pre class="code">k</pre> to value <pre class="code">v</pre><a id="i979720815-2"/><a id="i1877298566-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">(k</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">v,</pre>&nbsp;<pre class="code">l</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">w)</pre>
  </td>
  <td>
    The map containing all mappings of <pre class="code">ms</pre> as well as the given key/value pairs
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">++</pre>&nbsp;<pre class="code">kvs</pre>
  </td>
  <td>
    The map containing all mappings of <pre class="code">ms</pre> as well as all key/value pairs of <pre class="code">kvs</pre><a id="i-2098881509-2"/><a id="i-1132988814-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">updated</pre>&nbsp;<pre class="code">(k,</pre>&nbsp;<pre class="code">v)</pre>
  </td>
  <td>
    Same as <pre class="code">ms</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">(k</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">v)</pre><a id="i280406998-1"/><a id="i-385480958-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Removals:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">-</pre>&nbsp;<pre class="code">k</pre>
  </td>
  <td>
    The map containing all mappings of <pre class="code">ms</pre> except for any mapping of key <pre class="code">k</pre><a id="i345428644-2"/><a id="i-191488371-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">-</pre>&nbsp;<pre class="code">(k,</pre>&nbsp;<pre class="code">l,</pre>&nbsp;<pre class="code">m)</pre>
  </td>
  <td>
    The map containing all mappings of <pre class="code">ms</pre> except for any mapping with the given keys
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">--</pre>&nbsp;<pre class="code">ks</pre>
  </td>
  <td>
    The map containing all mappings of <pre class="code">ms</pre> except for any mapping with a key in <pre class="code">ks</pre><a id="i710869262-2"/><a id="i2074410039-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Subcollections:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms.keys</pre>
  </td>
  <td>
    An iterable containing each key in <pre class="code">ms</pre><a id="i1213467709-2"/><a id="i905643277-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms.keySet</pre>
  </td>
  <td>
    A set containing each key in <pre class="code">ms</pre><a id="i891405326-2"/><a id="i-1555199396-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms.keysIterator</pre>
  </td>
  <td>
    An iterator yielding each key in <pre class="code">ms</pre><a id="i1344362607-1"/><a id="i854987931-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms.values</pre>
  </td>
  <td>
    An iterable containing each value associated with a key in <pre class="code">ms</pre><a id="i-546077233-2"/><a id="i-1244327429-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms.valuesIterator</pre>
  </td>
  <td>
    An iterator yielding each value associated
with a key in <pre class="code">ms</pre><a id="i1069490177-1"/><a id="i1168331657-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Transformation:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">filterKeys</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    A map view containing only those mappings in <pre class="code">ms</pre> where the key
                satisfies predicate <pre class="code">p</pre><a id="i1510668197-1"/><a id="i-378449435-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">mapValues</pre>&nbsp;<pre class="code">f</pre>
  </td>
  <td>
    A map view resulting from applying function <pre class="code">f</pre> to each value
                associated with a key in <pre class="code">ms</pre><a id="i26169043-1"/><a id="i1850239525-1"/>
  </td>
</tr>
</table>


<p><a id="tab-mutmapops"/></p>

<h5>Operations in trait <pre class="code">mutable.Map</pre></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Additions and updates:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms(k)</pre>&nbsp;<pre class="code">=</pre>&nbsp;<pre class="code">v</pre>
  </td>
  <td>
    (or, written out, <pre class="code">ms.update(k,</pre>&nbsp;<pre class="code">v)</pre>) Adds mapping from key <pre class="code">k</pre> to value <pre class="code">v</pre> to map <pre class="code">ms</pre> as a side effect, overwriting
                any previous mapping of <pre class="code">k</pre><a id="i2073501059-1"/><a id="i-1259360862-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">+=</pre>&nbsp;<pre class="code">(k</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">v)</pre>
  </td>
  <td>
    Adds mapping from key <pre class="code">k</pre> to value <pre class="code">v</pre> to map <pre class="code">ms</pre> as a side effect and returns <pre class="code">ms</pre> itself<a id="i1314809716-2"/><a id="i2003257106-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">+=</pre>&nbsp;<pre class="code">(k</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">v,</pre>&nbsp;<pre class="code">l</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">w)</pre>
  </td>
  <td>
    Adds the given mappings to <pre class="code">ms</pre> as a side effect and returns <pre class="code">ms</pre> itself
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">++=</pre>&nbsp;<pre class="code">kvs</pre>
  </td>
  <td>
    Adds all mappings in <pre class="code">kvs</pre> to <pre class="code">ms</pre> as a side effect and returns <pre class="code">ms</pre> itself<a id="i-1693229076-2"/><a id="i-1544177818-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">put</pre>&nbsp;<pre class="code">(k,</pre>&nbsp;<pre class="code">v)</pre>
  </td>
  <td>
    Adds mapping from key <pre class="code">k</pre> to value <pre class="code">v</pre> to <pre class="code">ms</pre> and returns any value
                     previously associated with <pre class="code">k</pre> as an option<a id="i-254405943-1"/><a id="i-1633348394-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">getOrElseUpdate</pre>&nbsp;<pre class="code">(k,</pre>&nbsp;<pre class="code">d)</pre>
  </td>
  <td>
    If key <pre class="code">k</pre> is defined in map <pre class="code">ms</pre>, returns its associated value. Otherwise,
                updates <pre class="code">ms</pre> with the mapping <pre class="code">k</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">d</pre> and returns <pre class="code">d</pre><a id="i1864005077-1"/><a id="i1498468194-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Removals:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">-=</pre>&nbsp;<pre class="code">k</pre>
  </td>
  <td>
    Removes mapping with key <pre class="code">k</pre> from <pre class="code">ms</pre> as a side effect and returns <pre class="code">ms</pre> itself<a id="i1816489082-2"/><a id="i1608234298-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">-=</pre>&nbsp;<pre class="code">(k,</pre>&nbsp;<pre class="code">l,</pre>&nbsp;<pre class="code">m)</pre>
  </td>
  <td>
    Removes mappings with the given keys from <pre class="code">ms</pre> as a side effect and returns <pre class="code">ms</pre> itself
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">--=</pre>&nbsp;<pre class="code">ks</pre>
  </td>
  <td>
    Removes all keys in <pre class="code">ks</pre> from <pre class="code">ms</pre> as a side effect and returns <pre class="code">ms</pre> itself<a id="i-610325776-2"/><a id="i-1837007177-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">remove</pre>&nbsp;<pre class="code">k</pre>
  </td>
  <td>
    Removes any mapping with key <pre class="code">k</pre> from <pre class="code">ms</pre> and returns  any value
                     previously associated with <pre class="code">k</pre> as an option<a id="i1270433470-1"/><a id="i-1355125411-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">retain</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    Keeps only those mappings in <pre class="code">ms</pre> that have a key satisfying predicate <pre class="code">p</pre>.<a id="i1264214975-1"/><a id="i-1354930722-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms.clear()</pre>
  </td>
  <td>
    Removes all mappings from <pre class="code">ms</pre><a id="i-914297593-1"/><a id="i-1997028780-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Transformation and cloning:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms</pre>&nbsp;<pre class="code">transform</pre>&nbsp;<pre class="code">f</pre>
  </td>
  <td>
    Transforms all associated values in map <pre class="code">ms</pre> with function <pre class="code">f</pre>
  </td>
</tr>
<tr>
  <td>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">ms.clone</pre>
  </td>
  <td>
    Returns a new mutable map with the same mappings as <pre class="code">ms</pre><a id="i-1974543337-1"/><a id="i-1997018780-1"/>
  </td>
</tr>
</table>


<p>The addition and removal operations for maps mirror those for sets.
As for sets, mutable maps also support the non-destructive
addition operations <pre class="code">+</pre>, <pre class="code">-</pre>, and <pre class="code">updated</pre>, but they are used less
frequently because they involve a copying of the mutable map. 
Instead, a mutable map <pre class="code">m</pre> is usually updated "in place," using
the two variants <pre class="code">m(key)</pre>&nbsp;<pre class="code">=</pre>&nbsp;<pre class="code">value</pre> or <pre class="code">m</pre>&nbsp;<pre class="code">+=</pre>&nbsp;<pre class="code">(key</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">value)</pre>. There is also the variant <pre class="code">m</pre>&nbsp;<pre class="code">put</pre>&nbsp;<pre class="code">(key,</pre>&nbsp;<pre class="code">value)</pre>, which
returns an <pre class="code">Option</pre> value that contains the value 
previously associated with <pre class="code">key</pre>, or <pre class="code">None</pre> if the <pre class="code">key</pre> did not
exist in the map before.</p>

<p>The <pre class="code">getOrElseUpdate</pre> is useful for accessing maps that act as
caches. Say you have an expensive computation triggered by invoking
a function <pre class="code">f</pre>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;f(x:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"taking&nbsp;my&nbsp;time."</code>);&nbsp;Thread.sleep(<code class="literal">100</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.reverse&nbsp;}
  <code class="output">f:&nbsp;(x:&nbsp;String)String</code>
</pre>


<p>Assume further that <pre class="code">f</pre> has no side-effects, so invoking it again
with the same argument will always yield the same result. In that case
you could save time by storing previously computed bindings of
argument and results of <pre class="code">f</pre> in a map, and only computing the result of
<pre class="code">f</pre> if a result of an argument was not found there. You could say the map is a
<span style="font-style:italic">cache</span> for the computations of the function <pre class="code">f</pre>.</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;cache&nbsp;=&nbsp;<code class="typename">collection.mutable.Map[String,&nbsp;String]</code>()
  <code class="output">cache:&nbsp;scala.collection.mutable.Map[String,String]&nbsp;=&nbsp;Map()</code>
</pre>


<p>You can now create a more efficient caching version of the <pre class="code">f</pre>
function:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;cachedF(s:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;cache.getOrElseUpdate(s,&nbsp;f(s))
  <code class="output">cachedF:&nbsp;(s:&nbsp;String)String</code>
  <br />  scala&gt;&nbsp;cachedF(<code class="quotedstring">"abc"</code>)
  <code class="output">taking&nbsp;my&nbsp;time.</code>
  <code class="output">res16:&nbsp;String&nbsp;=&nbsp;cba</code>
  <br />  scala&gt;&nbsp;cachedF(<code class="quotedstring">"abc"</code>)
  <code class="output">res17:&nbsp;String&nbsp;=&nbsp;cba</code>
</pre>


<p>Note that the second argument to <pre class="code">getOrElseUpdate</pre> is "by-name,"
so the computation of <pre class="code">f("abc")</pre> above is only performed if
<pre class="code">getOrElseUpdate</pre> requires the value of its second argument, which is
precisely if its first argument is not found in the <pre class="code">cache</pre> map.
You could also have implemented <pre class="code">cachedF</pre> directly, using just basic
map operations, but it would have have taken more code to do so:</p>

<pre>
  <code class="vem">def</code>&nbsp;cachedF(arg:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;cache&nbsp;get&nbsp;arg&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Some</code>(result)&nbsp;=&gt;&nbsp;result
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">None</code>&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;result&nbsp;=&nbsp;f(arg)
  &nbsp;&nbsp;&nbsp;&nbsp;cache(arg)&nbsp;=&nbsp;result
  &nbsp;&nbsp;&nbsp;&nbsp;result
  }
</pre>


<h3>24.8 Concrete immutable collection classes</h3>


<p>Scala provides many concrete immutable collection classes for you to
choose from.  They differ in the traits they implement (maps, sets,
sequences), whether they can be infinite, and the speed of
various operations.  We'll start by reviewing the most
common immutable collection types.</p>

<h4>Lists</h4>


<p>Lists are finite immutable sequences.  They provide constant-time
access to their first element as well as the rest of the list, and
they have a constant-time cons operation for adding a new element to
the front of the list.  Many other operations take linear time.  See
<a href="working-with-lists.html">Chapters 16</a> and<a href="implementing-lists.html"> 22</a>
for extensive discussions about lists.</p>

<h4>Streams</h4>


<p>A stream is like a list except that its elements are computed lazily.<a id="i-1334114643-2"/>
Because of this, a stream can be infinitely long.  Only those elements
requested will be computed.  Otherwise, streams have the same performance
characteristics as lists.</p>

<p>Whereas lists are constructed with the <pre class="code">::</pre> operator, streams are
constructed with the similar-looking <pre class="code">#::</pre>.  Here is a simple example
of a stream containing the integers 1, 2, and 3:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;str&nbsp;=&nbsp;<code class="literal">1</code>&nbsp;#::&nbsp;<code class="literal">2</code>&nbsp;#::&nbsp;<code class="literal">3</code>&nbsp;#::&nbsp;Stream.empty
  <code class="output">str:&nbsp;scala.collection.immutable.Stream[Int]&nbsp;=&nbsp;Stream(1,&nbsp;?)</code>
</pre>


<p>The head of this stream is 1, and the tail of it has 2 and 3.  The
tail is not printed here, though, because it hasn't been computed yet!
Streams are required to compute lazily, and the <pre class="code">toString</pre> method of a
stream is careful not to force any extra evaluation.</p>

<p>Below is a more complex example.  It computes a stream that contains a
Fibonacci sequence starting with the given two numbers.  A Fibonacci
sequence is one where each element is the sum of the previous two
elements in the series:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;fibFrom(a:&nbsp;<code class="typename">Int</code>,&nbsp;b:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Stream[Int]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;#::&nbsp;fibFrom(b,&nbsp;a&nbsp;+&nbsp;b)
  <code class="output">fibFrom:&nbsp;(a:&nbsp;Int,&nbsp;b:&nbsp;Int)Stream[Int]</code>
</pre>


<p>This function is deceptively simple.  The first element of the
sequence is clearly <pre class="code">a</pre>, and the rest of the sequence is the
Fibonacci sequence starting with <pre class="code">b</pre> followed by <pre class="code">a</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">b</pre>.  The tricky
part is computing this sequence without causing an infinite recursion.
If the function used <pre class="code">::</pre> instead of <pre class="code">#::</pre>, then every call to the
function would result in another call, thus causing an infinite
recursion.  Since it uses <pre class="code">#::</pre>, though, the right-hand side is not
evaluated until it is requested.</p>

<p>Here are the first few elements of the Fibonacci sequence starting
with two ones:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fibs&nbsp;=&nbsp;fibFrom(<code class="literal">1</code>,&nbsp;<code class="literal">1</code>).take(<code class="literal">7</code>)
  <code class="output">fibs:&nbsp;scala.collection.immutable.Stream[Int]&nbsp;=&nbsp;Stream(1,&nbsp;?)</code>
  <br />  scala&gt;&nbsp;fibs.toList
  <code class="output">res23:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;5,&nbsp;8,&nbsp;13)</code>
</pre>


<h4>Vectors</h4>


<p><a id="sec-collections-api-vectors"/></p>

<p>Lists are very efficient when the algorithm processing them is careful
to only process their heads.  Accessing, adding, and removing the head
of a list takes only constant time, whereas accessing or modifying
elements later in the list takes time linear in the depth into the
list.</p>

<p>Vectors are a collection type that give
efficient access to elements beyond the head.
Access to any elements of a vector take only "effectively constant time,"
as defined below.
It's a larger constant than for access to
the head of a list or for reading an element of an array, but it's a
constant nonetheless. As a result, algorithms using vectors do not
have to be careful about accessing just the head of the
sequence. They can access and modify elements at arbitrary
locations, and thus they can be much more convenient to write.</p>

<p>Vectors are built and modified just like any other sequence:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;vec&nbsp;=&nbsp;scala.collection.immutable.Vector.empty
  <code class="output">vec:&nbsp;scala.collection.immutable.Vector[Nothing]&nbsp;=&nbsp;Vector()</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;vec2&nbsp;=&nbsp;vec&nbsp;:+&nbsp;<code class="literal">1</code>&nbsp;:+&nbsp;<code class="literal">2</code>
  <code class="output">vec2:&nbsp;scala.collection.immutable.Vector[Int]&nbsp;=&nbsp;Vector(1,&nbsp;2)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;vec3&nbsp;=&nbsp;<code class="literal">100</code>&nbsp;+:&nbsp;vec2
  <code class="output">vec3:&nbsp;scala.collection.immutable.Vector[Int]</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;Vector(100,&nbsp;1,&nbsp;2)</code>
  <br />  scala&gt;&nbsp;vec3(<code class="literal">0</code>)
  <code class="output">res24:&nbsp;Int&nbsp;=&nbsp;100</code>
</pre>


<p>Vectors are represented as broad, shallow trees. Every
tree node contains up to 32 elements of the vector or contains up to
32 other tree nodes. Vectors with up to 32 elements can be represented
in a single node. Vectors with up to <pre class="code">32</pre>&nbsp;<pre class="code">*</pre>&nbsp;<pre class="code">32</pre>&nbsp;<pre class="code">=</pre>&nbsp;<pre class="code">1024</pre> elements can be
represented with a single indirection. Two hops from the root of the
tree to the final element node are sufficient for vectors with up to
2<sup>15</sup> elements, three hops for vectors with 2<sup>20</sup>, four hops for
vectors with 2<sup>25</sup> elements and five hops for vectors with up to
2<sup>30</sup> elements. So for all vectors of reasonable size, an element
selection involves up to five primitive array selections. This is what we
meant when we wrote that element access is "effectively constant
time."</p>

<p>Vectors are immutable, so you cannot change an element of a vector in place.
However, with the <pre class="code">updated</pre> method you can
create a new vector that differs from a given vector only
in a single element:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;vec&nbsp;=&nbsp;<code class="typename">Vector</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">vec:&nbsp;scala.collection.immutable.Vector[Int]&nbsp;=&nbsp;Vector(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;vec&nbsp;updated&nbsp;(<code class="literal">2</code>,&nbsp;<code class="literal">4</code>)
  <code class="output">res25:&nbsp;scala.collection.immutable.Vector[Int]&nbsp;=&nbsp;Vector(1,&nbsp;2,&nbsp;4)</code>
  <br />  scala&gt;&nbsp;vec
  <code class="output">res26:&nbsp;scala.collection.immutable.Vector[Int]&nbsp;=&nbsp;Vector(1,&nbsp;2,&nbsp;3)</code>
</pre>


<p>As the last line above shows, a call to <pre class="code">updated</pre> has no effect on
the original vector <pre class="code">vec</pre>. Like selection, functional vector updates
are also "effectively constant time." Updating an element in the
middle of a vector can be done by copying the node that contains the
element, and every node that points to it, starting from the root of
the tree.  This means that a functional update creates between one and
five nodes that each contain up to 32 elements or subtrees. This is 
certainly more expensive than an in-place update in a mutable array, but 
still a lot cheaper than copying the whole vector.</p>

<p>Because vectors strike a good balance between fast random selections and 
fast random functional updates, they are currently the default implementation of
immutable indexed sequences:</p>

<pre>
  scala&gt;&nbsp;<code class="typename">collection.immutable.IndexedSeq</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res27:&nbsp;scala.collection.immutable.IndexedSeq[Int]</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;Vector(1,&nbsp;2,&nbsp;3)</code>
</pre>


<h4>Immutable stacks</h4>


<p>If you need a last-in-first-out sequence, you can use a
<pre class="code">Stack</pre><a id="i-1444208192-1"/>.  You push an element
onto a stack with <pre class="code">push</pre><a id="i-995193675-1"/>, pop an element with <pre class="code">pop</pre><a id="i14430026-1"/>, and peek at the top of the stack without
removing it with <pre class="code">top</pre><a id="i-361766182-1"/>.  All of these operations are constant time.</p>

<p>Here are some simple operations performed on a stack:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;stack&nbsp;=&nbsp;scala.collection.immutable.Stack.empty
  <code class="output">stack:&nbsp;scala.collection.immutable.Stack[Nothing]&nbsp;=&nbsp;Stack()</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;hasOne&nbsp;=&nbsp;stack.push(<code class="literal">1</code>)
  <code class="output">hasOne:&nbsp;scala.collection.immutable.Stack[Int]&nbsp;=&nbsp;Stack(1)</code>
  <br />  scala&gt;&nbsp;stack
  <code class="output">res28:&nbsp;scala.collection.immutable.Stack[Nothing]&nbsp;=&nbsp;Stack()</code>
  <br />  scala&gt;&nbsp;hasOne.top
  <code class="output">res29:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br />  scala&gt;&nbsp;hasOne.pop
  <code class="output">res30:&nbsp;scala.collection.immutable.Stack[Int]&nbsp;=&nbsp;Stack()</code>
</pre>


<p>Immutable stacks are used rarely in Scala programs because their
functionality is subsumed by lists: A <pre class="code">push</pre> on an immutable stack is
the same as a <pre class="code">::</pre> on a list, and a <pre class="code">pop</pre> on a stack is the same a
<pre class="code">tail</pre> on a list.</p>

<h4>Immutable queues</h4>


<p>A queue is just like a stack except that it is first-in-first-out
rather than last-in-first-out<a id="i-705909367-1"/>. A simplified implementation of immutable queues was discussed in
<a href="type-parameterization.html">Chapter 19</a>. Here's how you can create an empty immutable queue:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;empty&nbsp;=&nbsp;<code class="typename">scala.collection.immutable.Queue[Int]</code>()
  <code class="output">empty:&nbsp;scala.collection.immutable.Queue[Int]&nbsp;=&nbsp;Queue()</code>
</pre>


<p>You can append an element to an immutable queue with 
<pre class="code">enqueue</pre><a id="i432237508-1"/>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;has1&nbsp;=&nbsp;empty.enqueue(<code class="literal">1</code>)
  <code class="output">has1:&nbsp;scala.collection.immutable.Queue[Int]&nbsp;=&nbsp;Queue(1)</code>
</pre>


<p>To append multiple elements to a queue, call <pre class="code">enqueue</pre>
with a collection as its argument:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;has123&nbsp;=&nbsp;has1.enqueue(<code class="typename">List</code>(<code class="literal">2</code>,&nbsp;<code class="literal">3</code>))
  <code class="output">has123:&nbsp;scala.collection.immutable.Queue[Int]&nbsp;=&nbsp;Queue(1,&nbsp;2,&nbsp;</code>
  <code class="output">3)</code>
</pre>


<p>To remove an element from the head of the queue, use
<pre class="code">dequeue</pre><a id="i2031764716-1"/>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;(element,&nbsp;has23)&nbsp;=&nbsp;has123.dequeue
  <code class="output">element:&nbsp;Int&nbsp;=&nbsp;1</code>
  <code class="output">has23:&nbsp;scala.collection.immutable.Queue[Int]&nbsp;=&nbsp;Queue(2,&nbsp;3)</code>
</pre>


<p>Note that <pre class="code">dequeue</pre> returns a pair consisting of the element
removed and the rest of the queue.</p>

<h4>Ranges</h4>


<p>A range is an ordered sequence of integers that are equally spaced
apart.  For example, "1, 2, 3" is a range, as is "5, 8, 11, 14."
To create a range in Scala, use the predefined methods <pre class="code">to</pre> and
<pre class="code">by</pre>. Here are some examples:</p>

<pre>
  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">3</code>
  <code class="output">res31:&nbsp;scala.collection.immutable.Range.Inclusive</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;Range(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;<code class="literal">5</code>&nbsp;to&nbsp;<code class="literal">14</code>&nbsp;by&nbsp;<code class="literal">3</code>
  <code class="output">res32:&nbsp;scala.collection.immutable.Range&nbsp;=&nbsp;Range(5,&nbsp;8,&nbsp;11,&nbsp;14)</code>
</pre>


<p>If you want to create a range that is exclusive of its upper limit,
 use the convenience method <pre class="code">until</pre> instead of <pre class="code">to</pre>:</p>

<pre>
  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;until&nbsp;<code class="literal">3</code>
  <code class="output">res33:&nbsp;scala.collection.immutable.Range&nbsp;=&nbsp;Range(1,&nbsp;2)</code>
</pre>


<p>Ranges are represented in constant space, because they can be defined
by just three numbers: their start, their end, and the stepping value.
Because of this representation, most operations on ranges are
extremely fast.</p>

<h4>Hash tries</h4>


<p><a id="sec-hash-tries"/></p>

<p>Hash tries<a href="collections-in-depth.html#footnotemain24-3">[3]</a> are a standard way to implement immutable sets and maps efficiently.  Their representation is similar to vectors in that they
are also trees where every node has 32 elements or 32 subtrees, but selection is done based on a hash code.
For instance, to find a given key in a map, you use the lowest five bits of the hash code of the key to
select the first subtree, the next five bits the next subtree, and so on.
Selection stops once all elements stored in a node have hash codes
that differ from each other in the bits that are selected so far.
Thus, not all the bits of the hash code are necessarily used.</p>

<p>Hash tries strike a nice balance between reasonably fast lookups and
reasonably efficient functional insertions <pre class="code">(+)</pre> and deletions
<pre class="code">(-)</pre>.  That's why they underlie Scala's default implementations of
immutable maps and sets. In fact, Scala has a further optimization for
immutable sets and maps that contain less than five elements.  Sets
and maps with one to four elements are stored as single objects that
just contain the elements (or key/value pairs in the case of a map) as
fields. The empty immutable set and empty immutable map is in each
case a singleton object&mdash;there's no need to duplicate storage for those
because an empty immutable set or map will always stay empty.</p>

<h4>Red-black trees</h4>


<p>Red-black trees are a form of balanced binary trees where some nodes
are designated "red" and others "black."  Like any
balanced binary tree, operations on them reliably complete in time
logarithmic to the size of the tree.</p>

<p>Scala provides implementations of sets and maps that use a red-black
tree internally. You access them under the names <pre class="code">TreeSet</pre> and <pre class="code">TreeMap</pre>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;set&nbsp;=&nbsp;collection.immutable.TreeSet.empty[<code class="typename">Int</code>]
  <code class="output">set:&nbsp;scala.collection.immutable.TreeSet[Int]&nbsp;=&nbsp;TreeSet()</code>
  <br />  scala&gt;&nbsp;set&nbsp;+&nbsp;<code class="literal">1</code>&nbsp;+&nbsp;<code class="literal">3</code>&nbsp;+&nbsp;<code class="literal">3</code>
  <code class="output">res34:&nbsp;scala.collection.immutable.TreeSet[Int]&nbsp;=&nbsp;TreeSet(1,&nbsp;3)</code>
</pre>


<p>Red-black trees are also the standard implementation of <pre class="code">SortedSet</pre> 
in Scala, because they provide an efficient iterator that returns
all elements of the set in sorted order.</p>

<h4>Immutable bit sets</h4>


<p>A bit set represents a collection of small integers as the bits of a
larger integer. For example, the bit set containing 3, 2, and 0 would
be represented as the integer 1101 in binary, which is 13 in decimal.</p>

<p>Internally, bit sets use an array of 64-bit <pre class="code">Long</pre>s.  The first
<pre class="code">Long</pre> in the array is for integers 0 through 63, the second is for
64 through 127, and so on.  Thus, bit sets are very compact so long as
the largest integer in the set is less than a few hundred or so.</p>

<p>Operations on bit sets are very fast.  Testing for inclusion takes
constant time.  Adding an item to the set takes time proportional to
the number of <pre class="code">Long</pre>s in the bit set's array, which is typically a
small number.  Here are some simple examples of the use of a bit set:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bits&nbsp;=&nbsp;scala.collection.immutable.BitSet.empty
  <code class="output">bits:&nbsp;scala.collection.immutable.BitSet&nbsp;=&nbsp;BitSet()</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;moreBits&nbsp;=&nbsp;bits&nbsp;+&nbsp;<code class="literal">3</code>&nbsp;+&nbsp;<code class="literal">4</code>&nbsp;+&nbsp;<code class="literal">4</code>
  <code class="output">moreBits:&nbsp;scala.collection.immutable.BitSet&nbsp;=&nbsp;BitSet(3,&nbsp;4)</code>
  <br />  scala&gt;&nbsp;moreBits(<code class="literal">3</code>)
  <code class="output">res35:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br />  scala&gt;&nbsp;moreBits(<code class="literal">0</code>)
  <code class="output">res36:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>


<h4>List maps</h4>


<p>A list map represents a map as a linked list of key-value pairs. In
general, operations on a list map might have to iterate through the
entire list. Thus, operations on a list map take time linear in the
size of the map. In fact there is little usage for list maps in Scala
because standard immutable maps are almost always faster. The only
possible difference is if the map is for some reason constructed in
such a way that the first elements in the list are selected much more
often than the other elements.</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;map&nbsp;=&nbsp;<code class="typename">collection.immutable.ListMap</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">1</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"one"</code>,&nbsp;<code class="literal">2</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"two"</code>)
  <code class="output">map:&nbsp;scala.collection.immutable.ListMap[Int,String]&nbsp;=&nbsp;Map(1&nbsp;</code>
  <code class="output">-&gt;&nbsp;one,&nbsp;2&nbsp;-&gt;&nbsp;two)</code>
  <br />  scala&gt;&nbsp;map(<code class="literal">2</code>)
  <code class="output">res37:&nbsp;String&nbsp;=&nbsp;"two"</code>
</pre>


<h3>24.9 Concrete mutable collection classes</h3>


<p>Now that you've seen the most commonly used immutable collection classes
that Scala provides in its standard library, take a look at 
the mutable collection classes.</p>

<h4>Array buffers</h4>


<p>You've already seen array buffers in
<a href="working-with-other-collections.html#sec-collections-arraybuf">Section 17.1</a>. An array buffer holds an
array and a size. Most operations on an array buffer have the same
speed as an array, because the operations simply access and modify the
underlying array. Additionally, array buffers can have data
efficiently added to the end. Appending an item to an array buffer
takes amortized constant time.
Thus, array buffers are useful for
efficiently building up a large collection whenever the new items are
always added to the end. Here are some examples:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;collection.mutable.ArrayBuffer.empty[<code class="typename">Int</code>]
  <code class="output">buf:&nbsp;scala.collection.mutable.ArrayBuffer[Int]</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;ArrayBuffer()</code>
  <br />  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">1</code>
  <code class="output">res38:&nbsp;buf.type&nbsp;=&nbsp;ArrayBuffer(1)</code>
  <br />  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">10</code>
  <code class="output">res39:&nbsp;buf.type&nbsp;=&nbsp;ArrayBuffer(1,&nbsp;10)</code>
  <br />  scala&gt;&nbsp;buf.toArray
  <code class="output">res40:&nbsp;Array[Int]&nbsp;=&nbsp;Array(1,&nbsp;10)</code>
</pre>


<h4>List buffers</h4>


<p>You've also already seen list buffers in
<a href="working-with-other-collections.html#sec-collections-listbuf">Section 17.1</a>.  A list buffer is like an
array buffer except that it uses a linked list internally instead of
an array. If you plan to convert the buffer to a list once it is built
up, use a list buffer instead of an array buffer. Here's an example:<a href="collections-in-depth.html#footnotemain24-4">[4]</a></p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;collection.mutable.ListBuffer.empty[<code class="typename">Int</code>]
  <code class="output">buf:&nbsp;scala.collection.mutable.ListBuffer[Int]</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;ListBuffer()</code>
  <br />  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">1</code>
  <code class="output">res41:&nbsp;buf.type&nbsp;=&nbsp;ListBuffer(1)</code>
  <br />  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">10</code>
  <code class="output">res42:&nbsp;buf.type&nbsp;=&nbsp;ListBuffer(1,&nbsp;10)</code>
  <br />  scala&gt;&nbsp;buf.toList
  <code class="output">res43:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;10)</code>
</pre>


<h4>String builders</h4>


<p>Just like an array buffer is useful for building arrays, and a list
buffer is useful for building lists, a string builder is useful for
building strings. String builders are so commonly used that they
are already imported into the default namespace. Create them with
a simple <pre class="code">new</pre>&nbsp;<pre class="code">StringBuilder</pre>, like this:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">StringBuilder</code>
  <code class="output">buf:&nbsp;StringBuilder&nbsp;=</code>
  <br />  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="quotedstring">'a'</code>
  <code class="output">res44:&nbsp;buf.type&nbsp;=&nbsp;a</code>
  <br />  scala&gt;&nbsp;buf&nbsp;++=&nbsp;<code class="quotedstring">"bcdef"</code>
  <code class="output">res45:&nbsp;buf.type&nbsp;=&nbsp;abcdef</code>
  <br />  scala&gt;&nbsp;buf.toString
  <code class="output">res46:&nbsp;String&nbsp;=&nbsp;abcdef</code>
</pre>


<h4>Linked lists</h4>


<p>Linked lists are mutable sequences that consist of nodes that are
linked with <pre class="code">next</pre> pointers. In most languages <pre class="code">null</pre> would be
picked as the empty linked list. That does not work for Scala
collections, because even empty sequences must support all sequence
methods. <pre class="code">LinkedList.empty.isEmpty</pre>, in particular, should return
<pre class="code">true</pre> and not throw a <pre class="code">NullPointerException</pre>. Empty linked lists
are encoded instead in a special way: Their <pre class="code">next</pre> field points back
to the node itself.</p>

<p>Like their immutable cousins, linked lists are best operated on
sequentially.  In addition, linked lists make it easy to insert an
element or linked list into another linked list.</p>

<h4>Double linked lists</h4>


<p><pre class="code">DoubleLinkedList</pre>s are like the single linked lists described in the
previous subsection, except besides <pre class="code">next</pre>, they have another
mutable field, <pre class="code">prev</pre>, that points to the element preceding the current
node. The main benefit of that additional link is that it makes
element removal very fast.</p>

<h4>Mutable lists</h4>


<p>A <pre class="code">MutableList</pre> consists of a single linked list together with a
pointer that refers to the terminal empty node of that list.  This
makes list append a constant time operation because it avoids having
to traverse the list in search for its terminal node. <pre class="code">MutableList</pre>
is currently the standard implementation of <pre class="code">mutable.LinearSeq</pre> in Scala.</p>

<h4>Queues</h4>


<p>Scala provides mutable queues in addition to immutable ones.  You use
a mutable queue similarly to the way you use an immutable one, but instead
of <pre class="code">enqueue</pre>, you use the <pre class="code">+=</pre> and <pre class="code">++=</pre> operators to append. Also,
on a mutable queue, the <pre class="code">dequeue</pre> method will just remove the head
element from the queue and return it. Here's an example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;queue&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">scala.collection.mutable.Queue[String]</code>
  <code class="output">queue:&nbsp;scala.collection.mutable.Queue[String]&nbsp;=&nbsp;Queue()</code>
  <br />  scala&gt;&nbsp;queue&nbsp;+=&nbsp;<code class="quotedstring">"a"</code>
  <code class="output">res47:&nbsp;queue.type&nbsp;=&nbsp;Queue(a)</code>
  <br />  scala&gt;&nbsp;queue&nbsp;++=&nbsp;<code class="typename">List</code>(<code class="quotedstring">"b"</code>,&nbsp;<code class="quotedstring">"c"</code>)
  <code class="output">res48:&nbsp;queue.type&nbsp;=&nbsp;Queue(a,&nbsp;b,&nbsp;c)</code>
  <br />  scala&gt;&nbsp;queue
  <code class="output">res49:&nbsp;scala.collection.mutable.Queue[String]&nbsp;=&nbsp;Queue(a,&nbsp;b,&nbsp;c)</code>
  <br />  scala&gt;&nbsp;queue.dequeue
  <code class="output">res50:&nbsp;String&nbsp;=&nbsp;a</code>
  <br />  scala&gt;&nbsp;queue
  <code class="output">res51:&nbsp;scala.collection.mutable.Queue[String]&nbsp;=&nbsp;Queue(b,&nbsp;c)</code>
</pre>


<h4>Array sequences</h4>


<p>Array sequences are mutable sequences of fixed size that store their
elements internally in an <pre class="code">Array[AnyRef]</pre>. They are implemented in
Scala by class <pre class="code">ArraySeq</pre>.</p>

<p>You would typically use an <pre class="code">ArraySeq</pre> if you want an array for its
performance characteristics, but you also want to create generic
instances of the sequence where you do not know the type of the
elements and do not have a <pre class="code">ClassTag</pre> to provide it at
run-time. You will find out about these issues with arrays shortly,
in <a href="collections-in-depth.html#sec-arrays">Section 24.10</a>.</p>

<h4>Stacks</h4>


<p>You saw immutable stacks earlier.  There is also a mutable version.
It works exactly the same as the immutable version except that
modifications happen in place. Here's an example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;stack&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">scala.collection.mutable.Stack[Int]</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">stack:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack()</code>
  <br />  scala&gt;&nbsp;stack.push(<code class="literal">1</code>)
  <code class="output">res52:&nbsp;stack.type&nbsp;=&nbsp;Stack(1)</code>
  <br />  scala&gt;&nbsp;stack
  <code class="output">res53:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack(1)</code>
  <br />  scala&gt;&nbsp;stack.push(<code class="literal">2</code>)
  <code class="output">res54:&nbsp;stack.type&nbsp;=&nbsp;Stack(2,&nbsp;1)</code>
  <br />  scala&gt;&nbsp;stack
  <code class="output">res55:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack(2,&nbsp;1)</code>
  <br />  scala&gt;&nbsp;stack.top
  <code class="output">res56:&nbsp;Int&nbsp;=&nbsp;2</code>
  <br />  scala&gt;&nbsp;stack
  <code class="output">res57:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack(2,&nbsp;1)</code>
  <br />  scala&gt;&nbsp;stack.pop
  <code class="output">res58:&nbsp;Int&nbsp;=&nbsp;2</code>
  <br />  scala&gt;&nbsp;stack&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">res59:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack(1)</code>
</pre>


<h4>Array stacks</h4>


<p><pre class="code">ArrayStack</pre> is an alternative implementation of a mutable stack,
which is backed by an <pre class="code">Array</pre> that gets resized as needed. It
provides fast indexing and is generally slightly more efficient for
most operations than a normal mutable stack.</p>

<h4>Hash tables</h4>


<p>A hash table stores its elements in an underlying array, placing each
item at a position in the array determined by the hash code of that
item. Adding an element to a hash table takes only constant time, so
long as there isn't already another element in the array that has the
same hash code. Hash tables are thus very fast so long as the objects
placed in them have a good distribution of hash codes. As a result,
the default mutable map and set types in Scala are based on hash
tables.</p>

<p>Hash sets and maps are used just like any other set or map. Here are
some simple examples:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;map&nbsp;=&nbsp;collection.mutable.HashMap.empty[<code class="typename">Int</code>,<code class="typename">String</code>]
  <code class="output">map:&nbsp;scala.collection.mutable.HashMap[Int,String]&nbsp;=&nbsp;Map()</code>
  <br />  scala&gt;&nbsp;map&nbsp;+=&nbsp;(<code class="literal">1</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"make&nbsp;a&nbsp;web&nbsp;site"</code>)
  <code class="output">res60:&nbsp;map.type&nbsp;=&nbsp;Map(1&nbsp;-&gt;&nbsp;make&nbsp;a&nbsp;web&nbsp;site)</code>
  <br />  scala&gt;&nbsp;map&nbsp;+=&nbsp;(<code class="literal">3</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"profit!"</code>)
  <code class="output">res61:&nbsp;map.type&nbsp;=&nbsp;Map(1&nbsp;-&gt;&nbsp;make&nbsp;a&nbsp;web&nbsp;site,&nbsp;3&nbsp;-&gt;&nbsp;profit!)</code>
  <br />  scala&gt;&nbsp;map(<code class="literal">1</code>)
  <code class="output">res62:&nbsp;String&nbsp;=&nbsp;make&nbsp;a&nbsp;web&nbsp;site</code>
  <br />  scala&gt;&nbsp;map&nbsp;contains&nbsp;<code class="literal">2</code>
  <code class="output">res63:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>


<p>Iteration over a hash table is not guaranteed to occur in any
particular order. Iteration simply proceeds through the underlying
array in whichever order it happens to be. To get a guaranteed
iteration order, use a <em>linked</em> hash map or set instead of
a regular one.  A linked hash map or set is just like a
regular hash map or set except that it also includes a linked
list of the elements in the order they were added. Iteration over
such a collection is always in the same order that the elements
were initially added.</p>

<h4>Weak hash maps</h4>


<p>A weak hash map<a id="i-707232831-1"/> is a special kind of hash map in which the garbage
collector does not follow links from the map to the keys stored in
it. This means that a key and its associated value will disappear from
the map if there is no other reference to that key. Weak hash maps are
useful for tasks such as caching, where you want to re-use an
expensive function's result if the function is called again on the
same key. If keys and function results are stored in a regular hash
map, the map could grow without bounds, and no key would ever become
garbage. Using a weak hash map avoids this problem. As soon as a key
object becomes unreachable, it's entry is removed from the weak
hash map. Weak hash maps in Scala are implemented as a wrapper of an
underlying Java implementation, <pre class="code">java.util.WeakHashMap</pre>.</p>

<h4>Concurrent Maps</h4>


<p>A concurrent map can be accessed by several threads at once. In
addition to the usual <pre class="code">Map</pre> operations, it provides the following
atomic operations:</p>

<p><a id="tab-cmapops"/></p>

<h5>Operations in trait <pre class="code">ConcurrentMap</pre> <a id="i-1337741596-1"/></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <pre class="code">m</pre>&nbsp;<pre class="code">putIfAbsent(k,</pre>&nbsp;<pre class="code">v)</pre>
  </td>
  <td>
    Adds key/value binding <pre class="code">k</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">m</pre> unless <pre class="code">k</pre> is
                            already defined in <pre class="code">m</pre><a id="i-432133008-1"/><a id="i-1114573962-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">m</pre>&nbsp;<pre class="code">remove</pre>&nbsp;<pre class="code">(k,</pre>&nbsp;<pre class="code">v)</pre>
  </td>
  <td>
    Removes entry for <pre class="code">k</pre> if it is currently
                            mapped to <pre class="code">v</pre><a id="i-573548081-1"/><a id="i-218120845-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">m</pre>&nbsp;<pre class="code">replace</pre>&nbsp;<pre class="code">(k,</pre>&nbsp;<pre class="code">old,</pre>&nbsp;<pre class="code">new)</pre>
  </td>
  <td>
    Replaces value associated with key <pre class="code">k</pre> to
                            <pre class="code">new</pre>, if it was previously bound to
                            <pre class="code">old</pre><a id="i-400154625-1"/><a id="i1830849445-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">m</pre>&nbsp;<pre class="code">replace</pre>&nbsp;<pre class="code">(k,</pre>&nbsp;<pre class="code">v)</pre>
  </td>
  <td>
    Replaces value associated with key <pre class="code">k</pre> to
                            <pre class="code">v</pre>, if it was previously bound to some value
  </td>
</tr>
</table>


<p><pre class="code">ConcurrentMap</pre> is a trait in the Scala collections library.
Currently, its only implementation is Java's
<pre class="code">java.util.concurrent.ConcurrentMap</pre>, which can be converted
automatically into a Scala map using the 
standard Java/Scala collection conversions, which will be described
in <a href="collections-in-depth.html#sec-javaconversions">Section 24.17</a>.</p>

<h4>Mutable bit sets</h4>


<p>A mutable bit set is just like an immutable one, except that it can be
modified in place. Mutable bit sets are slightly more efficient at
updating than immutable ones, because they don't have to copy around
<pre class="code">Long</pre>s that haven't changed. Here is an example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bits&nbsp;=&nbsp;scala.collection.mutable.BitSet.empty
  <code class="output">bits:&nbsp;scala.collection.mutable.BitSet&nbsp;=&nbsp;BitSet()</code>
  <br />  scala&gt;&nbsp;bits&nbsp;+=&nbsp;<code class="literal">1</code>
  <code class="output">res64:&nbsp;bits.type&nbsp;=&nbsp;BitSet(1)</code>
  <br />  scala&gt;&nbsp;bits&nbsp;+=&nbsp;<code class="literal">3</code>
  <code class="output">res65:&nbsp;bits.type&nbsp;=&nbsp;BitSet(1,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;bits
  <code class="output">res66:&nbsp;scala.collection.mutable.BitSet&nbsp;=&nbsp;BitSet(1,&nbsp;3)</code>
</pre>


<h3 id="sec-arrays">24.10 Arrays</h3>


<p>Arrays are a special kind of collection in Scala. One the one hand,
Scala arrays correspond one-to-one to Java arrays. That is, a Scala
array <pre class="code">Array[Int]</pre> is represented as a Java <pre class="code">int[]</pre>, an
<pre class="code">Array[Double]</pre> is represented as a Java <pre class="code">double[]</pre> and an
<pre class="code">Array[String]</pre> is represented as a Java <pre class="code">String[]</pre>.  But at the
same time, Scala arrays offer much more their Java analogues.  First,
Scala arrays can be <span style="font-style:italic">generic</span>. That is, you can have an
<pre class="code">Array[T]</pre>, where <pre class="code">T</pre> is a type parameter or abstract type. 
Second, Scala arrays are compatible with Scala sequences&mdash;you can pass an
<pre class="code">Array[T]</pre> where a <pre class="code">Seq[T]</pre> is required. Finally, Scala arrays also support all
sequence operations. Here's an example of this in action:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a1&nbsp;=&nbsp;<code class="typename">Array</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">a1:&nbsp;Array[Int]&nbsp;=&nbsp;Array(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a2&nbsp;=&nbsp;a1&nbsp;map&nbsp;(_&nbsp;*&nbsp;<code class="literal">3</code>)
  <code class="output">a2:&nbsp;Array[Int]&nbsp;=&nbsp;Array(3,&nbsp;6,&nbsp;9)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a3&nbsp;=&nbsp;a2&nbsp;filter&nbsp;(_&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">2</code>&nbsp;!=&nbsp;<code class="literal">0</code>)
  <code class="output">a3:&nbsp;Array[Int]&nbsp;=&nbsp;Array(3,&nbsp;9)</code>
  <br />  scala&gt;&nbsp;a3.reverse
  <code class="output">res1:&nbsp;Array[Int]&nbsp;=&nbsp;Array(9,&nbsp;3)</code>
</pre>


<p>Given that Scala arrays are represented just like Java arrays, how can
these additional features be supported in Scala?</p>

<p>The answer lies in systematic use of implicit conversions. An array
cannot pretend to <span style="font-style:italic">be</span> a sequence, because the data type
representation of a native array is not a subtype of <pre class="code">Seq</pre>. Instead,
whenever an array would be used as a <pre class="code">Seq</pre>, implicitly wrap it in
a subclass of <pre class="code">Seq</pre>. The name of that subclass is
<pre class="code">scala.collection.mutable.WrappedArray</pre>. Here you see it in action:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;seq:&nbsp;<code class="typename">Seq[Int]</code>&nbsp;=&nbsp;a1
  seq:&nbsp;<code class="typename">Seq[Int]</code>&nbsp;=&nbsp;<code class="typename">WrappedArray</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a4:&nbsp;<code class="typename">Array[Int]</code>&nbsp;=&nbsp;seq.toArray
  a4:&nbsp;<code class="typename">Array[Int]</code>&nbsp;=&nbsp;<code class="typename">Array</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <br />  scala&gt;&nbsp;a1&nbsp;eq&nbsp;a4
  res2:&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;<code class="vem">true</code>
</pre>


<p>This interaction demonstrates that arrays are compatible with sequences, because
there's an implicit conversion from <pre class="code">Array</pre> to <pre class="code">WrappedArray</pre>. To go the other way, from
a <pre class="code">WrappedArray</pre> to an <pre class="code">Array</pre>, you can use the <pre class="code">toArray</pre> method defined in <pre class="code">Traversable</pre>. 
The last interpreter line above shows that wrapping then unwrapping with <pre class="code">toArray</pre> gives you back
the same array you started with.</p>

<p>There is yet another implicit conversion that gets applied to arrays. This conversion
simply "adds" all sequence methods to arrays but does not turn the array itself 
into a sequence. "Adding" means that the array is wrapped in another object of type <pre class="code">ArrayOps</pre>, which
supports all sequence methods. Typically, this <pre class="code">ArrayOps</pre> object is short-lived; it will
usually be inaccessible after the call to the sequence method and its storage can be recycled.
Modern VMs often avoid creating this object entirely.</p>

<p>The difference between the two implicit conversions on arrays is demonstrated here:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;seq:&nbsp;<code class="typename">Seq[Int]</code>&nbsp;=&nbsp;a1
  <code class="output">seq:&nbsp;Seq[Int]&nbsp;=&nbsp;WrappedArray(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;seq.reverse
  <code class="output">res2:&nbsp;Seq[Int]&nbsp;=&nbsp;WrappedArray(3,&nbsp;2,&nbsp;1)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;ops:&nbsp;<code class="typename">collection.mutable.ArrayOps[Int]</code>&nbsp;=&nbsp;a1
  <code class="output">ops:&nbsp;scala.collection.mutable.ArrayOps[Int]&nbsp;=&nbsp;[I(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;ops.reverse
  <code class="output">res3:&nbsp;Array[Int]&nbsp;=&nbsp;Array(3,&nbsp;2,&nbsp;1)</code>
</pre>


<p>You see that calling <pre class="code">reverse</pre> on <pre class="code">seq</pre>, which is a <pre class="code">WrappedArray</pre>, will give again a 
<pre class="code">WrappedArray</pre>. That's logical, because wrapped arrays are <pre class="code">Seq</pre>s, and calling <pre class="code">reverse</pre>
on any <pre class="code">Seq</pre> will give again a <pre class="code">Seq</pre>. On the other hand, calling <pre class="code">reverse</pre> on the 
<pre class="code">ops</pre> value of class <pre class="code">ArrayOps</pre> will result in an <pre class="code">Array</pre>, not a <pre class="code">Seq</pre>.</p>

<p>The <pre class="code">ArrayOps</pre> example above was quite artificial, intended only to show the difference
to <pre class="code">WrappedArray</pre>. Normally, you'd never define a value of class <pre class="code">ArrayOps</pre>. You'd 
just call a <pre class="code">Seq</pre> method on an array:</p>

<pre>
  scala&gt;&nbsp;a1.reverse
  <code class="output">res4:&nbsp;Array[Int]&nbsp;=&nbsp;Array(3,&nbsp;2,&nbsp;1)</code>
</pre>


<p>The <pre class="code">ArrayOps</pre> object gets inserted automatically by the implicit conversion. So the
line above is equivalent to the following line, 
where <pre class="code">intArrayOps</pre> was the conversion that was implicitly inserted previously:</p>

<pre>
  scala&gt;&nbsp;intArrayOps(a1).reverse
  <code class="output">res5:&nbsp;Array[Int]&nbsp;=&nbsp;Array(3,&nbsp;2,&nbsp;1)</code>
</pre>


<p>This raises the question how the compiler picked
<pre class="code">intArrayOps</pre> over the other implicit conversion to <pre class="code">WrappedArray</pre>
in the line above. After all, both conversions map an array to a type
that supports a <pre class="code">reverse</pre> method, which is what the input specified.
The answer to that question is that the two implicit conversions are
prioritized.  The <pre class="code">ArrayOps</pre> conversion has a higher priority than
the <pre class="code">WrappedArray</pre> conversion.  The first is defined in the <pre class="code">Predef</pre>
object whereas the second is defined in a class
<pre class="code">scala.LowPriorityImplicits</pre>, which is a superclass of
<pre class="code">Predef</pre>. Implicits in subclasses and subobjects take precedence over
implicits in base classes. So if both conversions are applicable, the
one in <pre class="code">Predef</pre> is chosen. A very similar scheme, which was
described in <a href="implicit-conversions-and-parameters.html#sec-when-multiple-conversions-apply">Section 21.7</a>, works for strings.</p>

<p>So now you know how arrays can be compatible with sequences and how
they can support all sequence operations. What about genericity?  In
Java you cannot write a <pre class="code">T[]</pre> where <pre class="code">T</pre> is a type parameter.  How
then is Scala's <pre class="code">Array[T]</pre> represented? In fact a generic array<a id="i953627543-1"/><a id="i337692579-1"/> like
<pre class="code">Array[T]</pre> could be at run time any of Java's eight primitive array
types <pre class="code">byte[]</pre>, <pre class="code">short[]</pre>, <pre class="code">char[]</pre>, <pre class="code">int[]</pre>, <pre class="code">long[]</pre>, <pre class="code">float[]</pre>,
<pre class="code">double[]</pre>, <pre class="code">boolean[]</pre>, or it could be an array of objects. The
only common run-time type encompassing all of these types is <pre class="code">AnyRef</pre>
(or, equivalently <pre class="code">java.lang.Object</pre>), so that's the type to which
the Scala compiler maps <pre class="code">Array[T]</pre>.  At run-time, when an element of
an array of type <pre class="code">Array[T]</pre> is accessed or updated there is a
sequence of type tests that determine the actual array type, followed
by the correct array operation on the Java array. These type tests
slow down array operations somewhat. You can expect accesses to
generic arrays to be three to four times slower than accesses to
primitive or object arrays. This means that if you need maximal
performance, you should prefer concrete over generic arrays.</p>

<p>Representing the generic array type is not enough, however, there must
also be a way to <span style="font-style:italic">create</span> generic arrays. This is an even harder
problem, which requires a little bit of help from you. To illustrate
the problem, consider the following attempt to write a generic method that creates an array:</p>

<div style="page-break-after:always"/>


<pre>
  <code class="comment">//&nbsp;This&nbsp;is&nbsp;wrong!</code>
  <code class="vem">def</code>&nbsp;evenElems[T](xs:&nbsp;<code class="typename">Vector[T]</code>):&nbsp;<code class="typename">Array[T]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;arr&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[T]</code>((xs.length&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;/&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;xs.length&nbsp;by&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;arr(i&nbsp;/&nbsp;<code class="literal">2</code>)&nbsp;=&nbsp;xs(i)
  &nbsp;&nbsp;arr
  }
</pre>


<p>The <pre class="code">evenElems</pre> method returns a new array that consists of all elements
of the argument vector <pre class="code">xs</pre> that are at even positions in the vector.
The first line of the body of <pre class="code">evenElems</pre> creates the result array, which 
has the same element type as the argument. So depending on the actual type parameter 
for <pre class="code">T</pre>, this could be an <pre class="code">Array[Int]</pre>, or an <pre class="code">Array[Boolean]</pre>, or an array of some 
of the other primitive types in Java, or an array of some reference type. 
But these types all have different runtime representations, so how is the Scala runtime 
going to pick the correct one? In fact, it can't do that based on the information it is given,
because the actual type that corresponds to the type parameter <pre class="code">T</pre> is erased at runtime.
That's why you will get the following error message if you attempt to compile the code above:</p>

<pre>
  error:&nbsp;cannot&nbsp;find&nbsp;<code class="vem">class</code>&nbsp;tag&nbsp;<code class="vem">for</code>&nbsp;element&nbsp;<code class="vem">type</code>&nbsp;T
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;arr&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[T]</code>((arr.length&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;/&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
</pre>


<p>What's required here is that you help the compiler by providing a
runtime hint of what the actual type parameter of <pre class="code">evenElems</pre>
is. This runtime hint takes the form of a <span style="font-style:italic">class tag</span> of type
<pre class="code">scala.reflect.ClassTag</pre>. A class tag describes the <em>erased type</em>
of a given type, which is all the information needed to construct an
array of that type.</p>

<p>In many cases the compiler can generate a class tag on its own.  Such
is the case for a concrete type like <pre class="code">Int</pre> or <pre class="code">String</pre>. It's also
the case for certain generic types, like <pre class="code">List[T]</pre>, where enough
information is known to predict the erased type; in this example the
erased type would be <pre class="code">List</pre>.</p>

<p>For fully generic cases, the usual idiom is to pass the class tag
using a context bound, as discussed in
<a href="implicit-conversions-and-parameters.html#sec-context-bounds">Section 21.6</a>. Here is how the above definition
could be fixed by using a context bound:</p>

<pre>
  <code class="comment">//&nbsp;This&nbsp;works</code>
  <code class="vem">import</code>&nbsp;scala.reflect.ClassTag
  <code class="vem">def</code>&nbsp;evenElems[T:&nbsp;<code class="typename">ClassTag</code>](xs:&nbsp;<code class="typename">Vector[T]</code>):&nbsp;<code class="typename">Array[T]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;arr&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[T]</code>((xs.length&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;/&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;xs.length&nbsp;by&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;arr(i&nbsp;/&nbsp;<code class="literal">2</code>)&nbsp;=&nbsp;xs(i)
  &nbsp;&nbsp;arr
  }
</pre>


<p>In this new definition, when the <pre class="code">Array[T]</pre> is created, the compiler
looks for a class tag for the type parameter <pre class="code">T</pre>, that is, it will
look for an implicit value of type <pre class="code">ClassTag[T]</pre>. If such a value is
found, the class tag is used to construct the right kind of
array. Otherwise, you'll see an error message like the one shown
previously.</p>

<p>Here is an interpreter interaction that uses the <pre class="code">evenElems</pre> method:</p>

<pre>
  scala&gt;&nbsp;evenElems(<code class="typename">Vector</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">5</code>))
  <code class="output">res6:&nbsp;Array[Int]&nbsp;=&nbsp;Array(1,&nbsp;3,&nbsp;5)</code>
  <br />  scala&gt;&nbsp;evenElems(<code class="typename">Vector</code>(<code class="quotedstring">"this"</code>,&nbsp;<code class="quotedstring">"is"</code>,&nbsp;<code class="quotedstring">"a"</code>,&nbsp;<code class="quotedstring">"test"</code>,&nbsp;<code class="quotedstring">"run"</code>))
  <code class="output">res7:&nbsp;Array[java.lang.String]&nbsp;=&nbsp;Array(this,&nbsp;a,&nbsp;run)</code>
</pre>


<p>In both cases, the Scala compiler automatically constructed a class tag for the element type
(first <pre class="code">Int</pre>, then <pre class="code">String</pre>) and passed it to the implicit parameter of the <pre class="code">evenElems</pre> method.
The compiler can do that for all concrete types, but not if the argument is itself another
type parameter without its class tag. For instance, the following fails:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;wrap[U](xs:&nbsp;<code class="typename">Vector[U]</code>)&nbsp;=&nbsp;evenElems(xs)
  <code class="output">&lt;console&gt;:9:&nbsp;error:&nbsp;No&nbsp;ClassTag&nbsp;available&nbsp;for&nbsp;U</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;wrap[U](xs:&nbsp;Vector[U])&nbsp;=&nbsp;evenElems(xs)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>What happened here is that the <pre class="code">evenElems</pre> demands a class tag for the type parameter <pre class="code">U</pre>, 
but none was found. The solution in this case is, of course, to demand another implicit class tag for <pre class="code">U</pre>.
So the following works:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;wrap[U:&nbsp;<code class="typename">ClassTag</code>](xs:&nbsp;<code class="typename">Vector[U]</code>)&nbsp;=&nbsp;evenElems(xs)
  <code class="output">wrap:&nbsp;[U](xs:&nbsp;Vector[U])(implicit&nbsp;evidence$1:</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scala.reflect.ClassTag[U])Array[U]</code>
</pre>


<p>This example also shows that the context bound in the definition of <pre class="code">U</pre> is just a shorthand
for an implicit parameter named here <pre class="code">evidence$1</pre> of type <pre class="code">ClassTag[U]</pre>.</p>

<h3>24.11 Strings</h3>


<p>Like arrays, strings are not directly sequences, but they can be
converted to them, and they also support all sequence operations.
Here are some examples of operations you can invoke on strings:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;str&nbsp;=&nbsp;<code class="quotedstring">"hello"</code>
  <code class="output">str:&nbsp;java.lang.String&nbsp;=&nbsp;hello</code>
  <br />  scala&gt;&nbsp;str.reverse
  <code class="output">res6:&nbsp;String&nbsp;=&nbsp;olleh</code>
  <br />  scala&gt;&nbsp;str.map(_.toUpper)
  <code class="output">res7:&nbsp;String&nbsp;=&nbsp;HELLO</code>
  <br />  scala&gt;&nbsp;str&nbsp;drop&nbsp;<code class="literal">3</code>&nbsp;
  <code class="output">res8:&nbsp;String&nbsp;=&nbsp;lo</code>
  <br />  scala&gt;&nbsp;str&nbsp;slice&nbsp;(<code class="literal">1</code>,&nbsp;<code class="literal">4</code>)
  <code class="output">res9:&nbsp;String&nbsp;=&nbsp;ell</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;s:&nbsp;<code class="typename">Seq[Char]</code>&nbsp;=&nbsp;str
  <code class="output">s:&nbsp;Seq[Char]&nbsp;=&nbsp;WrappedString(h,&nbsp;e,&nbsp;l,&nbsp;l,&nbsp;o)</code>
</pre>


<p>These operations are supported by two implicit conversions, which were
explained in
<a href="implicit-conversions-and-parameters.html#sec-when-multiple-conversions-apply">Section 21.7</a>.  The first,
low-priority conversion maps a <pre class="code">String</pre> to a <pre class="code">WrappedString</pre>, which
is a subclass of <pre class="code">immutable.IndexedSeq</pre>. This conversion was applied
in the last line of the previous example in which a string was converted into a <pre class="code">Seq</pre>. The
other, high-priority conversion maps a string to a <pre class="code">StringOps</pre>
object, which adds all methods on immutable sequences to strings.
This conversion was implicitly inserted in the method calls of
<pre class="code">reverse</pre>, <pre class="code">map</pre>, <pre class="code">drop</pre>, and <pre class="code">slice</pre> in the previous example.</p>

<h3>24.12 Performance characteristics</h3>


<p>As the previous explanations have shown, different collection
types have different performance characteristics.<a id="i1597641046-1"/> That's often the
primary reason for picking one collection type over another. You can
see the performance characteristics of some common operations on
collections summarized in two tables, <a href="collections-in-depth.html#tab-seq-perf">Table 24.12</a> and
<a href="collections-in-depth.html#tab-setmap-perf">Table 24.12</a>.</p>

<p><a id="tab-seq-perf"/></p>

<table style="border-collapse: collapse">
<tr>
  <td>
  </td>
  <td>
    <span style="font-size:small">head</span>
  </td>
  <td>
    <span style="font-size:small">tail</span>
  </td>
  <td>
    <span style="font-size:small">apply</span>
  </td>
  <td>
    <span style="font-size:small">update</span>
  </td>
  <td>
    <span style="font-size:small">prepend</span>
  </td>
  <td>
    <span style="font-size:small">append</span>
  </td>
  <td>
    <span style="font-size:small">insert</span>
  </td>
</tr>
<tr class="topline ">
  <td>
    <span style="font-weight:bold">immutable</span>
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">List</pre>
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    -
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">Stream</pre>
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    -
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">Vector</pre>
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    -
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">Stack</pre>
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    -
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">Queue</pre>
  </td>
  <td>
    aC
  </td>
  <td>
    aC
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    -
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">Range</pre>
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    -
  </td>
  <td>
    -
  </td>
  <td>
    -
  </td>
  <td>
    -
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">String</pre>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    -
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">mutable</span>
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">ArrayBuffer</pre>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    aC
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">ListBuffer</pre>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">StringBuilder</pre>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    aC
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">MutableList</pre>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">Queue</pre>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">ArraySeq</pre>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    -
  </td>
  <td>
    -
  </td>
  <td>
    -
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">Stack</pre>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">ArrayStack</pre>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    aC
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">Array</pre>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    C
  </td>
  <td>
    C
  </td>
  <td>
    -
  </td>
  <td>
    -
  </td>
  <td>
    -
  </td>
</tr>
</table>


<h5>Performance characteristics of sequence types</h5>


<p><a id="tab-setmap-perf"/></p>

<table style="border-collapse: collapse">
<tr>
  <td>
  </td>
  <td>
    <span style="font-size:small">lookup</span>
  </td>
  <td>
    <span style="font-size:small">add</span>
  </td>
  <td>
    <span style="font-size:small">remove</span>
  </td>
  <td>
    <span style="font-size:small">min</span>
  </td>
</tr>
<tr class="topline ">
  <td>
    <span style="font-weight:bold">immutable</span>
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">HashSet/HashMap</pre>
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">TreeSet/TreeMap</pre>
  </td>
  <td>
    Log
  </td>
  <td>
    Log
  </td>
  <td>
    Log
  </td>
  <td>
    Log
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">BitSet</pre>
  </td>
  <td>
    C
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    eC<a href="collections-in-depth.html#footnotemain24-5">[5]</a>
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">ListMap</pre>
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">mutable</span>
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">HashSet/HashMap</pre>
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">WeakHashMap</pre>
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    eC
  </td>
  <td>
    L
  </td>
</tr>
<tr>
  <td>
    &nbsp;&nbsp;&nbsp;&nbsp;<pre class="code">BitSet</pre>
  </td>
  <td>
    C
  </td>
  <td>
    aC
  </td>
  <td>
    C
  </td>
  <td>
    eC[5] 
  </td>
</tr>
</table>


<h5>Performance characteristics of set and map types</h5>


<div style="page-break-after:always"/>


<p>The entries in these two tables are explained as follows:</p>

<table style="border-collapse: collapse">
<tr>
  <td>
    C
  </td>
  <td>
    The operation takes (fast) constant time.
  </td>
</tr>
<tr>
  <td>
    eC
  </td>
  <td>
    The operation takes effectively constant time, 
     but this might depend on some assumptions such as 
     the maximum length of a vector or the distribution of hash keys.
  </td>
</tr>
<tr>
  <td>
    aC
  </td>
  <td>
    The operation takes amortized constant time. Some invocations of the operation
     might take longer, but if many operations are performed
     on average only constant time per operation is taken.
  </td>
</tr>
<tr>
  <td>
    Log
  </td>
  <td>
    The operation takes time proportional to the logarithm of the collection size.
  </td>
</tr>
<tr>
  <td>
    L
  </td>
  <td>
    The operation is linear, that is it takes time proportional to the collection size.
  </td>
</tr>
<tr>
  <td>
    -
  </td>
  <td>
    The operation is not supported.
  </td>
</tr>
</table>           


<p><a href="collections-in-depth.html#tab-seq-perf">Table 24.12</a> treats sequence types&mdash;both immutable and
mutable&mdash;with the following operations:</p>

<table style="border-collapse: collapse">
<tr>
  <td>
    head
  </td>
  <td>
    Selecting the first element of the sequence.
  </td>
</tr>
<tr>
  <td>
    tail
  </td>
  <td>
    Producing a new sequence that consists of all elements
           except the first one.
  </td>
</tr>
<tr>
  <td>
    apply
  </td>
  <td>
    Indexing.
  </td>
</tr>
<tr>
  <td>
    update
  </td>
  <td>
    Functional update (with <pre class="code">updated</pre>) for immutable sequences,
        side-effecting update (with <pre class="code">update</pre>) for mutable sequences.
  </td>
</tr>
<tr>
  <td>
    prepend
  </td>
  <td>
    Adding an element to the front of the sequence.
          For immutable sequences, this produces a new sequence.
          For mutable sequences it modifies the existing sequence.
  </td>
</tr>
<tr>
  <td>
    append
  </td>
  <td>
    Adding an element at the end of the sequence.
          For immutable sequences, this produces a new sequence.
          For mutable sequences it modifies the existing sequence.
  </td>
</tr>
<tr>
  <td>
    insert
  </td>
  <td>
    Inserting an element at an arbitrary position in the sequence.
         This is only supported directly for mutable sequences.
  </td>
</tr>
</table>


<p><a href="collections-in-depth.html#tab-setmap-perf">Table 24.12</a> treats mutable and immutable sets and
maps with the following operations:</p>

<table style="border-collapse: collapse">
<tr>
  <td>
    lookup
  </td>
  <td>
    Testing whether an element is contained in set, 
         or selecting a value associated with a key.
  </td>
</tr>
<tr>
  <td>
    add
  </td>
  <td>
    Adding a new element to a set or a new key/value pair to a map.
  </td>
</tr>
<tr>
  <td>
    remove
  </td>
  <td>
    Removing an element from a set or a key from a map.
  </td>
</tr>
<tr>
  <td>
    min
  </td>
  <td>
    The smallest element of the set, or the smallest key of a map.
  </td>
</tr>
</table>


<h3 id="sec-coll-arch-eq">24.13 Equality</h3>


<p>The collection libraries have a uniform approach to equality and
hashing. The idea is, first, to divide collections into sets, maps,
and sequences. Collections in different categories are always
unequal. For instance, <pre class="code">Set(1,</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">3)</pre> is unequal to <pre class="code">List(1,</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">3)</pre>
even though they contain the same elements.  On the other hand, within
the same category, collections are equal if and only if they have the
same elements (for sequences: the same elements in the same order). For
example, <pre class="code">List(1,</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">3)</pre>&nbsp;<pre class="code">==</pre>&nbsp;<pre class="code">Vector(1,</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">3)</pre>, and 
<pre class="code">HashSet(1,</pre>&nbsp;<pre class="code">2)</pre>&nbsp;<pre class="code">==</pre>&nbsp;<pre class="code">TreeSet(2,</pre>&nbsp;<pre class="code">1)</pre>.</p>

<p>It does not matter for the equality check whether a collection is
mutable or immutable. For a mutable collection, equality simply
depends on the current elements at
the time the equality test is performed. This
means that a mutable collection might be equal to different
collections at different times, depending what elements are added or
removed. This is a potential trap when using a mutable collection as
a key in a hash map. For example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;collection.mutable.{<code class="typename">HashMap</code>,&nbsp;<code class="typename">ArrayBuffer</code>}
  <code class="output">import&nbsp;collection.mutable.{HashMap,&nbsp;ArrayBuffer}</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;<code class="typename">ArrayBuffer</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">buf:&nbsp;scala.collection.mutable.ArrayBuffer[Int]&nbsp;=&nbsp;</code>
  <code class="output">ArrayBuffer(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;map&nbsp;=&nbsp;<code class="typename">HashMap</code>(buf&nbsp;-&gt;&nbsp;<code class="literal">3</code>)
  <code class="output">map:&nbsp;scala.collection.mutable.HashMap[scala.collection.</code>
  <code class="output">mutable.ArrayBuffer[Int],Int]&nbsp;=&nbsp;Map((ArrayBuffer(1,&nbsp;2,&nbsp;3),3))</code>
</pre>


<pre>
  scala&gt;&nbsp;map(buf)
  <code class="output">res13:&nbsp;Int&nbsp;=&nbsp;3</code>
  <br />  scala&gt;&nbsp;buf(<code class="literal">0</code>)&nbsp;+=&nbsp;<code class="literal">1</code>
  <br />  scala&gt;&nbsp;map(buf)
  <code class="output">java.util.NoSuchElementException:&nbsp;key&nbsp;not&nbsp;found:&nbsp;</code>
  <code class="output">&nbsp;&nbsp;ArrayBuffer(2,&nbsp;2,&nbsp;3)&nbsp;</code>
</pre>


<p>In this example, the selection in the last line will most likely fail
because the hash code of the array <pre class="code">xs</pre> has changed in the
second-to-last line. Therefore, the hash-code-based lookup will look at
a different place than the one in which <pre class="code">xs</pre> was stored.</p>

<h3 id="sec-views">24.14 Views</h3>


<p>Collections have quite a few methods that construct new collections.<a id="i112204398-1"/><a id="i-1938971378-1"/>
Some examples are <pre class="code">map</pre>, <pre class="code">filter</pre>, and <pre class="code">++</pre>. We call such methods <span style="font-style:italic">transformers</span><a id="i-1856481670-1"/>
because they take at least one collection as their receiver object and produce 
another collection in their result.</p>

<p>Transformers can be implemented in two principal ways: strict and non-strict (or lazy). A strict transformer constructs a new collection with all of its elements. A non-strict, or lazy, transformer constructs only a proxy for the result collection, and its elements are constructed on demand.</p>

<p>As an example of a non-strict transformer, consider the following implementation
of a lazy map operation:</p>

<pre>
  <code class="vem">def</code>&nbsp;lazyMap[T,&nbsp;U](coll:&nbsp;<code class="typename">Iterable[T]</code>,&nbsp;f:&nbsp;T&nbsp;=&gt;&nbsp;U)&nbsp;=
  &nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Iterable[U]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;iterator&nbsp;=&nbsp;coll.iterator&nbsp;map&nbsp;f
  &nbsp;&nbsp;}
</pre>


<p>Note that <pre class="code">lazyMap</pre> constructs a new <pre class="code">Iterable</pre> without stepping through all 
elements of the given collection <pre class="code">coll</pre>. The given function <pre class="code">f</pre> is instead applied
to the elements of the new collection's <pre class="code">iterator</pre> as they are demanded.</p>

<p>Scala collections are by default strict in all their transformers,
except for <pre class="code">Stream</pre>, which implements all its transformer methods
lazily. However, there is a systematic way to turn every collection
into a lazy one and <span style="font-style:italic">vice versa</span>, which is based on collection
views. A <span style="font-style:italic">view</span> is a special kind of collection that represents
some base collection, but implements all of its transformers lazily.</p>

<p>To go from a collection to its view, you can use the <pre class="code">view</pre> method on
the collection. If <pre class="code">xs</pre> is some collection, then <pre class="code">xs.view</pre><a id="i-1406999493-2"/><a id="i-1473277169-2"/> is the
same collection, but with all transformers implemented lazily.  To get
back from a view to a strict collection, you can use the <pre class="code">force</pre> method.<a id="i1012198449-1"/></p>

<p>As an example, say you have a vector of <pre class="code">Int</pre>s over which you want to
map two functions in succession:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;v&nbsp;=&nbsp;<code class="typename">Vector</code>(<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">10</code>:&nbsp;_*)
  <code class="output">v:&nbsp;scala.collection.immutable.Vector[Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;Vector(1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9,&nbsp;10)</code>
  <br />  scala&gt;&nbsp;v&nbsp;map&nbsp;(_&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;map&nbsp;(_&nbsp;*&nbsp;<code class="literal">2</code>)
  <code class="output">res5:&nbsp;scala.collection.immutable.Vector[Int]&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;Vector(4,&nbsp;6,&nbsp;8,&nbsp;10,&nbsp;12,&nbsp;14,&nbsp;16,&nbsp;18,&nbsp;20,&nbsp;22)</code>
</pre>


<p>In the last statement, the expression <pre class="code">v</pre>&nbsp;<pre class="code">map</pre>&nbsp;<pre class="code">(_</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">1)</pre> constructs a
new vector that is then transformed into a third vector by the second
call to <pre class="code">map</pre>&nbsp;<pre class="code">(_</pre>&nbsp;<pre class="code">*</pre>&nbsp;<pre class="code">2)</pre>. In many
situations, constructing the intermediate result from the first call to
<pre class="code">map</pre> is a bit wasteful.  In the pseudo example, it would be faster to do
a single <pre class="code">map</pre> with the composition of the two functions <pre class="code">(_</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">1)</pre>
and <pre class="code">(_</pre>&nbsp;<pre class="code">*</pre>&nbsp;<pre class="code">2)</pre>. If you have the two functions available in the same
place you can do this by hand. But quite often, successive
transformations of a data structure are done in different program
modules. Fusing those transformations would then undermine modularity.
A more general way to avoid the intermediate results
is by turning the vector first into a view, applying all transformations to the view,
and finally forcing the view to a vector:</p>

<pre>
  scala&gt;&nbsp;(v.view&nbsp;map&nbsp;(_&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;map&nbsp;(_&nbsp;*&nbsp;<code class="literal">2</code>)).force
  <code class="output">res12:&nbsp;Seq[Int]&nbsp;=&nbsp;Vector(4,&nbsp;6,&nbsp;8,&nbsp;10,&nbsp;12,&nbsp;14,&nbsp;16,&nbsp;18,&nbsp;20,&nbsp;22)&nbsp;&nbsp;</code>
</pre>


<p>We'll do this sequence of operations again, one by one:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;vv&nbsp;=&nbsp;v.view
  <code class="output">vv:&nbsp;scala.collection.SeqView[Int,Vector[Int]]&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;SeqView(1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9,&nbsp;10)</code>
</pre>


<p>The application <pre class="code">v.view</pre> gives you a <pre class="code">SeqView</pre>, <i>i.e.</i>, a lazily evaluated <pre class="code">Seq</pre>.
The type <pre class="code">SeqView</pre> has two type parameters. The first, <pre class="code">Int</pre>, shows the type
of the view's elements. The second, <pre class="code">Vector[Int]</pre>, shows you the type constructor
you get back when forcing the view.</p>

<p>Applying the first <pre class="code">map</pre> to the view gives you:</p>

<pre>
  scala&gt;&nbsp;vv&nbsp;map&nbsp;(_&nbsp;+&nbsp;<code class="literal">1</code>)
  <code class="output">res13:&nbsp;scala.collection.SeqView[Int,Seq[_]]&nbsp;=&nbsp;SeqViewM(...)</code>
</pre>


<p>The result of the <pre class="code">map</pre> is a value that prints <pre class="code">SeqViewM(...)</pre>.
This is in essence a wrapper that records the fact that a <pre class="code">map</pre> with function
<pre class="code">(_</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">1)</pre> needs to be applied on the vector <pre class="code">v</pre>. It does not apply that map
until the view is <pre class="code">force</pre>d, however. The "<pre class="code">M</pre>" after <pre class="code">SeqView</pre> is an indication
that the view encapsulates a <pre class="code">map</pre> operation. Other letters indicate other delayed operations. 
For instance "<pre class="code">S</pre>" indicates a delayed <pre class="code">slice</pre> operation, and "<pre class="code">R</pre>" indicates a <pre class="code">reverse</pre>.
We'll now apply the second <pre class="code">map</pre> to the last result.</p>

<pre>
  scala&gt;&nbsp;res13&nbsp;map&nbsp;(_&nbsp;*&nbsp;<code class="literal">2</code>)
  <code class="output">res14:&nbsp;scala.collection.SeqView[Int,Seq[_]]&nbsp;=&nbsp;SeqViewMM(...)</code>
</pre>


<p>You now get a <pre class="code">SeqView</pre> that contains two map operations, so it prints with a double "<pre class="code">M</pre>":
<pre class="code">SeqViewMM(...)</pre>. Finally, forcing the last result gives:</p>

<pre>
  scala&gt;&nbsp;res14.force
  <code class="output">res15:&nbsp;Seq[Int]&nbsp;=&nbsp;Vector(4,&nbsp;6,&nbsp;8,&nbsp;10,&nbsp;12,&nbsp;14,&nbsp;16,&nbsp;18,&nbsp;20,&nbsp;22)</code>
</pre>


<p>Both stored functions get applied as part of the execution of the <pre class="code">force</pre> operation and 
a new vector is constructed. That way, no intermediate data structure is needed.</p>

<p>One detail to note is that the static type of the final result is a
<pre class="code">Seq</pre>, not a <pre class="code">Vector</pre>. Tracing the types back we see that as soon as
the first delayed map was applied, the result had static type
<pre class="code">SeqViewM[Int,</pre>&nbsp;<pre class="code">Seq[_]]</pre>. That is, the "knowledge" that the view was
applied to the specific sequence type <pre class="code">Vector</pre> got lost. The implementation of a view
for any particular class requires quite a bit of code, so the Scala collection libraries provide views
mostly only for general collection types, not for specific
implementations.<a href="collections-in-depth.html#footnotemain24-6">[6]</a></p>

<p>There are two reasons why you might want to consider using views. The
first is performance. You have seen that by switching a collection to a 
view the construction of intermediate results can be avoided. 
These savings can be quite important. As another example, consider the problem
of finding the first palindrome in a list of words. A palindrome is a word that reads backwards
the same as forwards. Here are the necessary definitions:</p>

<pre>
  <code class="vem">def</code>&nbsp;isPalindrome(x:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;x&nbsp;==&nbsp;x.reverse
  <code class="vem">def</code>&nbsp;findPalindrome(s:&nbsp;<code class="typename">Seq[String]</code>)&nbsp;=&nbsp;s&nbsp;find&nbsp;isPalindrome
</pre>


<p>Now, assume you have a very long sequence <pre class="code">words</pre> 
and you want to find a palindrome in the first million words of that sequence. Can you re-use the definition of <pre class="code">findPalindrome</pre>?
Of course, you could write:</p>

<pre>
  findPalindrome(words&nbsp;take&nbsp;<code class="literal">1000000</code>)
</pre>


<p>This nicely separates the two aspects of taking the first million words of a sequence and finding
a palindrome in it. But the downside is that it always constructs an intermediary sequence 
consisting of one million words, even if the first word of that sequence is already a palindrome.
So potentially, 999,999 words are copied into the intermediary result without being 
inspected at all afterwards. Many programmers would give up here and write their own
specialized version of finding palindromes in some given prefix of an argument sequence.
But with views, you don't have to. Simply write:</p>

<pre>
  findPalindrome(words.view&nbsp;take&nbsp;<code class="literal">1000000</code>)
</pre>


<p>This has the same nice separation of concerns, but instead of a
sequence of a million elements it will only construct a single
lightweight view object. This way, you do not need to choose between
performance and modularity.</p>

<p>The second use case applies to views over mutable sequences.  Many
transformer functions on such views provide a window into the original
sequence that can then be used to update selectively some elements of that sequence.
To see this in an example, suppose you have an array <pre class="code">arr</pre>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;arr&nbsp;=&nbsp;(<code class="literal">0</code>&nbsp;to&nbsp;<code class="literal">9</code>).toArray
  <code class="output">arr:&nbsp;Array[Int]&nbsp;=&nbsp;Array(0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9)</code>
</pre>


<p>You can create a subwindow into that array by creating a slice of a view of the array:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;subarr&nbsp;=&nbsp;arr.view.slice(<code class="literal">3</code>,&nbsp;<code class="literal">6</code>)
  <code class="output">subarr:&nbsp;scala.collection.mutable.IndexedSeqView[</code>
  <code class="output">&nbsp;&nbsp;Int,Array[Int]]&nbsp;=&nbsp;IndexedSeqViewS(...)</code>
</pre>


<p>This gives a view, <pre class="code">subarr</pre>, which refers to the elements at positions 3 through 5 of
the array <pre class="code">arr</pre>. The view does not copy these elements,  it just provides a reference to them.
Now, assume you have a method that modifies some elements of a sequence. For instance,
the following <pre class="code">negate</pre> method would negate all elements of the sequence of integers it's given:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;negate(xs:&nbsp;<code class="typename">collection.mutable.Seq[Int]</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;xs.length)&nbsp;xs(i)&nbsp;=&nbsp;-xs(i)
  <code class="output">negate:&nbsp;(xs:&nbsp;scala.collection.mutable.Seq[Int])Unit</code>
</pre>


<p>Assume now you want to negate elements at positions three through five of the array <pre class="code">arr</pre>.
Can you use <pre class="code">negate</pre> for this? Using a view, this is simple:</p>

<pre>
  scala&gt;&nbsp;negate(subarr)
  <br />  scala&gt;&nbsp;arr
  <code class="output">res4:&nbsp;Array[Int]&nbsp;=&nbsp;Array(0,&nbsp;1,&nbsp;2,&nbsp;-3,&nbsp;-4,&nbsp;-5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9)</code>
</pre>


<p>What happened here is that <pre class="code">negate</pre> changed all elements of <pre class="code">subarr</pre>, which
were a slice of the elements of <pre class="code">arr</pre>. Again, you see that views help in keeping things modular.
The code above nicely separated the question of what index range to apply a method to
from the question what method to apply.</p>

<p>After having seen all these nifty uses of views you might wonder why
have strict collections at all? One reason is that performance
comparisons do not always favor lazy over strict collections. For
smaller collection sizes the added overhead of forming and applying
closures in views is often greater than the gain from avoiding the
intermediary data structures. A possibly more important reason is that
evaluation in views can be very confusing if the delayed
operations have side effects.</p>

<p>Here's an example that bit a few users of versions of Scala before 2.8.
In these versions the <pre class="code">Range</pre> type was lazy, so it behaved in effect like a view.
People were trying to create a number of actors<a href="collections-in-depth.html#footnotemain24-7">[7]</a>
like this:</p>

<pre>
  <code class="vem">val</code>&nbsp;actors&nbsp;=&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">10</code>)&nbsp;<code class="vem">yield</code>&nbsp;actor&nbsp;{&nbsp;...&nbsp;}
</pre>


<p>They were surprised that none of the actors were executing afterwards, even though the 
<pre class="code">actor</pre> method should create and start an actor from the code that's enclosed in the braces following it.
To explain why nothing happened, remember that the <pre class="code">for</pre> expression above is equivalent to an application of the <pre class="code">map</pre> method:</p>

<pre>
  <code class="vem">val</code>&nbsp;actors&nbsp;=&nbsp;(<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">10</code>)&nbsp;map&nbsp;(i&nbsp;=&gt;&nbsp;actor&nbsp;{&nbsp;...&nbsp;})
</pre>


<p>Since previously the range produced by <pre class="code">(1</pre>&nbsp;<pre class="code">to</pre>&nbsp;<pre class="code">10)</pre> behaved like a view, the result of the <pre class="code">map</pre>
was again a view. That is, no element was computed, and, consequently, no actor was created!
Actors would have been created by forcing the range of the whole expression, but it's far from
obvious that this is what was required to make the actors do their work.</p>

<p>To avoid surprises like this, the Scala collections gained more regular
rules in version 2.8. All collections except streams and views are
strict. The only way to go from a strict to a lazy collection is via the
<pre class="code">view</pre> method. The only way to go back is via <pre class="code">force</pre>.
So the <pre class="code">actors</pre> definition above would behave as expected in Scala 2.8 in that
it would create and start ten actors. To get back the surprising previous behavior, 
you'd have to add an explicit <pre class="code">view</pre> method call:</p>

<pre>
  <code class="vem">val</code>&nbsp;actors&nbsp;=&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;(<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">10</code>).view)&nbsp;<code class="vem">yield</code>&nbsp;actor&nbsp;{&nbsp;...&nbsp;}
</pre>


<p>In summary, views are a powerful tool to reconcile concerns of
efficiency with concerns of modularity. But in order not to be
entangled in aspects of delayed evaluation, you should restrict views
to two scenarios. Either you apply views in purely functional code
where collection transformations do not have side effects. Or you
apply them over mutable collections where all modifications are done
explicitly.  What's best avoided is a mixture of views and operations
that create new collections while also having side effects.</p>

<h3>24.15 Iterators</h3>


<p>An iterator is not a collection, but rather a way to access the
elements of a collection one by one. The two basic operations on an
iterator <pre class="code">it</pre> are <pre class="code">next</pre> and <pre class="code">hasNext</pre>. A call to <pre class="code">it.next()</pre> will
return the next element of the iterator and advance the state of the
iterator. Calling <pre class="code">next</pre> again on the same iterator will then yield
the element one beyond the one returned previously. If there are no
more elements to return, a call to <pre class="code">next</pre> will throw a
<pre class="code">NoSuchElementException</pre>. You can find out whether there are more
elements to return using <pre class="code">Iterator</pre>'s <pre class="code">hasNext</pre> method.</p>

<p>The most straightforward way to "step through" all the elements
returned by an iterator is to use a <pre class="code">while</pre> loop:</p>

<div style="page-break-after:always"/>


<pre>
  <code class="vem">while</code>&nbsp;(it.hasNext)&nbsp;
  &nbsp;&nbsp;println(it.next())
</pre>


<p>Iterators in Scala also provide analogues of most of the methods that
you find in the <pre class="code">Traversable</pre>, <pre class="code">Iterable</pre>, and <pre class="code">Seq</pre> traits. For instance, they provide a
<pre class="code">foreach</pre> method that executes a given procedure on each element returned by an iterator.
Using <pre class="code">foreach</pre>, the loop above could be abbreviated to:</p>

<pre>
  it&nbsp;foreach&nbsp;println
</pre>


<p>As always, <pre class="code">for</pre> expressions can be used as an alternate syntax for expressions involving
<pre class="code">foreach</pre>, <pre class="code">map</pre>, <pre class="code">filter</pre>, and <pre class="code">flatMap</pre>, so yet another way to print
all elements returned by an iterator would be:</p>

<pre>
  <code class="vem">for</code>&nbsp;(elem&nbsp;&lt;-&nbsp;it)&nbsp;println(elem)
</pre>


<p>There's an important difference between the <pre class="code">foreach</pre> method on
iterators and the same method on traversable collections: When called
on an iterator, <pre class="code">foreach</pre> will leave the iterator at its end when it
is done. So calling <pre class="code">next</pre> again on the same iterator will fail with
a <pre class="code">NoSuchElementException</pre>. By contrast, when called on a
collection, <pre class="code">foreach</pre> leaves the number of elements in the collection
unchanged (unless the passed function adds or removes elements, but
this is discouraged, because it can easily lead to surprising results).</p>

<p>The other operations that <pre class="code">Iterator</pre> has in common with
<pre class="code">Traversable</pre> have the same property of leaving the iterator at its end when done. For instance, iterators provide
a <pre class="code">map</pre> method, which returns a new iterator:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;it&nbsp;=&nbsp;<code class="typename">Iterator</code>(<code class="quotedstring">"a"</code>,&nbsp;<code class="quotedstring">"number"</code>,&nbsp;<code class="quotedstring">"of"</code>,&nbsp;<code class="quotedstring">"words"</code>)
  <code class="output">it:&nbsp;Iterator[java.lang.String]&nbsp;=&nbsp;non-empty&nbsp;iterator</code>
  <br />  scala&gt;&nbsp;it.map(_.length)
  <code class="output">res1:&nbsp;Iterator[Int]&nbsp;=&nbsp;non-empty&nbsp;iterator</code>
  <br />  scala&gt;&nbsp;res1&nbsp;foreach&nbsp;println
  <code class="output">1</code>
  <code class="output">6</code>
  <code class="output">2</code>
  <code class="output">5</code>
  <br />  scala&gt;&nbsp;it.next()
  <code class="output">java.util.NoSuchElementException:&nbsp;next&nbsp;on&nbsp;empty&nbsp;iterator</code>
</pre>


<p>As you can see, after the call to <pre class="code">map</pre>, the <pre class="code">it</pre> iterator has advanced to its end.</p>

<p>Another example is the <pre class="code">dropWhile</pre> method, which can be used to find the first element
of an iterator that has a certain property. For instance, to find the first 
word in the iterator shown previously that has at least two characters, you could write:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;it&nbsp;=&nbsp;<code class="typename">Iterator</code>(<code class="quotedstring">"a"</code>,&nbsp;<code class="quotedstring">"number"</code>,&nbsp;<code class="quotedstring">"of"</code>,&nbsp;<code class="quotedstring">"words"</code>)
  <code class="output">it:&nbsp;Iterator[java.lang.String]&nbsp;=&nbsp;non-empty&nbsp;iterator</code>
  <br />  scala&gt;&nbsp;it&nbsp;dropWhile&nbsp;(_.length&nbsp;&lt;&nbsp;<code class="literal">2</code>)
  <code class="output">res4:&nbsp;Iterator[java.lang.String]&nbsp;=&nbsp;non-empty&nbsp;iterator</code>
  <br />  scala&gt;&nbsp;it.next()
  <code class="output">res5:&nbsp;java.lang.String&nbsp;=&nbsp;number</code>
</pre>


<p>Note again that <pre class="code">it</pre> has changed by the call to <pre class="code">dropWhile</pre>: it now points to the 
second word "number" in the list. In fact, <pre class="code">it</pre> and the result <pre class="code">res4</pre> returned
by <pre class="code">dropWhile</pre> will return exactly the same sequence of elements.</p>

<p>There is only one standard operation, <pre class="code">duplicate</pre>, which allows you to re-use the same iterator:</p>

<pre>
  <code class="vem">val</code>&nbsp;(it1,&nbsp;it2)&nbsp;=&nbsp;it.duplicate
</pre>


<p>The call to duplicate gives you <span style="font-style:italic">two</span> iterators, which each return exactly the same elements as the iterator <pre class="code">it</pre>. The two iterators work independently; advancing one does not affect the other.
By contrast the original iterator, <pre class="code">it</pre>, is advanced to its end by <pre class="code">duplicate</pre> and is 
thus rendered unusable.</p>

<p>In summary, iterators behave like collections <span style="font-style:italic">if you never
  access an iterator again after invoking a method on it</span>. The Scala
  collection libraries make this explicit with an abstraction called
  <pre class="code">TraversableOnce</pre>, which is a common supertrait of <pre class="code">Traversable</pre> and
  <pre class="code">Iterator</pre>. As the name implies, <pre class="code">TraversableOnce</pre> objects can be
  traversed using <pre class="code">foreach</pre>, but the state of that object after the
  traversal is not specified. If the <pre class="code">TraversableOnce</pre> object is in fact an <pre class="code">Iterator</pre>,
  it will be at its end after the traversal, but if it is a <pre class="code">Traversable</pre>, it
  will still exist as before. A common use case of <pre class="code">TraversableOnce</pre> is as an argument
  type for methods that can take either an iterator or traversable as argument.
  An example is the appending method <pre class="code">++</pre> in trait <pre class="code">Traversable</pre>. 
  It takes a <pre class="code">TraversableOnce</pre> parameter, so you can append elements coming
  from either an iterator or a traversable collection.</p>

<p>All operations on iterators are summarized in <a href="collections-in-depth.html#tab-iteratorops">Table 24.12</a>.</p>

<p><a id="tab-iteratorops"/></p>

<h5>Operations in trait <pre class="code">Iterator</pre> <a id="i-1527861747-1"/></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Abstract methods:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.next()</pre>
  </td>
  <td>
    Returns the next element in the iterator and advances past <pre class="code">it</pre>.<a id="i569433333-1"/><a id="i314774649-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.hasNext</pre>
  </td>
  <td>
    Returns <pre class="code">true</pre> if <pre class="code">it</pre> can return another element.<a id="i-2058143621-1"/><a id="i387741031-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Variations:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.buffered</pre>
  </td>
  <td>
    A buffered iterator returning all elements of <pre class="code">it</pre>.<a id="i-1907025783-1"/><a id="i1783293797-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">grouped</pre>&nbsp;<pre class="code">size</pre>
  </td>
  <td>
    An iterator that yields the elements returned by <pre class="code">it</pre>
                   in fixed-sized sequence "chunks."<a id="i-1552726294-1"/><a id="i-15589352-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">xs</pre>&nbsp;<pre class="code">sliding</pre>&nbsp;<pre class="code">size</pre>
  </td>
  <td>
    An iterator that yields the elements returned by <pre class="code">it</pre>
                   in sequences representing a sliding fixed-sized window.<a id="i966114842-1"/><a id="i1866691304-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Copying:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">copyToBuffer</pre>&nbsp;<pre class="code">buf</pre>
  </td>
  <td>
    Copies all elements returned by <pre class="code">it</pre> to buffer <pre class="code">buf</pre>.<a id="i1918312792-1"/><a id="i1226176694-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">copyToArray(arr,</pre>&nbsp;<pre class="code">s,</pre>&nbsp;<pre class="code">l)</pre>
  </td>
  <td>
    Copies at most <pre class="code">l</pre> elements returned by <pre class="code">it</pre> to array
                    <pre class="code">arr</pre> starting at index <pre class="code">s</pre>. The last two
                    arguments are optional.<a id="i172626160-1"/><a id="i869836579-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Duplication:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.duplicate</pre>
  </td>
  <td>
    A pair of iterators that each independently return all elements
                   of <pre class="code">it</pre>.<a id="i-1453185571-1"/><a id="i587712325-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Additions:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">++</pre>&nbsp;<pre class="code">jt</pre>
  </td>
  <td>
    An iterator returning all elements returned by iterator <pre class="code">it</pre>,
                   followed by all elements returned by iterator <pre class="code">jt</pre>.<a id="i-387881431-1"/><a id="i-456055993-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">padTo</pre>&nbsp;<pre class="code">(len,</pre>&nbsp;<pre class="code">x)</pre>
  </td>
  <td>
    The iterator that returns all elements of <pre class="code">it</pre> 
                  followed by copies of <pre class="code">x</pre>
                  until length <pre class="code">len</pre> elements are returned overall.<a id="i1257723354-1"/><a id="i1169787304-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Maps:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">map</pre>&nbsp;<pre class="code">f</pre>
  </td>
  <td>
    The iterator obtained from applying the function <pre class="code">f</pre> to every
                   element returned from <pre class="code">it</pre>.<a id="i-1166599508-1"/><a id="i1949815574-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">flatMap</pre>&nbsp;<pre class="code">f</pre>
  </td>
  <td>
    The iterator obtained from applying the
                   iterator-valued function <pre class="code">f</pre> to every element in <pre class="code">it</pre> and
                   appending the results.<a id="i1343836714-1"/><a id="i-1087860771-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">collect</pre>&nbsp;<pre class="code">f</pre>
  </td>
  <td>
    The iterator obtained from applying the partial function <pre class="code">f</pre> to every
                   element in <pre class="code">it</pre> for which it is defined and
                   collecting the results.<a id="i538616478-1"/><a id="i640426468-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Conversions:<!-- \hfill -->  </span>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.toArray</pre>
  </td>
  <td>
    Collects the elements returned by <pre class="code">it</pre> in an array.<a id="i-681097814-1"/><a id="i-1491400360-1"/><a id="i595962916-4"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.toList</pre>
  </td>
  <td>
    Collects the elements returned by <pre class="code">it</pre> in a list.<a id="i240940271-1"/><a id="i2030419391-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.toIterable</pre>
  </td>
  <td>
    Collects the elements returned by <pre class="code">it</pre> in an iterable.<a id="i-1426035429-1"/><a id="i-690923245-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.toSeq</pre>
  </td>
  <td>
    Collects the elements returned by <pre class="code">it</pre> in a sequence.<a id="i1681639716-1"/><a id="i1173882654-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.toIndexedSeq</pre>
  </td>
  <td>
    Collects the elements returned by <pre class="code">it</pre> in an indexed sequence.<a id="i721790495-1"/><a id="i-31950321-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.toStream</pre>
  </td>
  <td>
    Collects the elements returned by <pre class="code">it</pre> in a stream.<a id="i-1134937331-1"/><a id="i1528404065-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.toSet</pre>
  </td>
  <td>
    Collects the elements returned by <pre class="code">it</pre> in a set.<a id="i1774699137-1"/><a id="i1173882657-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.toMap</pre>
  </td>
  <td>
    Collects the key/value pairs returned by <pre class="code">it</pre> in a map.<a id="i-667416889-1"/><a id="i1173876763-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Size info:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.isEmpty</pre>
  </td>
  <td>
    Tests whether the iterator is empty (opposite of <pre class="code">hasNext</pre>).<a id="i-461566043-1"/><a id="i1749021437-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.nonEmpty</pre>
  </td>
  <td>
    Tests whether the collection contains elements (alias of <pre class="code">hasNext</pre>).<a id="i-1077580280-1"/><a id="i390920454-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.size</pre>
  </td>
  <td>
    The number of elements returned by <pre class="code">it</pre>. Note: <pre class="code">it</pre> will
                   be at its end after this operation!<a id="i178959271-1"/><a id="i314927495-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.length</pre>
  </td>
  <td>
    Same as <pre class="code">it.size</pre>.<a id="i510850146-1"/><a id="i1793161964-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.hasDefiniteSize</pre>
  </td>
  <td>
    Returns true if <pre class="code">it</pre> is known to return finitely many elements
                   (by default the same as <pre class="code">isEmpty</pre>).<a id="i-195904867-1"/><a id="i1898792709-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Element retrieval index search:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">find</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    An option containing the first element returned by <pre class="code">it</pre>
                    that satisfies <pre class="code">p</pre>, or <pre class="code">None</pre> if no element
                    qualifies. Note: The iterator advances to just after the
                    element, or, if none is found, to the end.<a id="i1544372032-1"/><a id="i314539839-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">indexOf</pre>&nbsp;<pre class="code">x</pre>
  </td>
  <td>
    The index of the first element returned by <pre class="code">it</pre> that equals <pre class="code">x</pre>. Note:
                  The iterator advances past the position of this element.<a id="i1628073567-1"/><a id="i1634273027-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">indexWhere</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    The index of the first element returned by <pre class="code">it</pre> that satisfies <pre class="code">p</pre>. Note:
                  The iterator advances past the position of this element.<a id="i337051379-1"/><a id="i-1113971653-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Subiterators:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">take</pre>&nbsp;<pre class="code">n</pre>
  </td>
  <td>
    An iterator returning of the first <pre class="code">n</pre>
                     elements of <pre class="code">it</pre>. Note: <pre class="code">it</pre> will advance to the position
                     after the <pre class="code">n</pre>'th element, or to its end, if it contains
                     less than <pre class="code">n</pre> elements.<a id="i1767548558-1"/><a id="i314949133-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">drop</pre>&nbsp;<pre class="code">n</pre>
  </td>
  <td>
    The iterator that starts with the <pre class="code">(n</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">1)</pre>'th element of <pre class="code">it</pre>.
                     Note: <pre class="code">it</pre> will advance to the same position.<a id="i-1271894919-1"/><a id="i314488949-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">slice</pre>&nbsp;<pre class="code">(m,</pre>&nbsp;<pre class="code">n)</pre>
  </td>
  <td>
    The iterator that returns a slice of the elements returned
                     from <pre class="code">it</pre>, starting with the <pre class="code">m</pre>'th element and ending
                     before the <pre class="code">n</pre>'th element.<a id="i281283382-1"/><a id="i1172890828-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">takeWhile</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    An iterator returning elements from <pre class="code">it</pre> as long as 
                     condition <pre class="code">p</pre> is true.<a id="i-147054031-1"/><a id="i877321508-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">dropWhile</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    An iterator skipping elements from <pre class="code">it</pre> as long as 
                     condition <pre class="code">p</pre> is true, and returning the remainder.<a id="i1718350537-1"/><a id="i-1135205444-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">filter</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    An iterator returning all elements from <pre class="code">it</pre> that
                     satisfy the condition <pre class="code">p</pre>.<a id="i1114360848-1"/><a id="i1625033598-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">withFilter</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    Same as <pre class="code">it</pre>&nbsp;<pre class="code">filter</pre>&nbsp;<pre class="code">p</pre>. Needed so that iterators
                     can be used in <pre class="code">for</pre> expressions.<a id="i-545883542-1"/><a id="i-54851356-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">filterNot</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    An iterator returning all elements from <pre class="code">it</pre> that
                     do not satisfy the condition <pre class="code">p</pre>.<a id="i1252578477-1"/><a id="i-1495363979-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Subdivisions:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">partition</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    Splits <pre class="code">it</pre> into a pair of two iterators; 
                     one returning all elements from <pre class="code">it</pre> that satisfy the predicate <pre class="code">p</pre>, 
                     the other returning all elements from <pre class="code">it</pre> that do not.<a id="i-351940047-1"/><a id="i1881181476-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Element conditions:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">forall</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    A boolean indicating whether the predicate <pre class="code">p</pre> holds for
                    all elements returned by <pre class="code">it</pre>.<a id="i-453827760-1"/><a id="i1630735422-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">exists</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    A boolean indicating whether the predicate <pre class="code">p</pre> holds for
                    some element in <pre class="code">it</pre>.<a id="i679062444-1"/><a id="i1610167394-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">count</pre>&nbsp;<pre class="code">p</pre>
  </td>
  <td>
    The number of elements in <pre class="code">it</pre> that satisfy the
                    predicate <pre class="code">p</pre>.<a id="i1575808601-1"/><a id="i1158215753-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Folds:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">(z</pre>&nbsp;<pre class="code">/:</pre>&nbsp;<pre class="code">it)(op)</pre>
  </td>
  <td>
    Applies binary operation <pre class="code">op</pre> between successive
                    elements returned by <pre class="code">it</pre>, going left to right,
                    starting with <pre class="code">z</pre>.<a id="i-650090766-1"/><a id="i-752898660-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">(it</pre>&nbsp;<pre class="code">:\</pre>&nbsp;<pre class="code">z)(op)</pre>
  </td>
  <td>
    Applies binary operation <pre class="code">op</pre> between successive
                    elements returned by <pre class="code">it</pre>, going right to left,
                    starting with <pre class="code">z</pre>.<a id="i-181117874-1"/><a id="i-1970120157-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.foldLeft(z)(op)</pre>
  </td>
  <td>
    Same as <pre class="code">(z</pre>&nbsp;<pre class="code">/:</pre>&nbsp;<pre class="code">it)(op)</pre>.<a id="i2000454511-1"/><a id="i-696283602-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.foldRight(z)(op)</pre>
  </td>
  <td>
    Same as <pre class="code">(it</pre>&nbsp;<pre class="code">:\</pre>&nbsp;<pre class="code">z)(op)</pre>.<a id="i-542198878-1"/><a id="i-104294187-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">reduceLeft</pre>&nbsp;<pre class="code">op</pre>
  </td>
  <td>
    Applies binary operation <pre class="code">op</pre> between successive
                    elements returned by non-empty iterator <pre class="code">it</pre>, going left
                    to right.<a id="i-723508460-1"/><a id="i1225634707-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">reduceRight</pre>&nbsp;<pre class="code">op</pre>
  </td>
  <td>
    Applies binary operation <pre class="code">op</pre> between successive
                    elements returned by non-empty iterator <pre class="code">it</pre>, going
                    right to left.<a id="i2104320242-1"/><a id="i-654368752-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Specific folds:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.sum</pre>
  </td>
  <td>
    The sum of the numeric element values returned by iterator <pre class="code">it</pre>.<a id="i-735667043-1"/><a id="i1949821957-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.product</pre>
  </td>
  <td>
    The product of the numeric element values returned by iterator <pre class="code">it</pre>.<a id="i232754809-1"/><a id="i-618492503-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.min</pre>
  </td>
  <td>
    The minimum of the ordered element values returned by iterator <pre class="code">it</pre>.<a id="i-2125661578-1"/><a id="i1949815820-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.max</pre>
  </td>
  <td>
    The maximum of the ordered element values returned by iterator <pre class="code">it</pre>.<a id="i-918441052-1"/><a id="i1949815582-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Zippers:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">zip</pre>&nbsp;<pre class="code">jt</pre>
  </td>
  <td>
    An iterator of pairs of corresponding elements returned from iterators <pre class="code">it</pre> and <pre class="code">jt</pre>.<a id="i-1080229753-1"/><a id="i1949828315-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">zipAll</pre>&nbsp;<pre class="code">(jt,</pre>&nbsp;<pre class="code">x,</pre>&nbsp;<pre class="code">y)</pre>
  </td>
  <td>
    An iterator of pairs of corresponding elements returned from iterators <pre class="code">it</pre> and <pre class="code">jt</pre>,
                  where the shorter iterator is extended to match the longer one
                  by appending elements <pre class="code">x</pre> or <pre class="code">y</pre>.<a id="i374738376-1"/><a id="i-2097280314-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it.zipWithIndex</pre>
  </td>
  <td>
    An iterator of pairs of elements returned from <pre class="code">it</pre> with their indicies.<a id="i-886001315-1"/><a id="i-1744800495-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Update:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">patch</pre>&nbsp;<pre class="code">(i,</pre>&nbsp;<pre class="code">jt,</pre>&nbsp;<pre class="code">r)</pre>
  </td>
  <td>
    The iterator resulting from <pre class="code">it</pre> by replacing <pre class="code">r</pre> elements
                  starting with <pre class="code">i</pre> by the patch iterator <pre class="code">jt</pre>.<a id="i-1495891648-1"/><a id="i1169803138-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Comparison:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">sameElements</pre>&nbsp;<pre class="code">jt</pre>
  </td>
  <td>
    A test whether iterators <pre class="code">it</pre> and <pre class="code">jt</pre> return the same
                    elements in the same order. Note: At least one of <pre class="code">it</pre> and <pre class="code">jt</pre> will
                    be at its end after this operation.<a id="i-278620245-1"/><a id="i-1277312253-1"/>
  </td>
</tr>
<tr>
  <td>
    <span style="font-weight:bold">Strings:<!-- \hfill -->  </span>
  </td>
  <td>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">addString</pre> (b, start,
  </td>
</tr>
<tr>
  <td>
    <pre class="code">sep,</pre>&nbsp;<pre class="code">end)</pre>
  </td>
  <td>
    Adds a string to <pre class="code">StringBuilder</pre> <pre class="code">b</pre> that shows all elements returned by <pre class="code">it</pre>
                      between separators <pre class="code">sep</pre> enclosed in strings
                      <pre class="code">start</pre> and <pre class="code">end</pre>. <pre class="code">start</pre>,<pre class="code">sep</pre>, and <pre class="code">end</pre> are
                      all optional.<a id="i2043006297-1"/><a id="i-613121460-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">it</pre>&nbsp;<pre class="code">mkString</pre> (start,
  </td>
</tr>
<tr>
  <td>
    <pre class="code">sep,</pre>&nbsp;<pre class="code">end)</pre>
  </td>
  <td>
    Converts the iterator to a string that shows all elements returned by <pre class="code">it</pre>
                      between separators <pre class="code">sep</pre> enclosed in strings
                      <pre class="code">start</pre> and <pre class="code">end</pre>. <pre class="code">start</pre>,<pre class="code">sep</pre>, and <pre class="code">end</pre> are
                      all optional.<a id="i-872604647-1"/><a id="i-1336376875-1"/>
  </td>
</tr>
</table>


<h4>Buffered iterators</h4>


<p>Sometimes you want an iterator that can "look ahead" so that you
can inspect the next element to be returned without advancing past
that element. Consider, for instance, the task to skip leading empty
strings from an iterator that returns a sequence of strings. You might 
be tempted to write something like the following method:</p>

<pre>
  <code class="comment">//&nbsp;This&nbsp;won't&nbsp;work</code>
  <code class="vem">def</code>&nbsp;skipEmptyWordsNOT(it:&nbsp;<code class="typename">Iterator[String]</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">while</code>&nbsp;(it.next().isEmpty)&nbsp;{}
  }
</pre>


<p>But looking at this code more closely, it's clear that this is wrong: the code
will indeed skip leading empty strings, but it will also advance <pre class="code">it</pre> past the 
first non-empty string!</p>

<p>The solution to this problem is to use a buffered
iterator, an instance of trait <pre class="code">BufferedIterator</pre>. <pre class="code">BufferedIterator</pre> is a subtrait of <pre class="code">Iterator</pre>, which
provides one extra method, <pre class="code">head</pre>. Calling <pre class="code">head</pre> on a buffered
iterator will return its first element, but will not advance the
iterator. Using a buffered iterator, skipping empty words can be written like this:</p>

<pre>
  <code class="vem">def</code>&nbsp;skipEmptyWords(it:&nbsp;<code class="typename">BufferedIterator[String]</code>)&nbsp;=
  &nbsp;&nbsp;<code class="vem">while</code>&nbsp;(it.head.isEmpty)&nbsp;{&nbsp;it.next()&nbsp;}
</pre>


<p>Every iterator can be converted to a buffered iterator by calling its <pre class="code">buffered</pre> method.
Here's an example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;it&nbsp;=&nbsp;<code class="typename">Iterator</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">4</code>)
  <code class="output">it:&nbsp;Iterator[Int]&nbsp;=&nbsp;non-empty&nbsp;iterator</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bit&nbsp;=&nbsp;it.buffered
  <code class="output">bit:&nbsp;java.lang.Object&nbsp;with&nbsp;scala.collection.</code>
  <code class="output">&nbsp;&nbsp;BufferedIterator[Int]&nbsp;=&nbsp;non-empty&nbsp;iterator</code>
  <br />  scala&gt;&nbsp;bit.head
  <code class="output">res10:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br />  scala&gt;&nbsp;bit.next()
  <code class="output">res11:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br />  scala&gt;&nbsp;bit.next()
  <code class="output">res11:&nbsp;Int&nbsp;=&nbsp;2</code>
</pre>


<p>Note that calling <pre class="code">head</pre> on the buffered iterator, <pre class="code">bit</pre>, did not advance it. 
Therefore, the subsequent call, <pre class="code">bit.next()</pre>, returned again the same value as <pre class="code">bit.head</pre>.</p>

<h3>24.16 Creating collections from scratch</h3>


<p>You have already seen syntax like <pre class="code">List(1,</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">3)</pre>, which creates a list of three integers,
and <pre class="code">Map('A'</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">1,</pre>&nbsp;<pre class="code">'C'</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">2)</pre>, which creates a map with two bindings. This
is actually a universal feature of Scala collections. You can take any
collection name and follow it by a list of elements in
parentheses. The result will be a new collection with the given
elements. Here are some more examples:</p>

<pre>
  <code class="typename">Traversable</code>()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;An&nbsp;empty&nbsp;traversable&nbsp;object</code>
  <code class="typename">List</code>()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;The&nbsp;empty&nbsp;list</code>
  <code class="typename">List</code>(<code class="literal">1.0</code>,&nbsp;<code class="literal">2.0</code>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;A&nbsp;list&nbsp;with&nbsp;elements&nbsp;1.0,&nbsp;2.0</code>
  <code class="typename">Vector</code>(<code class="literal">1.0</code>,&nbsp;<code class="literal">2.0</code>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;A&nbsp;vector&nbsp;with&nbsp;elements&nbsp;1.0,&nbsp;2.0</code>
  <code class="typename">Iterator</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;An&nbsp;iterator&nbsp;returning&nbsp;three&nbsp;integers.</code>
  <code class="typename">Set</code>(dog,&nbsp;cat,&nbsp;bird)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;A&nbsp;set&nbsp;of&nbsp;three&nbsp;animals</code>
  <code class="typename">HashSet</code>(dog,&nbsp;cat,&nbsp;bird)&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;A&nbsp;hash&nbsp;set&nbsp;of&nbsp;the&nbsp;same&nbsp;animals</code>
  <code class="typename">Map</code>(<code class="quotedstring">'a'</code>&nbsp;-&gt;&nbsp;<code class="literal">7</code>,&nbsp;<code class="quotedstring">'b'</code>&nbsp;-&gt;&nbsp;<code class="literal">0</code>)&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;A&nbsp;map&nbsp;from&nbsp;characters&nbsp;to&nbsp;integers</code>
</pre>


<p>"Under the covers" each of the above lines 
is a call to the <pre class="code">apply</pre> method of some object. 
For instance, the third line above expands to:</p>

<pre>
  List.apply(<code class="literal">1.0</code>,&nbsp;<code class="literal">2.0</code>)
</pre>


<p>So this is a call to the <pre class="code">apply</pre> method of the companion object of
the <pre class="code">List</pre> class. That method takes an arbitrary number of arguments
and constructs a list from them. Every collection class in the Scala
library has a companion object with such an <pre class="code">apply</pre> method. It does
not matter whether the collection class represents a concrete
implementation, like <pre class="code">List</pre>, <pre class="code">Stream</pre>, or <pre class="code">Vector</pre>, or
whether it is an trait such as <pre class="code">Seq</pre>, <pre class="code">Set</pre>, or
<pre class="code">Traversable</pre>. In the latter case, calling <pre class="code">apply</pre> will produce some
default implementation of the trait. Here are some examples:</p>

<pre>
  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res17:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;<code class="typename">Traversable</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res18:&nbsp;Traversable[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;<code class="typename">mutable.Traversable</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res19:&nbsp;scala.collection.mutable.Traversable[Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;ArrayBuffer(1,&nbsp;2,&nbsp;3)</code>
</pre>


<p>Besides <pre class="code">apply</pre>, every collection companion object also defines a
member <pre class="code">empty</pre>, which returns an empty collection. So instead of
<pre class="code">List()</pre> you could write <pre class="code">List.empty</pre>, instead of <pre class="code">Map()</pre>,
<pre class="code">Map.empty</pre>, and so on.</p>

<p>Descendants of <pre class="code">Seq</pre> traits also provide other factory operations
in their companion objects. These are summarized in
<a href="collections-in-depth.html#tab-seqfac">Table 24.13</a>. In short, there's:</p>

<ul>


<li><b></b> <pre class="code">concat</pre>, which concatenates an arbitrary number of traversables
together, 


</li>
<li><b></b> <pre class="code">fill</pre> and <pre class="code">tabulate</pre>, which generate single or 
multi-dimensional sequences of given dimensions initialized by some expression
or tabulating function,  


</li>
<li><b></b> <pre class="code">range</pre>, which generates integer sequences 
with some constant step length, and


</li>
<li><b></b> <pre class="code">iterate</pre>, which generates the sequence
resulting from repeated application of a function to a start element. 


</li></ul>


<p><a id="tab-seqfac"/></p>

<h5>Factory methods for sequences <a id="i-36026129-1"/></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <pre class="code">S.empty</pre>
  </td>
  <td>
    The empty sequence<a id="i-1584968040-1"/><a id="i-117561730-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">S(x,</pre>&nbsp;<pre class="code">y,</pre>&nbsp;<pre class="code">z)</pre>
  </td>
  <td>
    A sequence consisting of elements <pre class="code">x</pre>, <pre class="code">y</pre>, and <pre class="code">z</pre><a id="i-507343367-1"/><a id="i-121166689-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">S.concat(xs,</pre>&nbsp;<pre class="code">ys,</pre>&nbsp;<pre class="code">zs)</pre>
  </td>
  <td>
    The sequence obtained by concatenating the elements
                 of <pre class="code">xs</pre>, <pre class="code">ys</pre>, and <pre class="code">zs</pre><a id="i-396825960-1"/><a id="i595065859-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">S.fill(n)(e)</pre>
  </td>
  <td>
    A sequence of length <pre class="code">n</pre> where each element is computed by
                 expression <pre class="code">e</pre><a id="i853270601-1"/><a id="i827517490-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">S.fill(m,</pre>&nbsp;<pre class="code">n)(e)</pre>
  </td>
  <td>
    A sequence of sequences of dimension <pre class="code">m</pre>  <span style="font-family:sans-serif">x</span>  <pre class="code">n</pre> 
                 where each element is computed by expression <pre class="code">e</pre>
                 (exists also in higher dimensions)
  </td>
</tr>
<tr>
  <td>
    <pre class="code">S.tabulate(n)(f)</pre>
  </td>
  <td>
    A sequence of length <pre class="code">n</pre> where the element at each index 
                 <i>i</i> is computed by <span class="code">f(<i>i</i>)</span><a id="i-2126047930-1"/><a id="i323881813-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">S.tabulate(m,</pre>&nbsp;<pre class="code">n)(f)</pre>
  </td>
  <td>
    A sequence of sequences of dimension <pre class="code">m</pre> <span style="font-family:sans-serif">x</span> <pre class="code">n</pre> 
                 where the element at each index 
                 (<i>i</i>, <i>j</i>) is computed by <span class="code">f(<i>i</i>,</span>&nbsp;<span class="code"><i>j</i>)</span>
                 (exists also in higher dimensions)
  </td>
</tr>
<tr>
  <td>
    <pre class="code">S.range(start,</pre>&nbsp;<pre class="code">end)</pre>
  </td>
  <td>
    The sequence of integers <pre class="code">start</pre> ... <pre class="code">end</pre>&nbsp;<pre class="code">-</pre>&nbsp;<pre class="code">1</pre><a id="i-736072056-1"/><a id="i-105915794-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">S.range(start,</pre>&nbsp;<pre class="code">end,</pre>&nbsp;<pre class="code">step)</pre>
  </td>
  <td>
    The sequence of integers starting with <pre class="code">start</pre> and 
                 progressing by <pre class="code">step</pre> increments up to, and excluding, the 
                 <pre class="code">end</pre> value
  </td>
</tr>
<tr>
  <td>
    <pre class="code">S.iterate(x,</pre>&nbsp;<pre class="code">n)(f)</pre>
  </td>
  <td>
    The sequence of length <pre class="code">n</pre> with elements 
                 <pre class="code">x</pre>, <pre class="code">f(x)</pre>, <pre class="code">f(f(x))</pre>, ...<a id="i814580229-1"/><a id="i-1862459029-1"/>
  </td>
</tr>
</table>


<h3 id="sec-javaconversions">24.17 Conversions between Java and Scala collections</h3>


<p>Like Scala, Java has a rich collections library. There are many<a id="i-1787774928-1"/><a id="i884164092-1"/><a id="i1284266897-1"/>
similarities between the two. For instance, both libraries know
iterators, iterables, sets, maps, and sequences. But there are also
important differences. In particular, the Scala libraries put much
more emphasis on immutable collections, and provide many more
operations that transform a collection into a new one.</p>

<p>Sometimes you might need to convert from one collection framework to the
other. For instance, you might want to access to an existing Java
collection, as if it were a Scala collection. Or you might want to pass
one of Scala's collections to a Java method that expects the Java
counterpart. It is quite easy to do this, because Scala offers
implicit conversions between all the major collection types in the
<pre class="code">JavaConversions</pre> object.<a id="i-1559392124-1"/> In particular, you will find bidirectional
conversions between the following types:</p>

<pre>
  <code class="typename">Iterator</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hArr;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Iterator</code>
  <code class="typename">Iterator</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hArr;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Enumeration</code>
  <code class="typename">Iterable</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hArr;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.lang.Iterable</code>
  <code class="typename">Iterable</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hArr;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Collection</code>
  <code class="typename">mutable.Buffer</code>&nbsp;&nbsp;&nbsp;&hArr;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.List</code>
  <code class="typename">mutable.Set</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hArr;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Set</code>
  <code class="typename">mutable.Map</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hArr;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Map</code>
</pre>


<p>To enable these conversions, simply import like this:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;collection.JavaConversions._
  <code class="vem">import</code>&nbsp;collection.JavaConversions._
</pre>


<p>You have now automatic conversions between Scala collections and 
their corresponding Java collections.</p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;collection.mutable._
  <code class="output">import&nbsp;collection.mutable._</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;jul:&nbsp;<code class="typename">java.util.List[Int]</code>&nbsp;=&nbsp;<code class="typename">ArrayBuffer</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">jul:&nbsp;java.util.List[Int]&nbsp;=&nbsp;[1,&nbsp;2,&nbsp;3]</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf:&nbsp;<code class="typename">Seq[Int]</code>&nbsp;=&nbsp;jul
  <code class="output">buf:&nbsp;scala.collection.mutable.Seq[Int]&nbsp;=&nbsp;ArrayBuffer(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;m:&nbsp;<code class="typename">java.util.Map[String,&nbsp;Int]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">HashMap</code>(<code class="quotedstring">"abc"</code>&nbsp;-&gt;&nbsp;<code class="literal">1</code>,&nbsp;<code class="quotedstring">"hello"</code>&nbsp;-&gt;&nbsp;<code class="literal">2</code>)
  <code class="output">m:&nbsp;java.util.Map[String,Int]&nbsp;=&nbsp;{hello=2,&nbsp;abc=1}</code>
</pre>


<p>Internally, these conversion work by setting up a "wrapper" object
that forwards all operations to the underlying collection object. So
collections are never copied when converting between Java and Scala.
An interesting property is that if you do a round-trip conversion
from, say, a Java type to its corresponding Scala type, and back to the
same Java type, you end up with the identical collection object you
started with.</p>

<p>Some other common Scala collections exist that can also be converted
to Java types, but for which no corresponding conversion exists in the
other direction. These are:</p>

<div style="page-break-after:always"/>


<pre>
  <code class="typename">Seq</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.List</code>&nbsp;
  <code class="typename">mutable.Seq</code>&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.List</code>
  <code class="typename">Set</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Set</code>&nbsp;
  <code class="typename">Map</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Map</code>&nbsp;
</pre>


<p>Because Java does not distinguish between
mutable and immutable collections in their type, a conversion from, say,
<pre class="code">collection.immutable.List</pre> will yield a <pre class="code">java.util.List</pre>, on which all attempted mutation
operations will throw an <pre class="code">UnsupportedOperationException</pre>. Here's an example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;jul:&nbsp;<code class="typename">java.util.List[Int]</code>&nbsp;=&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">jul:&nbsp;java.util.List[Int]&nbsp;=&nbsp;[1,&nbsp;2,&nbsp;3]</code>
  <br />  scala&gt;&nbsp;jul.add(<code class="literal">7</code>)
  <code class="output">java.lang.UnsupportedOperationException</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;java.util.AbstractList.add(AbstractList.java:131)</code>
</pre>


<h3>24.18 Conclusion</h3>


<p>You've now seen how to use Scala's collection in great detail. Scala's
collections take the approach of giving you powerful building blocks
rather than a number of ad hoc utility methods. Putting together two
or three such building blocks allows you to express an enormous number
of useful computations. This style of library is especially effective
due to Scala having a light syntax for function literals, and due to
it providing many collection types that are persistent and immutable.</p>

<p>This chapter has shown collections from the point of view of a
programmer using the collection library. The next chapter will show
you how the collections are built and how you can add your own
collection types.</p>

<hr/>
<h4>Footnotes for Chapter 24:</h4>


<p><a id="footnotemain24-1"/>[1] Partial functions were described in <a href="case-classes-and-pattern-matching.html#sec-partial-functions">Section 15.7</a>.</p>

<p><a id="footnotemain24-2"/>[2] Hash tries are described in <a href="collections-in-depth.html#sec-hash-tries">Section 24.8</a>.</p>

<p><a id="footnotemain24-3"/>[3] "Trie" comes from the word "re<em>trie</em>val" and is pronounced <em>tree</em> or <em>try</em>.</p>

<p><a id="footnotemain24-4"/>[4] The "<pre class="code">buf.type</pre>" that appears in
the interpreter responses in this and several other examples in this section is a <em>singleton type</em>.<a id="i-108236764-1"/> As will be
explained in <a href="modular-programming-using-objects.html#sec-tracking-module-instances">Section 29.6</a>, <pre class="code">buf.type</pre>
means the variable holds exactly the object referred to by <pre class="code">buf</pre>.</p>

<p><a id="footnotemain24-5"/>[5] Assuming bits are densely packed.</p>

<p><a id="footnotemain24-6"/>[6] An exception to this is arrays: applying delayed operations
on arrays will again give results with static type <pre class="code">Array</pre>.</p>

<p><a id="footnotemain24-7"/>[7] The Scala actors library has been deprecated, but this historical example is still relevant.</p>

<div style="page-break-after:always"/>


<div style="page-break-after:always"/>

</body>
</html>
