<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8"/>
    <title>Programming in Scala, 3rd Edition</title>

    <link rel="stylesheet" type="text/css" href="book.css" />
  </head>
<body>
<h2><a id="chap-type-parameterization">Chapter 19</a></h2>
<h1>Type Parameterization</h1>


<p>In this chapter, we'll explain the details of type parameterization in
Scala.<a id="i-1818778992-1"/> Along
the way we'll demonstrate some of the techniques for information hiding 
introduced in <a href="packages-and-imports.html">Chapter 13</a> by using a concrete example: the
design of a class for purely functional queues. We're presenting type parameterization
and information hiding together, because information hiding can be used to obtain
more general type parameterization variance annotations.</p>

<p>Type parameterization allows you to write generic classes and
traits<a id="i-1986667706-1"/><a id="i1515783126-1"/><a id="i1083106947-1"/><a id="i1530367874-1"/>. For example, sets are generic and take a type parameter:
they are defined as <pre class="code">Set[T]</pre><a id="i-906912898-1"/>. As a result, any particular set instance might be a <pre class="code">Set[String]</pre>, a <pre class="code">Set[Int]</pre>, <i>etc.</i>, but
it must be a set of <em>something</em>. Unlike Java, which allows raw
types,<a id="i414933374-1"/><a id="i1163979645-1"/> Scala requires that you specify type parameters.
Variance defines inheritance relationships of parameterized types, such as whether a <pre class="code">Set[String]</pre>, for example, is a subtype of <pre class="code">Set[AnyRef]</pre>.</p>

<p>The chapter contains three parts. The first part develops a data
structure for purely functional queues. The second part develops techniques to hide internal
representation details of this structure. The final part explains
variance of type parameters and how it interacts with information
hiding.</p>

<h3>19.1 Functional queues</h3>


<p>A functional queue is a data structure with three operations:</p>

<table style="border-collapse: collapse">
<tr>
  <td>
    <pre class="code">head</pre>
  </td>
  <td>
    returns the first element of the queue
  </td>
</tr>
<tr>
  <td>
    <pre class="code">tail</pre>
  </td>
  <td>
    returns a queue without its first element
  </td>
</tr>
<tr>
  <td>
    <pre class="code">enqueue</pre>
  </td>
  <td>
    returns a new queue with a given element
  </td>
</tr>
<tr>
  <td>
  </td>
  <td>
    appended at the end
  </td>
</tr>
</table>


<p>Unlike a mutable queue, a functional queue does not change its contents
when an element is appended. Instead, a new queue is returned that contains the element.
The goal of this chapter will be to create a class, which we'll name <pre class="code">Queue</pre>, that works like this:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;q&nbsp;=&nbsp;<code class="typename">Queue</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">q:&nbsp;Queue[Int]&nbsp;=&nbsp;Queue(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;q1&nbsp;=&nbsp;q&nbsp;enqueue&nbsp;<code class="literal">4</code>
  <code class="output">q1:&nbsp;Queue[Int]&nbsp;=&nbsp;Queue(1,&nbsp;2,&nbsp;3,&nbsp;4)</code>
  <br />  scala&gt;&nbsp;q
  <code class="output">res0:&nbsp;Queue[Int]&nbsp;=&nbsp;Queue(1,&nbsp;2,&nbsp;3)</code>
</pre>


<p>If <pre class="code">Queue</pre> were a mutable implementation, the <pre class="code">enqueue</pre> operation
in the second input line above would affect the contents of <pre class="code">q</pre>; 
in fact both the result, <pre class="code">q1</pre>, and the original queue, <pre class="code">q</pre>, would contain the 
sequence <pre class="code">1,</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">3,</pre>&nbsp;<pre class="code">4</pre> after the operation. But for a functional queue, the 
appended value shows up only in the result, <pre class="code">q1</pre>, not in the queue, <pre class="code">q</pre>, being operated on.</p>

<p>Purely functional queues also have some similarity with lists.  Both
are so called <span style="font-style:italic">fully persistent</span> data structures<a id="i-1691614745-1"/>, where old
versions remain available even after extensions or modifications.
Both support <pre class="code">head</pre> and <pre class="code">tail</pre> operations. But where a list is
usually extended at the front, using a <pre class="code">::</pre> operation, a queue is extended at the
end, using <pre class="code">enqueue</pre>.</p>

<p>How can this be implemented efficiently? Ideally, a
functional (immutable) queue should not have a fundamentally higher
overhead than an imperative (mutable) one. That is, all three
operations, <pre class="code">head</pre>, <pre class="code">tail</pre>, and <pre class="code">enqueue</pre>, should operate in constant
time.</p>

<p>One simple approach to implement a functional queue would be to use a
list as representation type. Then <pre class="code">head</pre> and <pre class="code">tail</pre> would just
translate into the same operations on the list, whereas <pre class="code">enqueue</pre>
would be concatenation.</p>

<p>This would give the following
implementation:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">SlowAppendQueue[T]</code>(elems:&nbsp;<code class="typename">List[T]</code>)&nbsp;{&nbsp;<code class="comment">//&nbsp;Not&nbsp;efficient</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;head&nbsp;=&nbsp;elems.head
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">SlowAppendQueue</code>(elems.tail)
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;T)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">SlowAppendQueue</code>(elems&nbsp;:::&nbsp;<code class="typename">List</code>(x))
  }
</pre>


<p>The problem with this implementation is in the <pre class="code">enqueue</pre> operation.
It takes time proportional to the number of elements stored in the
queue. If you want constant time append, you could also try to reverse
the order of the elements in the representation list, so that the last element
that's appended comes first in the list. This would lead to the
following implementation:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">SlowHeadQueue[T]</code>(smele:&nbsp;<code class="typename">List[T]</code>)&nbsp;{&nbsp;<code class="comment">//&nbsp;Not&nbsp;efficient</code>
  &nbsp;&nbsp;<code class="comment">//&nbsp;smele&nbsp;is&nbsp;elems&nbsp;reversed</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;head&nbsp;=&nbsp;smele.last
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">SlowHeadQueue</code>(smele.init)
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;T)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">SlowHeadQueue</code>(x&nbsp;::&nbsp;smele)
  }
</pre>


<p>Now <pre class="code">enqueue</pre> is constant time, but <pre class="code">head</pre> and <pre class="code">tail</pre> are not. They
now take time proportional to the number of elements stored in the
queue.</p>

<p>Looking at these two examples, it does not seem easy to come up with
an implementation that's constant time for all three operations. In
fact, it looks doubtful that this is even possible! However, by
combining the two operations you can get very close. The idea is to
represent a queue by two lists, called <pre class="code">leading</pre> and <pre class="code">trailing</pre>.
The <pre class="code">leading</pre> list contains elements towards the front, whereas the
<pre class="code">trailing</pre> list contains elements towards the back of the queue in
reversed order. The contents of the whole queue are at each instant 
equal to "<pre class="code">leading</pre>&nbsp;<pre class="code">:::</pre>&nbsp;<pre class="code">trailing.reverse</pre>".</p>

<p>Now, to append an element, you just cons it to the <pre class="code">trailing</pre> list
using the <pre class="code">::</pre> operator,<a id="i1411857630-3"/>
so <pre class="code">enqueue</pre> is constant time. This means that, when an initially empty queue is constructed
from successive <pre class="code">enqueue</pre> operations, the <pre class="code">trailing</pre> list will grow whereas
the <pre class="code">leading</pre> list will stay empty. Then, before the first <pre class="code">head</pre> or <pre class="code">tail</pre> operation is performed
on an empty <pre class="code">leading</pre> list, the whole <pre class="code">trailing</pre> list is copied to
<pre class="code">leading</pre>, reversing the order of the elements. 
This is done in an operation called <pre class="code">mirror</pre>.
<a href="type-parameterization.html#lst-simple-functional-queues">Listing 19.1</a> 
shows an implementation of queues that uses this approach.</p>

<p><a id="lst-simple-functional-queues"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Queue[T]</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;leading:&nbsp;<code class="typename">List[T]</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;trailing:&nbsp;<code class="typename">List[T]</code>&nbsp;
  &nbsp;&nbsp;)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;mirror&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(leading.isEmpty)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue</code>(trailing.reverse,&nbsp;<code class="typename">Nil</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;head&nbsp;=&nbsp;mirror.leading.head
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail&nbsp;=&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;q&nbsp;=&nbsp;mirror&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue</code>(q.leading.tail,&nbsp;q.trailing)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;T)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue</code>(leading,&nbsp;x&nbsp;::&nbsp;trailing)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 19.1 - A basic functional queue.</h5>


<p>What is the complexity of this implementation of queues? 
The <pre class="code">mirror</pre> operation might take time proportional to the number of queue elements,
but only if list <pre class="code">leading</pre> is empty. It returns directly if <pre class="code">leading</pre> is non-empty. 
Because <pre class="code">head</pre> and <pre class="code">tail</pre> call <pre class="code">mirror</pre>, their complexity might be
linear in the size of the queue, too. However, the longer the queue gets, the less often
<pre class="code">mirror</pre> is called.</p>

<p>Indeed, assume a queue of length <i>n</i> with an empty <pre class="code">leading</pre> list.
Then <pre class="code">mirror</pre> has to reverse-copy a list of length <i>n</i>. However, the next time <pre class="code">mirror</pre> will have to do any work is once the <pre class="code">leading</pre> list is empty again, which will be the case after <i>n</i>
<pre class="code">tail</pre> operations. This means you can "charge" each of these <i>n</i> <pre class="code">tail</pre> operations with one
<i>n</i>'th of the complexity of <pre class="code">mirror</pre>, which means a constant amount of work.
Assuming that <pre class="code">head</pre>, <pre class="code">tail</pre>, and <pre class="code">enqueue</pre> operations appear with about the same frequency,
the <span style="font-style:italic">amortized</span> complexity is hence constant for each operation.
So functional queues are asymptotically just as efficient as mutable ones.</p>

<p>Now, there are some caveats that need to be attached to
this argument. First, the discussion was only about asymptotic
behavior; the constant factors might well be somewhat different.
Second, the argument rested on the fact that <pre class="code">head</pre>, <pre class="code">tail</pre> and
<pre class="code">enqueue</pre> are called with about the same frequency. If <pre class="code">head</pre> is
called much more often than the other two operations, the argument is
not valid, as each call to <pre class="code">head</pre> might involve a costly
re-organization of the list with <pre class="code">mirror</pre>. The second caveat can be
avoided; it is possible to design functional queues so that in a
sequence of successive <pre class="code">head</pre> operations only the first one might
require a re-organization. You will find out at the end of this
chapter how this is done.</p>

<h3>19.2 Information hiding</h3>


<p>The implementation of <pre class="code">Queue</pre> shown in <a href="type-parameterization.html#lst-simple-functional-queues">Listing 19.1</a> is now quite good with regards to<a id="i374717171-2"/>
efficiency.  You might object, though, that this efficiency
is paid for by exposing
a needlessly detailed implementation. The <pre class="code">Queue</pre> constructor, which is
globally accessible, takes two lists as parameters, where one is
reversed&mdash;hardly an intuitive representation of a queue. 
What's needed is a way to hide this constructor from client code. In this section, we'll
show you some ways to accomplish this in Scala.</p>

<h4>Private constructors and factory methods</h4>


<p>In Java, you can hide a constructor by making it <pre class="code">private</pre>.  In Scala, the primary constructor does
not have an explicit definition;<a id="i2093291082-1"/><a id="i-1528003040-1"/> it is defined implicitly by the class
parameters and body. Nevertheless, it is still possible to hide
the primary constructor by adding a <pre class="code">private</pre> modifier in front of
the class parameter list<a id="i1958480308-1"/>, as shown in <a href="type-parameterization.html#lst-private-constructor">Listing 19.2</a>:</p>

<p><a id="lst-private-constructor"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Queue[T]</code>&nbsp;<code class="vem">private</code>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;leading:&nbsp;<code class="typename">List[T]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;trailing:&nbsp;<code class="typename">List[T]</code>
  &nbsp;&nbsp;)&nbsp;
</pre>


<h5>Listing 19.2 - Hiding a primary constructor by making it private.</h5>


<p>The <pre class="code">private</pre> modifier between the class name and its parameters
indicates that the constructor of <pre class="code">Queue</pre> is private: it can be
accessed only from within the class itself and its companion
object<a id="i-861331495-1"/>.
The class name <pre class="code">Queue</pre> is still public, so you can use it as a type, but you cannot
call its constructor:<a id="i-1604722710-1"/></p>

<pre>
  scala&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue</code>(<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>),&nbsp;<code class="typename">List</code>(<code class="literal">3</code>))
  <code class="output">&lt;console&gt;:9:&nbsp;error:&nbsp;constructor&nbsp;Queue&nbsp;in&nbsp;class&nbsp;Queue&nbsp;cannot&nbsp;</code>
  <code class="output">be&nbsp;accessed&nbsp;in&nbsp;object&nbsp;$iw</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Queue(List(1,&nbsp;2),&nbsp;List(3))</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>Now that the primary constructor of class <pre class="code">Queue</pre> can no longer be called from client code, 
there needs to be some other way to create new queues.
One possibility is to add an auxiliary constructor, like this:</p>

<pre>
  <code class="vem">def</code>&nbsp;<code class="vem">this</code>()&nbsp;=&nbsp;<code class="vem">this</code>(<code class="typename">Nil</code>,&nbsp;<code class="typename">Nil</code>)&nbsp;
</pre>


<p>The auxiliary constructor shown in the previous example builds an empty queue. As a refinement, the auxiliary constructor could take a list of
initial queue elements:</p>

<pre>
  <code class="vem">def</code>&nbsp;<code class="vem">this</code>(elems:&nbsp;T*)&nbsp;=&nbsp;<code class="vem">this</code>(elems.toList,&nbsp;<code class="typename">Nil</code>)
</pre>


<p>Recall that <pre class="code">T*</pre> is the notation for repeated parameters, as
described in <a href="functions-and-closures.html#sec-fancy-parameters">Section 8.8</a>.</p>

<p>Another possibility is to add a factory method that builds a queue
from such a sequence of initial elements. A neat way to do this is to
define an object <pre class="code">Queue</pre> that has the same name as the class being
defined and contains an <pre class="code">apply</pre> method, as shown in <a href="type-parameterization.html#lst-apply-factory">Listing 19.3</a>:</p>

<p><a id="lst-apply-factory"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Queue</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;constructs&nbsp;a&nbsp;queue&nbsp;with&nbsp;initial&nbsp;elements&nbsp;`xs'</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply[T](xs:&nbsp;T*)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue[T]</code>(xs.toList,&nbsp;<code class="typename">Nil</code>)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 19.3 - An <pre class="code">apply</pre> factory method in a companion object.</h5>


<p>By placing this object in the same source file as class <pre class="code">Queue</pre>, you make the object
a companion object of the class. 
You saw in <a href="packages-and-imports.html#sec-access-modifiers">Section 13.5</a> that a companion object has the same access rights 
as its class.  Because of this, the <pre class="code">apply</pre> method in object <pre class="code">Queue</pre>
can create a new <pre class="code">Queue</pre> object, even though the 
constructor of class <pre class="code">Queue</pre> is private.</p>

<p>Note that, because the factory method is called <pre class="code">apply</pre>, clients can
create queues with an expression such as <pre class="code">Queue(1,</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">3)</pre>. This expression
expands to <pre class="code">Queue.apply(1,</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">3)</pre> since <pre class="code">Queue</pre> is an object
instead of a function.
As a result, <pre class="code">Queue</pre> looks to clients as if it was a
globally defined factory method.  In reality, Scala has no globally visible
methods; every method must be contained in an object or a
class. However, using methods named <pre class="code">apply</pre> inside global objects, 
you can support usage patterns that look like invocations of global
methods.</p>

<p><a id="lst-type-abstract-functional-queues"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">Queue[T]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;head:&nbsp;T
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail:&nbsp;<code class="typename">Queue[T]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;T):&nbsp;<code class="typename">Queue[T]</code>
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Queue</code>&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply[T](xs:&nbsp;T*):&nbsp;<code class="typename">Queue[T]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">QueueImpl[T]</code>(xs.toList,&nbsp;<code class="typename">Nil</code>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">QueueImpl[T]</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;leading:&nbsp;<code class="typename">List[T]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;trailing:&nbsp;<code class="typename">List[T]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Queue[T]</code>&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;mirror&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(leading.isEmpty)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">QueueImpl</code>(trailing.reverse,&nbsp;<code class="typename">Nil</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;head:&nbsp;T&nbsp;=&nbsp;mirror.leading.head
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail:&nbsp;<code class="typename">QueueImpl[T]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;q&nbsp;=&nbsp;mirror
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">QueueImpl</code>(q.leading.tail,&nbsp;q.trailing)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;T)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">QueueImpl</code>(leading,&nbsp;x&nbsp;::&nbsp;trailing)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 19.4 - Type abstraction for functional queues.</h5>


<h4>An alternative: private classes</h4>


<p>Private constructors and private members are one way to hide the
initialization and representation of a class.<a id="i848757295-1"/> Another more radical
way is to hide the class itself and only export a trait that reveals
the public interface of the class. The code in 
<a href="type-parameterization.html#lst-type-abstract-functional-queues">Listing 19.4</a>
implements this design.
There's a trait <pre class="code">Queue</pre>, which declares the methods <pre class="code">head</pre>, <pre class="code">tail</pre>,
and <pre class="code">enqueue</pre>. All three methods are implemented in a subclass
<pre class="code">QueueImpl</pre>, which is itself a <pre class="code">private</pre> inner class of object<a id="i-1543098108-1"/>
<pre class="code">Queue</pre>. This exposes to clients the same information as before, but
using a different technique.
Instead of hiding individual constructors and methods, this version
hides the whole implementation class.</p>

<h3 id="sec-first-arrays">19.3 Variance annotations</h3>


<p><pre class="code">Queue</pre>, as defined in <a href="type-parameterization.html#lst-type-abstract-functional-queues">Listing 19.4</a>, is a trait, but<a id="i1555746715-1"/><a id="i935521398-1"/>
not a type. <pre class="code">Queue</pre> is not a type because it takes a type parameter.</p>

<p>As a result,
you cannot create variables of type <pre class="code">Queue</pre>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;doesNotCompile(q:&nbsp;<code class="typename">Queue</code>)&nbsp;=&nbsp;{}
  <code class="output">&lt;console&gt;:8:&nbsp;error:&nbsp;class&nbsp;Queue&nbsp;takes&nbsp;type&nbsp;parameters</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;doesNotCompile(q:&nbsp;Queue)&nbsp;=&nbsp;{}</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>Instead, trait <pre class="code">Queue</pre> enables you to specify <em>parameterized</em> types, such as <pre class="code">Queue[String]</pre>, <pre class="code">Queue[Int]</pre>, or <pre class="code">Queue[AnyRef]</pre>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;doesCompile(q:&nbsp;<code class="typename">Queue[AnyRef]</code>)&nbsp;=&nbsp;{}
  <code class="output">doesCompile:&nbsp;(q:&nbsp;Queue[AnyRef])Unit</code>
</pre>


<p>Thus, <pre class="code">Queue</pre> is a trait and <pre class="code">Queue[String]</pre> is a type.
<pre class="code">Queue</pre> is also called a <em>type constructor</em><a id="i1905256393-1"/> because you can construct a type with it by specifying a type parameter. (This is analogous to constructing an object instance with a plain-old 
constructor by specifying a value
parameter.) The type constructor <pre class="code">Queue</pre> "generates" a family of types, which includes <pre class="code">Queue[Int]</pre>,
<pre class="code">Queue[String]</pre>, and <pre class="code">Queue[AnyRef]</pre>.</p>

<p>You can also say that <pre class="code">Queue</pre> is a <em>generic</em>
trait.<a id="i1530367874-2"/><a id="i-1356826384-1"/> (Classes and traits that take type
parameters are "generic," but the types they generate are "parameterized," not generic.) The term "generic" means that you are
defining many specific types with one generically written class or trait. For example, trait <pre class="code">Queue</pre> in <a href="type-parameterization.html#lst-type-abstract-functional-queues">Listing 19.4</a>
defines a generic queue. <pre class="code">Queue[Int]</pre> and <pre class="code">Queue[String]</pre>, <i>etc.</i>, would be the specific queues.</p>

<p>The combination of type parameters and subtyping poses some
interesting questions.<a id="i-1780437500-1"/>
For example, are there any special subtyping relationships between members of the family of types generated
by <pre class="code">Queue[T]</pre>? More specifically, should a <pre class="code">Queue[String]</pre> be
considered a subtype of <pre class="code">Queue[AnyRef]</pre>?
Or more generally, if <pre class="code">S</pre> is a subtype of type <pre class="code">T</pre>,
then should <pre class="code">Queue[S]</pre> be considered a subtype of <pre class="code">Queue[T]</pre>?
If so, you could say that trait <pre class="code">Queue</pre> is <a href="glossary.html#g1865839257"><em>covariant</em></a> (or
"flexible") in its type parameter <pre class="code">T</pre><a id="i2006441693-1"/>. Or, since it just has one type parameter, you could say simply that
<pre class="code">Queue</pre>s are covariant. Covariant <pre class="code">Queue</pre>s would mean, for example, that you could pass a <pre class="code">Queue[String]</pre> to
the <pre class="code">doesCompile</pre> method shown previously, which takes a value
parameter of type <pre class="code">Queue[AnyRef]</pre>.</p>

<p>Intuitively, all this seems OK, since a
queue of <pre class="code">String</pre>s looks like a special case of a queue of
<pre class="code">AnyRef</pre>s.
In Scala, however, generic types have by default <a href="glossary.html#g-233237224"><em>nonvariant</em></a> (or "rigid") subtyping<a id="i1359580222-1"/>. That
is, with <pre class="code">Queue</pre> defined as in <a href="type-parameterization.html#lst-type-abstract-functional-queues">Listing 19.4</a>, queues with different element
types would never be in a subtype relationship.
A <pre class="code">Queue[String]</pre> would not be usable as a <pre class="code">Queue[AnyRef]</pre>.
However, you can demand
covariant (flexible) subtyping of queues by changing the first line of the
definition of class <pre class="code">Queue</pre> like this:</p>

<pre>
  <code class="vem">trait</code>&nbsp;<code class="typename">Queue[+T]</code>&nbsp;{&nbsp;...&nbsp;}
</pre>


<p>Prefixing a formal type parameter with a <pre class="code">+</pre> indicates that
subtyping is covariant (flexible) in that
parameter<a id="i-1315578930-1"/>. 
By adding this single character, you are telling Scala that you want
<pre class="code">Queue[String]</pre>, for example, to be considered a subtype of <pre class="code">Queue[AnyRef]</pre>.
 The compiler will check that <pre class="code">Queue</pre> is defined
in a way that this subtyping is sound.</p>

<p>Besides <pre class="code">+</pre>, there is also a prefix <pre class="code">-</pre>, which indicates
<a href="glossary.html#g-1356412796"><em>contravariant</em></a> subtyping<a id="i973833207-1"/><a id="i900875858-1"/>. If <pre class="code">Queue</pre> were defined like this:</p>

<pre>
  <code class="vem">trait</code>&nbsp;<code class="typename">Queue[-T]</code>&nbsp;{&nbsp;...&nbsp;}&nbsp;
</pre>


<p>then if <pre class="code">T</pre> is a subtype of type <pre class="code">S</pre>, this would imply
that <pre class="code">Queue[S]</pre> is a subtype of <pre class="code">Queue[T]</pre> (which in the case of queues
would be rather surprising!).  Whether a type parameter is covariant, contravariant, or nonvariant
is called the parameter's
<a href="glossary.html#g-1249575311"><em>variance</em></a><a id="i-1249575311-1"/>. The <pre class="code">+</pre> and <pre class="code">-</pre> symbols you can place next to type parameters 
are called <em>variance annotations</em>.<a id="i1554444807-1"/></p>

<p>In a purely functional world, many types are naturally covariant (flexible). However,
the situation changes once you introduce mutable data. To find out why, consider the
simple type of one-element cells that can be read or written, shown in <a href="type-parameterization.html#lst-nonvariant-cell">Listing 19.5</a>.
<a id="lst-nonvariant-cell"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Cell[T]</code>(init:&nbsp;T)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[<code class="vem">this</code>]&nbsp;<code class="vem">var</code>&nbsp;current&nbsp;=&nbsp;init
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;get&nbsp;=&nbsp;current
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;set(x:&nbsp;T)&nbsp;=&nbsp;{&nbsp;current&nbsp;=&nbsp;x&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 19.5 - A nonvariant (rigid) <pre class="code">Cell</pre> class.</h5>


<p>The <pre class="code">Cell</pre> type of <a href="type-parameterization.html#lst-nonvariant-cell">Listing 19.5</a> is declared nonvariant (rigid). For the sake
of argument,
assume for a moment that <pre class="code">Cell</pre> was declared covariant instead&mdash;<i>i.e.</i>, it was declared
<pre class="code">class</pre>&nbsp;<pre class="code">Cell[+T]</pre>&mdash;and that this passed the Scala
compiler. (It doesn't,
and we'll explain why shortly.) 
Then you could construct the following problematic statement sequence:</p>

<pre>
  <code class="vem">val</code>&nbsp;c1&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Cell[String]</code>(<code class="quotedstring">"abc"</code>)
  <code class="vem">val</code>&nbsp;c2:&nbsp;<code class="typename">Cell[Any]</code>&nbsp;=&nbsp;c1
  c2.set(<code class="literal">1</code>)
  <code class="vem">val</code>&nbsp;s:&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;c1.get&nbsp;
</pre>


<p>Seen by itself, each of these four lines looks OK. The first line creates a
cell of strings and stores it in a <pre class="code">val</pre> named <pre class="code">c1</pre>. The second line defines a new
<pre class="code">val</pre>, <pre class="code">c2</pre>, of type <pre class="code">Cell[Any]</pre>, which initialized with <pre class="code">c1</pre>. This is
OK since <pre class="code">Cell</pre>s are assumed to be covariant. The third line sets the
value of cell <pre class="code">c2</pre> to 1. This is also OK because the assigned value <pre class="code">1</pre> is an instance of
<pre class="code">c2</pre>'s element type <pre class="code">Any</pre>. Finally, the last line assigns the element value of 
<pre class="code">c1</pre> into a string. Nothing strange here, as both the sides are of the same type.
But taken together, these four lines end up
assigning the integer <pre class="code">1</pre> to the string <pre class="code">s</pre>. This is clearly a
violation of type soundness.</p>

<p>Which operation is to blame for the runtime fault? It
must be the second one, which uses covariant subtyping. 
The other statements are too simple and fundamental.
Thus, a <pre class="code">Cell</pre> of
<pre class="code">String</pre> is <span style="font-style:italic">not</span> also a <pre class="code">Cell</pre> of <pre class="code">Any</pre>, because there are
things you can do with a <pre class="code">Cell</pre> of <pre class="code">Any</pre> that you cannot do with 
a <pre class="code">Cell</pre> of <pre class="code">String</pre>.  You cannot use <pre class="code">set</pre> with an <pre class="code">Int</pre> argument on a 
<pre class="code">Cell</pre> of <pre class="code">String</pre>, for example.</p>

<p>In fact, were you to pass the covariant version of <pre class="code">Cell</pre> to the 
Scala compiler, you would get a compile-time error:<a id="i-1072664655-1"/></p>

<pre>
  <code class="output">Cell.scala:7:&nbsp;error:&nbsp;covariant&nbsp;type&nbsp;T&nbsp;occurs&nbsp;in</code>
  <code class="output">contravariant&nbsp;position&nbsp;in&nbsp;type&nbsp;T&nbsp;of&nbsp;value&nbsp;x</code>
  <code class="output">&nbsp;&nbsp;&nbsp;def&nbsp;set(x:&nbsp;T)&nbsp;=&nbsp;current&nbsp;=&nbsp;x</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<h4>Variance and arrays</h4>


<p>It's interesting to compare this behavior with arrays in Java. In
principle, arrays are just like cells except that they can have more
than one element. Nevertheless, arrays are treated as covariant in Java.</p>

<p>You can try an example analogous to the cell interaction described here with
Java arrays:</p>

<pre>
  //&nbsp;this&nbsp;is&nbsp;Java
  String[]&nbsp;a1&nbsp;=&nbsp;{&nbsp;"abc"&nbsp;};
  Object[]&nbsp;a2&nbsp;=&nbsp;a1;
  a2[0]&nbsp;=&nbsp;new&nbsp;Integer(17);
  String&nbsp;s&nbsp;=&nbsp;a1[0];
</pre>


<p>If you try out this example, you will find that it compiles. But executing the program
will cause an <pre class="code">ArrayStore</pre> exception to be thrown when <pre class="code">a2[0]</pre>
is assigned to an <pre class="code">Integer</pre>:</p>

<pre>
  <code class="output">Exception&nbsp;in&nbsp;thread&nbsp;"main"&nbsp;java.lang.ArrayStoreException:&nbsp;</code>
  <code class="output">java.lang.Integer</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;JavaArrays.main(JavaArrays.java:8)</code>
</pre>


<p>What happens here is that
Java stores the element type of the array at runtime. Then, every time
an array element is updated, the new element value is checked against
the stored type. If it is not an instance of that type, an
<pre class="code">ArrayStore</pre> exception is thrown.<a id="i1807481219-1"/></p>

<p>You might ask why Java adopted this design, which seems both
unsafe and expensive. When asked this question, James Gosling,<a id="i1512661551-1"/>
the principal inventor of the Java language, answered that they
wanted to have a simple means to treat arrays generically. For
instance, they wanted to be able to write a method to sort all
elements of an array, using a signature like the following that takes an array of <pre class="code">Object</pre>:</p>

<pre>
  void&nbsp;sort(<code class="typename">Object[]</code>&nbsp;a,&nbsp;<code class="typename">Comparator</code>&nbsp;cmp)&nbsp;{&nbsp;...&nbsp;}
</pre>


<p>Covariance of arrays was needed so that arrays of arbitrary reference
types could be passed to this <pre class="code">sort</pre> method. Of course, with the
arrival of Java generics, such a <pre class="code">sort</pre> method can now be written with a
type parameter, so the covariance of arrays is no longer
necessary<a id="i1590614948-1"/>. 
For compatibility reasons, though, it has persisted in Java to this day.</p>

<div style="page-break-after:always"/>


<p>Scala tries to be purer than Java in not treating arrays as covariant.
Here's what you get if you translate the first two lines of the array
example to Scala:<a id="i-677980410-3"/></p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a1&nbsp;=&nbsp;<code class="typename">Array</code>(<code class="quotedstring">"abc"</code>)
  <code class="output">a1:&nbsp;Array[String]&nbsp;=&nbsp;Array(abc)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a2:&nbsp;<code class="typename">Array[Any]</code>&nbsp;=&nbsp;a1
  <code class="output">&lt;console&gt;:8:&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Array[String]</code>
  <code class="output">&nbsp;required:&nbsp;Array[Any]</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;a2:&nbsp;Array[Any]&nbsp;=&nbsp;a1</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>What happened here is that Scala treats arrays as nonvariant (rigid), so
an <pre class="code">Array[String]</pre> is not considered to conform to an <pre class="code">Array[Any]</pre>.
However, sometimes it is necessary to interact with legacy methods in
Java that use an <pre class="code">Object</pre> array as a means to emulate a generic array. For
instance, you might want to call a <pre class="code">sort</pre> method like the one described previously
with an array of <pre class="code">String</pre>s as argument. To make this possible,
Scala lets you cast an array of <pre class="code">T</pre>s to an array of any supertype of
<pre class="code">T</pre>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a2:&nbsp;<code class="typename">Array[Object]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a1.asInstanceOf[<code class="typename">Array[Object]</code>]
  <code class="output">a2:&nbsp;Array[Object]&nbsp;=&nbsp;Array(abc)</code>
</pre>


<p>The cast is always legal at compile-time, and it will always 
succeed at run-time because the JVM's underlying run-time model treats 
arrays as covariant, just as Java the language does.
But you might get <pre class="code">ArrayStore</pre> exceptions afterwards, 
again just as you would in Java.</p>

<h3>19.4 Checking variance annotations</h3>


<p>Now that you have seen some examples where variance is unsound, you<a id="i-245097893-1"/>
may be wondering which kind of class definitions need to be rejected and
which can be accepted. So far, all violations of type
soundness involved some reassignable field or array element. The purely
functional implementation of queues, on the other hand, looks like a
good candidate for covariance. However, the following
example shows that you can "engineer" an unsound situation even if there
is no reassignable field.</p>

<p>To set up the example, assume that queues as defined in <a href="type-parameterization.html#lst-type-abstract-functional-queues">Listing 19.4</a> are
covariant. Then, create a subclass of queues that specializes the
element type to <pre class="code">Int</pre> and overrides the <pre class="code">enqueue</pre> method:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">StrangeIntQueue</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Queue[Int]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(math.sqrt(x))
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">super</code>.enqueue(x)
  &nbsp;&nbsp;}
  }
</pre>


<p>The <pre class="code">enqueue</pre> method in
<pre class="code">StrangeIntQueue</pre> prints out the square root of
its (integer) argument before doing the append proper.</p>

<p>Now, you can 
write a counterexample in two lines:</p>

<pre>
  <code class="vem">val</code>&nbsp;x:&nbsp;<code class="typename">Queue[Any]</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">StrangeIntQueue</code>
  x.enqueue(<code class="quotedstring">"abc"</code>)
</pre>


<p>The first of these two lines is valid because <pre class="code">StrangeIntQueue</pre> is a
subclass of <pre class="code">Queue[Int]</pre> and, assuming covariance of queues,
<pre class="code">Queue[Int]</pre> is a subtype of <pre class="code">Queue[Any]</pre>. The second line is valid because
you can append a <pre class="code">String</pre> to a <pre class="code">Queue[Any]</pre>.
However, taken together, these two lines have the effect of applying a
square root method to a string, which makes no sense.</p>

<p>Clearly it's not just mutable fields that make covariant types unsound.
The problem is more general. It turns out that as soon as a generic
parameter type appears as the type of a method parameter, the
containing class or trait may not be covariant in
that type parameter.</p>

<p>For queues, the <pre class="code">enqueue</pre>
method violates this condition:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">Queue[+T]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;T)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;...
  }
</pre>


<p>Running a modified queue class like the one above through a Scala compiler would yield:<a id="i-1072664655-2"/></p>

<pre>
  <code class="output">Queues.scala:11:&nbsp;error:&nbsp;covariant&nbsp;type&nbsp;T&nbsp;occurs&nbsp;in</code>
  <code class="output">contravariant&nbsp;position&nbsp;in&nbsp;type&nbsp;T&nbsp;of&nbsp;value&nbsp;x</code>
  <code class="output">&nbsp;&nbsp;def&nbsp;enqueue(x:&nbsp;T)&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>Reassignable fields are a special case of the rule that disallows type parameters annotated with <pre class="code">+</pre>
from being used as method parameter types. As mentioned in <a href="mutable-objects.html#sec-properties">Section 18.2</a>, a
reassignable field, "<pre class="code">var</pre>&nbsp;<pre class="code">x:</pre>&nbsp;<pre class="code">T</pre>", is treated in Scala as a getter method, "<pre class="code">def</pre>&nbsp;<pre class="code">x:</pre>&nbsp;<pre class="code">T</pre>",
and a setter method, "<pre class="code">def</pre>&nbsp;<pre class="code">x_=(y:</pre>&nbsp;<pre class="code">T)</pre>"<a id="i-1969580643-2"/>. As you can see, the setter method has a  
parameter of the field's type <pre class="code">T</pre>. So that type may not be covariant.</p>

<div class="pointofinterest">
<h3>The fast track</h3>


<p>In the rest of this section, we'll describe the mechanism by which the
Scala compiler checks variance annotations.
If you're not interested in such detail right now, you can safely skip to <a href="type-parameterization.html#sec-lower-bounds">Section 19.5</a>. The
most important thing to understand is that the Scala compiler
will check any variance annotations you place on type parameters. For example, if you try to declare a type parameter to
be covariant (by adding a <pre class="code">+</pre>), but that could lead to potential runtime errors, your program
won't compile.</p>

</div>


<p>To verify correctness of variance annotations,
the Scala compiler classifies all positions in a class or trait body
as <em>positive</em>, <em>negative</em> or <em>neutral</em>. A "position" is any
location in the class or trait (but from now on we'll just write "class")
body where a type parameter may be used. For example, every method value parameter is a position because
a method value parameter has a type. Therefore a type parameter could appear in that position.</p>

<p>The compiler checks each use of each of the class's type parameters. Type parameters
annotated with <pre class="code">+</pre>
may only be used in positive positions, while type parameters
annotated with <pre class="code">-</pre> may only be used in negative positions.  
A type parameter with no variance annotation
may be used in any position, and is, therefore, the only
kind of type parameter that can be used in neutral
positions of the class body.</p>

<p>To classify the positions, the compiler starts from the declaration of
a type parameter and then moves inward through deeper nesting levels.
Positions at the top level of the declaring class are classified as
positive.  By default, positions at deeper nesting levels are
classified the same as that at enclosing levels, but there are a handful
of exceptions where the classification changes.
Method value parameter positions are classified to the
<em>flipped</em> classification relative to positions
outside the method, where the flip of a positive classification is negative, the flip of a negative classification is positive, and
the flip of a neutral classification is still neutral.</p>

<p>Besides method value parameter positions, the current classification is also flipped at the type parameters of methods.
A classification is sometimes flipped at the type argument
position of a type, such as the <pre class="code">Arg</pre> in <pre class="code">C[Arg]</pre>,
depending on the variance of the corresponding type parameter.
If <pre class="code">C</pre>'s type
parameter is annotated with a <pre class="code">+</pre> then the
classification stays the same.  If
<pre class="code">C</pre>'s type parameter is annotated with a <pre class="code">-</pre>, then the current classification is flipped.  If <pre class="code">C</pre>'s
type parameter has no variance annotation then the current classification is changed to
neutral.</p>

<p>As a somewhat contrived example, consider the following class
definition, where several positions are
annotated with their classifications, <pre class="code"><sup>+</sup></pre> (for
positive) or <pre class="code"><sup>-</sup></pre> (for
negative):</p>

<pre>
  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Cat[-T,&nbsp;+U]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;meow[W<sup>-</sup>](volume:&nbsp;T<sup>-</sup>,&nbsp;listener:&nbsp;<code class="typename">Cat[U<sup>+</sup>,&nbsp;T<sup>-</sup>]</code><sup>-</sup>)
  &nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<code class="typename">Cat[Cat[U<sup>+</sup>,&nbsp;T<sup>-</sup>]<sup>-</sup>,&nbsp;U<sup>+</sup>]</code><sup>+</sup>
  }
</pre>


<p>The positions of the type parameter, <pre class="code">W</pre>, and the two value
parameters, <pre class="code">volume</pre> and <pre class="code">listener</pre>, are all negative.
Looking at the result type of <pre class="code">meow</pre>,
the position of the first <pre class="code">Cat[U,</pre>&nbsp;<pre class="code">T]</pre> argument is
negative because <pre class="code">Cat</pre>'s first type parameter, <pre class="code">T</pre>, is annotated with a <pre class="code">-</pre>.
 The type <pre class="code">U</pre> inside this argument is again in positive position
(two flips), whereas the type <pre class="code">T</pre> inside that argument is still in negative position.</p>

<p>You see from this discussion that it's quite hard to keep track of
variance positions. That's why it's a welcome relief that the Scala
compiler does this job for you.</p>

<p>Once the classifications are computed, the compiler checks that each
type parameter is only used in positions that are classified
appropriately.  In this case, <pre class="code">T</pre> is only used in negative
positions, and <pre class="code">U</pre> is only used in positive positions.
So class <pre class="code">Cat</pre> is type correct.</p>

<h3 id="sec-lower-bounds">19.5 Lower bounds</h3>


<p>Back to the <pre class="code">Queue</pre> class. You saw that the previous definition
of <pre class="code">Queue[T]</pre> shown in <a href="type-parameterization.html#lst-type-abstract-functional-queues">Listing 19.4</a> cannot be made covariant
in <pre class="code">T</pre> because <pre class="code">T</pre> appears
as a type of a parameter
of the <pre class="code">enqueue</pre> method, and that's a negative
position.</p>

<p>Fortunately, there's a way to get unstuck: you can generalize 
<pre class="code">enqueue</pre> by making it polymorphic (<i>i.e.</i>, giving the <pre class="code">enqueue</pre> method itself a type parameter)
and using a <em>lower bound</em> for its type parameter.<a id="i1770535476-1"/><a id="i1742340276-1"/> <a href="type-parameterization.html#lst-lower-bound">Listing 19.6</a> shows a new 
formulation of <pre class="code">Queue</pre> that implements this idea.</p>

<p><a id="lst-lower-bound"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Queue[+T]</code>&nbsp;(<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;leading:&nbsp;<code class="typename">List[T]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;trailing:&nbsp;<code class="typename">List[T]</code>&nbsp;)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue[U&nbsp;&gt;:&nbsp;T](x:&nbsp;U)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue[U]</code>(leading,&nbsp;x&nbsp;::&nbsp;trailing)&nbsp;<code class="comment">//&nbsp;...</code>
  &nbsp;&nbsp;}
</pre>


<h5>Listing 19.6 - A type parameter with a lower bound.</h5>


<p>The new definition gives <pre class="code">enqueue</pre> a type parameter <pre class="code">U</pre>, and with the syntax, "<pre class="code">U</pre>&nbsp;<pre class="code">&gt;:</pre>&nbsp;<pre class="code">T</pre>", defines <pre class="code">T</pre> as the lower bound
for <pre class="code">U</pre>. As a result,<a id="i1800766244-1"/>
<pre class="code">U</pre> is required to be a supertype of <pre class="code">T</pre>.<a href="type-parameterization.html#footnotemain19-1">[1]</a>
The parameter to <pre class="code">enqueue</pre> is now
of type <pre class="code">U</pre> instead of type <pre class="code">T</pre>, and the return value of the
method is now <pre class="code">Queue[U]</pre> instead of <pre class="code">Queue[T]</pre>.</p>

<p>For example, suppose there is a class <pre class="code">Fruit</pre> with two subclasses,
<pre class="code">Apple</pre> and <pre class="code">Orange</pre>. With the new definition of class <pre class="code">Queue</pre>, it
is possible to append an <pre class="code">Orange</pre> to a <pre class="code">Queue[Apple]</pre>. The result
will be a <pre class="code">Queue[Fruit]</pre>.</p>

<p>This revised definition of <pre class="code">enqueue</pre> is type correct.  Intuitively, if
<pre class="code">T</pre> is a more specific type than expected (for example, <pre class="code">Apple</pre> instead of
<pre class="code">Fruit</pre>), a call to <pre class="code">enqueue</pre> will still work because <pre class="code">U</pre>
(<pre class="code">Fruit</pre>) will still be a supertype of <pre class="code">T</pre> (<pre class="code">Apple</pre>).<a href="type-parameterization.html#footnotemain19-2">[2]</a></p>

<p>The new definition of <pre class="code">enqueue</pre> is arguably better than the old, because it is more general.  Unlike the old version, the new
definition allows you to append an arbitrary supertype <pre class="code">U</pre> of the queue
element type <pre class="code">T</pre>.  The result is then a <pre class="code">Queue[U]</pre>. Together with
queue covariance, this gives the right kind of flexibility for
modeling queues of different element types in a natural way.</p>

<p>This shows that variance annotations and lower bounds play well together. 
They are a good example of <span style="font-style:italic">type-driven design</span>, where the types of an
interface guide its detailed design and implementation<a id="i819829841-1"/>. In the case of
queues, it's likely you would not have thought of the refined
implementation of <pre class="code">enqueue</pre> with a lower bound. But you might have
decided to make queues covariant, in which case, the compiler would
have pointed out the variance error for <pre class="code">enqueue</pre>. Correcting the
variance error by adding a lower bound makes <pre class="code">enqueue</pre> more general and
queues as a whole more usable.</p>

<p>This observation is also the main reason that Scala prefers
declaration-site variance over use-site variance as it is found in
Java's
wildcards.<a id="i358663587-1"/><a id="i1971613366-1"/><a id="i-364469185-1"/> With use-site variance, you are on your own
designing a class.  It will be the clients of the class that need to
put in the wildcards, and if they get it wrong, some important
instance methods will no longer be applicable.
Variance being a tricky
business, users usually get it wrong, and they come away thinking that
wildcards and generics are overly complicated.  With definition-side
variance, you express your intent to the compiler, and the compiler
will double check that the methods you want available will indeed be
available.</p>

<h3>19.6 Contravariance</h3>


<p>So far in this chapter, all examples you've seen were either covariant or nonvariant.
But there are also cases where contravariance is
natural.<a id="i900875858-2"/> 
For instance, consider the trait of output channels shown in <a href="type-parameterization.html#lst-contravariant-output-channel">Listing 19.7</a>:
<a id="lst-contravariant-output-channel"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">OutputChannel[-T]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;write(x:&nbsp;T)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 19.7 - A contravariant output channel.</h5>


<p>Here, <pre class="code">OutputChannel</pre> is defined to be contravariant in <pre class="code">T</pre>.  So an output channel of
<pre class="code">AnyRef</pre>s, say, is a subtype of an output channel of <pre class="code">String</pre>s.
Although it may seem non-intuitive, it actually
 makes sense. To see why, consider what you can do with an
<pre class="code">OutputChannel[String]</pre>. 
The only supported operation is writing a
<pre class="code">String</pre> to it.  The same operation can also be done on an
<pre class="code">OutputChannel[AnyRef]</pre>. So it is safe to substitute an
<pre class="code">OutputChannel[AnyRef]</pre> for an <pre class="code">OutputChannel[String]</pre>.
By contrast, it would not be
safe to substitute an <pre class="code">OutputChannel[String]</pre> where an
<pre class="code">OutputChannel[AnyRef]</pre> is required. After all, you can send any
object to an <pre class="code">OutputChannel[AnyRef]</pre>, whereas an
<pre class="code">OutputChannel[String]</pre> requires that the written values are all
strings.</p>

<p>This reasoning points to a general principle in type system
design: It
is safe to assume that a type <pre class="code">T</pre> is a subtype of a type <pre class="code">U</pre> if you
can substitute a value of type <pre class="code">T</pre> wherever a value of type <pre class="code">U</pre> is
required. This is called the <span style="font-style:italic">Liskov Substitution
Principle</span><a id="i1033900893-1"/>.  The
principle holds if <pre class="code">T</pre> supports the same operations as <pre class="code">U</pre>, and all
of <pre class="code">T</pre>'s operations require less and provide more than the
corresponding operations in <pre class="code">U</pre>. In the case of output channels, an
<pre class="code">OutputChannel[AnyRef]</pre> can be a subtype of an <pre class="code">OutputChannel[String]</pre> because 
the two support the same <pre class="code">write</pre> operation, and this operation requires less
in <pre class="code">OutputChannel[AnyRef]</pre> than in <pre class="code">OutputChannel[String]</pre>. "Less" means 
the argument is only required to be an <pre class="code">AnyRef</pre> in the first case, 
whereas it is required to be a <pre class="code">String</pre> in the second case.</p>

<p>Sometimes covariance and contravariance are mixed in the same type. A
prominent example is Scala's function traits. 
For instance, whenever you write the function type <pre class="code">A</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">B</pre>,
Scala expands this to <pre class="code">Function1[A,</pre>&nbsp;<pre class="code">B]</pre>.  The definition of
<pre class="code">Function1</pre> in the standard library uses both covariance
and contravariance: the <pre class="code">Function1</pre> trait is contravariant in the function argument type <pre class="code">S</pre> and covariant in the result type <pre class="code">T</pre>,<a id="i-921885027-1"/><a id="i-1806331359-1"/>
as shown in <a href="type-parameterization.html#lst-function-variance">Listing 19.8</a>.
This satisfies the Liskov Substitution Principle because arguments are something that's required, whereas results
are something that's provided.</p>

<p><a id="lst-function-variance"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">Function1[-S,&nbsp;+T]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(x:&nbsp;S):&nbsp;T
  &nbsp;&nbsp;}
</pre>


<h5>Listing 19.8 - Covariance and contravariance of <pre class="code">Function1</pre>s.</h5>


<p>As an example, consider the application shown in <a href="type-parameterization.html#lst-parrot-contravariance">Listing 19.9</a>. Here, class
<pre class="code">Publication</pre> contains one parametric field, <pre class="code">title</pre>, of type <pre class="code">String</pre>.
Class <pre class="code">Book</pre> extends <pre class="code">Publication</pre> and forwards its string <pre class="code">title</pre> parameter to the constructor of its superclass.
The <pre class="code">Library</pre> singleton object defines a set of books and a method <pre class="code">printBookList</pre>, which takes
a function, named <pre class="code">info</pre>, of type <pre class="code">Book</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">AnyRef</pre>. In other words, the type of the lone parameter to <pre class="code">printBookList</pre> is a function
that takes one <pre class="code">Book</pre> argument and returns an <pre class="code">AnyRef</pre>. The <pre class="code">Customer</pre> application defines a method, <pre class="code">getTitle</pre>,
which takes a <pre class="code">Publication</pre> as its lone parameter and returns a <pre class="code">String</pre>, the title of the passed <pre class="code">Publication</pre>.</p>

<p><a id="lst-parrot-contravariance"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Publication</code>(<code class="vem">val</code>&nbsp;title:&nbsp;<code class="typename">String</code>)
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Book</code>(title:&nbsp;<code class="typename">String</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Publication</code>(title)
  <br />  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Library</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;books:&nbsp;<code class="typename">Set[Book]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Set</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Book</code>(<code class="quotedstring">"Programming&nbsp;in&nbsp;Scala"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Book</code>(<code class="quotedstring">"Walden"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;printBookList(info:&nbsp;<code class="typename">Book</code>&nbsp;=&gt;&nbsp;<code class="typename">AnyRef</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(book&nbsp;&lt;-&nbsp;books)&nbsp;println(info(book))
  &nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Customer</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">App</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;getTitle(p:&nbsp;<code class="typename">Publication</code>):&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;p.title
  &nbsp;&nbsp;&nbsp;Library.printBookList(getTitle)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 19.9 - Demonstration of function type parameter variance.</h5>


<p>Now take a look at the last line in <pre class="code">Customer</pre>. This line invokes <pre class="code">Library</pre>'s <pre class="code">printBookList</pre> method and passes
<pre class="code">getTitle</pre>, wrapped in a function value:</p>

<pre>
  Library.printBookList(getTitle)
</pre>


<p>This line of code type checks even though <pre class="code">String</pre>, the function's result type, is a subtype
of <pre class="code">AnyRef</pre>, the result type of <pre class="code">printBookList</pre>'s <pre class="code">info</pre> parameter. This code
passes the compiler because function result types are declared to be covariant (the <pre class="code">+T</pre> in 
<a href="type-parameterization.html#lst-function-variance">Listing 19.8</a>). If you look inside the body of <pre class="code">printBookList</pre>, you can
get a glimpse of why this makes sense.</p>

<p>The <pre class="code">printBookList</pre> method iterates through its book list and invokes the passed function
on each book. It passes the <pre class="code">AnyRef</pre> result returned by <pre class="code">info</pre> to <pre class="code">println</pre>, which invokes <pre class="code">toString</pre> on it and prints the result.
This activity will work with <pre class="code">String</pre> as well as any other subclass of <pre class="code">AnyRef</pre>, which is what
covariance of function result types means.</p>

<p>Now consider the parameter type of the function being passed to the <pre class="code">printBookList</pre> method. Although <pre class="code">printBookList</pre>'s
parameter type is declared as <pre class="code">Book</pre>, the <pre class="code">getTitle</pre> we're passing
in takes a <pre class="code">Publication</pre>, a <em>supertype</em> of
<pre class="code">Book</pre><a id="i-331888331-1"/>. The reason this works is that since
<pre class="code">printBookList</pre>'s parameter type is <pre class="code">Book</pre>, the body of the <pre class="code">printBookList</pre> method will only be allowed
to pass a <pre class="code">Book</pre> into the function. And because <pre class="code">getTitle</pre>'s parameter type is <pre class="code">Publication</pre>,
the body of that function will only be able to access on its parameter, <pre class="code">p</pre>, members that are declared in
class <pre class="code">Publication</pre>. Because any method declared in <pre class="code">Publication</pre> is also available on its subclass <pre class="code">Book</pre>, 
everything should work, which is what contravariance of function parameter types means.
You can see all this graphically in <a href="type-parameterization.html#fig-contravariance">Figure 19.1</a>.</p>

<p>The code in <a href="type-parameterization.html#lst-parrot-contravariance">Listing 19.9</a>
compiles because <pre class="code">Publication</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">String</pre> is a subtype of <pre class="code">Book</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">AnyRef</pre>, as shown in the center of the <a href="type-parameterization.html#fig-contravariance">Figure 19.1</a>. Because
the result type of a <pre class="code">Function1</pre> is defined as covariant, the inheritance relationship of the two result types, shown at the right
of the diagram, is in the same direction as that of the two functions shown in the center. By contrast, because
the parameter type of a <pre class="code">Function1</pre> is defined as contravariant, the inheritance relationship of the two parameter types, shown at the
left of the diagram, is in the opposite direction as that of the two functions.</p>

<div class="figure"><a id="fig-contravariance"/>


<p><img src="images/variance160.png" alt="image images/variance160.png"/></p>

</div>
<h5> Figure 19.1 - Covariance and contravariance in function type parameters.</h5>


<p><a id="lst-optimized-functional-queues"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Queue[+T]</code>&nbsp;<code class="vem">private</code>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[<code class="vem">this</code>]&nbsp;<code class="vem">var</code>&nbsp;leading:&nbsp;<code class="typename">List[T]</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[<code class="vem">this</code>]&nbsp;<code class="vem">var</code>&nbsp;trailing:&nbsp;<code class="typename">List[T]</code>
  &nbsp;&nbsp;)&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;mirror()&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(leading.isEmpty)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">while</code>&nbsp;(!trailing.isEmpty)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leading&nbsp;=&nbsp;trailing.head&nbsp;::&nbsp;leading
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trailing&nbsp;=&nbsp;trailing.tail
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;head:&nbsp;T&nbsp;=&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mirror()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leading.head&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail:&nbsp;<code class="typename">Queue[T]</code>&nbsp;=&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mirror()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue</code>(leading.tail,&nbsp;trailing)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue[U&nbsp;&gt;:&nbsp;T](x:&nbsp;U)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue[U]</code>(leading,&nbsp;x&nbsp;::&nbsp;trailing)
  &nbsp;&nbsp;}</pre>


<h5>Listing 19.10 - An optimized functional queue.</h5>


<h3 id="variance-object-local">19.7 Object private data</h3>


<p>The <pre class="code">Queue</pre> class seen so far has a
problem in that the <pre class="code">mirror</pre> operation will repeatedly copy the
<pre class="code">trailing</pre> into the <pre class="code">leading</pre> list if <pre class="code">head</pre> is called several
times in a row on a list where <pre class="code">leading</pre> is empty.  The wasteful
copying could be avoided by adding some judicious side
effects. <a href="type-parameterization.html#lst-optimized-functional-queues">Listing 19.10</a> presents a new
implementation of <pre class="code">Queue</pre>, which performs at most one <pre class="code">trailing</pre> to
<pre class="code">leading</pre> adjustment for any sequence of <pre class="code">head</pre> operations.</p>

<p>What's different with respect to the previous version is that now
<pre class="code">leading</pre> and <pre class="code">trailing</pre> are reassignable variables, and <pre class="code">mirror</pre>
performs the reverse copy from <pre class="code">trailing</pre> to <pre class="code">leading</pre> as
a side effect on the current queue instead of returning a new queue.
This side effect is purely internal to the implementation of the
<pre class="code">Queue</pre> operation; since <pre class="code">leading</pre> and <pre class="code">trailing</pre> are private
variables, the effect is not visible to clients of <pre class="code">Queue</pre>.  
So by the terminology established in <a href="mutable-objects.html">Chapter 18</a>,
the new version of <pre class="code">Queue</pre> still defines purely functional objects, 
in spite of the fact that they now contain reassignable fields.</p>

<p>You might wonder whether this code passes the Scala type
checker. After all, queues now contain two reassignable fields of the
covariant parameter type <pre class="code">T</pre>.  Is this not a violation of the
variance rules? It would be indeed, except for the detail that
<pre class="code">leading</pre> and <pre class="code">trailing</pre> have a <pre class="code">private[this]</pre> modifier, and are
thus declared to be object private.</p>

<p>As mentioned in
<a href="packages-and-imports.html#sec-access-modifiers">Section 13.5</a>, object private members
can be accessed only from within the object in which they are defined.
It turns out that accesses to variables from the same object in
which they are defined do not cause problems with variance. The
intuitive explanation is that, in order to construct a case where
variance would lead to type errors, you need to have a reference to a
containing object that has a statically weaker type than the type the object was
defined with. For accesses to object private values, however, this is impossible.</p>

<p>Scala's variance checking rules contain a special case for object private
definitions.<a id="i-245097893-2"/>  Such definitions are omitted when it is checked that a
type parameter with either a <pre class="code">+</pre> or <pre class="code">-</pre> annotation
occurs only in positions that have
the same variance classification. Therefore, the code in 
<a href="type-parameterization.html#lst-optimized-functional-queues">Listing 19.10</a> compiles without error.
On the other hand, if you had left out the <pre class="code">[this]</pre> qualifiers from the 
two <pre class="code">private</pre> modifiers, you would see two type errors:<a id="i-517711887-1"/></p>

<pre>
  <code class="output">Queues.scala:1:&nbsp;error:&nbsp;covariant&nbsp;type&nbsp;T&nbsp;occurs&nbsp;in&nbsp;</code>
  <code class="output">contravariant&nbsp;position&nbsp;in&nbsp;type&nbsp;List[T]&nbsp;of&nbsp;parameter&nbsp;of</code>
  <code class="output">setter&nbsp;leading_=</code>
  <code class="output">class&nbsp;Queue[+T]&nbsp;private&nbsp;(private&nbsp;var&nbsp;leading:&nbsp;List[T],</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">Queues.scala:1:&nbsp;error:&nbsp;covariant&nbsp;type&nbsp;T&nbsp;occurs&nbsp;in&nbsp;</code>
  <code class="output">contravariant&nbsp;position&nbsp;in&nbsp;type&nbsp;List[T]&nbsp;of&nbsp;parameter&nbsp;of</code>
  <code class="output">setter&nbsp;trailing_=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;var&nbsp;trailing:&nbsp;List[T])&nbsp;{</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<h3 id="sec-upper-bounds">19.8 Upper bounds</h3>


<p>In <a href="working-with-lists.html#lst-merge-sort-function">Listing 16.1</a>  <a href="working-with-lists.html#lst-merge-sort-function">here</a>, we showed a merge sort function for lists
that took a comparison function as a first argument and a list to sort
as a second, curried argument.<a id="i-1812239373-1"/><a id="i1036774557-1"/> Another way you might
want to organize such a sort function is by requiring the type of the list to mix in the <pre class="code">Ordered</pre> trait. As mentioned in
<a href="traits.html#sec-the-ordered-trait">Section 12.4</a>, by mixing <pre class="code">Ordered</pre> into a class and implementing <pre class="code">Ordered</pre>'s one abstract method, <pre class="code">compare</pre>, you<a id="i1970675952-2"/><a id="i2068605051-3"/>
enable clients to compare instances of that class with <pre class="code">&lt;</pre>, <pre class="code">&gt;</pre>, <pre class="code">&lt;=</pre>, and <pre class="code">&gt;=</pre>.  For example, <a href="type-parameterization.html#lst-ordered-person">Listing 19.11</a> shows <pre class="code">Ordered</pre>
being mixed into a <pre class="code">Person</pre> class.</p>

<p>As a result, you can compare two people like this:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;robert&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Robert"</code>,&nbsp;<code class="quotedstring">"Jones"</code>)
  <code class="output">robert:&nbsp;Person&nbsp;=&nbsp;Robert&nbsp;Jones</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;sally&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Sally"</code>,&nbsp;<code class="quotedstring">"Smith"</code>)
  <code class="output">sally:&nbsp;Person&nbsp;=&nbsp;Sally&nbsp;Smith</code>
  <br />  scala&gt;&nbsp;robert&nbsp;&lt;&nbsp;sally
  <code class="output">res0:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>


<p><a id="lst-ordered-person"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Person</code>(<code class="vem">val</code>&nbsp;firstName:&nbsp;<code class="typename">String</code>,&nbsp;<code class="vem">val</code>&nbsp;lastName:&nbsp;<code class="typename">String</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Ordered[Person]</code>&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;compare(that:&nbsp;<code class="typename">Person</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;lastNameComparison&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastName.compareToIgnoreCase(that.lastName)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(lastNameComparison&nbsp;!=&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastNameComparison
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstName.compareToIgnoreCase(that.firstName)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;firstName&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;"</code>&nbsp;+&nbsp;lastName
  &nbsp;&nbsp;}
</pre>


<h5>Listing 19.11 - A <pre class="code">Person</pre> class that mixes in the <pre class="code">Ordered</pre> trait.</h5>


<p><a id="lst-upper-bound-sort"/></p>

<pre>
  <code class="vem">def</code>&nbsp;orderedMergeSort[T&nbsp;&lt;:&nbsp;<code class="typename">Ordered[T]</code>](xs:&nbsp;<code class="typename">List[T]</code>):&nbsp;<code class="typename">List[T]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;merge(xs:&nbsp;<code class="typename">List[T]</code>,&nbsp;ys:&nbsp;<code class="typename">List[T]</code>):&nbsp;<code class="typename">List[T]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;(xs,&nbsp;ys)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;(<code class="typename">Nil</code>,&nbsp;_)&nbsp;=&gt;&nbsp;ys
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;(_,&nbsp;<code class="typename">Nil</code>)&nbsp;=&gt;&nbsp;xs
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;(x&nbsp;::&nbsp;xs1,&nbsp;y&nbsp;::&nbsp;ys1)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(x&nbsp;&lt;&nbsp;y)&nbsp;x&nbsp;::&nbsp;merge(xs1,&nbsp;ys)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;y&nbsp;::&nbsp;merge(xs,&nbsp;ys1)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;n&nbsp;=&nbsp;xs.length&nbsp;/&nbsp;<code class="literal">2</code>
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(n&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;xs
  &nbsp;&nbsp;<code class="vem">else</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;(ys,&nbsp;zs)&nbsp;=&nbsp;xs&nbsp;splitAt&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;merge(orderedMergeSort(ys),&nbsp;orderedMergeSort(zs))
  &nbsp;&nbsp;}
  }
</pre>


<h5>Listing 19.12 - A merge sort function with an upper bound.</h5>


<div style="page-break-after:always"/>


<p>To require that the type of the list passed to your new sort function mixes in <pre class="code">Ordered</pre>, you need to<a id="i1850759422-1"/>
use an <em>upper bound</em>. An upper bound is specified similar to a lower bound, except instead of the <pre class="code">&gt;:</pre>
symbol used for lower bounds, you use a <pre class="code">&lt;:</pre> symbol, as shown in <a href="type-parameterization.html#lst-upper-bound-sort">Listing 19.12</a>.</p>

<p>With the "<pre class="code">T</pre>&nbsp;<pre class="code">&lt;:</pre>&nbsp;<pre class="code">Ordered[T]</pre>" syntax, you indicate that the type parameter, <pre class="code">T</pre>, has an upper bound, <pre class="code">Ordered[T]</pre>. This
means that the element type of the list passed to <pre class="code">orderedMergeSort</pre> must be a subtype of <pre class="code">Ordered</pre>. Thus, you could pass
a <pre class="code">List[Person]</pre> to <pre class="code">orderedMergeSort</pre> because <pre class="code">Person</pre> mixes in <pre class="code">Ordered</pre>.</p>

<p>For example, consider this
list:<a id="i1588987823-1"/><a id="i-604737946-1"/><a id="i717131072-1"/><a id="i438821039-2"/><a id="i2020741259-1"/></p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;people&nbsp;=&nbsp;<code class="typename">List</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Larry"</code>,&nbsp;<code class="quotedstring">"Wall"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Anders"</code>,&nbsp;<code class="quotedstring">"Hejlsberg"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Guido"</code>,&nbsp;<code class="quotedstring">"van&nbsp;Rossum"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Alan"</code>,&nbsp;<code class="quotedstring">"Kay"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Yukihiro"</code>,&nbsp;<code class="quotedstring">"Matsumoto"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <code class="output">people:&nbsp;List[Person]&nbsp;=&nbsp;List(Larry&nbsp;Wall,&nbsp;Anders&nbsp;Hejlsberg,</code>
  <code class="output">&nbsp;&nbsp;Guido&nbsp;van&nbsp;Rossum,&nbsp;Alan&nbsp;Kay,&nbsp;Yukihiro&nbsp;Matsumoto)</code>
</pre>


<p>Because the element type of this list, <pre class="code">Person</pre>, mixes in (and is therefore a subtype of) 
<pre class="code">Ordered[People]</pre>, you can pass the list to <pre class="code">orderedMergeSort</pre>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;sortedPeople&nbsp;=&nbsp;orderedMergeSort(people)
  <code class="output">sortedPeople:&nbsp;List[Person]&nbsp;=&nbsp;List(Anders&nbsp;Hejlsberg,&nbsp;Alan&nbsp;Kay,</code>
  <code class="output">&nbsp;&nbsp;Yukihiro&nbsp;Matsumoto,&nbsp;Guido&nbsp;van&nbsp;Rossum,&nbsp;Larry&nbsp;Wall)</code>
</pre>


<p>Now, although the sort function shown in <a href="type-parameterization.html#lst-upper-bound-sort">Listing 19.12</a> serves as a useful illustration
of upper bounds, it isn't actually the most general
way in Scala to design a sort function that takes advantage of the <pre class="code">Ordered</pre> trait.</p>

<p>For example, you couldn't
use the <pre class="code">orderedMergeSort</pre> function to sort a list of
integers, because class <pre class="code">Int</pre> is not a subtype of <pre class="code">Ordered[Int]</pre>:<a id="i-1803074733-1"/></p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;wontCompile&nbsp;=&nbsp;orderedMergeSort(<code class="typename">List</code>(<code class="literal">3</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">1</code>))
  <code class="output">&lt;console&gt;:5:&nbsp;error:&nbsp;inferred&nbsp;type&nbsp;arguments&nbsp;[Int]&nbsp;do</code>
  <code class="output">&nbsp;&nbsp;&nbsp;not&nbsp;conform&nbsp;to&nbsp;method&nbsp;orderedMergeSort's&nbsp;type</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameter&nbsp;bounds&nbsp;[T&nbsp;&lt;:&nbsp;Ordered[T]]</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;wontCompile&nbsp;=&nbsp;orderedMergeSort(List(3,&nbsp;2,&nbsp;1))</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>In <a href="implicit-conversions-and-parameters.html#sec-context-bounds">Section 21.6</a>, we'll show you how to use <em>implicit parameters</em> and
<em>context bounds</em> to achieve a more general
solution.<a id="i-568821387-1"/><a id="i-956942778-1"/></p>

<h3>19.9 Conclusion</h3>


<p>In this chapter you saw several techniques for information
hiding: private constructors, factory methods, type abstraction, and
object private members. You also learned how to specify data type
variance and what it implies for class implementation. Finally, you
saw two techniques which help in obtaining flexible variance
annotations: lower bounds for method type parameters and
<pre class="code">private[this]</pre> annotations for local fields and methods.</p>

<hr/>
<h4>Footnotes for Chapter 19:</h4>


<p><a id="footnotemain19-1"/>[1] Supertype and subtype relationships are reflexive, which means a type is both
a supertype and a subtype of itself. Even though <pre class="code">T</pre> is a lower bound for <pre class="code">U</pre>, you could still pass in a <pre class="code">T</pre> to <pre class="code">enqueue</pre>.</p>

<p><a id="footnotemain19-2"/>[2] Technically,
what happens is a flip occurs for lower bounds.  The
type parameter <pre class="code">U</pre> is in a negative position (1 flip), while the
lower bound (<pre class="code">&gt;:</pre>&nbsp;<pre class="code">T</pre>) is in a positive position (2 flips).</p>

<div style="page-break-after:always"/>


<div style="page-break-after:always"/>



</body>
</html>
