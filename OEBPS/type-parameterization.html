<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8"/>
    <title>Programming in Scala, 3rd Edition</title>

    <link rel="stylesheet" type="text/css" href="book.css" />
  </head>
<body>
<h2><a id="chap-type-parameterization">Chapter 19</a></h2>
<h1>Type Parameterization</h1>


<p>In this chapter, we'll explain the details of type parameterization in
Scala.<a id="i-1818778992-1"/> Along
the way we'll demonstrate some of the techniques for information hiding 
introduced in <a href="packages-and-imports.html">Chapter 13</a> by using a concrete example: the
design of a class for purely functional queues. We're presenting type parameterization
and information hiding together, because information hiding can be used to obtain
more general type parameterization variance annotations.</p>

<p>Type parameterization allows you to write generic classes and
traits<a id="i-1986667706-1"/><a id="i1515783126-1"/><a id="i1083106947-1"/><a id="i1530367874-1"/>. For example, sets are generic and take a type parameter:
they are defined as <span class="code">Set[T]</span><a id="i-906912898-1"/>. As a result, any particular set instance might be a <span class="code">Set[String]</span>, a <span class="code">Set[Int]</span>, <i>etc.</i>, but
it must be a set of <em>something</em>. Unlike Java, which allows raw
types,<a id="i414933374-1"/><a id="i1163979645-1"/> Scala requires that you specify type parameters.
Variance defines inheritance relationships of parameterized types, such as whether a <span class="code">Set[String]</span>, for example, is a subtype of <span class="code">Set[AnyRef]</span>.</p>

<p>The chapter contains three parts. The first part develops a data
structure for purely functional queues. The second part develops techniques to hide internal
representation details of this structure. The final part explains
variance of type parameters and how it interacts with information
hiding.</p>

<h3>19.1 Functional queues</h3>


<p>A functional queue is a data structure with three operations:</p>

<table style="border-collapse: collapse">
<tr>
  <td>
    <span class="code">head</span>
  </td>
  <td>
    returns the first element of the queue
  </td>
</tr>
<tr>
  <td>
    <span class="code">tail</span>
  </td>
  <td>
    returns a queue without its first element
  </td>
</tr>
<tr>
  <td>
    <span class="code">enqueue</span>
  </td>
  <td>
    returns a new queue with a given element
  </td>
</tr>
<tr>
  <td>
  </td>
  <td>
    appended at the end
  </td>
</tr>
</table>


<p>Unlike a mutable queue, a functional queue does not change its contents
when an element is appended. Instead, a new queue is returned that contains the element.
The goal of this chapter will be to create a class, which we'll name <span class="code">Queue</span>, that works like this:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;q&nbsp;=&nbsp;<code class="typename">Queue</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">q:&nbsp;Queue[Int]&nbsp;=&nbsp;Queue(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;q1&nbsp;=&nbsp;q&nbsp;enqueue&nbsp;<code class="literal">4</code>
  <code class="output">q1:&nbsp;Queue[Int]&nbsp;=&nbsp;Queue(1,&nbsp;2,&nbsp;3,&nbsp;4)</code>
  <br />  scala&gt;&nbsp;q
  <code class="output">res0:&nbsp;Queue[Int]&nbsp;=&nbsp;Queue(1,&nbsp;2,&nbsp;3)</code>
</pre>


<p>If <span class="code">Queue</span> were a mutable implementation, the <span class="code">enqueue</span> operation
in the second input line above would affect the contents of <span class="code">q</span>; 
in fact both the result, <span class="code">q1</span>, and the original queue, <span class="code">q</span>, would contain the 
sequence <span class="code">1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3,</span>&nbsp;<span class="code">4</span> after the operation. But for a functional queue, the 
appended value shows up only in the result, <span class="code">q1</span>, not in the queue, <span class="code">q</span>, being operated on.</p>

<p>Purely functional queues also have some similarity with lists.  Both
are so called <span style="font-style:italic">fully persistent</span> data structures<a id="i-1691614745-1"/>, where old
versions remain available even after extensions or modifications.
Both support <span class="code">head</span> and <span class="code">tail</span> operations. But where a list is
usually extended at the front, using a <span class="code">::</span> operation, a queue is extended at the
end, using <span class="code">enqueue</span>.</p>

<p>How can this be implemented efficiently? Ideally, a
functional (immutable) queue should not have a fundamentally higher
overhead than an imperative (mutable) one. That is, all three
operations, <span class="code">head</span>, <span class="code">tail</span>, and <span class="code">enqueue</span>, should operate in constant
time.</p>

<p>One simple approach to implement a functional queue would be to use a
list as representation type. Then <span class="code">head</span> and <span class="code">tail</span> would just
translate into the same operations on the list, whereas <span class="code">enqueue</span>
would be concatenation.</p>

<p>This would give the following
implementation:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">SlowAppendQueue[T]</code>(elems:&nbsp;<code class="typename">List[T]</code>)&nbsp;{&nbsp;<code class="comment">//&nbsp;Not&nbsp;efficient</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;head&nbsp;=&nbsp;elems.head
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">SlowAppendQueue</code>(elems.tail)
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;T)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">SlowAppendQueue</code>(elems&nbsp;:::&nbsp;<code class="typename">List</code>(x))
  }
</pre>


<p>The problem with this implementation is in the <span class="code">enqueue</span> operation.
It takes time proportional to the number of elements stored in the
queue. If you want constant time append, you could also try to reverse
the order of the elements in the representation list, so that the last element
that's appended comes first in the list. This would lead to the
following implementation:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">SlowHeadQueue[T]</code>(smele:&nbsp;<code class="typename">List[T]</code>)&nbsp;{&nbsp;<code class="comment">//&nbsp;Not&nbsp;efficient</code>
  &nbsp;&nbsp;<code class="comment">//&nbsp;smele&nbsp;is&nbsp;elems&nbsp;reversed</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;head&nbsp;=&nbsp;smele.last
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">SlowHeadQueue</code>(smele.init)
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;T)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">SlowHeadQueue</code>(x&nbsp;::&nbsp;smele)
  }
</pre>


<p>Now <span class="code">enqueue</span> is constant time, but <span class="code">head</span> and <span class="code">tail</span> are not. They
now take time proportional to the number of elements stored in the
queue.</p>

<p>Looking at these two examples, it does not seem easy to come up with
an implementation that's constant time for all three operations. In
fact, it looks doubtful that this is even possible! However, by
combining the two operations you can get very close. The idea is to
represent a queue by two lists, called <span class="code">leading</span> and <span class="code">trailing</span>.
The <span class="code">leading</span> list contains elements towards the front, whereas the
<span class="code">trailing</span> list contains elements towards the back of the queue in
reversed order. The contents of the whole queue are at each instant 
equal to "<span class="code">leading</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">trailing.reverse</span>".</p>

<p>Now, to append an element, you just cons it to the <span class="code">trailing</span> list
using the <span class="code">::</span> operator,<a id="i1411857630-3"/>
so <span class="code">enqueue</span> is constant time. This means that, when an initially empty queue is constructed
from successive <span class="code">enqueue</span> operations, the <span class="code">trailing</span> list will grow whereas
the <span class="code">leading</span> list will stay empty. Then, before the first <span class="code">head</span> or <span class="code">tail</span> operation is performed
on an empty <span class="code">leading</span> list, the whole <span class="code">trailing</span> list is copied to
<span class="code">leading</span>, reversing the order of the elements. 
This is done in an operation called <span class="code">mirror</span>.
<a href="type-parameterization.html#lst-simple-functional-queues">Listing 19.1</a> 
shows an implementation of queues that uses this approach.</p>

<p><a id="lst-simple-functional-queues"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Queue[T]</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;leading:&nbsp;<code class="typename">List[T]</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;trailing:&nbsp;<code class="typename">List[T]</code>&nbsp;
  &nbsp;&nbsp;)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;mirror&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(leading.isEmpty)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue</code>(trailing.reverse,&nbsp;<code class="typename">Nil</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;head&nbsp;=&nbsp;mirror.leading.head
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail&nbsp;=&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;q&nbsp;=&nbsp;mirror&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue</code>(q.leading.tail,&nbsp;q.trailing)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;T)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue</code>(leading,&nbsp;x&nbsp;::&nbsp;trailing)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 19.1 - A basic functional queue.</h5>


<p>What is the complexity of this implementation of queues? 
The <span class="code">mirror</span> operation might take time proportional to the number of queue elements,
but only if list <span class="code">leading</span> is empty. It returns directly if <span class="code">leading</span> is non-empty. 
Because <span class="code">head</span> and <span class="code">tail</span> call <span class="code">mirror</span>, their complexity might be
linear in the size of the queue, too. However, the longer the queue gets, the less often
<span class="code">mirror</span> is called.</p>

<p>Indeed, assume a queue of length <i>n</i> with an empty <span class="code">leading</span> list.
Then <span class="code">mirror</span> has to reverse-copy a list of length <i>n</i>. However, the next time <span class="code">mirror</span> will have to do any work is once the <span class="code">leading</span> list is empty again, which will be the case after <i>n</i>
<span class="code">tail</span> operations. This means you can "charge" each of these <i>n</i> <span class="code">tail</span> operations with one
<i>n</i>'th of the complexity of <span class="code">mirror</span>, which means a constant amount of work.
Assuming that <span class="code">head</span>, <span class="code">tail</span>, and <span class="code">enqueue</span> operations appear with about the same frequency,
the <span style="font-style:italic">amortized</span> complexity is hence constant for each operation.
So functional queues are asymptotically just as efficient as mutable ones.</p>

<p>Now, there are some caveats that need to be attached to
this argument. First, the discussion was only about asymptotic
behavior; the constant factors might well be somewhat different.
Second, the argument rested on the fact that <span class="code">head</span>, <span class="code">tail</span> and
<span class="code">enqueue</span> are called with about the same frequency. If <span class="code">head</span> is
called much more often than the other two operations, the argument is
not valid, as each call to <span class="code">head</span> might involve a costly
re-organization of the list with <span class="code">mirror</span>. The second caveat can be
avoided; it is possible to design functional queues so that in a
sequence of successive <span class="code">head</span> operations only the first one might
require a re-organization. You will find out at the end of this
chapter how this is done.</p>

<h3>19.2 Information hiding</h3>


<p>The implementation of <span class="code">Queue</span> shown in <a href="type-parameterization.html#lst-simple-functional-queues">Listing 19.1</a> is now quite good with regards to<a id="i374717171-2"/>
efficiency.  You might object, though, that this efficiency
is paid for by exposing
a needlessly detailed implementation. The <span class="code">Queue</span> constructor, which is
globally accessible, takes two lists as parameters, where one is
reversed&mdash;hardly an intuitive representation of a queue. 
What's needed is a way to hide this constructor from client code. In this section, we'll
show you some ways to accomplish this in Scala.</p>

<h4>Private constructors and factory methods</h4>


<p>In Java, you can hide a constructor by making it <span class="code">private</span>.  In Scala, the primary constructor does
not have an explicit definition;<a id="i2093291082-1"/><a id="i-1528003040-1"/> it is defined implicitly by the class
parameters and body. Nevertheless, it is still possible to hide
the primary constructor by adding a <span class="code">private</span> modifier in front of
the class parameter list<a id="i1958480308-1"/>, as shown in <a href="type-parameterization.html#lst-private-constructor">Listing 19.2</a>:</p>

<p><a id="lst-private-constructor"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Queue[T]</code>&nbsp;<code class="vem">private</code>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;leading:&nbsp;<code class="typename">List[T]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;trailing:&nbsp;<code class="typename">List[T]</code>
  &nbsp;&nbsp;)&nbsp;
</pre>


<h5>Listing 19.2 - Hiding a primary constructor by making it private.</h5>


<p>The <span class="code">private</span> modifier between the class name and its parameters
indicates that the constructor of <span class="code">Queue</span> is private: it can be
accessed only from within the class itself and its companion
object<a id="i-861331495-1"/>.
The class name <span class="code">Queue</span> is still public, so you can use it as a type, but you cannot
call its constructor:<a id="i-1604722710-1"/></p>

<pre>
  scala&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue</code>(<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>),&nbsp;<code class="typename">List</code>(<code class="literal">3</code>))
  <code class="output">&lt;console&gt;:9:&nbsp;error:&nbsp;constructor&nbsp;Queue&nbsp;in&nbsp;class&nbsp;Queue&nbsp;cannot&nbsp;</code>
  <code class="output">be&nbsp;accessed&nbsp;in&nbsp;object&nbsp;$iw</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Queue(List(1,&nbsp;2),&nbsp;List(3))</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>Now that the primary constructor of class <span class="code">Queue</span> can no longer be called from client code, 
there needs to be some other way to create new queues.
One possibility is to add an auxiliary constructor, like this:</p>

<pre>
  <code class="vem">def</code>&nbsp;<code class="vem">this</code>()&nbsp;=&nbsp;<code class="vem">this</code>(<code class="typename">Nil</code>,&nbsp;<code class="typename">Nil</code>)&nbsp;
</pre>


<p>The auxiliary constructor shown in the previous example builds an empty queue. As a refinement, the auxiliary constructor could take a list of
initial queue elements:</p>

<pre>
  <code class="vem">def</code>&nbsp;<code class="vem">this</code>(elems:&nbsp;T*)&nbsp;=&nbsp;<code class="vem">this</code>(elems.toList,&nbsp;<code class="typename">Nil</code>)
</pre>


<p>Recall that <span class="code">T*</span> is the notation for repeated parameters, as
described in <a href="functions-and-closures.html#sec-fancy-parameters">Section 8.8</a>.</p>

<p>Another possibility is to add a factory method that builds a queue
from such a sequence of initial elements. A neat way to do this is to
define an object <span class="code">Queue</span> that has the same name as the class being
defined and contains an <span class="code">apply</span> method, as shown in <a href="type-parameterization.html#lst-apply-factory">Listing 19.3</a>:</p>

<p><a id="lst-apply-factory"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Queue</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;constructs&nbsp;a&nbsp;queue&nbsp;with&nbsp;initial&nbsp;elements&nbsp;`xs'</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply[T](xs:&nbsp;T*)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue[T]</code>(xs.toList,&nbsp;<code class="typename">Nil</code>)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 19.3 - An <span class="code">apply</span> factory method in a companion object.</h5>


<p>By placing this object in the same source file as class <span class="code">Queue</span>, you make the object
a companion object of the class. 
You saw in <a href="packages-and-imports.html#sec-access-modifiers">Section 13.5</a> that a companion object has the same access rights 
as its class.  Because of this, the <span class="code">apply</span> method in object <span class="code">Queue</span>
can create a new <span class="code">Queue</span> object, even though the 
constructor of class <span class="code">Queue</span> is private.</p>

<p>Note that, because the factory method is called <span class="code">apply</span>, clients can
create queues with an expression such as <span class="code">Queue(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span>. This expression
expands to <span class="code">Queue.apply(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span> since <span class="code">Queue</span> is an object
instead of a function.
As a result, <span class="code">Queue</span> looks to clients as if it was a
globally defined factory method.  In reality, Scala has no globally visible
methods; every method must be contained in an object or a
class. However, using methods named <span class="code">apply</span> inside global objects, 
you can support usage patterns that look like invocations of global
methods.</p>

<p><a id="lst-type-abstract-functional-queues"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">Queue[T]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;head:&nbsp;T
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail:&nbsp;<code class="typename">Queue[T]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;T):&nbsp;<code class="typename">Queue[T]</code>
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Queue</code>&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply[T](xs:&nbsp;T*):&nbsp;<code class="typename">Queue[T]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">QueueImpl[T]</code>(xs.toList,&nbsp;<code class="typename">Nil</code>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">QueueImpl[T]</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;leading:&nbsp;<code class="typename">List[T]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;trailing:&nbsp;<code class="typename">List[T]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Queue[T]</code>&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;mirror&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(leading.isEmpty)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">QueueImpl</code>(trailing.reverse,&nbsp;<code class="typename">Nil</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;head:&nbsp;T&nbsp;=&nbsp;mirror.leading.head
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail:&nbsp;<code class="typename">QueueImpl[T]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;q&nbsp;=&nbsp;mirror
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">QueueImpl</code>(q.leading.tail,&nbsp;q.trailing)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;T)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">QueueImpl</code>(leading,&nbsp;x&nbsp;::&nbsp;trailing)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 19.4 - Type abstraction for functional queues.</h5>


<h4>An alternative: private classes</h4>


<p>Private constructors and private members are one way to hide the
initialization and representation of a class.<a id="i848757295-1"/> Another more radical
way is to hide the class itself and only export a trait that reveals
the public interface of the class. The code in 
<a href="type-parameterization.html#lst-type-abstract-functional-queues">Listing 19.4</a>
implements this design.
There's a trait <span class="code">Queue</span>, which declares the methods <span class="code">head</span>, <span class="code">tail</span>,
and <span class="code">enqueue</span>. All three methods are implemented in a subclass
<span class="code">QueueImpl</span>, which is itself a <span class="code">private</span> inner class of object<a id="i-1543098108-1"/>
<span class="code">Queue</span>. This exposes to clients the same information as before, but
using a different technique.
Instead of hiding individual constructors and methods, this version
hides the whole implementation class.</p>

<h3 id="sec-first-arrays">19.3 Variance annotations</h3>


<p><span class="code">Queue</span>, as defined in <a href="type-parameterization.html#lst-type-abstract-functional-queues">Listing 19.4</a>, is a trait, but<a id="i1555746715-1"/><a id="i935521398-1"/>
not a type. <span class="code">Queue</span> is not a type because it takes a type parameter.</p>

<p>As a result,
you cannot create variables of type <span class="code">Queue</span>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;doesNotCompile(q:&nbsp;<code class="typename">Queue</code>)&nbsp;=&nbsp;{}
  <code class="output">&lt;console&gt;:8:&nbsp;error:&nbsp;class&nbsp;Queue&nbsp;takes&nbsp;type&nbsp;parameters</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;doesNotCompile(q:&nbsp;Queue)&nbsp;=&nbsp;{}</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>Instead, trait <span class="code">Queue</span> enables you to specify <em>parameterized</em> types, such as <span class="code">Queue[String]</span>, <span class="code">Queue[Int]</span>, or <span class="code">Queue[AnyRef]</span>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;doesCompile(q:&nbsp;<code class="typename">Queue[AnyRef]</code>)&nbsp;=&nbsp;{}
  <code class="output">doesCompile:&nbsp;(q:&nbsp;Queue[AnyRef])Unit</code>
</pre>


<p>Thus, <span class="code">Queue</span> is a trait and <span class="code">Queue[String]</span> is a type.
<span class="code">Queue</span> is also called a <em>type constructor</em><a id="i1905256393-1"/> because you can construct a type with it by specifying a type parameter. (This is analogous to constructing an object instance with a plain-old 
constructor by specifying a value
parameter.) The type constructor <span class="code">Queue</span> "generates" a family of types, which includes <span class="code">Queue[Int]</span>,
<span class="code">Queue[String]</span>, and <span class="code">Queue[AnyRef]</span>.</p>

<p>You can also say that <span class="code">Queue</span> is a <em>generic</em>
trait.<a id="i1530367874-2"/><a id="i-1356826384-1"/> (Classes and traits that take type
parameters are "generic," but the types they generate are "parameterized," not generic.) The term "generic" means that you are
defining many specific types with one generically written class or trait. For example, trait <span class="code">Queue</span> in <a href="type-parameterization.html#lst-type-abstract-functional-queues">Listing 19.4</a>
defines a generic queue. <span class="code">Queue[Int]</span> and <span class="code">Queue[String]</span>, <i>etc.</i>, would be the specific queues.</p>

<p>The combination of type parameters and subtyping poses some
interesting questions.<a id="i-1780437500-1"/>
For example, are there any special subtyping relationships between members of the family of types generated
by <span class="code">Queue[T]</span>? More specifically, should a <span class="code">Queue[String]</span> be
considered a subtype of <span class="code">Queue[AnyRef]</span>?
Or more generally, if <span class="code">S</span> is a subtype of type <span class="code">T</span>,
then should <span class="code">Queue[S]</span> be considered a subtype of <span class="code">Queue[T]</span>?
If so, you could say that trait <span class="code">Queue</span> is <a href="glossary.html#g1865839257"><em>covariant</em></a> (or
"flexible") in its type parameter <span class="code">T</span><a id="i2006441693-1"/>. Or, since it just has one type parameter, you could say simply that
<span class="code">Queue</span>s are covariant. Covariant <span class="code">Queue</span>s would mean, for example, that you could pass a <span class="code">Queue[String]</span> to
the <span class="code">doesCompile</span> method shown previously, which takes a value
parameter of type <span class="code">Queue[AnyRef]</span>.</p>

<p>Intuitively, all this seems OK, since a
queue of <span class="code">String</span>s looks like a special case of a queue of
<span class="code">AnyRef</span>s.
In Scala, however, generic types have by default <a href="glossary.html#g-233237224"><em>nonvariant</em></a> (or "rigid") subtyping<a id="i1359580222-1"/>. That
is, with <span class="code">Queue</span> defined as in <a href="type-parameterization.html#lst-type-abstract-functional-queues">Listing 19.4</a>, queues with different element
types would never be in a subtype relationship.
A <span class="code">Queue[String]</span> would not be usable as a <span class="code">Queue[AnyRef]</span>.
However, you can demand
covariant (flexible) subtyping of queues by changing the first line of the
definition of class <span class="code">Queue</span> like this:</p>

<pre>
  <code class="vem">trait</code>&nbsp;<code class="typename">Queue[+T]</code>&nbsp;{&nbsp;...&nbsp;}
</pre>


<p>Prefixing a formal type parameter with a <span class="code">+</span> indicates that
subtyping is covariant (flexible) in that
parameter<a id="i-1315578930-1"/>. 
By adding this single character, you are telling Scala that you want
<span class="code">Queue[String]</span>, for example, to be considered a subtype of <span class="code">Queue[AnyRef]</span>.
 The compiler will check that <span class="code">Queue</span> is defined
in a way that this subtyping is sound.</p>

<p>Besides <span class="code">+</span>, there is also a prefix <span class="code">-</span>, which indicates
<a href="glossary.html#g-1356412796"><em>contravariant</em></a> subtyping<a id="i973833207-1"/><a id="i900875858-1"/>. If <span class="code">Queue</span> were defined like this:</p>

<pre>
  <code class="vem">trait</code>&nbsp;<code class="typename">Queue[-T]</code>&nbsp;{&nbsp;...&nbsp;}&nbsp;
</pre>


<p>then if <span class="code">T</span> is a subtype of type <span class="code">S</span>, this would imply
that <span class="code">Queue[S]</span> is a subtype of <span class="code">Queue[T]</span> (which in the case of queues
would be rather surprising!).  Whether a type parameter is covariant, contravariant, or nonvariant
is called the parameter's
<a href="glossary.html#g-1249575311"><em>variance</em></a><a id="i-1249575311-1"/>. The <span class="code">+</span> and <span class="code">-</span> symbols you can place next to type parameters 
are called <em>variance annotations</em>.<a id="i1554444807-1"/></p>

<p>In a purely functional world, many types are naturally covariant (flexible). However,
the situation changes once you introduce mutable data. To find out why, consider the
simple type of one-element cells that can be read or written, shown in <a href="type-parameterization.html#lst-nonvariant-cell">Listing 19.5</a>.
<a id="lst-nonvariant-cell"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Cell[T]</code>(init:&nbsp;T)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[<code class="vem">this</code>]&nbsp;<code class="vem">var</code>&nbsp;current&nbsp;=&nbsp;init
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;get&nbsp;=&nbsp;current
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;set(x:&nbsp;T)&nbsp;=&nbsp;{&nbsp;current&nbsp;=&nbsp;x&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 19.5 - A nonvariant (rigid) <span class="code">Cell</span> class.</h5>


<p>The <span class="code">Cell</span> type of <a href="type-parameterization.html#lst-nonvariant-cell">Listing 19.5</a> is declared nonvariant (rigid). For the sake
of argument,
assume for a moment that <span class="code">Cell</span> was declared covariant instead&mdash;<i>i.e.</i>, it was declared
<span class="code">class</span>&nbsp;<span class="code">Cell[+T]</span>&mdash;and that this passed the Scala
compiler. (It doesn't,
and we'll explain why shortly.) 
Then you could construct the following problematic statement sequence:</p>

<pre>
  <code class="vem">val</code>&nbsp;c1&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Cell[String]</code>(<code class="quotedstring">"abc"</code>)
  <code class="vem">val</code>&nbsp;c2:&nbsp;<code class="typename">Cell[Any]</code>&nbsp;=&nbsp;c1
  c2.set(<code class="literal">1</code>)
  <code class="vem">val</code>&nbsp;s:&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;c1.get&nbsp;
</pre>


<p>Seen by itself, each of these four lines looks OK. The first line creates a
cell of strings and stores it in a <span class="code">val</span> named <span class="code">c1</span>. The second line defines a new
<span class="code">val</span>, <span class="code">c2</span>, of type <span class="code">Cell[Any]</span>, which initialized with <span class="code">c1</span>. This is
OK since <span class="code">Cell</span>s are assumed to be covariant. The third line sets the
value of cell <span class="code">c2</span> to 1. This is also OK because the assigned value <span class="code">1</span> is an instance of
<span class="code">c2</span>'s element type <span class="code">Any</span>. Finally, the last line assigns the element value of 
<span class="code">c1</span> into a string. Nothing strange here, as both the sides are of the same type.
But taken together, these four lines end up
assigning the integer <span class="code">1</span> to the string <span class="code">s</span>. This is clearly a
violation of type soundness.</p>

<p>Which operation is to blame for the runtime fault? It
must be the second one, which uses covariant subtyping. 
The other statements are too simple and fundamental.
Thus, a <span class="code">Cell</span> of
<span class="code">String</span> is <span style="font-style:italic">not</span> also a <span class="code">Cell</span> of <span class="code">Any</span>, because there are
things you can do with a <span class="code">Cell</span> of <span class="code">Any</span> that you cannot do with 
a <span class="code">Cell</span> of <span class="code">String</span>.  You cannot use <span class="code">set</span> with an <span class="code">Int</span> argument on a 
<span class="code">Cell</span> of <span class="code">String</span>, for example.</p>

<p>In fact, were you to pass the covariant version of <span class="code">Cell</span> to the 
Scala compiler, you would get a compile-time error:<a id="i-1072664655-1"/></p>

<pre>
  <code class="output">Cell.scala:7:&nbsp;error:&nbsp;covariant&nbsp;type&nbsp;T&nbsp;occurs&nbsp;in</code>
  <code class="output">contravariant&nbsp;position&nbsp;in&nbsp;type&nbsp;T&nbsp;of&nbsp;value&nbsp;x</code>
  <code class="output">&nbsp;&nbsp;&nbsp;def&nbsp;set(x:&nbsp;T)&nbsp;=&nbsp;current&nbsp;=&nbsp;x</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<h4>Variance and arrays</h4>


<p>It's interesting to compare this behavior with arrays in Java. In
principle, arrays are just like cells except that they can have more
than one element. Nevertheless, arrays are treated as covariant in Java.</p>

<p>You can try an example analogous to the cell interaction described here with
Java arrays:</p>

<pre>
  //&nbsp;this&nbsp;is&nbsp;Java
  String[]&nbsp;a1&nbsp;=&nbsp;{&nbsp;"abc"&nbsp;};
  Object[]&nbsp;a2&nbsp;=&nbsp;a1;
  a2[0]&nbsp;=&nbsp;new&nbsp;Integer(17);
  String&nbsp;s&nbsp;=&nbsp;a1[0];
</pre>


<p>If you try out this example, you will find that it compiles. But executing the program
will cause an <span class="code">ArrayStore</span> exception to be thrown when <span class="code">a2[0]</span>
is assigned to an <span class="code">Integer</span>:</p>

<pre>
  <code class="output">Exception&nbsp;in&nbsp;thread&nbsp;"main"&nbsp;java.lang.ArrayStoreException:&nbsp;</code>
  <code class="output">java.lang.Integer</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;JavaArrays.main(JavaArrays.java:8)</code>
</pre>


<p>What happens here is that
Java stores the element type of the array at runtime. Then, every time
an array element is updated, the new element value is checked against
the stored type. If it is not an instance of that type, an
<span class="code">ArrayStore</span> exception is thrown.<a id="i1807481219-1"/></p>

<p>You might ask why Java adopted this design, which seems both
unsafe and expensive. When asked this question, James Gosling,<a id="i1512661551-1"/>
the principal inventor of the Java language, answered that they
wanted to have a simple means to treat arrays generically. For
instance, they wanted to be able to write a method to sort all
elements of an array, using a signature like the following that takes an array of <span class="code">Object</span>:</p>

<pre>
  void&nbsp;sort(<code class="typename">Object[]</code>&nbsp;a,&nbsp;<code class="typename">Comparator</code>&nbsp;cmp)&nbsp;{&nbsp;...&nbsp;}
</pre>


<p>Covariance of arrays was needed so that arrays of arbitrary reference
types could be passed to this <span class="code">sort</span> method. Of course, with the
arrival of Java generics, such a <span class="code">sort</span> method can now be written with a
type parameter, so the covariance of arrays is no longer
necessary<a id="i1590614948-1"/>. 
For compatibility reasons, though, it has persisted in Java to this day.</p>

<div style="page-break-after:always"/>


<p>Scala tries to be purer than Java in not treating arrays as covariant.
Here's what you get if you translate the first two lines of the array
example to Scala:<a id="i-677980410-3"/></p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a1&nbsp;=&nbsp;<code class="typename">Array</code>(<code class="quotedstring">"abc"</code>)
  <code class="output">a1:&nbsp;Array[String]&nbsp;=&nbsp;Array(abc)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a2:&nbsp;<code class="typename">Array[Any]</code>&nbsp;=&nbsp;a1
  <code class="output">&lt;console&gt;:8:&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Array[String]</code>
  <code class="output">&nbsp;required:&nbsp;Array[Any]</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;a2:&nbsp;Array[Any]&nbsp;=&nbsp;a1</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>What happened here is that Scala treats arrays as nonvariant (rigid), so
an <span class="code">Array[String]</span> is not considered to conform to an <span class="code">Array[Any]</span>.
However, sometimes it is necessary to interact with legacy methods in
Java that use an <span class="code">Object</span> array as a means to emulate a generic array. For
instance, you might want to call a <span class="code">sort</span> method like the one described previously
with an array of <span class="code">String</span>s as argument. To make this possible,
Scala lets you cast an array of <span class="code">T</span>s to an array of any supertype of
<span class="code">T</span>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a2:&nbsp;<code class="typename">Array[Object]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a1.asInstanceOf[<code class="typename">Array[Object]</code>]
  <code class="output">a2:&nbsp;Array[Object]&nbsp;=&nbsp;Array(abc)</code>
</pre>


<p>The cast is always legal at compile-time, and it will always 
succeed at run-time because the JVM's underlying run-time model treats 
arrays as covariant, just as Java the language does.
But you might get <span class="code">ArrayStore</span> exceptions afterwards, 
again just as you would in Java.</p>

<h3>19.4 Checking variance annotations</h3>


<p>Now that you have seen some examples where variance is unsound, you<a id="i-245097893-1"/>
may be wondering which kind of class definitions need to be rejected and
which can be accepted. So far, all violations of type
soundness involved some reassignable field or array element. The purely
functional implementation of queues, on the other hand, looks like a
good candidate for covariance. However, the following
example shows that you can "engineer" an unsound situation even if there
is no reassignable field.</p>

<p>To set up the example, assume that queues as defined in <a href="type-parameterization.html#lst-type-abstract-functional-queues">Listing 19.4</a> are
covariant. Then, create a subclass of queues that specializes the
element type to <span class="code">Int</span> and overrides the <span class="code">enqueue</span> method:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">StrangeIntQueue</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Queue[Int]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(math.sqrt(x))
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">super</code>.enqueue(x)
  &nbsp;&nbsp;}
  }
</pre>


<p>The <span class="code">enqueue</span> method in
<span class="code">StrangeIntQueue</span> prints out the square root of
its (integer) argument before doing the append proper.</p>

<p>Now, you can 
write a counterexample in two lines:</p>

<pre>
  <code class="vem">val</code>&nbsp;x:&nbsp;<code class="typename">Queue[Any]</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">StrangeIntQueue</code>
  x.enqueue(<code class="quotedstring">"abc"</code>)
</pre>


<p>The first of these two lines is valid because <span class="code">StrangeIntQueue</span> is a
subclass of <span class="code">Queue[Int]</span> and, assuming covariance of queues,
<span class="code">Queue[Int]</span> is a subtype of <span class="code">Queue[Any]</span>. The second line is valid because
you can append a <span class="code">String</span> to a <span class="code">Queue[Any]</span>.
However, taken together, these two lines have the effect of applying a
square root method to a string, which makes no sense.</p>

<p>Clearly it's not just mutable fields that make covariant types unsound.
The problem is more general. It turns out that as soon as a generic
parameter type appears as the type of a method parameter, the
containing class or trait may not be covariant in
that type parameter.</p>

<p>For queues, the <span class="code">enqueue</span>
method violates this condition:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">Queue[+T]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;T)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;...
  }
</pre>


<p>Running a modified queue class like the one above through a Scala compiler would yield:<a id="i-1072664655-2"/></p>

<pre>
  <code class="output">Queues.scala:11:&nbsp;error:&nbsp;covariant&nbsp;type&nbsp;T&nbsp;occurs&nbsp;in</code>
  <code class="output">contravariant&nbsp;position&nbsp;in&nbsp;type&nbsp;T&nbsp;of&nbsp;value&nbsp;x</code>
  <code class="output">&nbsp;&nbsp;def&nbsp;enqueue(x:&nbsp;T)&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>Reassignable fields are a special case of the rule that disallows type parameters annotated with <span class="code">+</span>
from being used as method parameter types. As mentioned in <a href="mutable-objects.html#sec-properties">Section 18.2</a>, a
reassignable field, "<span class="code">var</span>&nbsp;<span class="code">x:</span>&nbsp;<span class="code">T</span>", is treated in Scala as a getter method, "<span class="code">def</span>&nbsp;<span class="code">x:</span>&nbsp;<span class="code">T</span>",
and a setter method, "<span class="code">def</span>&nbsp;<span class="code">x_=(y:</span>&nbsp;<span class="code">T)</span>"<a id="i-1969580643-2"/>. As you can see, the setter method has a  
parameter of the field's type <span class="code">T</span>. So that type may not be covariant.</p>

<div class="pointofinterest">
<h3>The fast track</h3>


<p>In the rest of this section, we'll describe the mechanism by which the
Scala compiler checks variance annotations.
If you're not interested in such detail right now, you can safely skip to <a href="type-parameterization.html#sec-lower-bounds">Section 19.5</a>. The
most important thing to understand is that the Scala compiler
will check any variance annotations you place on type parameters. For example, if you try to declare a type parameter to
be covariant (by adding a <span class="code">+</span>), but that could lead to potential runtime errors, your program
won't compile.</p>

</div>


<p>To verify correctness of variance annotations,
the Scala compiler classifies all positions in a class or trait body
as <em>positive</em>, <em>negative</em> or <em>neutral</em>. A "position" is any
location in the class or trait (but from now on we'll just write "class")
body where a type parameter may be used. For example, every method value parameter is a position because
a method value parameter has a type. Therefore a type parameter could appear in that position.</p>

<p>The compiler checks each use of each of the class's type parameters. Type parameters
annotated with <span class="code">+</span>
may only be used in positive positions, while type parameters
annotated with <span class="code">-</span> may only be used in negative positions.  
A type parameter with no variance annotation
may be used in any position, and is, therefore, the only
kind of type parameter that can be used in neutral
positions of the class body.</p>

<p>To classify the positions, the compiler starts from the declaration of
a type parameter and then moves inward through deeper nesting levels.
Positions at the top level of the declaring class are classified as
positive.  By default, positions at deeper nesting levels are
classified the same as that at enclosing levels, but there are a handful
of exceptions where the classification changes.
Method value parameter positions are classified to the
<em>flipped</em> classification relative to positions
outside the method, where the flip of a positive classification is negative, the flip of a negative classification is positive, and
the flip of a neutral classification is still neutral.</p>

<p>Besides method value parameter positions, the current classification is also flipped at the type parameters of methods.
A classification is sometimes flipped at the type argument
position of a type, such as the <span class="code">Arg</span> in <span class="code">C[Arg]</span>,
depending on the variance of the corresponding type parameter.
If <span class="code">C</span>'s type
parameter is annotated with a <span class="code">+</span> then the
classification stays the same.  If
<span class="code">C</span>'s type parameter is annotated with a <span class="code">-</span>, then the current classification is flipped.  If <span class="code">C</span>'s
type parameter has no variance annotation then the current classification is changed to
neutral.</p>

<p>As a somewhat contrived example, consider the following class
definition, where several positions are
annotated with their classifications, <span class="code"><sup>+</sup></span> (for
positive) or <span class="code"><sup>-</sup></span> (for
negative):</p>

<pre>
  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Cat[-T,&nbsp;+U]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;meow[W<sup>-</sup>](volume:&nbsp;T<sup>-</sup>,&nbsp;listener:&nbsp;<code class="typename">Cat[U<sup>+</sup>,&nbsp;T<sup>-</sup>]</code><sup>-</sup>)
  &nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<code class="typename">Cat[Cat[U<sup>+</sup>,&nbsp;T<sup>-</sup>]<sup>-</sup>,&nbsp;U<sup>+</sup>]</code><sup>+</sup>
  }
</pre>


<p>The positions of the type parameter, <span class="code">W</span>, and the two value
parameters, <span class="code">volume</span> and <span class="code">listener</span>, are all negative.
Looking at the result type of <span class="code">meow</span>,
the position of the first <span class="code">Cat[U,</span>&nbsp;<span class="code">T]</span> argument is
negative because <span class="code">Cat</span>'s first type parameter, <span class="code">T</span>, is annotated with a <span class="code">-</span>.
 The type <span class="code">U</span> inside this argument is again in positive position
(two flips), whereas the type <span class="code">T</span> inside that argument is still in negative position.</p>

<p>You see from this discussion that it's quite hard to keep track of
variance positions. That's why it's a welcome relief that the Scala
compiler does this job for you.</p>

<p>Once the classifications are computed, the compiler checks that each
type parameter is only used in positions that are classified
appropriately.  In this case, <span class="code">T</span> is only used in negative
positions, and <span class="code">U</span> is only used in positive positions.
So class <span class="code">Cat</span> is type correct.</p>

<h3 id="sec-lower-bounds">19.5 Lower bounds</h3>


<p>Back to the <span class="code">Queue</span> class. You saw that the previous definition
of <span class="code">Queue[T]</span> shown in <a href="type-parameterization.html#lst-type-abstract-functional-queues">Listing 19.4</a> cannot be made covariant
in <span class="code">T</span> because <span class="code">T</span> appears
as a type of a parameter
of the <span class="code">enqueue</span> method, and that's a negative
position.</p>

<p>Fortunately, there's a way to get unstuck: you can generalize 
<span class="code">enqueue</span> by making it polymorphic (<i>i.e.</i>, giving the <span class="code">enqueue</span> method itself a type parameter)
and using a <em>lower bound</em> for its type parameter.<a id="i1770535476-1"/><a id="i1742340276-1"/> <a href="type-parameterization.html#lst-lower-bound">Listing 19.6</a> shows a new 
formulation of <span class="code">Queue</span> that implements this idea.</p>

<p><a id="lst-lower-bound"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Queue[+T]</code>&nbsp;(<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;leading:&nbsp;<code class="typename">List[T]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;trailing:&nbsp;<code class="typename">List[T]</code>&nbsp;)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue[U&nbsp;&gt;:&nbsp;T](x:&nbsp;U)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue[U]</code>(leading,&nbsp;x&nbsp;::&nbsp;trailing)&nbsp;<code class="comment">//&nbsp;...</code>
  &nbsp;&nbsp;}
</pre>


<h5>Listing 19.6 - A type parameter with a lower bound.</h5>


<p>The new definition gives <span class="code">enqueue</span> a type parameter <span class="code">U</span>, and with the syntax, "<span class="code">U</span>&nbsp;<span class="code">&gt;:</span>&nbsp;<span class="code">T</span>", defines <span class="code">T</span> as the lower bound
for <span class="code">U</span>. As a result,<a id="i1800766244-1"/>
<span class="code">U</span> is required to be a supertype of <span class="code">T</span>.<a href="type-parameterization.html#footnotemain19-1">[1]</a>
The parameter to <span class="code">enqueue</span> is now
of type <span class="code">U</span> instead of type <span class="code">T</span>, and the return value of the
method is now <span class="code">Queue[U]</span> instead of <span class="code">Queue[T]</span>.</p>

<p>For example, suppose there is a class <span class="code">Fruit</span> with two subclasses,
<span class="code">Apple</span> and <span class="code">Orange</span>. With the new definition of class <span class="code">Queue</span>, it
is possible to append an <span class="code">Orange</span> to a <span class="code">Queue[Apple]</span>. The result
will be a <span class="code">Queue[Fruit]</span>.</p>

<p>This revised definition of <span class="code">enqueue</span> is type correct.  Intuitively, if
<span class="code">T</span> is a more specific type than expected (for example, <span class="code">Apple</span> instead of
<span class="code">Fruit</span>), a call to <span class="code">enqueue</span> will still work because <span class="code">U</span>
(<span class="code">Fruit</span>) will still be a supertype of <span class="code">T</span> (<span class="code">Apple</span>).<a href="type-parameterization.html#footnotemain19-2">[2]</a></p>

<p>The new definition of <span class="code">enqueue</span> is arguably better than the old, because it is more general.  Unlike the old version, the new
definition allows you to append an arbitrary supertype <span class="code">U</span> of the queue
element type <span class="code">T</span>.  The result is then a <span class="code">Queue[U]</span>. Together with
queue covariance, this gives the right kind of flexibility for
modeling queues of different element types in a natural way.</p>

<p>This shows that variance annotations and lower bounds play well together. 
They are a good example of <span style="font-style:italic">type-driven design</span>, where the types of an
interface guide its detailed design and implementation<a id="i819829841-1"/>. In the case of
queues, it's likely you would not have thought of the refined
implementation of <span class="code">enqueue</span> with a lower bound. But you might have
decided to make queues covariant, in which case, the compiler would
have pointed out the variance error for <span class="code">enqueue</span>. Correcting the
variance error by adding a lower bound makes <span class="code">enqueue</span> more general and
queues as a whole more usable.</p>

<p>This observation is also the main reason that Scala prefers
declaration-site variance over use-site variance as it is found in
Java's
wildcards.<a id="i358663587-1"/><a id="i1971613366-1"/><a id="i-364469185-1"/> With use-site variance, you are on your own
designing a class.  It will be the clients of the class that need to
put in the wildcards, and if they get it wrong, some important
instance methods will no longer be applicable.
Variance being a tricky
business, users usually get it wrong, and they come away thinking that
wildcards and generics are overly complicated.  With definition-side
variance, you express your intent to the compiler, and the compiler
will double check that the methods you want available will indeed be
available.</p>

<h3>19.6 Contravariance</h3>


<p>So far in this chapter, all examples you've seen were either covariant or nonvariant.
But there are also cases where contravariance is
natural.<a id="i900875858-2"/> 
For instance, consider the trait of output channels shown in <a href="type-parameterization.html#lst-contravariant-output-channel">Listing 19.7</a>:
<a id="lst-contravariant-output-channel"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">OutputChannel[-T]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;write(x:&nbsp;T)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 19.7 - A contravariant output channel.</h5>


<p>Here, <span class="code">OutputChannel</span> is defined to be contravariant in <span class="code">T</span>.  So an output channel of
<span class="code">AnyRef</span>s, say, is a subtype of an output channel of <span class="code">String</span>s.
Although it may seem non-intuitive, it actually
 makes sense. To see why, consider what you can do with an
<span class="code">OutputChannel[String]</span>. 
The only supported operation is writing a
<span class="code">String</span> to it.  The same operation can also be done on an
<span class="code">OutputChannel[AnyRef]</span>. So it is safe to substitute an
<span class="code">OutputChannel[AnyRef]</span> for an <span class="code">OutputChannel[String]</span>.
By contrast, it would not be
safe to substitute an <span class="code">OutputChannel[String]</span> where an
<span class="code">OutputChannel[AnyRef]</span> is required. After all, you can send any
object to an <span class="code">OutputChannel[AnyRef]</span>, whereas an
<span class="code">OutputChannel[String]</span> requires that the written values are all
strings.</p>

<p>This reasoning points to a general principle in type system
design: It
is safe to assume that a type <span class="code">T</span> is a subtype of a type <span class="code">U</span> if you
can substitute a value of type <span class="code">T</span> wherever a value of type <span class="code">U</span> is
required. This is called the <span style="font-style:italic">Liskov Substitution
Principle</span><a id="i1033900893-1"/>.  The
principle holds if <span class="code">T</span> supports the same operations as <span class="code">U</span>, and all
of <span class="code">T</span>'s operations require less and provide more than the
corresponding operations in <span class="code">U</span>. In the case of output channels, an
<span class="code">OutputChannel[AnyRef]</span> can be a subtype of an <span class="code">OutputChannel[String]</span> because 
the two support the same <span class="code">write</span> operation, and this operation requires less
in <span class="code">OutputChannel[AnyRef]</span> than in <span class="code">OutputChannel[String]</span>. "Less" means 
the argument is only required to be an <span class="code">AnyRef</span> in the first case, 
whereas it is required to be a <span class="code">String</span> in the second case.</p>

<p>Sometimes covariance and contravariance are mixed in the same type. A
prominent example is Scala's function traits. 
For instance, whenever you write the function type <span class="code">A</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">B</span>,
Scala expands this to <span class="code">Function1[A,</span>&nbsp;<span class="code">B]</span>.  The definition of
<span class="code">Function1</span> in the standard library uses both covariance
and contravariance: the <span class="code">Function1</span> trait is contravariant in the function argument type <span class="code">S</span> and covariant in the result type <span class="code">T</span>,<a id="i-921885027-1"/><a id="i-1806331359-1"/>
as shown in <a href="type-parameterization.html#lst-function-variance">Listing 19.8</a>.
This satisfies the Liskov Substitution Principle because arguments are something that's required, whereas results
are something that's provided.</p>

<p><a id="lst-function-variance"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">Function1[-S,&nbsp;+T]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(x:&nbsp;S):&nbsp;T
  &nbsp;&nbsp;}
</pre>


<h5>Listing 19.8 - Covariance and contravariance of <span class="code">Function1</span>s.</h5>


<p>As an example, consider the application shown in <a href="type-parameterization.html#lst-parrot-contravariance">Listing 19.9</a>. Here, class
<span class="code">Publication</span> contains one parametric field, <span class="code">title</span>, of type <span class="code">String</span>.
Class <span class="code">Book</span> extends <span class="code">Publication</span> and forwards its string <span class="code">title</span> parameter to the constructor of its superclass.
The <span class="code">Library</span> singleton object defines a set of books and a method <span class="code">printBookList</span>, which takes
a function, named <span class="code">info</span>, of type <span class="code">Book</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">AnyRef</span>. In other words, the type of the lone parameter to <span class="code">printBookList</span> is a function
that takes one <span class="code">Book</span> argument and returns an <span class="code">AnyRef</span>. The <span class="code">Customer</span> application defines a method, <span class="code">getTitle</span>,
which takes a <span class="code">Publication</span> as its lone parameter and returns a <span class="code">String</span>, the title of the passed <span class="code">Publication</span>.</p>

<p><a id="lst-parrot-contravariance"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Publication</code>(<code class="vem">val</code>&nbsp;title:&nbsp;<code class="typename">String</code>)
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Book</code>(title:&nbsp;<code class="typename">String</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Publication</code>(title)
  <br />  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Library</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;books:&nbsp;<code class="typename">Set[Book]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Set</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Book</code>(<code class="quotedstring">"Programming&nbsp;in&nbsp;Scala"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Book</code>(<code class="quotedstring">"Walden"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;printBookList(info:&nbsp;<code class="typename">Book</code>&nbsp;=&gt;&nbsp;<code class="typename">AnyRef</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(book&nbsp;&lt;-&nbsp;books)&nbsp;println(info(book))
  &nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Customer</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">App</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;getTitle(p:&nbsp;<code class="typename">Publication</code>):&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;p.title
  &nbsp;&nbsp;&nbsp;Library.printBookList(getTitle)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 19.9 - Demonstration of function type parameter variance.</h5>


<p>Now take a look at the last line in <span class="code">Customer</span>. This line invokes <span class="code">Library</span>'s <span class="code">printBookList</span> method and passes
<span class="code">getTitle</span>, wrapped in a function value:</p>

<pre>
  Library.printBookList(getTitle)
</pre>


<p>This line of code type checks even though <span class="code">String</span>, the function's result type, is a subtype
of <span class="code">AnyRef</span>, the result type of <span class="code">printBookList</span>'s <span class="code">info</span> parameter. This code
passes the compiler because function result types are declared to be covariant (the <span class="code">+T</span> in 
<a href="type-parameterization.html#lst-function-variance">Listing 19.8</a>). If you look inside the body of <span class="code">printBookList</span>, you can
get a glimpse of why this makes sense.</p>

<p>The <span class="code">printBookList</span> method iterates through its book list and invokes the passed function
on each book. It passes the <span class="code">AnyRef</span> result returned by <span class="code">info</span> to <span class="code">println</span>, which invokes <span class="code">toString</span> on it and prints the result.
This activity will work with <span class="code">String</span> as well as any other subclass of <span class="code">AnyRef</span>, which is what
covariance of function result types means.</p>

<p>Now consider the parameter type of the function being passed to the <span class="code">printBookList</span> method. Although <span class="code">printBookList</span>'s
parameter type is declared as <span class="code">Book</span>, the <span class="code">getTitle</span> we're passing
in takes a <span class="code">Publication</span>, a <em>supertype</em> of
<span class="code">Book</span><a id="i-331888331-1"/>. The reason this works is that since
<span class="code">printBookList</span>'s parameter type is <span class="code">Book</span>, the body of the <span class="code">printBookList</span> method will only be allowed
to pass a <span class="code">Book</span> into the function. And because <span class="code">getTitle</span>'s parameter type is <span class="code">Publication</span>,
the body of that function will only be able to access on its parameter, <span class="code">p</span>, members that are declared in
class <span class="code">Publication</span>. Because any method declared in <span class="code">Publication</span> is also available on its subclass <span class="code">Book</span>, 
everything should work, which is what contravariance of function parameter types means.
You can see all this graphically in <a href="type-parameterization.html#fig-contravariance">Figure 19.1</a>.</p>

<p>The code in <a href="type-parameterization.html#lst-parrot-contravariance">Listing 19.9</a>
compiles because <span class="code">Publication</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">String</span> is a subtype of <span class="code">Book</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">AnyRef</span>, as shown in the center of the <a href="type-parameterization.html#fig-contravariance">Figure 19.1</a>. Because
the result type of a <span class="code">Function1</span> is defined as covariant, the inheritance relationship of the two result types, shown at the right
of the diagram, is in the same direction as that of the two functions shown in the center. By contrast, because
the parameter type of a <span class="code">Function1</span> is defined as contravariant, the inheritance relationship of the two parameter types, shown at the
left of the diagram, is in the opposite direction as that of the two functions.</p>

<div class="figure"><a id="fig-contravariance"/>


<p><img src="images/variance160.png" alt="image images/variance160.png"/></p>

</div>
<h5> Figure 19.1 - Covariance and contravariance in function type parameters.</h5>


<p><a id="lst-optimized-functional-queues"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Queue[+T]</code>&nbsp;<code class="vem">private</code>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[<code class="vem">this</code>]&nbsp;<code class="vem">var</code>&nbsp;leading:&nbsp;<code class="typename">List[T]</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[<code class="vem">this</code>]&nbsp;<code class="vem">var</code>&nbsp;trailing:&nbsp;<code class="typename">List[T]</code>
  &nbsp;&nbsp;)&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;mirror()&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(leading.isEmpty)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">while</code>&nbsp;(!trailing.isEmpty)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leading&nbsp;=&nbsp;trailing.head&nbsp;::&nbsp;leading
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trailing&nbsp;=&nbsp;trailing.tail
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;head:&nbsp;T&nbsp;=&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mirror()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leading.head&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail:&nbsp;<code class="typename">Queue[T]</code>&nbsp;=&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mirror()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue</code>(leading.tail,&nbsp;trailing)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue[U&nbsp;&gt;:&nbsp;T](x:&nbsp;U)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue[U]</code>(leading,&nbsp;x&nbsp;::&nbsp;trailing)
  &nbsp;&nbsp;}</pre>


<h5>Listing 19.10 - An optimized functional queue.</h5>


<h3 id="variance-object-local">19.7 Object private data</h3>


<p>The <span class="code">Queue</span> class seen so far has a
problem in that the <span class="code">mirror</span> operation will repeatedly copy the
<span class="code">trailing</span> into the <span class="code">leading</span> list if <span class="code">head</span> is called several
times in a row on a list where <span class="code">leading</span> is empty.  The wasteful
copying could be avoided by adding some judicious side
effects. <a href="type-parameterization.html#lst-optimized-functional-queues">Listing 19.10</a> presents a new
implementation of <span class="code">Queue</span>, which performs at most one <span class="code">trailing</span> to
<span class="code">leading</span> adjustment for any sequence of <span class="code">head</span> operations.</p>

<p>What's different with respect to the previous version is that now
<span class="code">leading</span> and <span class="code">trailing</span> are reassignable variables, and <span class="code">mirror</span>
performs the reverse copy from <span class="code">trailing</span> to <span class="code">leading</span> as
a side effect on the current queue instead of returning a new queue.
This side effect is purely internal to the implementation of the
<span class="code">Queue</span> operation; since <span class="code">leading</span> and <span class="code">trailing</span> are private
variables, the effect is not visible to clients of <span class="code">Queue</span>.  
So by the terminology established in <a href="mutable-objects.html">Chapter 18</a>,
the new version of <span class="code">Queue</span> still defines purely functional objects, 
in spite of the fact that they now contain reassignable fields.</p>

<p>You might wonder whether this code passes the Scala type
checker. After all, queues now contain two reassignable fields of the
covariant parameter type <span class="code">T</span>.  Is this not a violation of the
variance rules? It would be indeed, except for the detail that
<span class="code">leading</span> and <span class="code">trailing</span> have a <span class="code">private[this]</span> modifier, and are
thus declared to be object private.</p>

<p>As mentioned in
<a href="packages-and-imports.html#sec-access-modifiers">Section 13.5</a>, object private members
can be accessed only from within the object in which they are defined.
It turns out that accesses to variables from the same object in
which they are defined do not cause problems with variance. The
intuitive explanation is that, in order to construct a case where
variance would lead to type errors, you need to have a reference to a
containing object that has a statically weaker type than the type the object was
defined with. For accesses to object private values, however, this is impossible.</p>

<p>Scala's variance checking rules contain a special case for object private
definitions.<a id="i-245097893-2"/>  Such definitions are omitted when it is checked that a
type parameter with either a <span class="code">+</span> or <span class="code">-</span> annotation
occurs only in positions that have
the same variance classification. Therefore, the code in 
<a href="type-parameterization.html#lst-optimized-functional-queues">Listing 19.10</a> compiles without error.
On the other hand, if you had left out the <span class="code">[this]</span> qualifiers from the 
two <span class="code">private</span> modifiers, you would see two type errors:<a id="i-517711887-1"/></p>

<pre>
  <code class="output">Queues.scala:1:&nbsp;error:&nbsp;covariant&nbsp;type&nbsp;T&nbsp;occurs&nbsp;in&nbsp;</code>
  <code class="output">contravariant&nbsp;position&nbsp;in&nbsp;type&nbsp;List[T]&nbsp;of&nbsp;parameter&nbsp;of</code>
  <code class="output">setter&nbsp;leading_=</code>
  <code class="output">class&nbsp;Queue[+T]&nbsp;private&nbsp;(private&nbsp;var&nbsp;leading:&nbsp;List[T],</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">Queues.scala:1:&nbsp;error:&nbsp;covariant&nbsp;type&nbsp;T&nbsp;occurs&nbsp;in&nbsp;</code>
  <code class="output">contravariant&nbsp;position&nbsp;in&nbsp;type&nbsp;List[T]&nbsp;of&nbsp;parameter&nbsp;of</code>
  <code class="output">setter&nbsp;trailing_=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;var&nbsp;trailing:&nbsp;List[T])&nbsp;{</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<h3 id="sec-upper-bounds">19.8 Upper bounds</h3>


<p>In <a href="working-with-lists.html#lst-merge-sort-function">Listing 16.1</a>  <a href="working-with-lists.html#lst-merge-sort-function">here</a>, we showed a merge sort function for lists
that took a comparison function as a first argument and a list to sort
as a second, curried argument.<a id="i-1812239373-1"/><a id="i1036774557-1"/> Another way you might
want to organize such a sort function is by requiring the type of the list to mix in the <span class="code">Ordered</span> trait. As mentioned in
<a href="traits.html#sec-the-ordered-trait">Section 12.4</a>, by mixing <span class="code">Ordered</span> into a class and implementing <span class="code">Ordered</span>'s one abstract method, <span class="code">compare</span>, you<a id="i1970675952-2"/><a id="i2068605051-3"/>
enable clients to compare instances of that class with <span class="code">&lt;</span>, <span class="code">&gt;</span>, <span class="code">&lt;=</span>, and <span class="code">&gt;=</span>.  For example, <a href="type-parameterization.html#lst-ordered-person">Listing 19.11</a> shows <span class="code">Ordered</span>
being mixed into a <span class="code">Person</span> class.</p>

<p>As a result, you can compare two people like this:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;robert&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Robert"</code>,&nbsp;<code class="quotedstring">"Jones"</code>)
  <code class="output">robert:&nbsp;Person&nbsp;=&nbsp;Robert&nbsp;Jones</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;sally&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Sally"</code>,&nbsp;<code class="quotedstring">"Smith"</code>)
  <code class="output">sally:&nbsp;Person&nbsp;=&nbsp;Sally&nbsp;Smith</code>
  <br />  scala&gt;&nbsp;robert&nbsp;&lt;&nbsp;sally
  <code class="output">res0:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>


<p><a id="lst-ordered-person"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Person</code>(<code class="vem">val</code>&nbsp;firstName:&nbsp;<code class="typename">String</code>,&nbsp;<code class="vem">val</code>&nbsp;lastName:&nbsp;<code class="typename">String</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Ordered[Person]</code>&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;compare(that:&nbsp;<code class="typename">Person</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;lastNameComparison&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastName.compareToIgnoreCase(that.lastName)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(lastNameComparison&nbsp;!=&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastNameComparison
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstName.compareToIgnoreCase(that.firstName)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;firstName&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;"</code>&nbsp;+&nbsp;lastName
  &nbsp;&nbsp;}
</pre>


<h5>Listing 19.11 - A <span class="code">Person</span> class that mixes in the <span class="code">Ordered</span> trait.</h5>


<p><a id="lst-upper-bound-sort"/></p>

<pre>
  <code class="vem">def</code>&nbsp;orderedMergeSort[T&nbsp;&lt;:&nbsp;<code class="typename">Ordered[T]</code>](xs:&nbsp;<code class="typename">List[T]</code>):&nbsp;<code class="typename">List[T]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;merge(xs:&nbsp;<code class="typename">List[T]</code>,&nbsp;ys:&nbsp;<code class="typename">List[T]</code>):&nbsp;<code class="typename">List[T]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;(xs,&nbsp;ys)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;(<code class="typename">Nil</code>,&nbsp;_)&nbsp;=&gt;&nbsp;ys
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;(_,&nbsp;<code class="typename">Nil</code>)&nbsp;=&gt;&nbsp;xs
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;(x&nbsp;::&nbsp;xs1,&nbsp;y&nbsp;::&nbsp;ys1)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(x&nbsp;&lt;&nbsp;y)&nbsp;x&nbsp;::&nbsp;merge(xs1,&nbsp;ys)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;y&nbsp;::&nbsp;merge(xs,&nbsp;ys1)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;n&nbsp;=&nbsp;xs.length&nbsp;/&nbsp;<code class="literal">2</code>
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(n&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;xs
  &nbsp;&nbsp;<code class="vem">else</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;(ys,&nbsp;zs)&nbsp;=&nbsp;xs&nbsp;splitAt&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;merge(orderedMergeSort(ys),&nbsp;orderedMergeSort(zs))
  &nbsp;&nbsp;}
  }
</pre>


<h5>Listing 19.12 - A merge sort function with an upper bound.</h5>


<div style="page-break-after:always"/>


<p>To require that the type of the list passed to your new sort function mixes in <span class="code">Ordered</span>, you need to<a id="i1850759422-1"/>
use an <em>upper bound</em>. An upper bound is specified similar to a lower bound, except instead of the <span class="code">&gt;:</span>
symbol used for lower bounds, you use a <span class="code">&lt;:</span> symbol, as shown in <a href="type-parameterization.html#lst-upper-bound-sort">Listing 19.12</a>.</p>

<p>With the "<span class="code">T</span>&nbsp;<span class="code">&lt;:</span>&nbsp;<span class="code">Ordered[T]</span>" syntax, you indicate that the type parameter, <span class="code">T</span>, has an upper bound, <span class="code">Ordered[T]</span>. This
means that the element type of the list passed to <span class="code">orderedMergeSort</span> must be a subtype of <span class="code">Ordered</span>. Thus, you could pass
a <span class="code">List[Person]</span> to <span class="code">orderedMergeSort</span> because <span class="code">Person</span> mixes in <span class="code">Ordered</span>.</p>

<p>For example, consider this
list:<a id="i1588987823-1"/><a id="i-604737946-1"/><a id="i717131072-1"/><a id="i438821039-2"/><a id="i2020741259-1"/></p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;people&nbsp;=&nbsp;<code class="typename">List</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Larry"</code>,&nbsp;<code class="quotedstring">"Wall"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Anders"</code>,&nbsp;<code class="quotedstring">"Hejlsberg"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Guido"</code>,&nbsp;<code class="quotedstring">"van&nbsp;Rossum"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Alan"</code>,&nbsp;<code class="quotedstring">"Kay"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Yukihiro"</code>,&nbsp;<code class="quotedstring">"Matsumoto"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <code class="output">people:&nbsp;List[Person]&nbsp;=&nbsp;List(Larry&nbsp;Wall,&nbsp;Anders&nbsp;Hejlsberg,</code>
  <code class="output">&nbsp;&nbsp;Guido&nbsp;van&nbsp;Rossum,&nbsp;Alan&nbsp;Kay,&nbsp;Yukihiro&nbsp;Matsumoto)</code>
</pre>


<p>Because the element type of this list, <span class="code">Person</span>, mixes in (and is therefore a subtype of) 
<span class="code">Ordered[People]</span>, you can pass the list to <span class="code">orderedMergeSort</span>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;sortedPeople&nbsp;=&nbsp;orderedMergeSort(people)
  <code class="output">sortedPeople:&nbsp;List[Person]&nbsp;=&nbsp;List(Anders&nbsp;Hejlsberg,&nbsp;Alan&nbsp;Kay,</code>
  <code class="output">&nbsp;&nbsp;Yukihiro&nbsp;Matsumoto,&nbsp;Guido&nbsp;van&nbsp;Rossum,&nbsp;Larry&nbsp;Wall)</code>
</pre>


<p>Now, although the sort function shown in <a href="type-parameterization.html#lst-upper-bound-sort">Listing 19.12</a> serves as a useful illustration
of upper bounds, it isn't actually the most general
way in Scala to design a sort function that takes advantage of the <span class="code">Ordered</span> trait.</p>

<p>For example, you couldn't
use the <span class="code">orderedMergeSort</span> function to sort a list of
integers, because class <span class="code">Int</span> is not a subtype of <span class="code">Ordered[Int]</span>:<a id="i-1803074733-1"/></p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;wontCompile&nbsp;=&nbsp;orderedMergeSort(<code class="typename">List</code>(<code class="literal">3</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">1</code>))
  <code class="output">&lt;console&gt;:5:&nbsp;error:&nbsp;inferred&nbsp;type&nbsp;arguments&nbsp;[Int]&nbsp;do</code>
  <code class="output">&nbsp;&nbsp;&nbsp;not&nbsp;conform&nbsp;to&nbsp;method&nbsp;orderedMergeSort's&nbsp;type</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameter&nbsp;bounds&nbsp;[T&nbsp;&lt;:&nbsp;Ordered[T]]</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;wontCompile&nbsp;=&nbsp;orderedMergeSort(List(3,&nbsp;2,&nbsp;1))</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>In <a href="implicit-conversions-and-parameters.html#sec-context-bounds">Section 21.6</a>, we'll show you how to use <em>implicit parameters</em> and
<em>context bounds</em> to achieve a more general
solution.<a id="i-568821387-1"/><a id="i-956942778-1"/></p>

<h3>19.9 Conclusion</h3>


<p>In this chapter you saw several techniques for information
hiding: private constructors, factory methods, type abstraction, and
object private members. You also learned how to specify data type
variance and what it implies for class implementation. Finally, you
saw two techniques which help in obtaining flexible variance
annotations: lower bounds for method type parameters and
<span class="code">private[this]</span> annotations for local fields and methods.</p>

<hr/>
<h4>Footnotes for Chapter 19:</h4>


<p><a id="footnotemain19-1"/>[1] Supertype and subtype relationships are reflexive, which means a type is both
a supertype and a subtype of itself. Even though <span class="code">T</span> is a lower bound for <span class="code">U</span>, you could still pass in a <span class="code">T</span> to <span class="code">enqueue</span>.</p>

<p><a id="footnotemain19-2"/>[2] Technically,
what happens is a flip occurs for lower bounds.  The
type parameter <span class="code">U</span> is in a negative position (1 flip), while the
lower bound (<span class="code">&gt;:</span>&nbsp;<span class="code">T</span>) is in a positive position (2 flips).</p>

<div style="page-break-after:always"/>


<div style="page-break-after:always"/>



</body>
</html>
