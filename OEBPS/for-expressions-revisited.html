<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8"/>
    <title>Programming in Scala, 3rd Edition</title>

    <link rel="stylesheet" type="text/css" href="book.css" />
  </head>
<body>
<h2><a id="chap-for-expressions-revisited">Chapter 23</a></h2>
<h1>For Expressions Revisited</h1>


<p><a href="working-with-lists.html">Chapter 16</a>
demonstrated that higher-order functions, such as
<pre class="code">map</pre>, <pre class="code">flatMap</pre>, and <pre class="code">filter</pre>, provide powerful
constructions for dealing with lists.  But sometimes the level of
abstraction required by these functions makes a program a bit hard to
understand.</p>

<p>Here's an example. Say you are given a list of persons,
each defined as an instance of a class <pre class="code">Person</pre>. Class <pre class="code">Person</pre> 
has fields indicating the person's name, whether he or she is male, 
and his or her children.</p>

<p>Here's the class definition:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Person</code>(name:&nbsp;<code class="typename">String</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isMale:&nbsp;<code class="typename">Boolean</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children:&nbsp;<code class="typename">Person</code>*)
</pre>


<p>Here's a list of some sample <pre class="code">person</pre>s:</p>

<pre>
  <code class="vem">val</code>&nbsp;lara&nbsp;=&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Lara"</code>,&nbsp;<code class="vem">false</code>)
  <code class="vem">val</code>&nbsp;bob&nbsp;=&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Bob"</code>,&nbsp;<code class="vem">true</code>)
  <code class="vem">val</code>&nbsp;julie&nbsp;=&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Julie"</code>,&nbsp;<code class="vem">false</code>,&nbsp;lara,&nbsp;bob)
  <code class="vem">val</code>&nbsp;persons&nbsp;=&nbsp;<code class="typename">List</code>(lara,&nbsp;bob,&nbsp;julie)
</pre>


<p>Now, say you want to find out the names of all pairs 
of mothers and their children in that list.
Using <pre class="code">map</pre>, <pre class="code">flatMap</pre> and <pre class="code">filter</pre>, you can formulate the following query:</p>

<pre>
  scala&gt;&nbsp;persons&nbsp;filter&nbsp;(p&nbsp;=&gt;&nbsp;!p.isMale)&nbsp;flatMap&nbsp;(p&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(p.children&nbsp;map&nbsp;(c&nbsp;=&gt;&nbsp;(p.name,&nbsp;c.name))))
  <code class="output">res0:&nbsp;List[(String,&nbsp;String)]&nbsp;=&nbsp;List((Julie,Lara),&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;(Julie,Bob))</code>
</pre>


<p>You could optimize this example a bit by using a <pre class="code">withFilter</pre> call instead of <pre class="code">filter</pre>.
This would avoid the creation of an intermediate data structure for female persons:</p>

<pre>
  scala&gt;&nbsp;persons&nbsp;withFilter&nbsp;(p&nbsp;=&gt;&nbsp;!p.isMale)&nbsp;flatMap&nbsp;(p&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(p.children&nbsp;map&nbsp;(c&nbsp;=&gt;&nbsp;(p.name,&nbsp;c.name))))
  <code class="output">res1:&nbsp;List[(String,&nbsp;String)]&nbsp;=&nbsp;List((Julie,Lara),&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;(Julie,Bob))</code>
</pre>


<p>These queries do their job, but they are not exactly trivial to write or understand.
Is there a simpler way? In fact, there is. Remember the <pre class="code">for</pre> expressions in 
<a href="builtin-control-structures.html#sec-for-expressions">Section 7.3</a><a id="i-207940604-3"/>? Using a <pre class="code">for</pre> expression, the same example 
can be written as follows:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(p&nbsp;&lt;-&nbsp;persons;&nbsp;<code class="vem">if</code>&nbsp;!p.isMale;&nbsp;c&nbsp;&lt;-&nbsp;p.children)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;(p.name,&nbsp;c.name)
  <code class="output">res2:&nbsp;List[(String,&nbsp;String)]&nbsp;=&nbsp;List((Julie,Lara),&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;(Julie,Bob))</code>
</pre>


<p>The result of this expression is exactly the same as the 
result of the previous expression.  What's more, most readers of the code would likely find the <pre class="code">for</pre> expression
much clearer than the previous query, which used the higher-order
functions, <pre class="code">map</pre><a id="i-482121133-1"/>,
<pre class="code">flatMap</pre><a id="i-1499753963-1"/>, and
<pre class="code">withFilter</pre><a id="i582713813-1"/>.</p>

<p>However, the last two queries are not as dissimilar as it might seem. In
fact, it turns out that the Scala compiler will translate the second
query into the first one. More generally, all <pre class="code">for</pre> expressions that
<pre class="code">yield</pre><a id="i-1534065145-1"/> a result are translated by the compiler into combinations of
invocations of the higher-order methods <pre class="code">map</pre>, <pre class="code">flatMap</pre>, and
<pre class="code">withFilter</pre>. All <pre class="code">for</pre> loops without <pre class="code">yield</pre> are translated into a
smaller set of higher-order functions: just <pre class="code">withFilter</pre>
and <pre class="code">foreach</pre><a id="i-493461951-1"/>.</p>

<p>In this chapter, you'll find out first about the precise rules of
writing <pre class="code">for</pre> expressions. After that, you'll see how they can make
combinatorial problems easier to solve. Finally, you'll learn how
<pre class="code">for</pre> expressions are translated, and how as a result, <pre class="code">for</pre> expressions can help you "grow" the
Scala language into new application domains.</p>

<h3>23.1 For expressions</h3>


<p>Generally, a <pre class="code">for</pre> expression is of the form:</p>

<pre>
  <code class="vem">for</code>&nbsp;(&nbsp;<code style="font-style:italic">seq</code>&nbsp;)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code>
</pre>


<p>Here, <span style="font-style:italic">seq</span> is a sequence of <span style="font-style:italic">generators</span>, <span style="font-style:italic">definitions</span>, and
<span style="font-style:italic">filters</span>, with semicolons between successive elements.
An example is the <pre class="code">for</pre> expression:</p>

<pre>
  <code class="vem">for</code>&nbsp;(p&nbsp;&lt;-&nbsp;persons;&nbsp;n&nbsp;=&nbsp;p.name;&nbsp;<code class="vem">if</code>&nbsp;(n&nbsp;startsWith&nbsp;<code class="quotedstring">"To"</code>))&nbsp;
  <code class="vem">yield</code>&nbsp;n
</pre>


<p>This <pre class="code">for</pre> expression contains one generator, one definition, and one filter.
As mentioned in <a href="builtin-control-structures.html#sec-for-expressions">Section 7.3</a>  <a href="builtin-control-structures.html#exa-for-semicolon-explanation">here</a>, you can also enclose the sequence in braces instead of parentheses. Then
the semicolons become optional:</p>

<pre>
  <code class="vem">for</code>&nbsp;{
  &nbsp;&nbsp;p&nbsp;&lt;-&nbsp;persons&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;a&nbsp;generator</code>
  &nbsp;&nbsp;n&nbsp;=&nbsp;p.name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;a&nbsp;definition</code>
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(n&nbsp;startsWith&nbsp;<code class="quotedstring">"To"</code>)&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;a&nbsp;filter</code>
  }&nbsp;<code class="vem">yield</code>&nbsp;n
</pre>


<p>A <span style="font-style:italic">generator</span> is of the form:<a id="i1422302298-1"/></p>

<pre>
  <code style="font-style:italic">pat</code>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code>
</pre>


<p>The expression <span style="font-style:italic">expr</span> typically returns a list, even though you will see
later that this can be generalized. The pattern <span style="font-style:italic">pat</span> gets matched
one-by-one against all elements of that list.<a id="i-1272952554-2"/><a id="i371386352-2"/> If the match succeeds, the 
variables in the pattern get bound to the corresponding parts of the element, 
just the way it is described in <a href="case-classes-and-pattern-matching.html">Chapter 15</a>.
But if the match fails, no <pre class="code">MatchError</pre> is thrown.<a id="i797126047-1"/>
Instead, the element is simply discarded from the iteration.</p>

<p>In the most common case,
the pattern <span style="font-style:italic">pat</span> is just a variable <span style="font-style:italic">x</span>, as in
<span class="code"><span style="font-style:italic">x</span></span>&nbsp;<pre class="code">&lt;-</pre>&nbsp;<span class="code"><span style="font-style:italic">expr</span></span>. In that case,
the variable <span style="font-style:italic">x</span> simply iterates over all elements returned by <span style="font-style:italic">expr</span>.</p>

<p>A <span style="font-style:italic">definition</span> is of the form:</p>

<pre>
  <code style="font-style:italic">pat</code>&nbsp;=&nbsp;<code style="font-style:italic">expr</code>
</pre>


<p>This definition binds the pattern <span style="font-style:italic">pat</span> to the value of <span style="font-style:italic">expr</span>, so it has the same effect as a <pre class="code">val</pre> definition:</p>

<pre>
  <code class="vem">val</code>&nbsp;<code style="font-style:italic">x</code>&nbsp;=&nbsp;<code style="font-style:italic">expr</code>
</pre>


<p>The most common case is again where the pattern is a simple variable <pre class="code">x</pre> (<i>e.g.</i>,
<span class="code"><span style="font-style:italic">x</span></span>&nbsp;<pre class="code">=</pre>&nbsp;<span class="code"><span style="font-style:italic">expr</span></span>). This defines <span style="font-style:italic">x</span> as a name for the value
<span style="font-style:italic">expr</span>.</p>

<p>A <span style="font-style:italic">filter</span> is of the form:</p>

<div style="page-break-after:always"/>


<pre>
  <code class="vem">if</code>&nbsp;<code style="font-style:italic">expr</code>
</pre>


<p>Here, <span style="font-style:italic">expr</span> is an expression of type <pre class="code">Boolean</pre>.<a id="i331566550-1"/>
The filter drops from the iteration all elements for which <span style="font-style:italic">expr</span> returns <pre class="code">false</pre>.</p>

<p>Every <pre class="code">for</pre> expression starts with a generator. If there are several
generators in a <pre class="code">for</pre> expression, later generators vary more rapidly than
earlier ones. You can verify this easily with the following simple test:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(x&nbsp;&lt;-&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>);&nbsp;y&nbsp;&lt;-&nbsp;<code class="typename">List</code>(<code class="quotedstring">"one"</code>,&nbsp;<code class="quotedstring">"two"</code>))&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;(x,&nbsp;y)
  <code class="output">res3:&nbsp;List[(Int,&nbsp;String)]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;List((1,one),&nbsp;(1,two),&nbsp;(2,one),&nbsp;(2,two))</code>
</pre>


<h3>23.2 The n-queens problem</h3>


<p>A particularly suitable application area of <pre class="code">for</pre> expressions are
combinatorial puzzles. An example of such a puzzle is the 8-queens
problem: Given a standard chess-board, place eight queens such that no
queen is in check from any other (a queen can check another piece if
they are on the same column, row, or diagonal). To find a solution to
this problem, it's actually simpler to generalize it to chess-boards
of arbitrary size. Hence, the problem is to place <i>N</i> queens on a
chess-board of <i>N</i>  <span style="font-family:sans-serif">x</span>  <i>N</i> squares, where the size <i>N</i> is
arbitrary. We'll start numbering cells at one, so the upper-left cell
of an <i>N</i>  <span style="font-family:sans-serif">x</span>  <i>N</i> board has coordinate (1, 1) and the lower-right
cell has coordinate (<i>N</i>, <i>N</i>).</p>

<p>To solve the N-queens problem, note that you need to place a queen in
each row.  So you could place queens in successive rows, each time
checking that a newly placed queen is not in check from any other
queens that have already been placed. In the course of this search, it
might happen that a queen that needs to be placed in row <i>k</i> would be
in check in all fields of that row from queens in row 1 to <i>k</i>-1. In
that case, you need to abort that part of the search in order to
continue with a different configuration of queens in columns 1 to
<i>k</i>-1.</p>

<p>An imperative solution to this problem would place queens one by one,
moving them around on the board. But it looks difficult to come up
with a scheme that really tries all possibilities. A more functional approach represents a solution directly, as a value.
A solution consists of a list of coordinates, one for each queen
placed on the board. 
Note, however, that a full solution can
not be found in a single step. It needs to be built up gradually, by
occupying successive rows with queens.</p>

<p>This suggests a recursive algorithm.  Assume you have already
generated all solutions of placing <i>k</i> queens on a board of size <i>N</i>
 <span style="font-family:sans-serif">x</span>  <i>N</i>, where <i>k</i> is less than <i>N</i>. Each such solution can be
presented by a list of length <i>k</i> of coordinates <pre class="code">(row,</pre>&nbsp;<pre class="code">column)</pre>,
where both row and column numbers range from 1 to <i>N</i>.  It's
convenient to treat these partial solution lists as stacks, where the
coordinates of the queen in row <i>k</i> come first in the list, followed
by the coordinates of the queen in row <i>k</i>-1, and so on. The bottom of
the stack is the coordinate of the queen placed in the first row of
the board.  All solutions together are represented as a list of
lists, with one element for each solution.</p>

<p>Now, to place the next queen in row <i>k</i>+1, generate all possible extensions
of each previous solution by one more queen. This yields another list
of solution lists, this time of length <i>k</i>+1. Continue the process
until you have obtained all solutions of the size of the chess-board <i>N</i>.</p>

<p>This algorithmic idea is embodied in function <pre class="code">placeQueens</pre> below:</p>

<pre>
  <code class="vem">def</code>&nbsp;queens(n:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">List[List[(Int,&nbsp;Int)]]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;placeQueens(k:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">List[List[(Int,&nbsp;Int)]]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(k&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">List</code>(<code class="typename">List</code>())
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queens&nbsp;&lt;-&nbsp;placeQueens(k&nbsp;-&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;column&nbsp;&lt;-&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queen&nbsp;=&nbsp;(k,&nbsp;column)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;isSafe(queen,&nbsp;queens)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<code class="vem">yield</code>&nbsp;queen&nbsp;::&nbsp;queens
  <br />  &nbsp;&nbsp;placeQueens(n)
  }
</pre>


<p>The outer function <pre class="code">queens</pre> in the program above simply calls <pre class="code">placeQueens</pre>
with the size of the board <pre class="code">n</pre> as its argument. The task of the function 
application <pre class="code">placeQueens(k)</pre> is to
generate all partial solutions of length <pre class="code">k</pre> in a list. Every element
of the list is one solution, represented by a list of length <pre class="code">k</pre>. So <pre class="code">placeQueens</pre> 
returns a list of lists.</p>

<p>If the parameter <pre class="code">k</pre> to <pre class="code">placeQueens</pre> is <pre class="code">0</pre>, this means that it needs
to generate all solutions of placing zero queens on zero rows. There
is only one such solution: place no queen at all. This solution is
represented by the empty list. So if <pre class="code">k</pre> is zero,
<pre class="code">placeQueens</pre> returns <pre class="code">List(List())</pre>, a list consisting of a single
element that is the empty list.  Note that this is quite different
from the empty list <pre class="code">List()</pre>. If <pre class="code">placeQueens</pre> returns <pre class="code">List()</pre>,
this means <span style="font-style:italic">no solutions</span>, instead of a single solution consisting
of no placed queens.</p>

<p>In the other case, where <pre class="code">k</pre> is not zero, all the work of
<pre class="code">placeQueens</pre> is done in a <pre class="code">for</pre> expression. The first generator of
that <pre class="code">for</pre> expression iterates through all solutions of placing <pre class="code">k</pre>&nbsp;<pre class="code">-</pre>&nbsp;<pre class="code">1</pre>
queens on the board. The second generator iterates through all
possible <pre class="code">column</pre>s on which the <pre class="code">k</pre>'th queen might be placed.  
The third part of the <pre class="code">for</pre> expression 
defines the newly considered <pre class="code">queen</pre> position to be the pair consisting of row
<pre class="code">k</pre> and each produced <pre class="code">column</pre>.
The fourth part of the <pre class="code">for</pre> expression is a filter which checks with
<pre class="code">isSafe</pre> whether the new queen is safe from check by all previous queens
(the definition of <pre class="code">isSafe</pre> will be discussed a bit later).</p>

<p>If the new queen is not in check from any other queens, it can form
part of a partial solution, so <pre class="code">placeQueens</pre> generates with 
<pre class="code">queen</pre>&nbsp;<pre class="code">::</pre>&nbsp;<pre class="code">queens</pre> a new solution. If the new queen is not safe from check,
the filter returns <pre class="code">false</pre>, so no solution is generated.</p>

<p>The only remaining bit is the <pre class="code">isSafe</pre> method, which is used to check whether a
given <pre class="code">queen</pre> is in check from any other element in a list of <pre class="code">queens</pre>. Here is its definition:</p>

<pre>
  <code class="vem">def</code>&nbsp;isSafe(queen:&nbsp;(<code class="typename">Int</code>,&nbsp;<code class="typename">Int</code>),&nbsp;queens:&nbsp;<code class="typename">List[(Int,&nbsp;Int)]</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;queens&nbsp;forall&nbsp;(q&nbsp;=&gt;&nbsp;!inCheck(queen,&nbsp;q))
  <br />  <code class="vem">def</code>&nbsp;inCheck(q1:&nbsp;(<code class="typename">Int</code>,&nbsp;<code class="typename">Int</code>),&nbsp;q2:&nbsp;(<code class="typename">Int</code>,&nbsp;<code class="typename">Int</code>))&nbsp;=&nbsp;
  &nbsp;&nbsp;q1._1&nbsp;==&nbsp;q2._1&nbsp;||&nbsp;&nbsp;<code class="comment">//&nbsp;same&nbsp;row</code>
  &nbsp;&nbsp;q1._2&nbsp;==&nbsp;q2._2&nbsp;||&nbsp;&nbsp;<code class="comment">//&nbsp;same&nbsp;column</code>
  &nbsp;&nbsp;(q1._1&nbsp;-&nbsp;q2._1).abs&nbsp;==&nbsp;(q1._2&nbsp;-&nbsp;q2._2).abs&nbsp;<code class="comment">//&nbsp;on&nbsp;diagonal</code>
</pre>


<p>The <pre class="code">isSafe</pre> method expresses that a <pre class="code">queen</pre> is safe with respect to some other <pre class="code">queens</pre> if 
it is not in check from any other queen. The <pre class="code">inCheck</pre> method expresses that
queens <pre class="code">q1</pre> and <pre class="code">q2</pre> are mutually in check.</p>

<p>It returns <pre class="code">true</pre> in one of three cases:</p>

<ol>


<li>If the two queens have the same row coordinate, 


</li>
<li>If the two queens have the same column coordinate, 


</li>
<li>If the two queens are on the same diagonal (<i>i.e.</i>, the difference between their rows and the difference between their columns are the same).


</li></ol>


<p>The first case&mdash;that the two queens have the same row coordinate&mdash;cannot happen in the application because <pre class="code">placeQueens</pre> already takes
care to place each queen in a different row.  So you could remove the
test without changing the functionality of the program.</p>

<h3 id="sec-for-queries">23.3 Querying with <pre class="code">for</pre> expressions</h3>


<p>The <pre class="code">for</pre> notation is essentially equivalent to common operations of
database query languages<a id="i1851175608-1"/>. For instance, say you are given a 
database named <pre class="code">books</pre>, represented as a list of books, where
<pre class="code">Book</pre> is defined as follows:</p>

<pre>
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Book</code>(title:&nbsp;<code class="typename">String</code>,&nbsp;authors:&nbsp;<code class="typename">String</code>*)
</pre>


<p>Here is a small example database represented as an in-memory
list:<a id="i471924076-2"/><a id="i-1712702061-2"/><a id="i1109104818-1"/><a id="i-601321358-1"/><a id="i134333723-1"/><a id="i875843663-1"/><a id="i1916394333-2"/><a id="i-1202190098-1"/><a id="i1512661551-2"/></p>

<pre>
  <code class="vem">val</code>&nbsp;books:&nbsp;<code class="typename">List[Book]</code>&nbsp;=
  &nbsp;&nbsp;<code class="typename">List</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Book</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Structure&nbsp;and&nbsp;Interpretation&nbsp;of&nbsp;Computer&nbsp;Programs"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Abelson,&nbsp;Harold"</code>,&nbsp;<code class="quotedstring">"Sussman,&nbsp;Gerald&nbsp;J."</code>
  &nbsp;&nbsp;&nbsp;&nbsp;),
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Book</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Principles&nbsp;of&nbsp;Compiler&nbsp;Design"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Aho,&nbsp;Alfred"</code>,&nbsp;<code class="quotedstring">"Ullman,&nbsp;Jeffrey"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;),
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Book</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Programming&nbsp;in&nbsp;Modula-2"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Wirth,&nbsp;Niklaus"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;),
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Book</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Elements&nbsp;of&nbsp;ML&nbsp;Programming"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Ullman,&nbsp;Jeffrey"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;),
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Book</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"The&nbsp;Java&nbsp;Language&nbsp;Specification"</code>,&nbsp;<code class="quotedstring">"Gosling,&nbsp;James"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Joy,&nbsp;Bill"</code>,&nbsp;<code class="quotedstring">"Steele,&nbsp;Guy"</code>,&nbsp;<code class="quotedstring">"Bracha,&nbsp;Gilad"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;)
</pre>


<p>To find the titles of all books whose author's last name is "Gosling":</p>

<pre>
  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(b&nbsp;&lt;-&nbsp;books;&nbsp;a&nbsp;&lt;-&nbsp;b.authors
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;a&nbsp;startsWith&nbsp;<code class="quotedstring">"Gosling"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;b.title
  <code class="output">res4:&nbsp;List[String]&nbsp;=&nbsp;List(The&nbsp;Java&nbsp;Language&nbsp;Specification)</code>
</pre>


<p>Or to find the titles of all books that have the string "Program" in
their title:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(b&nbsp;&lt;-&nbsp;books&nbsp;<code class="vem">if</code>&nbsp;(b.title&nbsp;indexOf&nbsp;<code class="quotedstring">"Program"</code>)&nbsp;&gt;=&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;b.title
  <code class="output">res5:&nbsp;List[String]&nbsp;=&nbsp;List(Structure&nbsp;and&nbsp;Interpretation&nbsp;of&nbsp;</code>
  <code class="output">&nbsp;&nbsp;Computer&nbsp;Programs,&nbsp;Programming&nbsp;in&nbsp;Modula-2,&nbsp;Elements&nbsp;of&nbsp;ML&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Programming)</code>
</pre>


<p>Or to find the names of all authors who have written at least two
books in the database:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(b1&nbsp;&lt;-&nbsp;books;&nbsp;b2&nbsp;&lt;-&nbsp;books&nbsp;<code class="vem">if</code>&nbsp;b1&nbsp;!=&nbsp;b2;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a1&nbsp;&lt;-&nbsp;b1.authors;&nbsp;a2&nbsp;&lt;-&nbsp;b2.authors&nbsp;<code class="vem">if</code>&nbsp;a1&nbsp;==&nbsp;a2)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;a1
  <code class="output">res6:&nbsp;List[String]&nbsp;=&nbsp;List(Ullman,&nbsp;Jeffrey,&nbsp;Ullman,&nbsp;Jeffrey)</code>
</pre>


<p>The last solution is still not perfect because authors will appear
several times in the list of results.  You still need to remove
duplicate authors from result lists.  This can be achieved with the
following function:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;removeDuplicates[A](xs:&nbsp;<code class="typename">List[A]</code>):&nbsp;<code class="typename">List[A]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(xs.isEmpty)&nbsp;xs
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xs.head&nbsp;::&nbsp;removeDuplicates(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xs.tail&nbsp;filter&nbsp;(x&nbsp;=&gt;&nbsp;x&nbsp;!=&nbsp;xs.head)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">removeDuplicates:&nbsp;[A](xs:&nbsp;List[A])List[A]</code>
  <br />  scala&gt;&nbsp;removeDuplicates(res6)
  <code class="output">res7:&nbsp;List[String]&nbsp;=&nbsp;List(Ullman,&nbsp;Jeffrey)</code>
</pre>


<p>It's worth noting that the last expression in method <pre class="code">removeDuplicates</pre>
can be equivalently expressed using a <pre class="code">for</pre> expression:</p>

<pre>
  xs.head&nbsp;::&nbsp;removeDuplicates(
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(x&nbsp;&lt;-&nbsp;xs.tail&nbsp;<code class="vem">if</code>&nbsp;x&nbsp;!=&nbsp;xs.head)&nbsp;<code class="vem">yield</code>&nbsp;x
  )
</pre>


<h3>23.4 Translation of <pre class="code">for</pre> expressions</h3>


<p>Every <pre class="code">for</pre> expression can be expressed in terms of the three
higher-order functions <pre class="code">map</pre>, <pre class="code">flatMap</pre>, and <pre class="code">withFilter</pre>.
This section describes the translation scheme, which is also used by the Scala compiler.</p>

<h4>Translating <pre class="code">for</pre> expressions with one generator</h4>


<p>First, assume you have a simple <pre class="code">for</pre> expression:</p>

<pre>
  <code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>
</pre>


<p>where <i>x</i> is a variable. Such an expression is translated to:</p>

<pre>
  <code style="font-style:italic">expr</code><sub>1</sub>.map(<i>x</i>&nbsp;=&gt;&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>)
</pre>


<h4>Translating <pre class="code">for</pre> expressions starting with a generator and a filter</h4>


<p>Now, consider <pre class="code">for</pre> expressions that combine a leading generator with some other
elements. A <pre class="code">for</pre> expression of the form:</p>

<pre>
  <code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>&nbsp;<code class="vem">if</code>&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>
</pre>


<p>is translated to:</p>

<pre>
  <code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>&nbsp;withFilter&nbsp;(<i>x</i>&nbsp;=&gt;&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>))&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>
</pre>


<p>This translation gives another <pre class="code">for</pre> expression that is  
shorter by one element than the original, because an <pre class="code">if</pre> 
element is transformed into an application of <pre class="code">withFilter</pre> on the first
generator expression. The translation then continues with this second expression, 
so in the end you obtain:</p>

<pre>
  <code style="font-style:italic">expr</code><sub>1</sub>&nbsp;withFilter&nbsp;(<i>x</i>&nbsp;=&gt;&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>)&nbsp;map&nbsp;(<i>x</i>&nbsp;=&gt;&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>)
</pre>


<p>The same translation scheme also applies if there are further elements 
following the filter. If <span style="font-style:italic">seq</span> is an arbitrary sequence of generators,
definitions, and filters, then:</p>

<pre>
  <code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>&nbsp;<code class="vem">if</code>&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>;&nbsp;<code style="font-style:italic">seq</code>)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>
</pre>


<p>is translated to:</p>

<pre>
  <code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>&nbsp;withFilter&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>;&nbsp;<code style="font-style:italic">seq</code>)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>
</pre>


<p>Then translation continues with the second expression, which is again shorter
by one element than the original one.</p>

<h4>Translating <pre class="code">for</pre> expressions starting with two generators</h4>


<p>The next case handles <pre class="code">for</pre> expressions that start with two generators, as in:</p>

<pre>
  <code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>;&nbsp;<i>y</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>;&nbsp;<code style="font-style:italic">seq</code>)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>
</pre>


<p>Again, assume that <span style="font-style:italic">seq</span> is an arbitrary sequence of
generators, definitions, and filters. In fact, <span style="font-style:italic">seq</span> might also be
empty, and in that case there would not be a semicolon after
<span class="code"><span style="font-style:italic">expr</span><sub>2</sub></span>. The translation scheme stays the same in each case. The 
<pre class="code">for</pre> expression above is translated to an application of <pre class="code">flatMap</pre>:</p>

<pre>
  <code style="font-style:italic">expr</code><sub>1</sub>.flatMap(<i>x</i>&nbsp;=&gt;&nbsp;<code class="vem">for</code>&nbsp;(<i>y</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>;&nbsp;<code style="font-style:italic">seq</code>)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>)
</pre>


<p>This time, there is another <pre class="code">for</pre> expression in the function value passed to <pre class="code">flatMap</pre>.
That <pre class="code">for</pre> expression (which is again simpler by one element than the original)
is in turn translated with the same rules.</p>

<p>The three translation schemes given so far are sufficient to translate
all <pre class="code">for</pre> expressions that contain just generators and filters, and
where generators bind only simple variables. Take, for instance, the query, "find all authors 
who have published at least two books," from <a href="for-expressions-revisited.html#sec-for-queries">Section 23.3</a>:</p>

<pre>
  <code class="vem">for</code>&nbsp;(b1&nbsp;&lt;-&nbsp;books;&nbsp;b2&nbsp;&lt;-&nbsp;books&nbsp;<code class="vem">if</code>&nbsp;b1&nbsp;!=&nbsp;b2;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a1&nbsp;&lt;-&nbsp;b1.authors;&nbsp;a2&nbsp;&lt;-&nbsp;b2.authors&nbsp;<code class="vem">if</code>&nbsp;a1&nbsp;==&nbsp;a2)
  <code class="vem">yield</code>&nbsp;a1
</pre>


<p>This query translates to the following <pre class="code">map</pre>/<pre class="code">flatMap</pre>/<pre class="code">filter</pre> combination:</p>

<pre>
  books&nbsp;flatMap&nbsp;(b1&nbsp;=&gt;
  &nbsp;&nbsp;books&nbsp;withFilter&nbsp;(b2&nbsp;=&gt;&nbsp;b1&nbsp;!=&nbsp;b2)&nbsp;flatMap&nbsp;(b2&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;b1.authors&nbsp;flatMap&nbsp;(a1&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b2.authors&nbsp;withFilter&nbsp;(a2&nbsp;=&gt;&nbsp;a1&nbsp;==&nbsp;a2)&nbsp;map&nbsp;(a2&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a1))))
</pre>


<p>The translation scheme presented so far does not yet handle generators
that bind whole patterns instead of simple variables.  It also
does not yet cover definitions. These two aspects will be explained in
the next two sub-sections.</p>

<h4>Translating patterns in generators</h4>


<p>The translation scheme becomes more complicated if the left hand side
of generator is a pattern, <span style="font-style:italic">pat</span>, other than a simple variable. The case where the <pre class="code">for</pre> expression binds a tuple of
variables is still relatively easy to handle. In that case, almost the same scheme as for single variables applies.</p>

<p>A <pre class="code">for</pre> expression of the form:</p>

<pre>
  <code class="vem">for</code>&nbsp;((<i>x</i><sub>1</sub>,&nbsp;...,&nbsp;<i>x</i><sub>n</sub>)&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>
</pre>


<p>translates to:</p>

<pre>
  <code style="font-style:italic">expr</code><sub>1</sub>.map&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;(<i>x</i><sub>1</sub>,&nbsp;...,&nbsp;<i>x</i><sub>n</sub>)&nbsp;=&gt;&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>&nbsp;}
</pre>


<p>Things become a bit more involved if the left hand side of the generator
is an arbitrary pattern <span style="font-style:italic">pat</span> instead of a single variable or a tuple.</p>

<p>In this case:</p>

<pre>
  <code class="vem">for</code>&nbsp;(<code style="font-style:italic">pat</code>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>
</pre>


<p>translates to:</p>

<pre>
  <code style="font-style:italic">expr</code><sub>1</sub>&nbsp;withFilter&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code style="font-style:italic">pat</code>&nbsp;=&gt;&nbsp;<code class="vem">true</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  }&nbsp;map&nbsp;{&nbsp;
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code style="font-style:italic">pat</code>&nbsp;=&gt;&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>
  }
</pre>


<p>That is, the generated items are first filtered and
only those that match <span style="font-style:italic">pat</span> are mapped. Therefore, it's guaranteed
that a pattern-matching generator will never throw a <pre class="code">MatchError</pre>.<a id="i797126047-2"/></p>

<p>The scheme here only treated the case where the <pre class="code">for</pre> expression
contains a single pattern-matching generator. Analogous rules apply if
the <pre class="code">for</pre> expression contains other generators, filters or
definitions. Because these additional rules don't add much new
insight, they are omitted from discussion here. If you are interested,
you can look them up in the <em>Scala Language Specification</em>  <a href="bibliography.html#sls">[Ode11]</a>.</p>

<h4>Translating definitions</h4>


<p>The last missing situation is where a <pre class="code">for</pre> expression contains embedded
definitions.  Here's a typical case:</p>

<pre>
  <code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>;&nbsp;<i>y</i>&nbsp;=&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>;&nbsp;<code style="font-style:italic">seq</code>)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>
</pre>


<p>Assume again that <span style="font-style:italic">seq</span> is a (possibly empty) sequence of generators, definitions, and filters.
This expression is translated to this one:</p>

<pre>
  <code class="vem">for</code>&nbsp;((<i>x</i>,&nbsp;<i>y</i>)&nbsp;&lt;-&nbsp;<code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>)&nbsp;<code class="vem">yield</code>&nbsp;(<i>x</i>,&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>);&nbsp;<code style="font-style:italic">seq</code>)&nbsp;
  <code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>
</pre>


<p>So you see that <span class="code"><span style="font-style:italic">expr</span><sub>2</sub></span> is evaluated each time there is a new <i>x</i> value being generated.
This re-evaluation is necessary because <span class="code"><span style="font-style:italic">expr</span><sub>2</sub></span> might refer to <i>x</i> and so needs
to be re-evaluated for changing values of <i>x</i>. For you as a programmer,
the conclusion is that it's probably not a good idea to have definitions
embedded in <pre class="code">for</pre> expressions that do not refer to variables bound by some 
preceding generator, because re-evaluating such expressions would be wasteful.
For instance, instead of:</p>

<pre>
  <code class="vem">for</code>&nbsp;(x&nbsp;&lt;-&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">1000</code>;&nbsp;y&nbsp;=&nbsp;expensiveComputationNotInvolvingX)
  <code class="vem">yield</code>&nbsp;x&nbsp;*&nbsp;y
</pre>


<p>it's usually better to write:</p>

<pre>
  <code class="vem">val</code>&nbsp;y&nbsp;=&nbsp;expensiveComputationNotInvolvingX
  <code class="vem">for</code>&nbsp;(x&nbsp;&lt;-&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">1000</code>)&nbsp;<code class="vem">yield</code>&nbsp;x&nbsp;*&nbsp;y
</pre>


<h4>Translating <pre class="code">for</pre> loops</h4>


<p>The previous subsections showed how <pre class="code">for</pre> expressions that
contain a <pre class="code">yield</pre> are translated.<a id="i-382847944-1"/> What about <pre class="code">for</pre> loops that simply
perform a side effect without returning anything? Their translation is
similar, but simpler than <pre class="code">for</pre> expressions. In principle, wherever the
previous translation scheme used a <pre class="code">map</pre> or a <pre class="code">flatMap</pre> in the
translation, the translation scheme for <pre class="code">for</pre> loops uses just a <pre class="code">foreach</pre>.</p>

<p>For instance, the expression:</p>

<pre>
  <code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>)&nbsp;<code style="font-style:italic">body</code>
</pre>


<p>translates to:</p>

<pre>
  <code style="font-style:italic">expr</code><sub>1</sub>&nbsp;foreach&nbsp;(<i>x</i>&nbsp;=&gt;&nbsp;<code style="font-style:italic">body</code>)
</pre>


<p>A larger example is the expression:</p>

<pre>
  <code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>;&nbsp;<code class="vem">if</code>&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>;&nbsp;<i>y</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>)&nbsp;<code style="font-style:italic">body</code>
</pre>


<p>This expression translates to:</p>

<pre>
  <code style="font-style:italic">expr</code><sub>1</sub>&nbsp;withFilter&nbsp;(<i>x</i>&nbsp;=&gt;&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>)&nbsp;foreach&nbsp;(<i>x</i>&nbsp;=&gt;
  &nbsp;&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>&nbsp;foreach&nbsp;(<i>y</i>&nbsp;=&gt;&nbsp;<code style="font-style:italic">body</code>))
</pre>


<p>For example, the following expression sums up all elements of a
matrix represented as a list of lists:</p>

<pre>
  <code class="vem">var</code>&nbsp;sum&nbsp;=&nbsp;<code class="literal">0</code>
  <code class="vem">for</code>&nbsp;(xs&nbsp;&lt;-&nbsp;xss;&nbsp;x&nbsp;&lt;-&nbsp;xs)&nbsp;sum&nbsp;+=&nbsp;x
</pre>


<p>This loop is translated into two nested <pre class="code">foreach</pre> applications:</p>

<pre>
  <code class="vem">var</code>&nbsp;sum&nbsp;=&nbsp;<code class="literal">0</code>
  xss&nbsp;foreach&nbsp;(xs&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;xs&nbsp;foreach&nbsp;(x&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;x))
</pre>


<h3>23.5 Going the other way</h3>


<p>The previous section showed that <pre class="code">for</pre> expressions can be translated
into applications of the higher-order functions <pre class="code">map</pre>, <pre class="code">flatMap</pre>,
and <pre class="code">withFilter</pre>.  In fact, you could equally go the other way:
Every application of a <pre class="code">map</pre>, <pre class="code">flatMap</pre>, or <pre class="code">filter</pre> 
can be represented as a <pre class="code">for</pre> expression.</p>

<p>Here are implementations of
the three methods in terms of <pre class="code">for</pre> expressions. The methods are contained
in an object <pre class="code">Demo</pre> to distinguish them from the standard operations
on <pre class="code">List</pre>s. To be concrete, the three functions all take a <pre class="code">List</pre> as parameter, but the translation
scheme would work just as well with other collection types:</p>

<pre>
  <code class="vem">object</code>&nbsp;<code class="typename">Demo</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;map[A,&nbsp;B](xs:&nbsp;<code class="typename">List[A]</code>,&nbsp;f:&nbsp;A&nbsp;=&gt;&nbsp;B):&nbsp;<code class="typename">List[B]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(x&nbsp;&lt;-&nbsp;xs)&nbsp;<code class="vem">yield</code>&nbsp;f(x)
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;flatMap[A,&nbsp;B](xs:&nbsp;<code class="typename">List[A]</code>,&nbsp;f:&nbsp;A&nbsp;=&gt;&nbsp;<code class="typename">List[B]</code>):&nbsp;<code class="typename">List[B]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(x&nbsp;&lt;-&nbsp;xs;&nbsp;y&nbsp;&lt;-&nbsp;f(x))&nbsp;<code class="vem">yield</code>&nbsp;y
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;filter[A](xs:&nbsp;<code class="typename">List[A]</code>,&nbsp;p:&nbsp;A&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>):&nbsp;<code class="typename">List[A]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(x&nbsp;&lt;-&nbsp;xs&nbsp;<code class="vem">if</code>&nbsp;p(x))&nbsp;<code class="vem">yield</code>&nbsp;x
  }
</pre>


<p>Not surprisingly, the translation of the <pre class="code">for</pre> expression used in the body of
<pre class="code">Demo.map</pre> will produce a call to <pre class="code">map</pre> in class <pre class="code">List</pre>.
Similarly, <pre class="code">Demo.flatMap</pre> and <pre class="code">Demo.filter</pre> translate to
<pre class="code">flatMap</pre> and <pre class="code">withFilter</pre> in class <pre class="code">List</pre>. So this little demonstration shows that <pre class="code">for</pre> expressions really are
equivalent in their expressiveness to applications of the three
functions <pre class="code">map</pre>, <pre class="code">flatMap</pre>, and <pre class="code">withFilter</pre>.</p>

<h3>23.6 Generalizing <pre class="code">for</pre></h3>


<p>Because the translation of <pre class="code">for</pre> expressions only relies on
the presence of methods <pre class="code">map</pre>, <pre class="code">flatMap</pre>, and
<pre class="code">withFilter</pre>, it is possible to apply the <pre class="code">for</pre> notation 
to a large class of data types.</p>

<p>You have already seen <pre class="code">for</pre> expressions over lists and arrays.  These
are supported because lists, as well as arrays, define operations
<pre class="code">map</pre>, <pre class="code">flatMap</pre>, and <pre class="code">withFilter</pre>. Because they define a <pre class="code">foreach</pre> method as well, <pre class="code">for</pre> loops
over these data types are also possible.</p>

<p>Besides lists and arrays, there are many other types in the Scala
standard library that support the same four methods and therefore
allow <pre class="code">for</pre> expressions. Examples are ranges, iterators, streams, and
all implementations of sets.<a id="i2076162232-1"/> It's also perfectly possible for your own
data types to support <pre class="code">for</pre> expressions by defining the necessary
methods. To support the full range of <pre class="code">for</pre> expressions and <pre class="code">for</pre> loops,
you need to define <pre class="code">map</pre>, <pre class="code">flatMap</pre>, <pre class="code">withFilter</pre>, and <pre class="code">foreach</pre> as
methods of your data type. But it's also possible to define a subset
of these methods, and thereby support a subset of all possible
<pre class="code">for</pre> expressions or loops.</p>

<p>Here are the precise rules:</p>

<ul>


<li>
If your type defines just <pre class="code">map</pre>, it allows <pre class="code">for</pre> expressions 
consisting of a single generator.


</li>
<li>
If it defines <pre class="code">flatMap</pre> as well as <pre class="code">map</pre>, it allows <pre class="code">for</pre> expressions
consisting of several generators.


</li>
<li>
If it defines <pre class="code">foreach</pre>, it allows <pre class="code">for</pre> loops (both with single and multiple generators).


</li>
<li>
If it defines <pre class="code">withFilter</pre>, it allows for 
filter expressions starting with an <pre class="code">if</pre> in
the <pre class="code">for</pre> expression.


</li></ul>


<p>The translation of <pre class="code">for</pre> expressions happens before type
checking.<a id="i-1430360982-1"/><a id="i746576009-1"/> This
allows for maximum flexibility because the only requirement is that the
result of expanding a <pre class="code">for</pre> expression type checks. Scala defines no
typing rules for the <pre class="code">for</pre> expressions themselves, and does not require that methods
<pre class="code">map</pre>, <pre class="code">flatMap</pre>, <pre class="code">withFilter</pre>, or <pre class="code">foreach</pre> have any particular
type signatures.</p>

<p>Nevertheless, there is a typical setup that captures the most
common intention of the higher order methods to which <pre class="code">for</pre> expressions translate. 
Say you have a
parameterized class, <pre class="code">C</pre>, which typically would stand for some sort of
collection. Then it's quite natural to pick the following type signatures 
for <pre class="code">map</pre>, <pre class="code">flatMap</pre>, <pre class="code">withFilter</pre>, and <pre class="code">foreach</pre>:</p>

<pre>
  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;C[A]&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;map[B](f:&nbsp;A&nbsp;=&gt;&nbsp;B):&nbsp;C[B]
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;flatMap[B](f:&nbsp;A&nbsp;=&gt;&nbsp;C[B]):&nbsp;C[B]
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;withFilter(p:&nbsp;A&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>):&nbsp;C[A]
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;foreach(b:&nbsp;A&nbsp;=&gt;&nbsp;<code class="typename">Unit</code>):&nbsp;<code class="typename">Unit</code>
  }
</pre>


<p>That is, the <pre class="code">map</pre> function takes a function from the collection's
element type <pre class="code">A</pre> to some other type <pre class="code">B</pre>. It produces a new
collection of the same kind <pre class="code">C</pre>, but with <pre class="code">B</pre> as the element type.
The <pre class="code">flatMap</pre> method takes a function <pre class="code">f</pre> from <pre class="code">A</pre> to some
<pre class="code">C</pre>-collection of <pre class="code">B</pre>s and produces a <pre class="code">C</pre>-collection of
<pre class="code">B</pre>s.  The <pre class="code">withFilter</pre> method takes a predicate function from the
collection's element type <pre class="code">A</pre> to <pre class="code">Boolean</pre>. It produces a collection
of the same type as the one on which it is invoked.  Finally, the
<pre class="code">foreach</pre> method takes a function from <pre class="code">A</pre> to <pre class="code">Unit</pre> and produces
a <pre class="code">Unit</pre> result:</p>

<p>In class <pre class="code">C</pre> above, the <pre class="code">withFilter</pre> method produces a new
collection of the same class. That means that every invocation of
<pre class="code">withFilter</pre> creates a new <pre class="code">C</pre> object, just the same as <pre class="code">filter</pre>
would work. Now, in the translation of for expressions, any calls to
<pre class="code">withFilter</pre> are always followed by calls to one of the other three
methods. Therefore, the object created by <pre class="code">withFilter</pre> will be
taken apart by one of the other methods immediately afterwards. If
objects of class <pre class="code">C</pre> are large (think long sequences), you might want
to avoid the creation of such an intermediate object. A standard
technique is to let <pre class="code">withFilter</pre> return not a <pre class="code">C</pre> object but just a
wrapper object that "remembers" that elements need to be filtered
before being processed further.</p>

<p>Concentrating on just the first three functions of class <pre class="code">C</pre>, the
following facts are noteworthy. In functional programming, there's a
general concept called a <span style="font-style:italic">monad</span>, which can explain a large number
of types with computations, ranging from collections, to computations
with state and I/O, backtracking computations, and transactions, to
name a few.<a id="i-1068505564-1"/> You can formulate functions <pre class="code">map</pre>,
<pre class="code">flatMap</pre>, and <pre class="code">withFilter</pre> on a monad, and, if you do, they end up
having exactly the types given here.</p>

<p>Furthermore, you can
characterize every monad by <pre class="code">map</pre>, <pre class="code">flatMap</pre>, and <pre class="code">withFilter</pre>,
plus a "unit" constructor that produces a monad from an element
value. In an object-oriented language, this "unit" constructor is
simply an instance constructor or a factory method.  Therefore,
<pre class="code">map</pre>, <pre class="code">flatMap</pre>, and <pre class="code">withFilter</pre> can be seen as an object-oriented
version of the functional concept of monad.  Because <pre class="code">for</pre>
expressions are equivalent to applications of these three methods,
they can be seen as syntax for monads.</p>

<p>All this suggests that the concept of <pre class="code">for</pre> expression is more
general than just iteration over a collection, and indeed it is. For
instance, <pre class="code">for</pre> expressions also play an important role in asynchronous
I/O, or as an alternative notation for optional values.
Watch out in the Scala libraries for occurrences of <pre class="code">map</pre>,
<pre class="code">flatMap</pre>, and <pre class="code">withFilter</pre>&mdash;when they are present,
<pre class="code">for</pre> expressions suggest themselves as a concise way of manipulating
elements of the type.</p>

<h3>23.7 Conclusion</h3>


<p>In this chapter, you were given a peek under the hood of
<pre class="code">for</pre> expressions and <pre class="code">for</pre> loops. You learned that they translate
into applications of a standard set of higher-order methods. As a
result, you saw that <pre class="code">for</pre> expressions are really
much more general than mere iterations over collections, and that you
can design your own classes to support them.</p>

<div style="page-break-after:always"/>


<div style="page-break-after:always"/>

</body>
</html>
