<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8"/>
    <title>Programming in Scala, 3rd Edition</title>

    <link rel="stylesheet" type="text/css" href="book.css" />
  </head>
<body>
<h2><a id="chap-working-with-other-collections">Chapter 17</a></h2>
<h1>Working with Other Collections</h1>


<p>Scala has a rich collection library. This chapter gives you a tour of the
most commonly used collection types and operations, showing just the
parts you will use most frequently.  <a href="collections-in-depth.html">Chapter 24</a>
will provide a more comprehensive tour of what's available, and
<a href="the-architecture-of-scala-collections.html">Chapter 25</a> will show how Scala's composition constructs
are used to provide such a rich API.
<a id="i1853891989-1"/></p>

<h3 id="sec-sequences">17.1 Sequences</h3>


<p>Sequence types let you work with groups of data lined up in order.
Because the elements are ordered, you can ask for the first element,
second element, 103rd element, and so on.  In this section, we'll give
you a quick tour of the most important sequences.</p>

<h4>Lists</h4>


<p>Perhaps the most important sequence type to know about
is class <pre class="code">List</pre>,<a id="i882498454-2"/>
the immutable linked-list described in detail in the previous chapter.
Lists support fast addition and
removal of items to the beginning of the list, but they do not
provide fast access to arbitrary indexes because the <a id="i-394736131-1"/>
implementation must iterate through the list linearly.</p>

<p>This combination of features might sound odd, but they hit a sweet
spot that works well for many algorithms.  The fast addition and
removal of initial elements means that pattern matching works well, as
described in <a href="case-classes-and-pattern-matching.html">Chapter 15</a>.
The immutability of lists helps you develop correct,
efficient algorithms because you never need to make copies of a list.</p>

<p>Here's a short example showing how to initialize a list, and access its head and tail:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;colors&nbsp;=&nbsp;<code class="typename">List</code>(<code class="quotedstring">"red"</code>,&nbsp;<code class="quotedstring">"blue"</code>,&nbsp;<code class="quotedstring">"green"</code>)
  <code class="output">colors:&nbsp;List[String]&nbsp;=&nbsp;List(red,&nbsp;blue,&nbsp;green)</code>
  <br />  scala&gt;&nbsp;colors.head
  <code class="output">res0:&nbsp;String&nbsp;=&nbsp;red</code>
  <br />  scala&gt;&nbsp;colors.tail
  <code class="output">res1:&nbsp;List[String]&nbsp;=&nbsp;List(blue,&nbsp;green)</code>
</pre>


<p>For a refresher on lists, see <a href="next-steps-in-scala.html#step8">Step 8</a> in <a href="next-steps-in-scala.html">Chapter 3</a>. You can find details on using lists in <a href="working-with-lists.html">Chapter 16</a>. Lists
will also be discussed in <a href="implementing-lists.html">Chapter 22</a>, which provides insight into how lists
are implemented in Scala.</p>

<h4>Arrays</h4>


<p>Arrays allow you to hold
a sequence of elements and efficiently access an element at an arbitrary position,<a id="i341425106-2"/>
 either to get or update the element, with a zero-based
index.<a id="i-1409164998-2"/><a id="i916713681-1"/>  Here's how you create an array whose size you know, but for which you don't yet know
the element values:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fiveInts&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[Int]</code>(<code class="literal">5</code>)
  <code class="output">fiveInts:&nbsp;Array[Int]&nbsp;=&nbsp;Array(0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0)</code>
</pre>


<p>Here's how you initialize an array when you do know the element values:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fiveToOne&nbsp;=&nbsp;<code class="typename">Array</code>(<code class="literal">5</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">1</code>)
  <code class="output">fiveToOne:&nbsp;Array[Int]&nbsp;=&nbsp;Array(5,&nbsp;4,&nbsp;3,&nbsp;2,&nbsp;1)</code>
</pre>


<p>As mentioned previously, arrays are accessed in Scala by placing an index in parentheses, not square brackets as in Java.
Here's an example of both accessing and updating an array element:</p>

<pre>
  scala&gt;&nbsp;fiveInts(<code class="literal">0</code>)&nbsp;=&nbsp;fiveToOne(<code class="literal">4</code>)
  <br />  scala&gt;&nbsp;fiveInts
  <code class="output">res3:&nbsp;Array[Int]&nbsp;=&nbsp;Array(1,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0)</code>
</pre>


<p>Scala arrays are represented in the same way as Java arrays.  So, you can seamlessly use
existing Java methods that return arrays.<a href="working-with-other-collections.html#footnotemain17-1">[1]</a></p>

<p>You have seen arrays in action many times in previous chapters.
The basics are in <a href="next-steps-in-scala.html#step7">Step 7</a> in <a href="next-steps-in-scala.html">Chapter 3</a>.
Several examples of iterating through the elements of an array with a <pre class="code">for</pre> expression are shown
in <a href="builtin-control-structures.html#sec-for-expressions">Section 7.3</a>. Arrays also figure prominently in the two-dimensional layout library
of <a href="composition-and-inheritance.html">Chapter 10</a>.</p>

<h4>List buffers</h4>


<p><a id="sec-collections-listbuf"/></p>

<p>Class <pre class="code">List</pre> provides fast access to the head of the list, but not the end. Thus, when you need to
build a list by appending to the end, consider building the list backwards by prepending elements
to the front. Then when you're done, call <pre class="code">reverse</pre> to get the elements in the order you need.</p>

<p>Another alternative, which avoids the <pre class="code">reverse</pre> operation, is to use a
<pre class="code">ListBuffer</pre>.<a id="i-1815843466-2"/>
A <pre class="code">ListBuffer</pre> is a mutable object (contained in package <pre class="code">scala.collection.mutable</pre>), which can<a id="i-737429794-1"/>
help you build lists more efficiently when you need to append. <pre class="code">ListBuffer</pre> provides constant time append and prepend
operations. You append elements with the <pre class="code">+=</pre>
operator,<a id="i714754650-1"/> and prepend
them with the <pre class="code">+=:</pre> operator.<a id="i35509127-1"/>
When you're done building, you can obtain
a <pre class="code">List</pre> by invoking <pre class="code">toList</pre><a id="i-330065859-1"/> on the <pre class="code">ListBuffer</pre>. Here's an example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.mutable.ListBuffer
  <code class="output">import&nbsp;scala.collection.mutable.ListBuffer</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ListBuffer[Int]</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">buf:&nbsp;scala.collection.mutable.ListBuffer[Int]&nbsp;=&nbsp;ListBuffer()</code>
  <br />  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">1</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">res4:&nbsp;buf.type&nbsp;=&nbsp;ListBuffer(1)</code>
  <br />  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">2</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">res5:&nbsp;buf.type&nbsp;=&nbsp;ListBuffer(1,&nbsp;2)</code>
  <br />  scala&gt;&nbsp;buf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">res6:&nbsp;scala.collection.mutable.ListBuffer[Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;ListBuffer(1,&nbsp;2)</code>
  <br />  scala&gt;&nbsp;<code class="literal">3</code>&nbsp;+=:&nbsp;buf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">res7:&nbsp;buf.type&nbsp;=&nbsp;ListBuffer(3,&nbsp;1,&nbsp;2)</code>
  <br />  scala&gt;&nbsp;buf.toList
  <code class="output">res8:&nbsp;List[Int]&nbsp;=&nbsp;List(3,&nbsp;1,&nbsp;2)</code>
</pre>


<p>Another reason to use <pre class="code">ListBuffer</pre> instead of <pre class="code">List</pre> is to prevent the potential for stack overflow.<a id="i-981382311-1"/>
If you can build a list in the desired order by prepending, but the recursive algorithm that would be required is
not tail recursive, you can use a <pre class="code">for</pre> expression or <pre class="code">while</pre> loop and a <pre class="code">ListBuffer</pre> instead.
You'll see <pre class="code">ListBuffer</pre> being used in this way in
<a href="implementing-lists.html#sec-the-listbuffer-class">Section 22.2</a>.</p>

<h4>Array buffers</h4>


<p><a id="sec-collections-arraybuf"/></p>

<p>An <pre class="code">ArrayBuffer</pre> is like an array,
except that you can additionally add and remove elements from the
beginning and end of the sequence<a id="i1906553817-1"/>.  All <pre class="code">Array</pre> operations are available,
though they are a little slower due to a layer of wrapping in the
implementation.  The new addition and removal operations are constant
time on average, but occasionally require linear time due to the
implementation needing to allocate a new array to hold the buffer's
contents.</p>

<p>To use an <pre class="code">ArrayBuffer</pre>, you must first import it from the mutable
collections package:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.mutable.ArrayBuffer
  <code class="output">import&nbsp;scala.collection.mutable.ArrayBuffer</code>
</pre>


<p>When you create an <pre class="code">ArrayBuffer</pre>, you must specify a type parameter, but you don't need
to specify a length.  The <pre class="code">ArrayBuffer</pre> will
adjust the allocated space automatically as needed:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrayBuffer[Int]</code>()
  <code class="output">buf:&nbsp;scala.collection.mutable.ArrayBuffer[Int]&nbsp;=&nbsp;</code>
  <code class="output">ArrayBuffer()</code>
</pre>


<p>You can append to an <pre class="code">ArrayBuffer</pre> using the <pre class="code">+=</pre> method:<a id="i-69907863-1"/></p>

<pre>
  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">12</code>
  <code class="output">res9:&nbsp;buf.type&nbsp;=&nbsp;ArrayBuffer(12)</code>
  <br />  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">15</code>
  <code class="output">res10:&nbsp;buf.type&nbsp;=&nbsp;ArrayBuffer(12,&nbsp;15)</code>
  <br />  scala&gt;&nbsp;buf
  <code class="output">res11:&nbsp;scala.collection.mutable.ArrayBuffer[Int]&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;ArrayBuffer(12,&nbsp;15)</code>
</pre>


<p>All the normal array methods are available.  For example,
you can ask an <pre class="code">ArrayBuffer</pre> its length or you can retrieve an element
by its index:</p>

<pre>
  scala&gt;&nbsp;buf.length
  <code class="output">res12:&nbsp;Int&nbsp;=&nbsp;2</code>
  <br />  scala&gt;&nbsp;buf(<code class="literal">0</code>)
  <code class="output">res13:&nbsp;Int&nbsp;=&nbsp;12</code>
</pre>


<h4>Strings (via <pre class="code">StringOps</pre>)</h4>


<p>One other sequence to be aware of is
<pre class="code">StringOps</pre>, which implements many sequence methods. Because <pre class="code">Predef</pre> has<a id="i1341725017-1"/>
an implicit conversion from <pre class="code">String</pre> to
<pre class="code">StringOps</pre><a id="i-1007334645-1"/>, you can treat any string like a sequence.
Here's an example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;hasUpperCase(s:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;s.exists(_.isUpper)
  <code class="output">hasUpperCase:&nbsp;(s:&nbsp;String)Boolean</code>
  <br />  scala&gt;&nbsp;hasUpperCase(<code class="quotedstring">"Robert&nbsp;Frost"</code>)
  <code class="output">res14:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br />  scala&gt;&nbsp;hasUpperCase(<code class="quotedstring">"e&nbsp;e&nbsp;cummings"</code>)
  <code class="output">res15:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>


<p>In this example, the <pre class="code">exists</pre><a id="i556038843-1"/> method is invoked on the string named <pre class="code">s</pre> in the <pre class="code">hasUpperCase</pre> method body. Because
no method named "<pre class="code">exists</pre>" is declared in class <pre class="code">String</pre> itself, the Scala compiler will implicitly convert 
<pre class="code">s</pre> to <pre class="code">StringOps</pre>, which has the method. The <pre class="code">exists</pre> method treats
the string as a sequence of characters, and will return true if any of the characters are upper case.<a href="working-with-other-collections.html#footnotemain17-2">[2]</a></p>

<h3 id="sec-sets-and-maps">17.2 Sets and maps</h3>


<p>You have already seen the basics of sets and maps in previous chapters, starting<a id="i3526737-2"/><a id="i3344023-2"/>
with <a href="next-steps-in-scala.html#step10">Step 10</a> in <a href="next-steps-in-scala.html">Chapter 3</a>.
In this section, we'll offer more insight into their use and show you a few more examples.</p>

<p>As mentioned previously, the Scala collections library offers both mutable and immutable versions
of sets and maps. The hierarchy for sets is shown in <a href="next-steps-in-scala.html#fig-set-hierarchy">Figure 3.2</a>  <a href="next-steps-in-scala.html#fig-set-hierarchy">here</a>,
and the hierarchy for maps is shown in <a href="next-steps-in-scala.html#fig-map-hierarchy">Figure 3.3</a>  <a href="next-steps-in-scala.html#fig-map-hierarchy">here</a>. As these
diagrams show, the simple names <pre class="code">Set</pre> and <pre class="code">Map</pre> are used by three traits each, residing in different packages.</p>

<p>By default when you write "<pre class="code">Set</pre>" or "<pre class="code">Map</pre>" you
get an immutable object. If you want the mutable variant, you need to
do an explicit import. Scala gives you easier access to the immutable variants, as a gentle encouragement
to prefer them over their mutable counterparts. The easy access is provided via the <pre class="code">Predef</pre> object, which is implicitly
imported into every Scala source file. <a href="working-with-other-collections.html#lst-predef-set-map">Listing 17.1</a> shows the relevant definitions:
<a id="lst-predef-set-map"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Predef</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">Map[A,&nbsp;+B]</code>&nbsp;=&nbsp;<code class="typename">collection.immutable.Map[A,&nbsp;B]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">Set[A]</code>&nbsp;=&nbsp;<code class="typename">collection.immutable.Set[A]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Map</code>&nbsp;=&nbsp;<code class="typename">collection.immutable.Map</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Set</code>&nbsp;=&nbsp;<code class="typename">collection.immutable.Set</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;...</code>
  &nbsp;&nbsp;}
</pre>


<h5>Listing 17.1 - Default map and set definitions in <pre class="code">Predef</pre>.</h5>


<p>The "<pre class="code">type</pre>" keyword<a id="i-1569140754-1"/> is used in <pre class="code">Predef</pre> to define <pre class="code">Set</pre>
and <pre class="code">Map</pre> as aliases for the longer fully qualified names of the immutable set and map traits.<a href="working-with-other-collections.html#footnotemain17-3">[3]</a>
The <pre class="code">val</pre>s named <pre class="code">Set</pre> and <pre class="code">Map</pre> are initialized to refer to the
singleton objects for the immutable <pre class="code">Set</pre> and <pre class="code">Map</pre>.
So <pre class="code">Map</pre> is the same as <pre class="code">Predef.Map</pre>, which is defined to be the same 
as <pre class="code">scala.collection.immutable.Map</pre>. This holds both for the <pre class="code">Map</pre> type and 
<pre class="code">Map</pre> object.</p>

<p>If you want to use both mutable and immutable sets or maps in the same source file,
one approach is to import the name of the package that contains the mutable variants:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.mutable
  <code class="output">import&nbsp;scala.collection.mutable</code>
</pre>


<p>You can continue to refer to the immutable set as <pre class="code">Set</pre>, as before, but can now refer to the mutable set
as <pre class="code">mutable.Set</pre>. Here's an example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;mutaSet&nbsp;=&nbsp;<code class="typename">mutable.Set</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">mutaSet:&nbsp;scala.collection.mutable.Set[Int]&nbsp;=&nbsp;Set(1,&nbsp;2,&nbsp;3)</code>
</pre>


<h4>Using sets</h4>


<p>The key characteristic of sets is that they will ensure that at most one of
each object, as determined by <pre class="code">==</pre><a id="i1401108821-1"/>, will be contained in the set at any one time.
As an example, we'll use a set to count the number of
different words in a string.</p>

<p>The <pre class="code">split</pre> method on <pre class="code">String</pre> can separate a
string into words<a id="i-456038910-1"/>, if you specify spaces and punctuation as word
separators.  The regular expression "<pre class="code">[</pre>&nbsp;<pre class="code">!,.]+</pre>" will suffice: It indicates
the string should be split at each place that one or more space and/or punctuation characters exist.</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;text&nbsp;=&nbsp;<code class="quotedstring">"See&nbsp;Spot&nbsp;run.&nbsp;Run,&nbsp;Spot.&nbsp;Run!"</code>
  <code class="output">text:&nbsp;String&nbsp;=&nbsp;See&nbsp;Spot&nbsp;run.&nbsp;Run,&nbsp;Spot.&nbsp;Run!</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;wordsArray&nbsp;=&nbsp;text.split(<code class="quotedstring">"[&nbsp;!,.]+"</code>)&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">wordsArray:&nbsp;Array[String]</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;Array(See,&nbsp;Spot,&nbsp;run,&nbsp;Run,&nbsp;Spot,&nbsp;Run)</code>
</pre>


<p>To count the distinct words, you can convert them to the same case and then add them to a set.
Because sets exclude duplicates, each distinct word will appear exactly
one time in the set.</p>

<p>First, you can create an empty set using the <pre class="code">empty</pre> method
provided on the <pre class="code">Set</pre> companion objects:<a id="i1582603163-1"/><a id="i1868251958-2"/></p>

<pre>
  scala&gt;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;words&nbsp;=&nbsp;mutable.Set.empty[<code class="typename">String</code>]
  <code class="output">words:&nbsp;scala.collection.mutable.Set[String]&nbsp;=&nbsp;Set()</code>
</pre>


<p>Then, just iterate through the words with a <pre class="code">for</pre> expression, convert each word
to lower case, and add it to the mutable set with the <pre class="code">+=</pre> operator:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(word&nbsp;&lt;-&nbsp;wordsArray)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;words&nbsp;+=&nbsp;word.toLowerCase
  <br />  scala&gt;&nbsp;words
  <code class="output">res17:&nbsp;scala.collection.mutable.Set[String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Set(see,&nbsp;run,&nbsp;spot)</code>
</pre>


<p>Thus, the text contained exactly three distinct words: spot, run, and see. The most commonly
used methods on both mutable and immutable sets are shown in <a href="working-with-other-collections.html#tab-set-operations">Table 17.1</a>.</p>

<p><a id="tab-set-operations"/></p>

<h5>Common operations for sets<a id="i51742212-1"/></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <pre class="code">val</pre>&nbsp;<pre class="code">nums</pre>&nbsp;<pre class="code">=</pre>&nbsp;<pre class="code">Set(1,</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">3)</pre>
  </td>
  <td>
    Creates an immutable set (<pre class="code">nums.toString</pre> returns <pre class="code">Set(1,</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">3)</pre>)
  </td>
</tr>
<tr>
  <td>
    <pre class="code">nums</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">5</pre>
  </td>
  <td>
    Adds an element (returns <pre class="code">Set(1,</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">3,</pre>&nbsp;<pre class="code">5)</pre>)<a id="i-457936727-2"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">nums</pre>&nbsp;<pre class="code">-</pre>&nbsp;<pre class="code">3</pre>
  </td>
  <td>
    Removes an element (returns <pre class="code">Set(1,</pre>&nbsp;<pre class="code">2)</pre>)<a id="i-1092228898-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">nums</pre>&nbsp;<pre class="code">++</pre>&nbsp;<pre class="code">List(5,</pre>&nbsp;<pre class="code">6)</pre>
  </td>
  <td>
    Adds multiple elements (returns <pre class="code">Set(1,</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">3,</pre>&nbsp;<pre class="code">5,</pre>&nbsp;<pre class="code">6)</pre>)<a id="i758428245-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">nums</pre>&nbsp;<pre class="code">--</pre>&nbsp;<pre class="code">List(1,</pre>&nbsp;<pre class="code">2)</pre>
  </td>
  <td>
    Removes multiple elements (returns <pre class="code">Set(3)</pre>)<a id="i-726788280-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">nums</pre>&nbsp;<pre class="code">&amp;</pre>&nbsp;<pre class="code">Set(1,</pre>&nbsp;<pre class="code">3,</pre>&nbsp;<pre class="code">5,</pre>&nbsp;<pre class="code">7)</pre>
  </td>
  <td>
    Takes the intersection of two sets (returns <pre class="code">Set(1,</pre>&nbsp;<pre class="code">3)</pre>)<a id="i617863161-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">nums.size</pre>
  </td>
  <td>
    Returns the size of the set (returns <pre class="code">3</pre>)<a id="i-217240950-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">nums.contains(3)</pre>
  </td>
  <td>
    Checks for inclusion (returns <pre class="code">true</pre>)<a id="i1685795628-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">import</pre>&nbsp;<pre class="code">scala.collection.mutable</pre>
  </td>
  <td>
    Makes the mutable collections easy to access
  </td>
</tr>
<tr>
  <td>
    <pre class="code">val</pre>&nbsp;<pre class="code">words</pre>&nbsp;<pre class="code">=</pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre><br />
  <pre class="code">mutable.Set.empty[String]</pre>
  </td>
  <td>
    Creates an empty, mutable set (<pre class="code">words.toString</pre> returns <pre class="code">Set()</pre>)<a id="i1582603163-2"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">words</pre>&nbsp;<pre class="code">+=</pre>&nbsp;<pre class="code">"the"</pre>
  </td>
  <td>
    Adds an element (<pre class="code">words.toString</pre> returns <pre class="code">Set(the)</pre>)<a id="i1314992430-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">words</pre>&nbsp;<pre class="code">-=</pre>&nbsp;<pre class="code">"the"</pre>
  </td>
  <td>
    Removes an element, if it exists (<pre class="code">words.toString</pre> returns <pre class="code">Set()</pre>)<a id="i1816671796-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">words</pre>&nbsp;<pre class="code">++=</pre>&nbsp;<pre class="code">List("do",</pre>&nbsp;<pre class="code">"re",</pre>&nbsp;<pre class="code">"mi")</pre>
  </td>
  <td>
    Adds multiple elements (<pre class="code">words.toString</pre> returns <pre class="code">Set(do,</pre>&nbsp;<pre class="code">re,</pre>&nbsp;<pre class="code">mi)</pre>)<a id="i-1693046362-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">words</pre>&nbsp;<pre class="code">--=</pre>&nbsp;<pre class="code">List("do",</pre>&nbsp;<pre class="code">"re")</pre>
  </td>
  <td>
    Removes multiple elements (<pre class="code">words.toString</pre> returns <pre class="code">Set(mi)</pre>)<a id="i-610143062-1"/>
  </td>
</tr>
<tr class="bottomline">
  <td>
    <pre class="code">words.clear</pre>
  </td>
  <td>
    Removes all elements (<pre class="code">words.toString</pre> returns <pre class="code">Set()</pre>)<a id="i-914291699-1"/>
  </td>
</tr>
</table>


<h4>Using maps</h4>


<p>Maps
let you associate a value with each element of a set.
Using a map looks similar to using an array, except
instead of indexing with integers counting from 0, you can use
any kind of key<a id="i3344023-3"/>.
If you import the <pre class="code">mutable</pre> package name, you can create an
empty mutable map like this:<a id="i-1094653291-1"/><a id="i-809004496-2"/></p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;map&nbsp;=&nbsp;mutable.Map.empty[<code class="typename">String</code>,&nbsp;<code class="typename">Int</code>]
  <code class="output">map:&nbsp;scala.collection.mutable.Map[String,Int]&nbsp;=&nbsp;Map()</code>
</pre>


<p>Note that when you create a map, you must specify two types.  The first
type is for the <em>keys</em> of the map, the second for the <em>values</em>.
In this case, the keys are strings and the values are integers. Setting entries in a map looks similar to setting entries in an array:<a id="i648989597-1"/></p>

<pre>
  scala&gt;&nbsp;map(<code class="quotedstring">"hello"</code>)&nbsp;=&nbsp;<code class="literal">1</code>
  <br />  scala&gt;&nbsp;map(<code class="quotedstring">"there"</code>)&nbsp;=&nbsp;<code class="literal">2</code>
  <br />  scala&gt;&nbsp;map
  <code class="output">res20:&nbsp;scala.collection.mutable.Map[String,Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Map(hello&nbsp;-&gt;&nbsp;1,&nbsp;there&nbsp;-&gt;&nbsp;2)</code>
</pre>


<p>Likewise, reading a map is similar to reading an array:</p>

<pre>
  scala&gt;&nbsp;map(<code class="quotedstring">"hello"</code>)
  <code class="output">res21:&nbsp;Int&nbsp;=&nbsp;1</code>
</pre>


<p>Putting it all together, here is a method that counts the number
of times each word occurs in a string:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;countWords(text:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;counts&nbsp;=&nbsp;mutable.Map.empty[<code class="typename">String</code>,&nbsp;<code class="typename">Int</code>]
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(rawWord&nbsp;&lt;-&nbsp;text.split(<code class="quotedstring">"[&nbsp;,!.]+"</code>))&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;word&nbsp;=&nbsp;rawWord.toLowerCase
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;oldCount&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(counts.contains(word))&nbsp;counts(word)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counts&nbsp;+=&nbsp;(word&nbsp;-&gt;&nbsp;(oldCount&nbsp;+&nbsp;<code class="literal">1</code>))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counts
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">countWords:&nbsp;(text:&nbsp;</code>
  <code class="output">String)scala.collection.mutable.Map[String,Int]</code>
  <br />  scala&gt;&nbsp;countWords(<code class="quotedstring">"See&nbsp;Spot&nbsp;run!&nbsp;Run,&nbsp;Spot.&nbsp;Run!"</code>)
  <code class="output">res22:&nbsp;scala.collection.mutable.Map[String,Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Map(spot&nbsp;-&gt;&nbsp;2,&nbsp;see&nbsp;-&gt;&nbsp;1,&nbsp;run&nbsp;-&gt;&nbsp;3)</code>
</pre>


<p>Given these counts, you can see that this text talks a lot about
running, but not so much about seeing.</p>

<p>The way this code works is that a mutable map, named <pre class="code">counts</pre>, maps each
word to the number of times it occurs in the text.  For each word in
the text, the word's old count is looked up, that count is incremented
by one, and the new count is saved back into <pre class="code">counts</pre>.  Note the use
of <pre class="code">contains</pre> to check whether a word has been seen yet or
not.  If
<pre class="code">counts.contains(word)</pre> is not true, then the word has not yet been
seen and zero is used for the count.</p>

<p>Many of the most commonly
used methods on both mutable and immutable maps are shown in <a href="working-with-other-collections.html#tab-map-operations">Table 17.2</a>.</p>

<p><a id="tab-map-operations"/></p>

<h5>Common operations for maps<a id="i-498146178-1"/></h5>
<table style="border-collapse: collapse">
<tr class="topline bottomline">
  <th>
<span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </th>
  <th>
<div style="text-align: center"><span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
</div>


  </th>
</tr>
<tr>
  <td>
    <pre class="code">val</pre>&nbsp;<pre class="code">nums</pre>&nbsp;<pre class="code">=</pre>&nbsp;<pre class="code">Map("i"</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">1,</pre>&nbsp;<pre class="code">"ii"</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">2)</pre>
  </td>
  <td>
    Creates an immutable map (<pre class="code">nums.toString</pre> returns <pre class="code">Map(i</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">1,</pre>&nbsp;<pre class="code">ii</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">2)</pre>)
  </td>
</tr>
<tr>
  <td>
    <pre class="code">nums</pre>&nbsp;<pre class="code">+</pre>&nbsp;<span class="code">(<span class="quotedstring">"vi"</span></span>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<span class="code"><span class="literal">6</span>)</span>
  </td>
  <td>
    Adds an entry (returns
                          <pre class="code">Map(i</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">1,</pre> <pre class="code">ii</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">vi</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">6)</pre>)<a id="i979720815-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">nums</pre>&nbsp;<pre class="code">-</pre>&nbsp;<pre class="code"><pre class="quotedstring">"ii"</pre></pre>
  </td>
  <td>
    Removes an entry 
                  (returns 
                   <pre class="code">Map(i</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">1)</pre>)<a id="i345428644-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">nums</pre>&nbsp;<pre class="code">++</pre>&nbsp;<span class="code"><span class="typename">List</span>(<span class="quotedstring">"iii"</span></span>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<span class="code"><span class="literal">3</span>,</span>&nbsp;<pre class="code"><pre class="quotedstring">"v"</pre></pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<span class="code"><span class="literal">5</span>)</span>
  </td>
  <td>
    Adds multiple entries (returns <pre class="code">Map(i</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">1,</pre> <pre class="code">ii</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">iii</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">3,</pre>&nbsp;<pre class="code">v</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">5)</pre>)<a id="i-2098881509-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">nums</pre>&nbsp;<pre class="code">--</pre>&nbsp;<span class="code"><span class="typename">List</span>(<span class="quotedstring">"i"</span>,</span>&nbsp;<span class="code"><span class="quotedstring">"ii"</span>)</span>
  </td>
  <td>
    Removes multiple entries  (returns
                          <pre class="code">Map()</pre>)<a id="i710869262-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">nums.size</pre>
  </td>
  <td>
    Returns the size of the map (returns <pre class="code">2</pre>)
  </td>
</tr>
<tr>
  <td>
    <span class="code">nums.contains(<span class="quotedstring">"ii"</span>)</span>
  </td>
  <td>
    Checks for inclusion (returns <pre class="code">true</pre>)<a id="i-1171514126-1"/>
  </td>
</tr>
<tr>
  <td>
    <span class="code">nums(<span class="quotedstring">"ii"</span>)</span>
  </td>
  <td>
    Retrieves the value at a specified
              key (returns <pre class="code">2</pre>)<a id="i648989597-2"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">nums.keys</pre>
  </td>
  <td>
    Returns the keys (returns an <pre class="code">Iterable</pre> over
                the strings <pre class="code">"i"</pre> and <pre class="code">"ii"</pre>)<a id="i1213467709-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">nums.keySet</pre>
  </td>
  <td>
    Returns the keys as a set (returns <pre class="code">Set(i,</pre>&nbsp;<pre class="code">ii)</pre>)<a id="i891405326-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">nums.values</pre>
  </td>
  <td>
    Returns the values (returns an <pre class="code">Iterable</pre> over
                the integers <pre class="code">1</pre> and <pre class="code">2</pre>)<a id="i-546077233-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">nums.isEmpty</pre>
  </td>
  <td>
    Indicates whether the map is empty (returns false)<a id="i-576053426-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">import</pre>&nbsp;<pre class="code">scala.collection.mutable</pre>
  </td>
  <td>
    Makes the mutable collections
                                     easy to access
  </td>
</tr>
<tr>
  <td>
    <pre class="code">val</pre>&nbsp;<pre class="code">words</pre>&nbsp;<pre class="code">=</pre>&nbsp;<pre class="code"></pre> <br />
  <span class="code">mutable.Map.empty[<span class="typename">String</span>,</span>&nbsp;<span class="code"><span class="typename">Int</span>]</span>
  </td>
  <td>
    Creates an empty, mutable map<a id="i-1094653291-2"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">words</pre>&nbsp;<pre class="code">+=</pre>&nbsp;<span class="code">(<span class="quotedstring">"one"</span></span>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<span class="code"><span class="literal">1</span>)</span>
  </td>
  <td>
    Adds a map entry from <pre class="code">"one"</pre> to <pre class="code">1</pre> (<pre class="code">words.toString</pre> returns <pre class="code">Map(one</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">1)</pre>)<a id="i1314809716-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">words</pre>&nbsp;<pre class="code">-=</pre>&nbsp;<pre class="code"><pre class="quotedstring">"one"</pre></pre>
  </td>
  <td>
    Removes a map entry, if it exists (<pre class="code">words.toString</pre> returns <pre class="code">Map()</pre>)<a id="i1816489082-1"/>
  </td>
</tr>
<tr>
  <td>
    <pre class="code">words</pre>&nbsp;<pre class="code">++=</pre>&nbsp;<span class="code"><span class="typename">List</span>(<span class="quotedstring">"one"</span></span>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<span class="code"><span class="literal">1</span>,</span>&nbsp;<pre class="code"></pre><br />
<pre class="code"><pre class="quotedstring">"two"</pre></pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<span class="code"><span class="literal">2</span>,</span>&nbsp;<pre class="code"><pre class="quotedstring">"three"</pre></pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<span class="code"><span class="literal">3</span>)</span>
  </td>
  <td>
    Adds multiple map entries (<pre class="code">words.toString</pre> returns <pre class="code">Map(one</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">1,</pre> <pre class="code">two</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">three</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">3)</pre>)<a id="i-1693229076-1"/>
  </td>
</tr>
<tr class="bottomline">
  <td>
    <pre class="code">words</pre>&nbsp;<pre class="code">--=</pre>&nbsp;<span class="code"><span class="typename">List</span>(<span class="quotedstring">"one"</span>,</span>&nbsp;<span class="code"><span class="quotedstring">"two"</span>)</span>
  </td>
  <td>
    Removes multiple objects (<pre class="code">words.toString</pre> returns <pre class="code">Map(three</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">3)</pre>)<a id="i-610325776-1"/>
  </td>
</tr>
</table>


<h4>Default sets and maps</h4>


<p>For most uses, the implementations of mutable and immutable sets and maps provided by<a id="i1372944617-1"/><a id="i1372761903-1"/>
the <pre class="code">Set()</pre>, <pre class="code">scala.collection.mutable.Map()</pre>, <i>etc.</i>, factories will likely be sufficient.
The implementations provided by these factories use a fast lookup algorithm, usually
involving a hash table, so they can quickly decide whether or not an
object is in the collection.</p>

<p>The <pre class="code">scala.collection.mutable.Set()</pre> factory method, for example, returns a <pre class="code">scala.collection.mutable.HashSet</pre>, which
uses a hash table internally.
Similarly, the 
<pre class="code">scala.collection.mutable.Map()</pre> factory returns a <pre class="code">scala.collection.mutable.HashMap</pre>.</p>

<p>The story for immutable sets and maps is a bit more involved. The class returned by
the <pre class="code">scala.collection.immutable.Set()</pre> factory method, for example, depends on how many elements you
pass to it, as shown in <a href="working-with-other-collections.html#tab-default-sets">Table 17.3</a>. For sets with fewer than five elements, a special
class devoted exclusively to sets of each particular size is used to maximize performance. Once you request a set that has five or
more elements in it, however, the factory method will return an implementation
that uses hash tries.</p>

<p>Similarly, the <pre class="code">scala.collection.immutable.Map()</pre> factory method will return a different class depending on how many key-value pairs you
pass to it, as shown in <a href="working-with-other-collections.html#tab-default-maps">Table 17.4</a>. As with sets, for immutable maps with fewer than five elements, a special
class devoted exclusively to maps of each particular size is used to maximize performance. Once a map has five or
more key-value pairs in it, however, an immutable <pre class="code">HashMap</pre> is used.</p>

<p>The default immutable implementation classes shown in <a href="working-with-other-collections.html#tab-default-sets">Tables 17.3</a> <a href="working-with-other-collections.html#tab-default-maps">and 17.4</a> work together
to give you maximum performance. For example, if you add an element to an <pre class="code">EmptySet</pre>, it will return a <pre class="code">Set1</pre>. If you add an
element to that <pre class="code">Set1</pre>, it will return a <pre class="code">Set2</pre>. If you then remove an element from the <pre class="code">Set2</pre>, you'll get another <pre class="code">Set1</pre>.</p>

<p><a id="tab-default-sets"/></p>

<h5>Table 17.3 - Default immutable set implementations</h5>


<div style="text-align: center">


<table style="border-collapse: collapse">
<tr class="topline ">
  <td>
    <span style="font-size:medium"><span style="font-weight:bold">Number of elements</span></span>
  </td>
  <td>
    <span style="font-size:medium"><span style="font-weight:bold">Implementation</span></span>
  </td>
</tr>
<tr class="topline ">
  <td>
    0
  </td>
  <td>
    <pre class="code">scala.collection.immutable.EmptySet</pre>
  </td>
</tr>
<tr>
  <td>
    1
  </td>
  <td>
    <pre class="code">scala.collection.immutable.Set1</pre>
  </td>
</tr>
<tr>
  <td>
    2
  </td>
  <td>
    <pre class="code">scala.collection.immutable.Set2</pre>
  </td>
</tr>
<tr>
  <td>
    3
  </td>
  <td>
    <pre class="code">scala.collection.immutable.Set3</pre>
  </td>
</tr>
<tr>
  <td>
    4
  </td>
  <td>
    <pre class="code">scala.collection.immutable.Set4</pre>
  </td>
</tr>
<tr>
  <td>
    5 or more
  </td>
  <td>
    <pre class="code">scala.collection.immutable.HashSet</pre>
  </td>
</tr>
</table>


</div>


<p><a id="tab-default-maps"/></p>

<h5>Table 17.4 - Default immutable map implementations</h5>


<div style="text-align: center">


<table style="border-collapse: collapse">
<tr class="topline ">
  <td>
    <span style="font-size:medium"><span style="font-weight:bold">Number of elements</span></span>
  </td>
  <td>
    <span style="font-size:medium"><span style="font-weight:bold">Implementation</span></span>
  </td>
</tr>
<tr class="topline ">
  <td>
    0
  </td>
  <td>
    <pre class="code">scala.collection.immutable.EmptyMap</pre>
  </td>
</tr>
<tr>
  <td>
    1
  </td>
  <td>
    <pre class="code">scala.collection.immutable.Map1</pre>
  </td>
</tr>
<tr>
  <td>
    2
  </td>
  <td>
    <pre class="code">scala.collection.immutable.Map2</pre>
  </td>
</tr>
<tr>
  <td>
    3
  </td>
  <td>
    <pre class="code">scala.collection.immutable.Map3</pre>
  </td>
</tr>
<tr>
  <td>
    4
  </td>
  <td>
    <pre class="code">scala.collection.immutable.Map4</pre>
  </td>
</tr>
<tr>
  <td>
    5 or more
  </td>
  <td>
    <pre class="code">scala.collection.immutable.HashMap</pre>
  </td>
</tr>
</table>


</div>


<h4>Sorted sets and maps</h4>


<p>On occasion you may need a set or map whose iterator returns elements in a particular order.
For this purpose, the Scala collections library provides traits
<pre class="code">SortedSet</pre><a id="i849148531-1"/> and
<pre class="code">SortedMap</pre>.<a id="i1172619245-1"/> These
traits are implemented by classes
<pre class="code">TreeSet</pre><a id="i300430876-1"/> and
<pre class="code">TreeMap</pre>,<a id="i623901590-1"/> which use a red-black tree to keep
elements (in the case of <pre class="code">TreeSet</pre>) or keys (in the case of <pre class="code">TreeMap</pre>) in order. The order
is determined by the <pre class="code">Ordered</pre><a id="i2068605051-2"/> trait, which the element type of the set, or key type of the map,
must either mix in or be implicitly convertible to. These classes only come in immutable variants. Here
are some <pre class="code">TreeSet</pre> examples:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.immutable.TreeSet
  <code class="output">import&nbsp;scala.collection.immutable.TreeSet</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;ts&nbsp;=&nbsp;<code class="typename">TreeSet</code>(<code class="literal">9</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">1</code>,&nbsp;<code class="literal">8</code>,&nbsp;<code class="literal">0</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">7</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">6</code>,&nbsp;<code class="literal">5</code>)
  <code class="output">ts:&nbsp;scala.collection.immutable.TreeSet[Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;TreeSet(0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;cs&nbsp;=&nbsp;<code class="typename">TreeSet</code>(<code class="quotedstring">'f'</code>,&nbsp;<code class="quotedstring">'u'</code>,&nbsp;<code class="quotedstring">'n'</code>)
  <code class="output">cs:&nbsp;scala.collection.immutable.TreeSet[Char]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;TreeSet(f,&nbsp;n,&nbsp;u)</code>
</pre>


<p>And here are a few <pre class="code">TreeMap</pre> examples:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.immutable.TreeMap
  <code class="output">import&nbsp;scala.collection.immutable.TreeMap</code>
  <br />  scala&gt;&nbsp;<code class="vem">var</code>&nbsp;tm&nbsp;=&nbsp;<code class="typename">TreeMap</code>(<code class="literal">3</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">'x'</code>,&nbsp;<code class="literal">1</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">'x'</code>,&nbsp;<code class="literal">4</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">'x'</code>)
  <code class="output">tm:&nbsp;scala.collection.immutable.TreeMap[Int,Char]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Map(1&nbsp;-&gt;&nbsp;x,&nbsp;3&nbsp;-&gt;&nbsp;x,&nbsp;4&nbsp;-&gt;&nbsp;x)</code>
  <br />  scala&gt;&nbsp;tm&nbsp;+=&nbsp;(<code class="literal">2</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">'x'</code>)
  <br />  scala&gt;&nbsp;tm
  <code class="output">res30:&nbsp;scala.collection.immutable.TreeMap[Int,Char]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Map(1&nbsp;-&gt;&nbsp;x,&nbsp;2&nbsp;-&gt;&nbsp;x,&nbsp;3&nbsp;-&gt;&nbsp;x,&nbsp;4&nbsp;-&gt;&nbsp;x)</code>
</pre>


<h3>17.3 Selecting mutable versus immutable collections</h3>


<p>For some problems, mutable collections work better, while for others,
immutable collections work better.<a id="i1445844177-1"/>  When in doubt, it is better to start with an immutable collection and
change it later, if you need to, because immutable collections can be easier to reason 
about than mutable ones.</p>

<p>Also, it can be worthwhile to go the opposite way sometimes.  If you find some code
that uses mutable collections becoming complicated and hard to reason
about, consider whether it would help to change some of the
collections to immutable alternatives<a id="i650543080-1"/>.  In particular, if you find yourself
worrying about making copies of mutable collections in just the right places, or thinking a lot about who "owns" or
"contains" a mutable collection, consider switching some of the
collections to their immutable counterparts.</p>

<p>Besides being potentially easier to reason about, immutable
collections can usually be stored more compactly than mutable ones if
the number of elements stored in the collection is small. For instance
an empty mutable map in its default representation of <pre class="code">HashMap</pre> takes up
about 80 bytes, and about 16 more are added for each entry that's added
to it. An empty immutable <pre class="code">Map</pre> is a single object that's shared
between all references, so referring to it essentially costs just a
single pointer field.</p>

<p>What's more, the Scala collections library currently stores
immutable maps and sets with up to four entries in a single object,
which typically takes up between 16 and 40 bytes, depending on the
number of entries stored in the collection.<a href="working-with-other-collections.html#footnotemain17-4">[4]</a> So for small maps and
sets, the immutable versions are much more compact than the mutable
ones. Given that many collections are small, switching them to be
immutable can bring important space savings and performance advantages.</p>

<p>To make it easier to switch from immutable to mutable collections, and vice versa, Scala provides some
syntactic sugar.  Even though immutable sets and maps do not support a
true <pre class="code">+=</pre> method, Scala gives a useful alternate interpretation to
<pre class="code">+=</pre>.  Whenever you write <pre class="code">a</pre>&nbsp;<pre class="code">+=</pre>&nbsp;<pre class="code">b</pre>, and <pre class="code">a</pre> does not support a method named <pre class="code">+=</pre>,
Scala will try interpreting it as <pre class="code">a</pre>&nbsp;<pre class="code">=</pre>&nbsp;<pre class="code">a</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">b</pre>.</p>

<p>For example,
immutable sets do not support a <pre class="code">+=</pre> operator:<a id="i1301665902-2"/></p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;people&nbsp;=&nbsp;<code class="typename">Set</code>(<code class="quotedstring">"Nancy"</code>,&nbsp;<code class="quotedstring">"Jane"</code>)
  <code class="output">people:&nbsp;scala.collection.immutable.Set[String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Set(Nancy,&nbsp;Jane)</code>
  <br />  scala&gt;&nbsp;people&nbsp;+=&nbsp;<code class="quotedstring">"Bob"</code>
  <code class="output">&lt;console&gt;:14:&nbsp;error:&nbsp;value&nbsp;+=&nbsp;is&nbsp;not&nbsp;a&nbsp;member&nbsp;of&nbsp;</code>
  <code class="output">scala.collection.immutable.Set[String]</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;people&nbsp;+=&nbsp;"Bob"</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>However, if you declare <pre class="code">people</pre> as a <pre class="code">var</pre>, instead of a <pre class="code">val</pre>, then the collection can be "updated" with a <pre class="code">+=</pre> operation, even though it is
immutable. First, a new collection will be created, and then <pre class="code">people</pre> 
will be reassigned to refer to the new collection:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">var</code>&nbsp;people&nbsp;=&nbsp;<code class="typename">Set</code>(<code class="quotedstring">"Nancy"</code>,&nbsp;<code class="quotedstring">"Jane"</code>)
  <code class="output">people:&nbsp;scala.collection.immutable.Set[String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Set(Nancy,&nbsp;Jane)</code>
  <br />  scala&gt;&nbsp;people&nbsp;+=&nbsp;<code class="quotedstring">"Bob"</code>
  <br />  scala&gt;&nbsp;people
  <code class="output">res34:&nbsp;scala.collection.immutable.Set[String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Set(Nancy,&nbsp;Jane,&nbsp;Bob)</code>
</pre>


<p>After this series of statements, the <pre class="code">people</pre> variable refers to a new immutable
set, which contains the added string, <pre class="code">"Bob"</pre>.
The same idea applies to any method ending in <pre class="code">=</pre>, not just
the <pre class="code">+=</pre> method. Here's the same syntax used with the <pre class="code">-=</pre> operator, which removes
an element from a set, and the <pre class="code">++=</pre> operator, which adds a collection of elements to
a set:</p>

<pre>
  scala&gt;&nbsp;people&nbsp;-=&nbsp;<code class="quotedstring">"Jane"</code>
  <br />  scala&gt;&nbsp;people&nbsp;++=&nbsp;<code class="typename">List</code>(<code class="quotedstring">"Tom"</code>,&nbsp;<code class="quotedstring">"Harry"</code>)
  <br />  scala&gt;&nbsp;people
  <code class="output">res37:&nbsp;scala.collection.immutable.Set[String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Set(Nancy,&nbsp;Bob,&nbsp;Tom,&nbsp;Harry)</code>
</pre>


<p>To see how this is useful, consider again the following <pre class="code">Map</pre> example
from <a href="a-scalable-language.html#sec-a-language-that-grows-on-you">Section 1.1</a>:</p>

<pre>
  <code class="vem">var</code>&nbsp;capital&nbsp;=&nbsp;<code class="typename">Map</code>(<code class="quotedstring">"US"</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Washington"</code>,&nbsp;<code class="quotedstring">"France"</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Paris"</code>)
  capital&nbsp;+=&nbsp;(<code class="quotedstring">"Japan"</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Tokyo"</code>)
  println(capital(<code class="quotedstring">"France"</code>))&nbsp;
</pre>


<p>This code uses immutable collections.  If you want to
try using mutable collections instead, all that
is necessary is to import the mutable version of <pre class="code">Map</pre>,
thus overriding the default import of the immutable <pre class="code">Map</pre>:</p>

<pre>
  <code class="vem">import</code>&nbsp;scala.collection.mutable.Map&nbsp;&nbsp;<code class="comment">//&nbsp;only&nbsp;change&nbsp;needed!</code>
  <code class="vem">var</code>&nbsp;capital&nbsp;=&nbsp;<code class="typename">Map</code>(<code class="quotedstring">"US"</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Washington"</code>,&nbsp;<code class="quotedstring">"France"</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Paris"</code>)
  capital&nbsp;+=&nbsp;(<code class="quotedstring">"Japan"</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Tokyo"</code>)
  println(capital(<code class="quotedstring">"France"</code>))&nbsp;
</pre>


<p>Not all examples are quite that easy to convert, but the special
treatment of methods ending in an equals sign will often reduce the
amount of code that needs changing.</p>

<p>By the way, this syntactic treatment works on any kind of value, not
just collections.  
For example, here it is being used on
floating-point numbers:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">var</code>&nbsp;roughlyPi&nbsp;=&nbsp;<code class="literal">3.0</code>
  <code class="output">roughlyPi:&nbsp;Double&nbsp;=&nbsp;3.0</code>
  <br />  scala&gt;&nbsp;roughlyPi&nbsp;+=&nbsp;<code class="literal">0.1</code>
  <br />  scala&gt;&nbsp;roughlyPi&nbsp;+=&nbsp;<code class="literal">0.04</code>
  <br />  scala&gt;&nbsp;roughlyPi
  <code class="output">res40:&nbsp;Double&nbsp;=&nbsp;3.14</code>
</pre>


<p>The effect of this expansion is similar to
Java's assignment operators (<pre class="code">+=</pre>, <pre class="code">-=</pre>, <pre class="code">*=</pre>, <i>etc.</i>), but it is more general because
every operator ending in <pre class="code">=</pre> can be converted.</p>

<h3>17.4 Initializing collections</h3>


<p>As you've seen previously, the most common way to create and initialize a collection is to pass the initial elements to a factory method
on the companion object of your chosen collection. You just place the elements in parentheses after the
companion object name, and the Scala compiler will transform that to an invocation of an <pre class="code">apply</pre> method on that companion object:</p>

<pre>
  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res41:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;<code class="typename">Set</code>(<code class="quotedstring">'a'</code>,&nbsp;<code class="quotedstring">'b'</code>,&nbsp;<code class="quotedstring">'c'</code>)
  <code class="output">res42:&nbsp;scala.collection.immutable.Set[Char]&nbsp;=&nbsp;Set(a,&nbsp;b,&nbsp;c)</code>
  <br />  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.mutable
  <code class="output">import&nbsp;scala.collection.mutable</code>
  <br />  
  scala&gt;&nbsp;<code class="typename">mutable.Map</code>(<code class="quotedstring">"hi"</code>&nbsp;-&gt;&nbsp;<code class="literal">2</code>,&nbsp;<code class="quotedstring">"there"</code>&nbsp;-&gt;&nbsp;<code class="literal">5</code>)
  <code class="output">res43:&nbsp;scala.collection.mutable.Map[String,Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Map(hi&nbsp;-&gt;&nbsp;2,&nbsp;there&nbsp;-&gt;&nbsp;5)</code>
  <br />  scala&gt;&nbsp;<code class="typename">Array</code>(<code class="literal">1.0</code>,&nbsp;<code class="literal">2.0</code>,&nbsp;<code class="literal">3.0</code>)
  <code class="output">res44:&nbsp;Array[Double]&nbsp;=&nbsp;Array(1.0,&nbsp;2.0,&nbsp;3.0)</code>
</pre>


<p>Although most often you can let the Scala compiler infer the element type of a collection from
the elements passed to its factory method,
sometimes you may want to create a collection but specify
a different type from the one the compiler would choose.  This is
especially an issue with mutable collections. Here's an example:<a id="i-677980410-2"/></p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.mutable
  <code class="output">import&nbsp;scala.collection.mutable</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;stuff&nbsp;=&nbsp;<code class="typename">mutable.Set</code>(<code class="literal">42</code>)
  <code class="output">stuff:&nbsp;scala.collection.mutable.Set[Int]&nbsp;=&nbsp;Set(42)</code>
  <br />  scala&gt;&nbsp;stuff&nbsp;+=&nbsp;<code class="quotedstring">"abracadabra"</code>
  <code class="output">&lt;console&gt;:16:&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;String("abracadabra")</code>
  <code class="output">&nbsp;required:&nbsp;Int</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stuff&nbsp;+=&nbsp;"abracadabra"</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>The problem here is that <pre class="code">stuff</pre> was given an element type of
<pre class="code">Int</pre>.  If you want it to have an element type of <pre class="code">Any</pre>, you
need to say so explicitly by putting the element type in square brackets,
like this:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;stuff&nbsp;=&nbsp;<code class="typename">mutable.Set[Any]</code>(<code class="literal">42</code>)
  <code class="output">stuff:&nbsp;scala.collection.mutable.Set[Any]&nbsp;=&nbsp;Set(42)</code>
</pre>


<p>Another special situation is if you want to initialize a collection with another collection. 
For example, imagine you have a list, but you want a <pre class="code">TreeSet</pre> containing the elements in the list. Here's the list:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;colors&nbsp;=&nbsp;<code class="typename">List</code>(<code class="quotedstring">"blue"</code>,&nbsp;<code class="quotedstring">"yellow"</code>,&nbsp;<code class="quotedstring">"red"</code>,&nbsp;<code class="quotedstring">"green"</code>)
  <code class="output">colors:&nbsp;List[String]&nbsp;=&nbsp;List(blue,&nbsp;yellow,&nbsp;red,&nbsp;green)</code>
</pre>


<p>You cannot pass the <pre class="code">colors</pre> list to the factory method for <pre class="code">TreeSet</pre>:<a id="i-1802169132-1"/></p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.immutable.TreeSet
  <code class="output">import&nbsp;scala.collection.immutable.TreeSet</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;treeSet&nbsp;=&nbsp;<code class="typename">TreeSet</code>(colors)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">&lt;console&gt;:16:&nbsp;error:&nbsp;No&nbsp;implicit&nbsp;Ordering&nbsp;defined&nbsp;for&nbsp;</code>
  <code class="output">List[String].</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;treeSet&nbsp;=&nbsp;TreeSet(colors)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>Instead, you'll need to create an empty <pre class="code">TreeSet[String]</pre> and add to it the elements of the list with the <pre class="code">TreeSet</pre>'s <pre class="code">++</pre> operator:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;treeSet&nbsp;=&nbsp;<code class="typename">TreeSet[String]</code>()&nbsp;++&nbsp;colors
  <code class="output">treeSet:&nbsp;scala.collection.immutable.TreeSet[String]&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;TreeSet(blue,&nbsp;green,&nbsp;red,&nbsp;yellow)</code>
</pre>


<h4>Converting to array or list</h4>


<p>If you need to initialize a list or array with another collection, on the other hand, it is quite straightforward. As
you've seen previously, to initialize a new list with another collection, simply
invoke <pre class="code">toList</pre><a id="i-1723195748-2"/> on
that collection<a id="i1406547745-1"/><a id="i-218379511-1"/><a id="i595962916-1"/>:</p>

<pre>
  scala&gt;&nbsp;treeSet.toList
  <code class="output">res50:&nbsp;List[String]&nbsp;=&nbsp;List(blue,&nbsp;green,&nbsp;red,&nbsp;yellow)</code>
</pre>


<p>Or, if you need an array, invoke <pre class="code">toArray</pre>:</p>

<pre>
  scala&gt;&nbsp;treeSet.toArray
  <code class="output">res51:&nbsp;Array[String]&nbsp;=&nbsp;Array(blue,&nbsp;green,&nbsp;red,&nbsp;yellow)</code>
</pre>


<p>Note that although the original <pre class="code">colors</pre> list was not sorted, the elements in the list produced by invoking <pre class="code">toList</pre> on the
<pre class="code">TreeSet</pre> are in alphabetical order. When you invoke <pre class="code">toList</pre> or <pre class="code">toArray</pre> on a collection, the order of the elements in the resulting
list or array will be the same as the order of elements produced by an iterator obtained by invoking <pre class="code">elements</pre> on that collection.
Because a <pre class="code">TreeSet[String]</pre>'s iterator will produce strings in alphabetical order, those strings will appear in alphabetical order
in the list resulting from invoking <pre class="code">toList</pre> on that <pre class="code">TreeSet</pre>.</p>

<p>Keep in mind, however, that conversion to lists or arrays
usually requires copying all of the elements of the collection, and thus may be
slow for large collections.  Sometimes you need to do it, though, due
to an existing API.  Further, many collections only have a few
elements anyway, in which case there is only a small speed penalty.</p>

<h4>Converting between mutable and immutable sets and maps</h4>


<p>Another situation that arises occasionally is the need to<a id="i-1962569096-1"/>
convert a mutable set or map to an immutable one, or <i>vice versa</i>. To accomplish this, you
can use the technique shown on the previous page to initialize a <pre class="code">TreeSet</pre> with the elements of a list.
Create a collection of the new type using the <pre class="code">empty</pre> method
and then add the new elements using either <pre class="code">++</pre> or <pre class="code">++=</pre>, whichever
is appropriate for the target collection type.
Here's how
you'd convert the immutable <pre class="code">TreeSet</pre> from the previous example to a mutable set, and back
again to an immutable one:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.mutable
  <code class="output">import&nbsp;scala.collection.mutable</code>
  <br />  scala&gt;&nbsp;treeSet
  <code class="output">res52:&nbsp;scala.collection.immutable.TreeSet[String]&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;TreeSet(blue,&nbsp;green,&nbsp;red,&nbsp;yellow)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;mutaSet&nbsp;=&nbsp;mutable.Set.empty&nbsp;++=&nbsp;treeSet
  <code class="output">mutaSet:&nbsp;scala.collection.mutable.Set[String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Set(red,&nbsp;blue,&nbsp;green,&nbsp;yellow)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;immutaSet&nbsp;=&nbsp;Set.empty&nbsp;++&nbsp;mutaSet
  <code class="output">immutaSet:&nbsp;scala.collection.immutable.Set[String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Set(red,&nbsp;blue,&nbsp;green,&nbsp;yellow)</code>
</pre>


<p>You can use the same technique to convert between mutable and immutable maps:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;muta&nbsp;=&nbsp;<code class="typename">mutable.Map</code>(<code class="quotedstring">"i"</code>&nbsp;-&gt;&nbsp;<code class="literal">1</code>,&nbsp;<code class="quotedstring">"ii"</code>&nbsp;-&gt;&nbsp;<code class="literal">2</code>)
  <code class="output">muta:&nbsp;scala.collection.mutable.Map[String,Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Map(ii&nbsp;-&gt;&nbsp;2,i&nbsp;-&gt;&nbsp;1)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;immu&nbsp;=&nbsp;Map.empty&nbsp;++&nbsp;muta
  <code class="output">immu:&nbsp;scala.collection.immutable.Map[String,Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Map(ii&nbsp;-&gt;&nbsp;2,&nbsp;i&nbsp;-&gt;&nbsp;1)</code>
</pre>


<h3>17.5 Tuples</h3>


<p>As described in <a href="next-steps-in-scala.html#step9">Step 9</a> in <a href="next-steps-in-scala.html">Chapter 3</a>,  a tuple combines a fixed<a id="i-862490197-1"/>
number of items together so that they can be passed around as a
whole.
Unlike an array or list, a tuple can hold objects with different types.
Here is an example of a tuple holding an integer, a string, and
the console:</p>

<pre>
  (<code class="literal">1</code>,&nbsp;<code class="quotedstring">"hello"</code>,&nbsp;<code class="typename">Console</code>)
</pre>


<p>Tuples save you the tedium of defining simplistic data-heavy classes.
Even though defining a class is already easy, it does require
a certain minimum effort, which sometimes serves no purpose.
Tuples save you the effort of choosing a name for the class,
choosing a scope to define the class in, and choosing names
for the members of the class.  If your class simply holds
an integer and a string, there is no clarity added by defining
a class named <pre class="code">AnIntegerAndAString</pre>.</p>

<p>Because tuples can combine objects of different types,
tuples do not inherit from <pre class="code">Traversable</pre>.
If you find yourself wanting to group exactly one integer and exactly one
string, then you want a tuple, not a <pre class="code">List</pre> or <pre class="code">Array</pre>.</p>

<p>A common application of tuples is returning multiple values from a method.<a id="i651595778-2"/><a id="i2120520132-2"/>
For example, here is a method that finds the longest word in a
collection and also returns its index:<a id="i-1690228669-3"/></p>

<pre>
  <code class="vem">def</code>&nbsp;longestWord(words:&nbsp;<code class="typename">Array[String]</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;word&nbsp;=&nbsp;words(<code class="literal">0</code>)
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;idx&nbsp;=&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">1</code>&nbsp;until&nbsp;words.length)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(words(i).length&nbsp;&gt;&nbsp;word.length)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;word&nbsp;=&nbsp;words(i)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx&nbsp;=&nbsp;i
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;(word,&nbsp;idx)
  }
</pre>


<p>Here is an example use of the method:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;longest&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;longestWord(<code class="quotedstring">"The&nbsp;quick&nbsp;brown&nbsp;fox"</code>.split(<code class="quotedstring">"&nbsp;"</code>))
  <code class="output">longest:&nbsp;(String,&nbsp;Int)&nbsp;=&nbsp;(quick,1)</code>
</pre>


<p>The <pre class="code">longestWord</pre> function here computes two items: <pre class="code">word</pre>, the
longest word in the array, and <pre class="code">idx</pre>, the index of that word.
To keep things simple, the function assumes there is at least
one word in the list, and it breaks ties by choosing the word
that comes earlier in the list.
Once the function has chosen which word and index to return,
it returns both of them together using the tuple syntax
<pre class="code">(word,</pre>&nbsp;<pre class="code">idx)</pre>.</p>

<p>To access elements of a tuple, you can use method <pre class="code">_1</pre> to access
the first element, <pre class="code">_2</pre> to access the second, and so on:</p>

<pre>
  scala&gt;&nbsp;longest._1
  <code class="output">res53:&nbsp;String&nbsp;=&nbsp;quick</code>
  <br />  scala&gt;&nbsp;longest._2
  <code class="output">res54:&nbsp;Int&nbsp;=&nbsp;1</code>
</pre>


<p>Additionally, you can assign each element of the tuple to its own<a id="i-467993090-2"/>
variable,<a href="working-with-other-collections.html#footnotemain17-5">[5]</a> like this:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;(word,&nbsp;idx)&nbsp;=&nbsp;longest
  <code class="output">word:&nbsp;String&nbsp;=&nbsp;quick</code>
  <code class="output">idx:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br />  scala&gt;&nbsp;word
  <code class="output">res55:&nbsp;String&nbsp;=&nbsp;quick</code>
</pre>


<p>By the way, if you leave off the parentheses you get a different result:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;word,&nbsp;idx&nbsp;=&nbsp;longest
  <code class="output">word:&nbsp;(String,&nbsp;Int)&nbsp;=&nbsp;(quick,1)</code>
  <code class="output">idx:&nbsp;(String,&nbsp;Int)&nbsp;=&nbsp;(quick,1)</code>
</pre>


<p>This syntax gives <a href="glossary.html#g-181260432"><em>multiple definitions</em></a> of the same
expression.<a id="i1286114796-1"/><a id="i664504196-1"/>
Each variable is initialized with its own evaluation of the expression
on the right-hand side.  That the expression evaluates to a tuple in
this case does not matter.  Both variables are initialized to the
tuple in its entirety.  See <a href="mutable-objects.html">Chapter 18</a> for
some examples where multiple definitions are convenient.</p>

<p>As a note of warning, tuples are almost too easy to use.  Tuples are<a id="i-726189942-1"/><a id="i-516778869-1"/>
great when you combine data that has no meaning beyond "an A and a
B."  However, whenever the combination has some meaning, or you want
to add some methods to the combination, it is better to go ahead and
create a class.  For example, do not use a 3-tuple for the combination
of a month, a day, and a year.  Make a <pre class="code">Date</pre> class.  It makes your
intentions explicit, which both clears up the code for human readers
and gives the compiler and language opportunities to help you
catch mistakes.</p>

<h3>17.6 Conclusion</h3>


<p>This chapter has given an overview of the Scala collections library and
the most important classes and traits in it. With this foundation you should
be able to work effectively with Scala collections, and know where to look in Scaladoc when
you need more information.
For more detailed information about Scala collections, look ahead to
<a href="collections-in-depth.html">Chapter 24</a> and <a href="the-architecture-of-scala-collections.html">Chapter 25</a>.
For now,
in the next chapter, we'll turn our attention from the Scala library back to the 
language and discuss Scala's support for mutable objects.</p>

<hr/>
<h4>Footnotes for Chapter 17:</h4>


<p><a id="footnotemain17-1"/>[1] The difference in variance of Scala's and Java's arrays&mdash;<i>i.e.</i>, whether
<pre class="code">Array[String]</pre> is a subtype of <pre class="code">Array[AnyRef]</pre>&mdash;will be discussed in <a href="type-parameterization.html#sec-first-arrays">Section 19.3</a>.</p>

<p><a id="footnotemain17-2"/>[2] The code given  <a href="a-scalable-language.html#subsec-scala-is-high-level">here</a> of <a href="a-scalable-language.html">Chapter 1</a>
presents a similar example.</p>

<p><a id="footnotemain17-3"/>[3] The <pre class="code">type</pre> keyword will be explained in more 
detail in <a href="abstract-members.html#sec-abstract-types">Section 20.6</a>.</p>

<p><a id="footnotemain17-4"/>[4] The "single object" is an
instance of <pre class="code">Set1</pre> through <pre class="code">Set4</pre>, or <pre class="code">Map1</pre> through <pre class="code">Map4</pre>, as shown in <a href="working-with-other-collections.html#tab-default-sets">Tables 17.3</a>
<a href="working-with-other-collections.html#tab-default-maps">and 17.4</a>.</p>

<p><a id="footnotemain17-5"/>[5] This syntax is actually a special case of
<em>pattern matching</em>, as described in detail in
<a href="case-classes-and-pattern-matching.html#sec-patterns-everywhere">Section 15.7</a>.</p>

<div style="page-break-after:always"/>


<div style="page-break-after:always"/>

</body>
</html>
