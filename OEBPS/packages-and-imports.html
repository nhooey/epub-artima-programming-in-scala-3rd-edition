<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8"/>
    <title>Programming in Scala, 3rd Edition</title>

    <link rel="stylesheet" type="text/css" href="book.css" />
  </head>
<body>
<h2><a id="chap-packages-and-imports">Chapter 13</a></h2>
<h1>Packages and Imports</h1>


<p>When working on a program, especially a large one,
it is important to minimize <em>coupling</em>&mdash;the extent to which
the various parts of the program rely on the other parts. Low coupling reduces the risk that a small, seemingly innocuous change
in one part of the program will have devastating consequences in another part.  One way to
minimize coupling is to write in a modular style.  You divide the program into a number of smaller modules, each of which has
an inside and an outside.  When working on the inside of a
module&mdash;its <em>implementation</em>&mdash;you need only coordinate with
other programmers working on that very same module.  Only when you must change the outside of a module&mdash;its <em>interface</em>&mdash;is it
necessary to coordinate with developers working on other modules.<a id="i750867693-1"/></p>

<p>This chapter shows several constructs that help you program in a
modular style.  It shows how to place things in packages, make
names visible through imports, and control the visibility of
definitions through access modifiers.  The constructs are similar in
spirit to constructs in Java, but there are some
differences&mdash;usually ways that are more consistent&mdash;so it's worth reading this
chapter even if you already know Java.</p>

<h3>13.1 Putting code in packages</h3>


<p>Scala code resides in the Java platform's global hierarchy of packages.
The example code
you've seen so far in this book has been in the <em>unnamed</em> package.<a id="i305704921-1"/><a id="i38834278-1"/>
You can place code into named packages in Scala in two ways. First, you
can place the contents of an entire file into a package
by putting a <pre class="code">package</pre> clause at the top of the file, as shown in <a href="packages-and-imports.html#lst-entire-file-package">Listing 13.1</a>.</p>

<p><a id="lst-entire-file-package"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;bobsrockets.navigation
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Navigator</code>
</pre>


<h5>Listing 13.1 - Placing the contents of an entire file into a package.<a id="i-1154528502-1"/></h5>


<p>The <pre class="code">package</pre> clause of <a href="packages-and-imports.html#lst-entire-file-package">Listing 13.1</a> places class <pre class="code">Navigator</pre> into the package named
<pre class="code">bobsrockets.navigation</pre>.  Presumably, this is the navigation
software developed by Bob's Rockets, Inc.</p>

<div class="note">
<h4>Note</h4>
Because Scala code is part of the Java ecosystem, it is
recommended to follow Java's reverse-domain-name convention for Scala packages that you release to the public. 
Thus, a better name for <pre class="code">Navigator</pre>'s package might be <pre class="code">com.bobsrockets.navigation</pre>. In this chapter, however,
we'll leave off the "<pre class="code">com.</pre>" to make the examples easier to understand.


</div>


<p>The other way you can place code into packages in Scala is more like
C# namespaces.<a id="i-999496559-1"/> You follow a package clause
by a section in curly braces that contains the definitions that go
into the package.  This syntax is called a
<em>packaging</em>.<a id="i1802065795-1"/> The packaging shown in
<a href="packages-and-imports.html#lst-dot-and-nested">Listing 13.2</a> has the same effect as the code in
<a href="packages-and-imports.html#lst-entire-file-package">Listing 13.1</a>:
<a id="lst-dot-and-nested"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;bobsrockets.navigation&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Navigator</code>
  &nbsp;&nbsp;}
</pre>


<h5>Listing 13.2 - Long form of a simple package declaration.</h5>


<p>For such simple examples, you might as well use the syntactic sugar
shown in <a href="packages-and-imports.html#lst-entire-file-package">Listing 13.1</a>.  However, one use of
the more general notation is to have different parts of a file in
different packages.  For example, you might include a class's tests in
the same file as the original code, but put the tests in a different
package, as shown<a id="i-1775661018-1"/> in
<a href="packages-and-imports.html#lst-nesting-packages">Listing 13.3</a>.</p>

<p><a id="lst-nesting-packages"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;bobsrockets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">package</code>&nbsp;navigation&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;In&nbsp;package&nbsp;bobsrockets.navigation</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Navigator</code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">package</code>&nbsp;tests&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;In&nbsp;package&nbsp;bobsrockets.navigation.tests</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">NavigatorSuite</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 13.3 - Multiple packages in the same file.</h5>


<p><a id="lst-concise"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;bobsrockets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">package</code>&nbsp;navigation&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Navigator</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;No&nbsp;need&nbsp;to&nbsp;say&nbsp;bobsrockets.navigation.StarMap</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;map&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">StarMap</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">StarMap</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Ship</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;No&nbsp;need&nbsp;to&nbsp;say&nbsp;bobsrockets.navigation.Navigator</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;nav&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">navigation.Navigator</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">package</code>&nbsp;fleets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Fleet</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;No&nbsp;need&nbsp;to&nbsp;say&nbsp;bobsrockets.Ship</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;addShip()&nbsp;=&nbsp;{&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Ship</code>&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 13.4 - Concise access to classes and packages.</h5>


<p><a id="lst-enclosing"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;bobsrockets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Ship</code>
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;bobsrockets.fleets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Fleet</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Doesn't&nbsp;compile!&nbsp;Ship&nbsp;is&nbsp;not&nbsp;in&nbsp;scope.</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;addShip()&nbsp;=&nbsp;{&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Ship</code>&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 13.5 - Symbols in enclosing packages not automatically available.</h5>


<p><a id="lst-hiding-packages"/></p>

<pre>
  &nbsp;&nbsp;<code class="comment">//&nbsp;In&nbsp;file&nbsp;launch.scala</code>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;launch&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Booster3</code>
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<code class="comment">//&nbsp;In&nbsp;file&nbsp;bobsrockets.scala</code>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;bobsrockets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">package</code>&nbsp;navigation&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">package</code>&nbsp;launch&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Booster1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">MissionControl</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;booster1&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">launch.Booster1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;booster2&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">bobsrockets.launch.Booster2</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;booster3&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;_root_.launch.Booster3
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">package</code>&nbsp;launch&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Booster2</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 13.6 - Accessing hidden package names.</h5>


<h3>13.2 Concise access to related code</h3>


<p>When code is divided into a package hierarchy, it doesn't just help
people browse through the code.  It also tells the compiler that code
in the same package is related in some way to each other.  Scala takes
advantage of this relatedness by allowing short, unqualified names
when accessing code that is in the same package.</p>

<p><a href="packages-and-imports.html#lst-concise">Listing 13.4</a> gives three simple examples.  First, as you
would expect, a class can be accessed from within its own package
without needing a prefix.  That's why <pre class="code">new</pre>&nbsp;<pre class="code">StarMap</pre> compiles.  Class
<pre class="code">StarMap</pre> is in the same package, <pre class="code">bobsrockets.navigation</pre>, as the
<pre class="code">new</pre> expression that accesses it, so the package name doesn't need
to be prefixed.</p>

<p>Second, a package itself can be accessed from its containing
package without needing a prefix. In <a href="packages-and-imports.html#lst-concise">Listing 13.4</a>, look
at how class <pre class="code">Navigator</pre> is instantiated.  The <pre class="code">new</pre> expression
appears in package <pre class="code">bobsrockets</pre>, which is the containing package of
<pre class="code">bobsrockets.navigation</pre>.  Thus, it can access package
<pre class="code">bobsrockets.navigation</pre> as simply <pre class="code">navigation</pre>.</p>

<p>Third, when using the curly-braces packaging syntax, all names
accessible in scopes outside the packaging are also available inside
it.  An example in <a href="packages-and-imports.html#lst-concise">Listing 13.4</a> is the way <pre class="code">addShip()</pre>
creates a new <pre class="code">Ship</pre>. The method is defined within two packagings: an
outer one for <pre class="code">bobsrockets</pre>, and an inner one for
<pre class="code">bobsrockets.fleets</pre>. Since <pre class="code">Ship</pre> is accessible in the outer
packaging, it can be referenced from within <pre class="code">addShip()</pre>.</p>

<p>Note that this kind of access is only available if you explicitly nest
the packagings.  If you stick to one package per file, then&mdash;like in
Java&mdash;the only names available will be the ones defined in the
current package.  In <a href="packages-and-imports.html#lst-enclosing">Listing 13.5</a>, the packaging of
<pre class="code">bobsrockets.fleets</pre> has been moved to the top level.  Since it is no
longer enclosed in a packaging for <pre class="code">bobsrockets</pre>, names from
<pre class="code">bobsrockets</pre> are not immediately in scope.  As a result, <pre class="code">new</pre>&nbsp;<pre class="code">Ship</pre>
gives a compile error. If nesting packages with braces shifts your code uncomfortably to the right, you can also use multiple package
clauses without the braces.<a href="packages-and-imports.html#footnotemain13-1">[1]</a> For instance, the code below also defines
class <pre class="code">Fleet</pre> in two nested packages <pre class="code">bobrockets</pre> and <pre class="code">fleets</pre>, 
just like you saw it in <a href="packages-and-imports.html#lst-concise">Listing 13.4</a>:</p>

<pre>
  <code class="vem">package</code>&nbsp;bobsrockets
  <code class="vem">package</code>&nbsp;fleets
  <code class="vem">class</code>&nbsp;<code class="typename">Fleet</code>&nbsp;{
  &nbsp;&nbsp;<code class="comment">//&nbsp;No&nbsp;need&nbsp;to&nbsp;say&nbsp;bobsrockets.Ship</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;addShip()&nbsp;=&nbsp;{&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Ship</code>&nbsp;}
  }
</pre>


<p>One final trick is important to know.  Sometimes, you end up coding in
a heavily crowded scope where package names are hiding each other.  In
<a href="packages-and-imports.html#lst-hiding-packages">Listing 13.6</a>, the scope of class <pre class="code">MissionControl</pre>
includes three separate packages named <pre class="code">launch</pre>!  There's one
<pre class="code">launch</pre> in <pre class="code">bobsrockets.navigation</pre>, one in <pre class="code">bobsrockets</pre>,
and one at the top level.  How would you reference each of
<pre class="code">Booster1</pre>, <pre class="code">Booster2</pre>, and
<pre class="code">Booster3</pre>?<a id="i-370748244-1"/><a id="i-33124968-1"/></p>

<p>Accessing the first one is easiest.  A reference to <pre class="code">launch</pre> by
itself will get you to package <pre class="code">bobsrockets.navigation.launch</pre>,
because that is the <pre class="code">launch</pre> package defined in the closest enclosing
scope.  Thus, you can refer to the first booster class as simply
<pre class="code">launch.Booster1</pre>.  Referring to the second one also is not tricky.
You can write <pre class="code">bobrockets.launch.Booster2</pre> and be clear about which
one you are referencing.  That leaves the question of the third
booster class: How can you access <pre class="code">Booster3</pre>, considering
that a nested <pre class="code">launch</pre> package shadows the top-level one?</p>

<p>To help in this situation, Scala provides a package named <pre class="code">_root_</pre>
that is outside any package a user can write. Put another way, every
top-level package you can write is treated as a member of package
<pre class="code">_root_</pre>.  For example, both <pre class="code">launch</pre> and <pre class="code">bobsrockets</pre> of
<a href="packages-and-imports.html#lst-hiding-packages">Listing 13.6</a> are members of package
<pre class="code">_root_</pre>. As a result, <pre class="code">_root_.launch</pre> gives you the top-level
<pre class="code">launch</pre> package, and <pre class="code">_root_.launch.Booster3</pre> designates the
outermost booster class.</p>

<h3 id="sec-imports">13.3 Imports</h3>


<p>In Scala, packages and their members can be imported using <pre class="code">import</pre><a id="i1926037870-2"/>
clauses.  Imported items can then be accessed by a simple name
like <pre class="code">File</pre>, as opposed to requiring a qualified name like
<pre class="code">java.io.File</pre>. For example, consider the code shown in <a href="packages-and-imports.html#lst-bobs-fruits">Listing 13.7</a>.</p>

<p><a id="lst-bobs-fruits"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;bobsdelights
  <br />  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Fruit</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;name:&nbsp;<code class="typename">String</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;color:&nbsp;<code class="typename">String</code>
  &nbsp;&nbsp;)
  <br />  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Fruits</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Apple</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Fruit</code>(<code class="quotedstring">"apple"</code>,&nbsp;<code class="quotedstring">"red"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Orange</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Fruit</code>(<code class="quotedstring">"orange"</code>,&nbsp;<code class="quotedstring">"orange"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Pear</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Fruit</code>(<code class="quotedstring">"pear"</code>,&nbsp;<code class="quotedstring">"yellowish"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;menu&nbsp;=&nbsp;<code class="typename">List</code>(<code class="typename">Apple</code>,&nbsp;<code class="typename">Orange</code>,&nbsp;<code class="typename">Pear</code>)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 13.7 - Bob's delightful fruits, ready for import.</h5>


<p>An <pre class="code">import</pre> clause makes members of a package or object available by their
names alone without needing to prefix them by the package or object name.
Here are some simple examples:</p>

<pre>
  <code class="comment">//&nbsp;easy&nbsp;access&nbsp;to&nbsp;Fruit</code>
  <code class="vem">import</code>&nbsp;bobsdelights.Fruit
  <br />  <code class="comment">//&nbsp;easy&nbsp;access&nbsp;to&nbsp;all&nbsp;members&nbsp;of&nbsp;bobsdelights</code>
  <code class="vem">import</code>&nbsp;bobsdelights._
  <br />  <code class="comment">//&nbsp;easy&nbsp;access&nbsp;to&nbsp;all&nbsp;members&nbsp;of&nbsp;Fruits</code>
  <code class="vem">import</code>&nbsp;bobsdelights.Fruits._
</pre>


<p>The first of these corresponds to Java's single type import and the second
to Java's <em>on-demand</em> import.<a id="i-410901588-1"/><a id="i-1858203568-1"/>
The only difference is that Scala's on-demand
imports are written with a trailing underscore (<pre class="code">_</pre>) instead of an
asterisk (<pre class="code">*</pre>). (After all, <pre class="code">*</pre> is a valid identifier in Scala!)
The third import clause above corresponds to
Java's import of static class fields.</p>

<p>These three imports give you a taste of what imports can do,
but Scala imports are actually much more general.  For one,
imports in Scala can appear anywhere, not just at the beginning of a
compilation unit. Also, they can refer to arbitrary values. For instance,
the import shown in <a href="packages-and-imports.html#lst-importing-object-members">Listing 13.8</a> is possible:
<a id="lst-importing-object-members"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;showFruit(fruit:&nbsp;<code class="typename">Fruit</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">import</code>&nbsp;fruit._
  &nbsp;&nbsp;&nbsp;&nbsp;println(name&nbsp;+&nbsp;<code class="quotedstring">"s&nbsp;are&nbsp;"</code>&nbsp;+&nbsp;color)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 13.8 - Importing the members of a regular (not singleton) object.</h5>


<p>Method <pre class="code">showFruit</pre> imports all members of its parameter <pre class="code">fruit</pre>,
which is of type <pre class="code">Fruit</pre>. The subsequent <pre class="code">println</pre> statement can
refer to <pre class="code">name</pre> and <pre class="code">color</pre> directly. These two references are
equivalent to <pre class="code">fruit.name</pre> and <pre class="code">fruit.color</pre>.
This syntax is particularly
useful when you use objects as modules, which will be described in
<a href="modular-programming-using-objects.html">Chapter 29</a>.</p>

<div class="aside">
<h3>Scala's flexible imports</h3>


<p>Scala's <pre class="code">import</pre> clauses are quite a bit more flexible than
Java's. There are three principal differences. In Scala, imports:</p>

<ul>


<li>may appear anywhere


</li>
<li>may refer to objects (singleton or regular)
in addition to packages


</li>
<li>let you rename and hide some of the imported members


</li></ul>


</div>


<p>Another way Scala's imports are flexible is that
they can import packages themselves, not just their non-package
members.  This is only natural if you think of nested packages
being contained in their surrounding package. For example, in <a href="packages-and-imports.html#lst-importing-package-name">Listing 13.9</a>, 
the package <pre class="code">java.util.regex</pre> is imported. This makes <pre class="code">regex</pre> usable as a simple name. To access
the <pre class="code">Pattern</pre> singleton object from the <pre class="code">java.util.regex</pre> package, you can just say, <pre class="code">regex.Pattern</pre>,
as shown in <a href="packages-and-imports.html#lst-importing-package-name">Listing 13.9</a>:</p>

<p><a id="lst-importing-package-name"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;java.util.regex
  <br />  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">AStarB</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Accesses&nbsp;java.util.regex.Pattern</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;pat&nbsp;=&nbsp;regex.Pattern.compile(<code class="quotedstring">"a*b"</code>)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 13.9 - Importing a package name.</h5>


<p>Imports in Scala can also rename or hide members. This is done with an
<span style="font-style:italic">import selector clause</span> enclosed in braces, which follows the
object from which members are imported. Here are some examples:<a id="i-1172048805-1"/><a id="i-303565265-1"/><a id="i1981623788-1"/><a id="i-1574838534-1"/></p>

<p><pre class="code">import</pre>&nbsp;<pre class="code">Fruits.{Apple,</pre>&nbsp;<pre class="code">Orange}</pre></p>

<p><br />
This imports just members <pre class="code">Apple</pre> and <pre class="code">Orange</pre> from object
<pre class="code">Fruits</pre>.</p>

<p><pre class="code">import</pre>&nbsp;<pre class="code">Fruits.{Apple</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">McIntosh,</pre>&nbsp;<pre class="code">Orange}</pre></p>

<p><br />
This imports the two members <pre class="code">Apple</pre> and <pre class="code">Orange</pre> from object<a id="i-252838726-1"/><a id="i-1444404533-1"/>
<pre class="code">Fruits</pre>. However, the <pre class="code">Apple</pre> object is renamed to <pre class="code">McIntosh</pre>,
so this object can be accessed with either <pre class="code">Fruits.Apple</pre> or
<pre class="code">McIntosh</pre>. A renaming clause is always of the form 
"<pre class="code">&lt;original-name&gt;</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">&lt;new-name&gt;</pre>".</p>

<p><pre class="code">import</pre>&nbsp;<pre class="code">java.sql.{Date</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">SDate}</pre></p>

<p><br />
This imports the SQL date class as <pre class="code">SDate</pre>, so that you
can simultaneously import the normal Java date class
as simply <pre class="code">Date</pre>.</p>

<p><pre class="code">import</pre>&nbsp;<pre class="code">java.{sql</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">S}</pre></p>

<p><br />
This imports the <pre class="code">java.sql</pre> package as <pre class="code">S</pre>, so that you
can write things like <pre class="code">S.Date</pre>.</p>

<p><pre class="code">import</pre>&nbsp;<pre class="code">Fruits.{_}</pre></p>

<p><br />
This imports all members from object <pre class="code">Fruits</pre>. It means the same
thing as <pre class="code">import</pre>&nbsp;<pre class="code">Fruits._</pre>.<a id="i91932059-1"/></p>

<p><pre class="code">import</pre>&nbsp;<pre class="code">Fruits.{Apple</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">McIntosh,</pre>&nbsp;<pre class="code">_}</pre></p>

<p><br />
This imports all members from object <pre class="code">Fruits</pre> but renames <pre class="code">Apple</pre> to <pre class="code">McIntosh</pre>.</p>

<p><pre class="code">import</pre>&nbsp;<pre class="code">Fruits.{Pear</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">_,</pre>&nbsp;<pre class="code">_}</pre><a id="i1258079951-1"/></p>

<p><br />
This imports all members of <pre class="code">Fruits</pre> <span style="font-style:italic">except</span> <pre class="code">Pear</pre>.
A clause of the form "<pre class="code">&lt;original-name&gt;</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">_</pre>"
excludes <pre class="code">&lt;original-name&gt;</pre> from the names that are imported. In a sense, renaming 
something to `<pre class="code">_</pre>' means hiding it altogether. This is useful to avoid<a id="i-236944399-1"/>
ambiguities. Say you have two packages, <pre class="code">Fruits</pre> and <pre class="code">Notebooks</pre>, which both define a class
<pre class="code">Apple</pre>. If you want to get just the notebook named <pre class="code">Apple</pre>, and not the fruit, 
you could still use two imports on demand like this:</p>

<pre>
  <code class="vem">import</code>&nbsp;Notebooks._
  <code class="vem">import</code>&nbsp;Fruits.{<code class="typename">Apple</code>&nbsp;=&gt;&nbsp;_,&nbsp;_}
</pre>


<p>This would import all <pre class="code">Notebooks</pre> and all <pre class="code">Fruits</pre>, except for <pre class="code">Apple</pre>.</p>

<p><br />
These examples demonstrate the great flexibility Scala offers
when it comes to importing members selectively and possibly under
different names.  In summary, an import selector can
consist of the following:</p>

<ul>


<li>A simple name <pre class="code">x</pre>. This includes <pre class="code">x</pre> in the set of imported names.


</li>
<li>A renaming clause <pre class="code">x</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">y</pre>. This makes the member named <pre class="code">x</pre> visible
      under the name <pre class="code">y</pre>.


</li>
<li>A hiding clause  <pre class="code">x</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">_</pre>. This excludes <pre class="code">x</pre> from the set of imported names.


</li>
<li>A <em>catch-all</em> `<pre class="code">_</pre>'. This imports all members except those members
      mentioned in a preceding clause. If a catch-all is given, it must come
      last in the list of import selectors.


</li></ul>


<p>The simpler import clauses shown at the beginning of this section
can be seen as special abbreviations of 
import clauses with a selector clause. For example, "<pre class="code">import</pre>&nbsp;<pre class="code">p._</pre>" is equivalent to
"<pre class="code">import</pre>&nbsp;<pre class="code">p.{_}</pre>" and "<pre class="code">import</pre>&nbsp;<pre class="code">p.n</pre>" is equivalent to "<pre class="code">import</pre>&nbsp;<pre class="code">p.{n}</pre>".</p>

<h3>13.4 Implicit imports</h3>


<p>Scala adds some imports implicitly to every program. In essence, it is as if<a id="i-1027603681-1"/><a id="i586706545-2"/><a id="i1384274725-1"/>
the following three import clauses had been added to the top of every source file with 
extension "<pre class="code">.scala</pre>":</p>

<pre>
  <code class="vem">import</code>&nbsp;java.lang._&nbsp;<code class="comment">//&nbsp;everything&nbsp;in&nbsp;the&nbsp;java.lang&nbsp;package</code>
  <code class="vem">import</code>&nbsp;scala._&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;everything&nbsp;in&nbsp;the&nbsp;scala&nbsp;package</code>
  <code class="vem">import</code>&nbsp;Predef._&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;everything&nbsp;in&nbsp;the&nbsp;Predef&nbsp;object</code>
</pre>


<p>The <pre class="code">java.lang</pre> package contains standard Java classes. It is always
implicitly imported in Scala source files.<a href="packages-and-imports.html#footnotemain13-2">[2]</a> Because <pre class="code">java.lang</pre> is imported implicitly, 
you can write <pre class="code">Thread</pre> instead of <pre class="code">java.lang.Thread</pre>, for instance.</p>

<p>As you have no doubt realized by now, the <pre class="code">scala</pre> package contains
the standard Scala library, with many common classes and
objects. Because <pre class="code">scala</pre> is imported implicitly, you can write
<pre class="code">List</pre> instead of <pre class="code">scala.List</pre>, for instance.</p>

<p>The <pre class="code">Predef</pre> object contains many definitions of types, methods, and
implicit conversions that are commonly used on Scala programs. For example, because
<pre class="code">Predef</pre> is imported implicitly, you can write <pre class="code">assert</pre> instead of
<pre class="code">Predef.assert</pre>.</p>

<p>These three import clauses are treated a bit specially in that
later imports overshadow earlier ones. For instance, the
<pre class="code">StringBuilder</pre> class is defined both in package <pre class="code">scala</pre> and, from
Java version 1.5 on, also in package <pre class="code">java.lang</pre>.  Because the
<pre class="code">scala</pre> import overshadows the <pre class="code">java.lang</pre> import, the simple name
<pre class="code">StringBuilder</pre> will refer to <pre class="code">scala.StringBuilder</pre>, not
<pre class="code">java.lang.StringBuilder</pre>.</p>

<h3 id="sec-access-modifiers">13.5 Access modifiers</h3>


<p>Members of packages, classes, or objects can be labeled with the<a id="i436061376-1"/>
access modifiers <pre class="code">private</pre> and <pre class="code">protected</pre>. These modifiers restrict
access to the members to certain regions of code.  Scala's
treatment of access modifiers roughly follows Java's but there are
some important differences which are explained in this section.</p>

<h4>Private members</h4>


<p>Private members in Scala are treated similarly to Java. A member labeled<a id="i-698337515-1"/><a id="i835454125-1"/>
<pre class="code">private</pre> is visible only inside the class or
object that contains the member definition. 
In Scala, this rule applies
also for inner classes.  This treatment is more consistent, but
differs from Java.  Consider the example shown in <a href="packages-and-imports.html#lst-private-access-differs">Listing 13.10</a>.</p>

<p><a id="lst-private-access-differs"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Outer</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Inner</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;f()&nbsp;=&nbsp;{&nbsp;println(<code class="quotedstring">"f"</code>)&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">InnerMost</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f()&nbsp;<code class="comment">//&nbsp;OK</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">Inner</code>).f()&nbsp;<code class="comment">//&nbsp;error:&nbsp;f&nbsp;is&nbsp;not&nbsp;accessible</code>
  &nbsp;&nbsp;}
</pre>


<h5>Listing 13.10 - How private access differs in Scala and Java.</h5>


<p>In Scala, the access <pre class="code">(new</pre>&nbsp;<pre class="code">Inner).f()</pre> is illegal because <pre class="code">f</pre> is declared <pre class="code">private</pre>
in <pre class="code">Inner</pre> and the access is not from within class <pre class="code">Inner</pre>. By contrast,
the first access to <pre class="code">f</pre> in class <pre class="code">InnerMost</pre> is OK, because that access is 
contained in the body of class <pre class="code">Inner</pre>. Java would permit both accesses 
because it lets an outer class access private members of its inner
classes.</p>

<h4>Protected members</h4>


<p>Access to <pre class="code">protected</pre> members in Scala is also a bit more restrictive than in Java.<a id="i-711542007-1"/>
In Scala, a <pre class="code">protected</pre> member is only accessible from subclasses of
the class in which the member is defined.  In Java such accesses are
also possible from other classes in the same package. In Scala, there
is another way to achieve this effect<a href="packages-and-imports.html#footnotemain13-3">[3]</a> so <pre class="code">protected</pre>
is free to be left as is. The example shown
in <a href="packages-and-imports.html#lst-protected-access-differs">Listing 13.11</a> illustrates protected accesses.
<a id="lst-protected-access-differs"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;p&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Super</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">def</code>&nbsp;f()&nbsp;=&nbsp;{&nbsp;println(<code class="quotedstring">"f"</code>)&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Sub</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Super</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f()
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Other</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">Super</code>).f()&nbsp;&nbsp;<code class="comment">//&nbsp;error:&nbsp;f&nbsp;is&nbsp;not&nbsp;accessible</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 13.11 - How protected access differs in Scala and Java.</h5>


<p>In <a href="packages-and-imports.html#lst-protected-access-differs">Listing 13.11</a>, the access to <pre class="code">f</pre> in class <pre class="code">Sub</pre> is OK because <pre class="code">f</pre> is
declared <pre class="code">protected</pre> in <pre class="code">Super</pre> and <pre class="code">Sub</pre> is a subclass of
<pre class="code">Super</pre>. By contrast the access to <pre class="code">f</pre> in <pre class="code">Other</pre> is not permitted,
because <pre class="code">Other</pre> does not inherit from <pre class="code">Super</pre>. In Java, the latter
access would be still permitted because <pre class="code">Other</pre> is in the same
package as <pre class="code">Sub</pre>.</p>

<h4>Public members</h4>


<p>Scala has no explicit modifier for public members:
Any member not labeled <pre class="code">private</pre> or <pre class="code">protected</pre> is
public. Public
members can be accessed from anywhere.</p>

<p><a id="lst-access-qualifiers"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;bobsrockets
  <br />  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;navigation&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[bobsrockets]&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Navigator</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">protected</code>[navigation]&nbsp;<code class="vem">def</code>&nbsp;useStarChart()&nbsp;=&nbsp;{}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">LegOfJourney</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[<code class="typename">Navigator</code>]&nbsp;<code class="vem">val</code>&nbsp;distance&nbsp;=&nbsp;<code class="literal">100</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[<code class="vem">this</code>]&nbsp;<code class="vem">var</code>&nbsp;speed&nbsp;=&nbsp;<code class="literal">200</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;launch&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">import</code>&nbsp;navigation._
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Vehicle</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[launch]&nbsp;<code class="vem">val</code>&nbsp;guide&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Navigator</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 13.12 - Flexible scope of protection with access qualifiers.</h5>


<h4>Scope of protection</h4>


<p><a id="subsec-scope-of-protection"/></p>

<p>Access modifiers in Scala can be augmented with qualifiers. A modifier
of the form <pre class="code">private[X]</pre> or <pre class="code">protected[X]</pre> means that access is private or protected
"up to" <pre class="code">X</pre>, where <pre class="code">X</pre> designates some enclosing package, class or singleton object.<a id="i488929967-1"/></p>

<p>Qualified access modifiers give you very fine-grained control over
visibility. In particular they enable you to express Java's
accessibility notions, such as package private, package protected, or
private up to outermost class, which are not directly expressible with
simple modifiers in Scala. But they also let you express accessibility
rules that cannot be expressed in Java.</p>

<p><a href="packages-and-imports.html#lst-access-qualifiers">Listing 13.12</a> presents an example with many access qualifiers being used. 
In this listing, class <pre class="code">Navigator</pre> is labeled <pre class="code">private[bobsrockets]</pre>.
This means that this class is visible in all classes and objects
that are contained in package <pre class="code">bobsrockets</pre>. In particular, the access
to <pre class="code">Navigator</pre> in object <pre class="code">Vehicle</pre> is permitted because <pre class="code">Vehicle</pre> is
contained 
in package <pre class="code">launch</pre>, which is contained in
<pre class="code">bobsrockets</pre>.  On the other hand, all code outside the
package <pre class="code">bobsrockets</pre> cannot access class <pre class="code">Navigator</pre>.</p>

<p>This technique is quite useful in large projects that span several
packages. It allows you to define things that are visible in several
sub-packages of your project but that remain hidden from clients
external to your project. The same technique is not possible in Java.
There, once a definition escapes its immediate package boundary, it is
visible to the world at large.</p>

<p>Of course, the qualifier of a <pre class="code">private</pre> may also be the directly
enclosing package. An example is the access modifier of <pre class="code">guide</pre>
in object <pre class="code">Vehicle</pre> in <a href="packages-and-imports.html#lst-access-qualifiers">Listing 13.12</a>. Such an access modifier is equivalent to Java's
package-private access.<a id="i908525335-1"/></p>

<p><a id="tab-leg-of-journey-private"/></p>

<h5>Table 13.1 - Effects of private qualifiers on <pre class="code">LegOfJourney.distance</pre></h5>


<div style="text-align: center">


<table style="border-collapse: collapse">
<tr class="topline ">
  <td>
    <em>no access modifier</em>
  </td>
  <td>
    public access
  </td>
</tr>
<tr>
  <td>
    <pre class="code">private[bobsrockets]</pre>
  </td>
  <td>
    access within outer package
  </td>
</tr>
<tr>
  <td>
    <pre class="code">private[navigation]</pre>
  </td>
  <td>
    same as package visibility in Java
  </td>
</tr>
<tr>
  <td>
    <pre class="code">private[Navigator]</pre>
  </td>
  <td>
    same as <pre class="code">private</pre> in Java
  </td>
</tr>
<tr>
  <td>
    <pre class="code">private[LegOfJourney]</pre>
  </td>
  <td>
    same as <pre class="code">private</pre> in Scala
  </td>
</tr>
<tr class="bottomline">
  <td>
    <pre class="code">private[this]</pre>
  </td>
  <td>
    access only from same object
  </td>
</tr>
</table>


</div>


<p>All qualifiers can also be applied to <pre class="code">protected</pre>, with the same
meaning as <pre class="code">private</pre>. That is, a modifier <pre class="code">protected[X]</pre> in a
class <pre class="code">C</pre> allows access to the labeled definition in all subclasses
of <pre class="code">C</pre> and also within the enclosing package, class, or object <pre class="code">X</pre>.
For instance, the <pre class="code">useStarChart</pre> method in <a href="packages-and-imports.html#lst-access-qualifiers">Listing 13.12</a>
is accessible in all subclasses of <pre class="code">Navigator</pre> and also in all
code contained in the enclosing package <pre class="code">navigation</pre>. It thus
corresponds exactly to the meaning of <pre class="code">protected</pre> in Java.</p>

<p>The qualifiers of <pre class="code">private</pre> can also refer to an enclosing class or
object.  For instance the <pre class="code">distance</pre> variable in class <pre class="code">LegOfJourney</pre> in <a href="packages-and-imports.html#lst-access-qualifiers">Listing 13.12</a> is
labeled <pre class="code">private[Navigator]</pre>, so it is visible from everywhere in
class <pre class="code">Navigator</pre>. This gives the same access capabilities as for
private members of inner classes in Java. A <pre class="code">private[C]</pre> where <pre class="code">C</pre>
is the outermost enclosing class is the same as just <pre class="code">private</pre> in
Java.<a id="i570723644-1"/><a id="i-1579182668-1"/></p>

<p>Finally, Scala also has an access modifier that is even more<a id="i-1909160422-1"/><a id="i623710400-1"/>
restrictive than <pre class="code">private</pre>.  A definition labeled <pre class="code">private[this]</pre>
is accessible only from within the same object that contains the
definition. Such a definition is called <span style="font-style:italic">object-private</span>.
For instance, the definition of <pre class="code">speed</pre>
in class <pre class="code">Navigator</pre> in <a href="packages-and-imports.html#lst-access-qualifiers">Listing 13.12</a> is
object-private. This means that any access must not only
be within class <pre class="code">Navigator</pre>, it must also be made from
the very same instance of <pre class="code">Navigator</pre>.  Thus 
the accesses "<pre class="code">speed</pre>" and "<pre class="code">this.speed</pre>" would be
legal from within <pre class="code">Navigator</pre>.</p>

<p>The following access, though, would not be allowed, even if it
appeared inside class <pre class="code">Navigator</pre>:</p>

<pre>
  <code class="vem">val</code>&nbsp;other&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Navigator</code>
  other.speed&nbsp;<code class="comment">//&nbsp;this&nbsp;line&nbsp;would&nbsp;not&nbsp;compile</code>
</pre>


<p>Marking a member <pre class="code">private[this]</pre> is a guarantee that 
it will not be seen from other objects of the same class. This can be
useful for documentation. It also sometimes lets
you write 
more general variance annotations (see
<a href="type-parameterization.html#variance-object-local">Section 19.7</a> for details).</p>

<p>To summarize, <a href="packages-and-imports.html#tab-leg-of-journey-private">Table 13.1</a>  <a href="packages-and-imports.html#tab-leg-of-journey-private">here</a> lists the effects of <pre class="code">private</pre>
qualifiers. Each line shows a qualified private modifier and what it
would mean if such a modifier were attached to
the <pre class="code">distance</pre> variable declared in class
<pre class="code">LegOfJourney</pre> in <a href="packages-and-imports.html#lst-access-qualifiers">Listing 13.12</a>.</p>

<h4>Visibility and companion objects</h4>


<p><a id="i-565810484-1"/></p>

<p>In Java, static members and instance members belong to the same class,
so access modifiers apply uniformly to them. You have already seen
that in Scala there are no static members; instead you can have a
companion object that contains members that exist only once.
For instance, in <a href="packages-and-imports.html#lst-companion-private">Listing 13.13</a> object <pre class="code">Rocket</pre> is a companion
of class <pre class="code">Rocket</pre>.
<a id="lst-companion-private"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Rocket</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">import</code>&nbsp;Rocket.fuel
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;canGoHomeAgain&nbsp;=&nbsp;fuel&nbsp;&gt;&nbsp;<code class="literal">20</code>
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Rocket</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;fuel&nbsp;=&nbsp;<code class="literal">10</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;chooseStrategy(rocket:&nbsp;<code class="typename">Rocket</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(rocket.canGoHomeAgain)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goHome()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pickAStar()
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;goHome()&nbsp;=&nbsp;{}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;pickAStar()&nbsp;=&nbsp;{}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 13.13 - Accessing private members of companion classes and objects.</h5>


<p>Scala's access rules privilege companion objects and classes when it
comes to private or protected accesses. A class shares all its access
rights with its companion object and <i>vice versa</i>.  In particular,
an object can access all private members of its companion class, just
as a class can access all private members of its companion object.</p>

<p>For instance, the <pre class="code">Rocket</pre> class in <a href="packages-and-imports.html#lst-companion-private">Listing 13.13</a> can access method <pre class="code">fuel</pre>,
which is declared <pre class="code">private</pre> in object <pre class="code">Rocket</pre>. Analogously, the
<pre class="code">Rocket</pre> object can access the private method <pre class="code">canGoHomeAgain</pre>
in class <pre class="code">Rocket</pre>.</p>

<p>One exception where the similarity between Scala and Java breaks down
concerns <pre class="code">protected</pre> <pre class="code">static</pre> members.  A protected static member of
a Java class <pre class="code">C</pre> can be accessed in all subclasses of <pre class="code">C</pre>.  By
contrast, a <pre class="code">protected</pre> member in a companion object makes no sense,
as singleton objects don't have any subclasses.</p>

<h3 id="sec-package-objects">13.6 Package objects</h3>


<p>So far, the only code you have seen added to packages are classes,
traits, and standalone objects.  These are by far the most common
definitions that are placed at the top level of a package. But Scala
doesn't limit you to just those&mdash;Any kind of definition that you can put
inside a class can also be at the top level of a package. If
you have some helper method you'd like to be in scope for an entire
package, go ahead and put it right at the top level of the package.</p>

<p>To do so, put the definitions in a <em>package object</em><a id="i-853360368-1"/>.  Each package is allowed to have one package object.  Any
definitions placed in a package object are considered members of the
package itself.</p>

<p>An example is shown in <a href="packages-and-imports.html#lst-package-object">Listing 13.14</a>.  File
<span class="texttt">package.scala</span> holds a package object for package
<pre class="code">bobsdelights</pre>.  Syntactically, a package object looks much like one
of the curly-braces packagings shown earlier in the chapter.  The only
difference is that it includes the <pre class="code">object</pre> keyword.  It's a package
<em>object</em>, not a <em>package</em>.  The contents of the curly braces
can include any definitions you like.  In this case, the package
object includes the <pre class="code">showFruit</pre> utility method from
<a href="packages-and-imports.html#lst-importing-object-members">Listing 13.8</a>.</p>

<p>Given that definition, any other code in any package can import
the method just like it would import a class.  For example,
<a href="packages-and-imports.html#lst-package-object">Listing 13.14</a> also shows the standalone object
<pre class="code">PrintMenu</pre>, which is located in a different package.  <pre class="code">PrintMenu</pre>
can import the utility method <pre class="code">showFruit</pre> in the same way it would
import the class <pre class="code">Fruit</pre>.</p>

<p><a id="lst-package-object"/></p>

<pre>
  &nbsp;&nbsp;<code class="comment">//&nbsp;In&nbsp;file&nbsp;bobsdelights/package.scala</code>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;<code class="vem">object</code>&nbsp;bobsdelights&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;showFruit(fruit:&nbsp;<code class="typename">Fruit</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">import</code>&nbsp;fruit._
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(name&nbsp;+&nbsp;<code class="quotedstring">"s&nbsp;are&nbsp;"</code>&nbsp;+&nbsp;color)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<code class="comment">//&nbsp;In&nbsp;file&nbsp;PrintMenu.scala</code>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;printmenu
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;bobsdelights.Fruits
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;bobsdelights.showFruit
  <br />  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">PrintMenu</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;main(args:&nbsp;<code class="typename">Array[String]</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(fruit&nbsp;&lt;-&nbsp;Fruits.menu)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showFruit(fruit)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 13.14 - A package object.</h5>


<p>Looking ahead, there are other uses of package objects for kinds of
definitions you haven't seen yet.  Package objects are frequently used
to hold package-wide type aliases
(<a href="abstract-members.html">Chapter 20</a>) and implicit conversions
(<a href="implicit-conversions-and-parameters.html">Chapter 21</a>).
The top-level <pre class="code">scala</pre> package has a package object, and its definitions
are available to all Scala code.</p>

<p>Package objects are compiled to class files named <pre class="code">package.class</pre>
that are the located in the directory of the package that they
augment. It's useful to keep the same convention for source files. So
you would typically put the source file of the package object
<pre class="code">bobsdelights</pre> of <a href="packages-and-imports.html#lst-package-object">Listing 13.14</a> into a file named
<pre class="code">package.scala</pre> that resides in the <pre class="code">bobsdelights</pre> directory.</p>

<h3>13.7 Conclusion</h3>


<p>In this chapter, you saw the basic constructs for dividing a program into
packages.  This gives you a simple and useful kind of modularity, so
that you can work with very large bodies of code without different
parts of the code trampling on each other.  Scala's system is the same
in spirit as Java's packages, but there are some
differences where Scala chooses to be more consistent or more general.</p>

<p>Looking ahead, <a href="modular-programming-using-objects.html">Chapter 29</a> describes a more flexible module
system than division into packages.  In addition to letting you
separate code into several namespaces, that approach allows modules to
be parameterized and inherit from each other. In the next chapter, we'll turn our attention
to assertions and unit testing.</p>

<hr/>
<h4>Footnotes for Chapter 13:</h4>


<p><a id="footnotemain13-1"/>[1] This style of multiple package clauses without braces is called <em>chained package clauses</em><a id="i2070019594-1"/><a id="i-1154528502-2"/>.</p>

<p><a id="footnotemain13-2"/>[2] Scala also originally had an
implementation on <pre class="code">.NET</pre>.<a id="i77181-3"/>, where namespace <pre class="code">System</pre>, 
the <pre class="code">.NET</pre> analogue of package <pre class="code">java.lang</pre>, was imported instead.</p>

<p><a id="footnotemain13-3"/>[3] Using <span class="textit">qualifiers</span>, described in "Scope of protection"  <a href="packages-and-imports.html#subsec-scope-of-protection">here</a>.</p>

<div style="page-break-after:always"/>


<div style="page-break-after:always"/>

</body>
</html>
