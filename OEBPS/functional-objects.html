<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8"/>
    <title>Programming in Scala, 3rd Edition</title>

    <link rel="stylesheet" type="text/css" href="book.css" />
  </head>
<body>
<h2><a id="chap-functional-objects">Chapter 6</a></h2>
<h1>Functional Objects</h1>


<p>With the understanding of Scala basics you've gained from previous
chapters, you're ready to design more full-featured classes
in Scala. In this chapter, the emphasis is on classes that define
functional objects, or objects that do not have any mutable
state.<a id="i47852440-1"/> As a running example, we'll create several variants of a class
that models rational numbers as immutable objects. Along the way,
we'll show you more aspects of object-oriented programming in Scala:
class parameters and constructors, methods and operators, private
members, overriding, checking preconditions, overloading, and self
references<a id="i1689782844-2"/><a id="i-2121954815-1"/>.</p>

<h3 id="sec-class-for-rational-numbers">6.1 A specification for class <pre class="code">Rational</pre></h3>


<p>A <em>rational number</em> is a number that can be expressed as a ratio <sup>n</sup>/<sub>d</sub>,
where <i>n</i> and <i>d</i> are integers, except that <i>d</i> cannot be zero.
<i>n</i> is called the <span style="font-style:italic">numerator</span> and <i>d</i> the <span style="font-style:italic">denominator</span>.
Examples of rational numbers are <sup>1</sup>/<sub>2</sub>, <sup>2</sup>/<sub>3</sub>, <sup>112</sup>/<sub>239</sub>, and
<sup>2</sup>/<sub>1</sub>. Compared to floating-point numbers, rational numbers have
the advantage that fractions are represented exactly, without
rounding or approximation.</p>

<p>The class we'll design in this chapter must model the behavior of rational numbers, including
allowing them to be added, subtracted, multiplied, and divided.
To add two rationals, you must first obtain a common
denominator, then add the two numerators. For example, to add <sup>1</sup>/<sub>2</sub> + <sup>2</sup>/<sub>3</sub>, you multiply both parts of
the left operand by 3 and both parts of the right operand by 2, which gives you <sup>3</sup>/<sub>6</sub> +
<sup>4</sup>/<sub>6</sub>. Adding the two numerators yields the result,
<sup>7</sup>/<sub>6</sub>. To multiply two rational numbers, you can simply multiply
their numerators and multiply their denominators. Thus,
<sup>1</sup>/<sub>2</sub> * <sup>2</sup>/<sub>5</sub> gives <sup>2</sup>/<sub>10</sub>, which can be
represented more compactly in its "normalized" form as <sup>1</sup>/<sub>5</sub>.  You divide by
swapping the numerator and denominator of the right operand and then
multiplying.  For instance <sup>1</sup>/<sub>2</sub> / <sup>3</sup>/<sub>5</sub> is the same as
<sup>1</sup>/<sub>2</sub> * <sup>5</sup>/<sub>3</sub>, or <sup>5</sup>/<sub>6</sub>.</p>

<p>One, maybe rather trivial, observation is that in mathematics, rational numbers do
not have mutable state. You can add one rational number to another, but the
result will be a new rational number.  The original numbers will not
have "changed." The immutable <pre class="code">Rational</pre> class we'll design in this chapter will have the same
property. Each rational number will be represented by one <pre class="code">Rational</pre>
object. When you add two
<pre class="code">Rational</pre> objects, you'll create a new <pre class="code">Rational</pre> object to hold the sum.</p>

<p>This chapter will give you a glimpse of some of the ways Scala enables you to write libraries 
that feel like native language support. For example, at the end of this chapter you'll
be able to do this with class <pre class="code">Rational</pre>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;oneHalf&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">oneHalf:&nbsp;Rational&nbsp;=&nbsp;1/2</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;twoThirds&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">twoThirds:&nbsp;Rational&nbsp;=&nbsp;2/3</code>
  <br />  scala&gt;&nbsp;(oneHalf&nbsp;/&nbsp;<code class="literal">7</code>)&nbsp;+&nbsp;(<code class="literal">1</code>&nbsp;-&nbsp;twoThirds)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">res0:&nbsp;Rational&nbsp;=&nbsp;17/42</code>
</pre>


<h3>6.2 Constructing a <pre class="code">Rational</pre></h3>


<p>A good place to start designing class <pre class="code">Rational</pre> is to consider how client programmers
will create a new <pre class="code">Rational</pre> object. Given we've decided to make <pre class="code">Rational</pre> objects immutable,
we'll require that clients provide all data needed by an instance (in this case, a numerator and
a denominator) when they construct the instance. Thus, we will start the
design with this:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)
</pre>


<p>One of the first things to note about this line of code is that if a class doesn't have
a body, you don't need to specify empty curly braces (though you could,
of course, if you wanted
to).<a id="i-1274918996-1"/><a id="i-1738295964-1"/>
The identifiers <pre class="code">n</pre> and <pre class="code">d</pre> in the
parentheses after the class name, <pre class="code">Rational</pre>, are called <em>class
parameters</em><a id="i177886610-1"/>. The Scala compiler will gather up these two class
parameters and create a <em>primary constructor</em> that takes the same
two parameters.<a id="i2081307927-1"/><a id="i161912641-1"/></p>

<div class="aside">
<h3>Immutable object trade-offs</h3>


<p>Immutable objects offer several advantages over mutable objects, and one
potential disadvantage.<a id="i1835948581-1"/> First, immutable objects are often easier to reason
about than mutable ones, because they do not have complex state spaces
that change over time. Second, you can pass immutable objects around
quite freely, whereas you may need to make defensive copies<a id="i-1422525536-1"/> of mutable
objects before passing them to other code. Third, there is no way for
two threads concurrently accessing an immutable to corrupt its state
once it has been properly constructed, because no thread can change the state of an immutable. Fourth, immutable objects make
safe hash table keys. If a mutable object is mutated after it is
placed into a <pre class="code">HashSet</pre>, for example, that object may not be found
the next time you look into the <pre class="code">HashSet</pre>.</p>

<p>The main disadvantage of immutable objects is that they sometimes
require that a large object graph be copied, whereas an update
could be done in its place. In some cases this can be awkward to express
and might also cause a performance bottleneck.  As a result, it is<a id="i-222173474-1"/>
not uncommon for libraries to provide mutable alternatives to immutable classes. For
example, class <pre class="code">StringBuilder</pre> is a mutable alternative to the immutable <pre class="code">String</pre>. We'll
give you more information on designing mutable objects in Scala in
<a href="mutable-objects.html">Chapter 18</a>.</p>

</div>


<div class="note">
<h4>Note</h4>


<p>This initial <pre class="code">Rational</pre> example highlights a difference between Java and Scala.<a id="i263298648-1"/>
In Java, classes have constructors, which can take parameters; whereas in Scala, classes can take parameters directly.
The Scala notation is more concise&mdash;class parameters can be used directly in the 
body of the class; there's no need to define fields and write assignments that copy
constructor parameters into fields. This can yield substantial savings in boilerplate code, 
especially for small classes.</p>

</div>


<p>The Scala compiler will compile any code you place in the class body, which isn't part of a field or a method
definition, into the primary constructor.
For example, you could print a debug message like this:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;println(<code class="quotedstring">"Created&nbsp;"</code>&nbsp;+&nbsp;n&nbsp;+&nbsp;<code class="quotedstring">"/"</code>&nbsp;+&nbsp;d)
  }
</pre>


<p>Given this code, the Scala compiler would place the call to <pre class="code">println</pre> into <pre class="code">Rational</pre>'s primary constructor.
The <pre class="code">println</pre> call will, therefore, print its debug message whenever you create a new <pre class="code">Rational</pre> instance:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">Created&nbsp;1/2</code>
  <code class="output">res0:&nbsp;Rational&nbsp;=&nbsp;Rational@2591e0c9</code>
</pre>


<h3 id="sec-reimp-tostring">6.3 Reimplementing the <pre class="code">toString</pre> method</h3>


<p>When we created an instance of <pre class="code">Rational</pre> in the previous example, the interpreter
printed "Rational@90110a". 
The interpreter obtained this somewhat funny looking string by
calling <pre class="code">toString</pre> on the <pre class="code">Rational</pre> object. By default, class <pre class="code">Rational</pre> 
inherits the implementation of <pre class="code">toString</pre> defined in class <pre class="code">java.lang.Object</pre>,
which just prints the class name, an @ sign, and a hexadecimal number.
The result of <pre class="code">toString</pre> is primarily intended to help programmers by providing information that can be used in
debug print statements, log messages, test failure reports, and interpreter and debugger output. The result currently
provided by <pre class="code">toString</pre> is not especially helpful because it doesn't give any clue about the rational number's value. A more useful implementation of <pre class="code">toString</pre> 
would print out the values of the <pre class="code">Rational</pre>'s numerator and denominator.
You can <em>override</em> the default implementation by adding a method <pre class="code">toString</pre>
to class <pre class="code">Rational</pre>, like this:<a id="i-189935346-1"/><a id="i-720005867-1"/></p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;n&nbsp;+&nbsp;<code class="quotedstring">"/"</code>&nbsp;+&nbsp;d
  }
</pre>


<p>The <pre class="code">override</pre> modifier in front of a method definition signals that a previous method definition
is overridden (more on this in <a href="composition-and-inheritance.html">Chapter 10</a>).
Since <pre class="code">Rational</pre> numbers will display nicely now,
we removed the debug <pre class="code">println</pre> statement we put into the body of
previous version of class <pre class="code">Rational</pre>.<a id="i1201360043-1"/>
You can test the new behavior of <pre class="code">Rational</pre> in the interpreter:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;x&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">1</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">x:&nbsp;Rational&nbsp;=&nbsp;1/3</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;y&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">5</code>,&nbsp;<code class="literal">7</code>)
  <code class="output">y:&nbsp;Rational&nbsp;=&nbsp;5/7</code>
</pre>


<h3 id="sec-checking-preconditions">6.4 Checking preconditions</h3>


<p>As a next step, we will turn our attention to a problem with the<a id="i1294809499-1"/>
current behavior of the primary constructor.  As mentioned at the
beginning of this chapter, rational numbers may not have a zero in the
denominator. Currently, however, the primary constructor accepts a
zero passed as <pre class="code">d</pre>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">5</code>,&nbsp;<code class="literal">0</code>)
  <code class="output">res1:&nbsp;Rational&nbsp;=&nbsp;5/0</code>
</pre>


<p>One of the benefits of object-oriented programming is that it allows
you to encapsulate data inside objects so that you can ensure the data
is valid throughout its lifetime.  In the case of an immutable object
such as <pre class="code">Rational</pre>, this means that you should ensure the data is
valid when the object is constructed. Given that a zero denominator is
an invalid state for a <pre class="code">Rational</pre> number, you should not let a
<pre class="code">Rational</pre> be constructed if a zero is passed in the <pre class="code">d</pre> parameter.</p>

<p>The best way to approach this problem is to define as a <em>precondition</em> of the primary
constructor that <pre class="code">d</pre> must be non-zero. A precondition is a constraint on values passed into
a method or constructor, a requirement which callers must fulfill. 
One way to do that is to use <pre class="code">require</pre>,<a href="functional-objects.html#footnotemain6-1">[1]</a>
like this:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;require(d&nbsp;!=&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;n&nbsp;+&nbsp;<code class="quotedstring">"/"</code>&nbsp;+&nbsp;d
  }
</pre>


<p>The <pre class="code">require</pre> method takes one boolean parameter. If the passed value
is true, <pre class="code">require</pre> will return normally<a id="i-2113140869-1"/>. Otherwise,
<pre class="code">require</pre> will prevent the object from being constructed by throwing an <pre class="code">IllegalArgumentException</pre>.</p>

<h3 id="sec-adding-fields">6.5 Adding fields</h3>


<p>Now that the primary constructor is properly enforcing its precondition, we will turn our
attention to supporting addition.  To do so, we'll define
a public <pre class="code">add</pre> method on class <pre class="code">Rational</pre> that takes another <pre class="code">Rational</pre> as a parameter.
To keep <pre class="code">Rational</pre> immutable, the <pre class="code">add</pre> method must not add the passed rational number to itself.
Rather, it must create and return a new <pre class="code">Rational</pre> that holds the sum.
You might think you could write <pre class="code">add</pre> this way:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{&nbsp;<code class="comment">//&nbsp;This&nbsp;won't&nbsp;compile</code>
  &nbsp;&nbsp;require(d&nbsp;!=&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;n&nbsp;+&nbsp;<code class="quotedstring">"/"</code>&nbsp;+&nbsp;d
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;add(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(n&nbsp;*&nbsp;that.d&nbsp;+&nbsp;that.n&nbsp;*&nbsp;d,&nbsp;d&nbsp;*&nbsp;that.d)
  }
</pre>


<p>However, given this code the compiler will complain:<a id="i988779894-1"/></p>

<pre>
  &lt;console&gt;:11:&nbsp;error:&nbsp;value&nbsp;d&nbsp;is&nbsp;not&nbsp;a&nbsp;member&nbsp;of&nbsp;Rational
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Rational(n&nbsp;*&nbsp;that.d&nbsp;+&nbsp;that.n&nbsp;*&nbsp;d,&nbsp;d&nbsp;*&nbsp;that.d)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
  &lt;console&gt;:11:&nbsp;error:&nbsp;value&nbsp;d&nbsp;is&nbsp;not&nbsp;a&nbsp;member&nbsp;of&nbsp;Rational
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Rational(n&nbsp;*&nbsp;that.d&nbsp;+&nbsp;that.n&nbsp;*&nbsp;d,&nbsp;d&nbsp;*&nbsp;that.d)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
</pre>


<p>Although class parameters <pre class="code">n</pre> and <pre class="code">d</pre> are in scope in the code of your <pre class="code">add</pre> method, you
can only access their value on the object on which <pre class="code">add</pre> was invoked. Thus, when you say <pre class="code">n</pre> or <pre class="code">d</pre>
in <pre class="code">add</pre>'s implementation, the compiler is happy to provide you with the values for
these class parameters. But it won't let you say <pre class="code">that.n</pre> or <pre class="code">that.d</pre> because <pre class="code">that</pre>
does not refer to the <pre class="code">Rational</pre> object on which <pre class="code">add</pre> was invoked.<a href="functional-objects.html#footnotemain6-2">[2]</a>
To access the numerator and denominator on <pre class="code">that</pre>, you'll need to make them into fields.
<a href="functional-objects.html#lst-rational-fields">Listing 6.1</a> shows how you could add these fields to class <pre class="code">Rational</pre>.<a href="functional-objects.html#footnotemain6-3">[3]</a><a id="i2138903369-1"/><a id="i-590826255-1"/></p>

<p><a id="lst-rational-fields"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;require(d&nbsp;!=&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numer:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denom:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;d
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;numer&nbsp;+&nbsp;<code class="quotedstring">"/"</code>&nbsp;+&nbsp;denom
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;add(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 6.1 - <pre class="code">Rational</pre> with fields.</h5>


<p>In the version of <pre class="code">Rational</pre> shown in <a href="functional-objects.html#lst-rational-fields">Listing 6.1</a>, we added two fields named <pre class="code">numer</pre> and <pre class="code">denom</pre>, and initialized
them with the values of class parameters <pre class="code">n</pre> and <pre class="code">d</pre>.<a href="functional-objects.html#footnotemain6-4">[4]</a> We also changed the implementation of
<pre class="code">toString</pre> and <pre class="code">add</pre> so that they use the fields, not the class parameters.
This version of class <pre class="code">Rational</pre> compiles. You can test it by adding some rational numbers:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;oneHalf&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">oneHalf:&nbsp;Rational&nbsp;=&nbsp;1/2</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;twoThirds&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">twoThirds:&nbsp;Rational&nbsp;=&nbsp;2/3</code>
  <br />  scala&gt;&nbsp;oneHalf&nbsp;add&nbsp;twoThirds
  <code class="output">res2:&nbsp;Rational&nbsp;=&nbsp;7/6</code>
</pre>


<p>One other thing you can do now that you couldn't do before is access the numerator and denominator values from outside
the object. Simply access the public <pre class="code">numer</pre> and <pre class="code">denom</pre> fields, like this:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;r&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">r:&nbsp;Rational&nbsp;=&nbsp;1/2</code>
  <br />  scala&gt;&nbsp;r.numer
  <code class="output">res3:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br />  scala&gt;&nbsp;r.denom
  <code class="output">res4:&nbsp;Int&nbsp;=&nbsp;2</code>
</pre>


<h3 id="sec-self-references">6.6 Self references</h3>


<p>The keyword <pre class="code">this</pre> refers to the<a id="i3559070-1"/><a id="i423816156-1"/>
object instance on which the currently executing method was invoked, or if used in
a constructor, the object instance being
constructed.
As an example, consider adding a method, <pre class="code">lessThan</pre>,
which tests whether the given <pre class="code">Rational</pre> is smaller than a parameter:</p>

<pre>
  <code class="vem">def</code>&nbsp;lessThan(that:&nbsp;<code class="typename">Rational</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">this</code>.numer&nbsp;*&nbsp;that.denom&nbsp;&lt;&nbsp;that.numer&nbsp;*&nbsp;<code class="vem">this</code>.denom
</pre>


<p>Here, <pre class="code">this.numer</pre> refers to the numerator of the object on which
<pre class="code">lessThan</pre> was invoked.  You can also leave off the <pre class="code">this</pre> prefix
and write just <pre class="code">numer</pre>; the two notations are equivalent.</p>

<p>As an example of where you can't do without <pre class="code">this</pre>, consider adding a
<pre class="code">max</pre> method to class <pre class="code">Rational</pre> that returns the greater of the
given rational number and an argument:</p>

<pre>
  <code class="vem">def</code>&nbsp;max(that:&nbsp;<code class="typename">Rational</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(<code class="vem">this</code>.lessThan(that))&nbsp;that&nbsp;<code class="vem">else</code>&nbsp;<code class="vem">this</code>
</pre>


<p>Here, the first <pre class="code">this</pre> is redundant. You could have left it off and written: <pre class="code">lessThan(that)</pre>.  But the second <pre class="code">this</pre> represents the result
of the method in the case where the test returns false; were you to omit
it, there would be nothing left to return!</p>

<h3 id="sec-multicons">6.7 Auxiliary constructors</h3>


<p>Sometimes you need multiple constructors in a class.  In Scala,
constructors
other than the primary constructor are called <a href="glossary.html#g729406368"><em>auxiliary constructors</em></a>.<a id="i-717257147-1"/><a id="i1136761043-1"/><a id="i-1656673269-1"/>
For example, a rational number with a denominator of 1 can be written more succinctly as
simply the numerator. Instead of <sup>5</sup>/<sub>1</sub>, for example, you can just write 5.
It might be nice, therefore, if instead of writing <pre class="code">new</pre>&nbsp;<pre class="code">Rational(5,</pre>&nbsp;<pre class="code">1)</pre>, client programmers could simply
write <pre class="code">new</pre>&nbsp;<pre class="code">Rational(5)</pre>. This would require adding an auxiliary constructor to <pre class="code">Rational</pre> that
takes only one argument, the numerator, with the denominator predefined to be 1.
<a href="functional-objects.html#lst-aux-constructor">Listing 6.2</a> shows what that would look like.</p>

<p><a id="lst-aux-constructor"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;require(d&nbsp;!=&nbsp;<code class="literal">0</code>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numer:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denom:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;d
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code class="vem">this</code>(n:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;<code class="vem">this</code>(n,&nbsp;<code class="literal">1</code>)&nbsp;<code class="comment">//&nbsp;auxiliary&nbsp;constructor</code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;numer&nbsp;+&nbsp;<code class="quotedstring">"/"</code>&nbsp;+&nbsp;denom
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;add(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 6.2 - <pre class="code">Rational</pre> with an auxiliary constructor.</h5>


<p>Auxiliary constructors in Scala start with <pre class="code">def</pre>&nbsp;<pre class="code">this(...)</pre>. The body of <pre class="code">Rational</pre>'s auxiliary constructor merely invokes
the primary constructor, passing along its lone argument, <pre class="code">n</pre>, as the
numerator and <pre class="code">1</pre> as the denominator.
You can see the auxiliary constructor in action by typing the
following into the interpreter:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;y&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">3</code>)
  <code class="output">y:&nbsp;Rational&nbsp;=&nbsp;3/1</code>
</pre>


<p>In Scala, every auxiliary constructor must invoke another constructor of the same
class as its first action. In other words, the first statement in every auxiliary
constructor in every Scala class will have the form "<pre class="code">this(</pre>...<pre class="code">)</pre>". The invoked constructor is either the
primary constructor (as in the <pre class="code">Rational</pre> example), or another
auxiliary constructor that comes textually before the calling
constructor. The net effect of this rule is that every constructor
invocation in Scala will end up eventually calling the primary
constructor of the class.  The primary constructor is thus the single
point of entry of a class.</p>

<div class="note">
<h4>Note</h4>


<p>If you're familiar with Java, you may wonder why Scala's rules for constructors are a bit more restrictive than
Java's. In Java, a constructor must either invoke another constructor of the same class, or directly invoke a
constructor of the superclass, as its first action. In a Scala class, only the primary constructor can invoke a
superclass constructor. The increased restriction in Scala is really a design trade-off that needed to be paid 
in exchange for the greater conciseness and simplicity of Scala's constructors compared to Java's.
Superclasses and the details of how constructor invocation
and inheritance interact will be explained in <a href="composition-and-inheritance.html">Chapter 10</a>.</p>

</div>


<h3>6.8 Private fields and methods</h3>


<p>In the previous version of <pre class="code">Rational</pre>, we simply initialized <pre class="code">numer</pre> with <pre class="code">n</pre> and
<pre class="code">denom</pre> with <pre class="code">d</pre>.
As a result, the numerator and
denominator of a <pre class="code">Rational</pre> can be larger than needed. For example, the fraction <sup>66</sup>/<sub>42</sub>
could be normalized to an equivalent reduced form, <sup>11</sup>/<sub>7</sub>, but <pre class="code">Rational</pre>'s primary constructor
doesn't currently do this:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">66</code>,&nbsp;<code class="literal">42</code>)
  <code class="output">res5:&nbsp;Rational&nbsp;=&nbsp;66/42</code>
</pre>


<p>To normalize in this way, you need to divide the numerator and denominator by their <em>greatest common divisor</em>.
For example, the greatest common divisor of 66 and 42 is 6. (In other words, 6 is the largest integer that divides evenly
into both 66 and 42.) Dividing both the numerator and denominator of <sup>66</sup>/<sub>42</sub> by 6 yields its reduced
form, <sup>11</sup>/<sub>7</sub>. <a href="functional-objects.html#lst-private-members">Listing 6.3</a> shows one way to do this:</p>

<p><a id="lst-private-members"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;require(d&nbsp;!=&nbsp;<code class="literal">0</code>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;g&nbsp;=&nbsp;gcd(n.abs,&nbsp;d.abs)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numer&nbsp;=&nbsp;n&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denom&nbsp;=&nbsp;d&nbsp;/&nbsp;g
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code class="vem">this</code>(n:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;<code class="vem">this</code>(n,&nbsp;<code class="literal">1</code>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;add(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;numer&nbsp;+&nbsp;<code class="quotedstring">"/"</code>&nbsp;+&nbsp;denom
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;gcd(a:&nbsp;<code class="typename">Int</code>,&nbsp;b:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(b&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;a&nbsp;<code class="vem">else</code>&nbsp;gcd(b,&nbsp;a&nbsp;<code class="texttt">%</code>&nbsp;b)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 6.3 - <pre class="code">Rational</pre> with a private field and method.<a id="i694224322-2"/><a id="i1692219636-2"/><a id="i-1558980393-1"/><a id="i-1621898821-1"/></h5>


<p>In this version of <pre class="code">Rational</pre>, we added a private field, <pre class="code">g</pre>, and modified the initializers
for <pre class="code">numer</pre> and <pre class="code">denom</pre>. (An <em>initializer</em> is the code that initializes a variable; for example, the
"<pre class="code">n</pre>&nbsp;<pre class="code">/</pre>&nbsp;<pre class="code">g</pre>" that initializes <pre class="code">numer</pre>.) Because <pre class="code">g</pre> is private, it can be accessed inside the body of the class, but not
outside<a id="i1857067865-1"/>. We also added a private method, <pre class="code">gcd</pre>, which calculates the greatest common
divisor of two passed <pre class="code">Int</pre>s. For example, <pre class="code">gcd(12,</pre>&nbsp;<pre class="code">8)</pre> is <pre class="code">4</pre>. 
As you saw in <a href="classes-and-objects.html#sec-classes-fields-methods">Section 4.1</a>,
to make a field or method private
you simply place the <pre class="code">private</pre> keyword in front of its definition.
The purpose of the private "helper method" <pre class="code">gcd</pre> is to factor out code needed by
some other part of the class, in this case, the primary constructor. To ensure <pre class="code">g</pre> is always positive, we
pass the absolute value of <pre class="code">n</pre> and <pre class="code">d</pre>, which we obtain by invoking
<pre class="code">abs</pre> on them, a method you can invoke on any <pre class="code">Int</pre> to get its
absolute value.<a id="i-1171773097-1"/></p>

<p>The Scala compiler will place the code for the initializers of <pre class="code">Rational</pre>'s three 
fields into the primary constructor in the order in which they appear
in the source code.<a id="i-400083503-1"/> Thus, <pre class="code">g</pre>'s initializer, <pre class="code">gcd(n.abs,</pre>&nbsp;<pre class="code">d.abs)</pre>, will execute before the other two,
because it appears first in the source. Field <pre class="code">g</pre> will be initialized with the result, the 
greatest common divisor of the absolute value of the class parameters, <pre class="code">n</pre> and <pre class="code">d</pre>.
Field <pre class="code">g</pre> is then used in the initializers of <pre class="code">numer</pre> and <pre class="code">denom</pre>. By dividing <pre class="code">n</pre> and <pre class="code">d</pre> by their greatest common divisor, <pre class="code">g</pre>, every <pre class="code">Rational</pre> will be constructed in
its normalized form:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">66</code>,&nbsp;<code class="literal">42</code>)
  <code class="output">res6:&nbsp;Rational&nbsp;=&nbsp;11/7</code>
</pre>


<h3>6.9 Defining operators</h3>


<p>The current implementation of <pre class="code">Rational</pre> addition is OK, but
could be made more convenient to use. You might ask yourself why you
can write:</p>

<pre>
  x&nbsp;+&nbsp;y
</pre>


<p>if <pre class="code">x</pre> and <pre class="code">y</pre> are integers or floating-point 
numbers, but you have to write:</p>

<pre>
  x.add(y)
</pre>


<p>or at least:<span style="color:#fff">11347</span></p>

<pre>
  x&nbsp;add&nbsp;y
</pre>


<p>if they are rational numbers. There's no convincing reason why this
should be so.  Rational numbers are numbers just like other numbers. In a
mathematical sense they are even more natural than, say, floating-point
numbers.</p>

<div style="page-break-after:always"/>


<p>Why should you not use the natural arithmetic operators on
them? In Scala you can do this. In the rest of this chapter, we'll show you how.</p>

<p>The first step is to replace <pre class="code">add</pre> by the usual
mathematical symbol. This is straightforward, as <pre class="code">+</pre>
is a legal identifier in Scala. We can simply define a method with
<pre class="code">+</pre> as its name. While we're at it, we may as well implement a method
named <pre class="code">*</pre> that performs multiplication. The result is shown in <a href="functional-objects.html#lst-operator-methods">Listing 6.4</a>:</p>

<p><a id="lst-operator-methods"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;require(d&nbsp;!=&nbsp;<code class="literal">0</code>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;g&nbsp;=&nbsp;gcd(n.abs,&nbsp;d.abs)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numer&nbsp;=&nbsp;n&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denom&nbsp;=&nbsp;d&nbsp;/&nbsp;g
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code class="vem">this</code>(n:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;<code class="vem">this</code>(n,&nbsp;<code class="literal">1</code>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;+&nbsp;(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;*&nbsp;(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(numer&nbsp;*&nbsp;that.numer,&nbsp;denom&nbsp;*&nbsp;that.denom)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;numer&nbsp;+&nbsp;<code class="quotedstring">"/"</code>&nbsp;+&nbsp;denom
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;gcd(a:&nbsp;<code class="typename">Int</code>,&nbsp;b:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(b&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;a&nbsp;<code class="vem">else</code>&nbsp;gcd(b,&nbsp;a&nbsp;<code class="texttt">%</code>&nbsp;b)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 6.4 - <pre class="code">Rational</pre> with operator methods.</h5>


<p>With class <pre class="code">Rational</pre> defined in this manner, you can now write:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;x&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">x:&nbsp;Rational&nbsp;=&nbsp;1/2</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;y&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">y:&nbsp;Rational&nbsp;=&nbsp;2/3</code>
  <br />  scala&gt;&nbsp;x&nbsp;+&nbsp;y
  <code class="output">res7:&nbsp;Rational&nbsp;=&nbsp;7/6</code>
</pre>


<p>As always, the operator syntax on the last input line is equivalent to 
a method call.<a id="i-614149608-3"/> You could also write:</p>

<pre>
  scala&gt;&nbsp;x.+(y)
  <code class="output">res8:&nbsp;Rational&nbsp;=&nbsp;7/6</code>
</pre>


<p>but this is not as readable.</p>

<p>Another thing to note is that given Scala's rules for operator precedence, which were described
in <a href="basic-types-and-operations.html#sec-precedence">Section 5.9</a>, the <pre class="code">*</pre> method will bind more tightly than the <pre class="code">+</pre> method
for <pre class="code">Rational</pre>s. In other words, expressions involving <pre class="code">+</pre> and <pre class="code">*</pre> operations on <pre class="code">Rational</pre>s will
behave as expected.<a id="i1955596960-2"/><a id="i2084616098-2"/> For example, <pre class="code">x</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">x</pre>&nbsp;<pre class="code">*</pre>&nbsp;<pre class="code">y</pre> will execute as <pre class="code">x</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">(x</pre>&nbsp;<pre class="code">*</pre>&nbsp;<pre class="code">y)</pre>, not <pre class="code">(x</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">x)</pre>&nbsp;<pre class="code">*</pre>&nbsp;<pre class="code">y</pre>:</p>

<pre>
  scala&gt;&nbsp;x&nbsp;+&nbsp;x&nbsp;*&nbsp;y
  <code class="output">res9:&nbsp;Rational&nbsp;=&nbsp;5/6</code>
  <br />  scala&gt;&nbsp;(x&nbsp;+&nbsp;x)&nbsp;*&nbsp;y
  <code class="output">res10:&nbsp;Rational&nbsp;=&nbsp;2/3</code>
  <br />  scala&gt;&nbsp;x&nbsp;+&nbsp;(x&nbsp;*&nbsp;y)
  <code class="output">res11:&nbsp;Rational&nbsp;=&nbsp;5/6</code>
</pre>


<h3>6.10 Identifiers in Scala</h3>


<p>You have now seen the two most important ways to form an identifier in
Scala: alphanumeric and operator. Scala has very flexible rules for
forming identifiers. Besides the two forms you have seen there are
also two others. All four forms of identifier formation are described in
this section.<a id="i1368189162-1"/></p>

<p>An <span style="font-style:italic">alphanumeric identifier</span> starts with a letter or underscore, which can be followed by further letters, digits, or
underscores. The `$' character also counts as a letter; however, it is reserved for
identifiers generated by the Scala compiler. Identifiers in user
programs should not contain `$' characters, even though it will compile; if they do, this might lead to name clashes
with identifiers generated by the Scala compiler.<a id="i-890920833-1"/></p>

<p>Scala follows Java's convention of using camel-case<a href="functional-objects.html#footnotemain6-5">[5]</a> identifiers,<a id="i81954455-1"/> such as <pre class="code">toString</pre> and <pre class="code">HashSet</pre>.<a id="i857734909-1"/><a id="i-917788527-1"/><a id="i350029111-1"/><a id="i-1611050102-1"/>
Although underscores are legal in identifiers, they are not used that often in Scala programs, in part to be
consistent with Java, but also because underscores have many other
non-identifier uses in Scala code<a id="i1978221382-1"/>. As a result, it
is best to avoid identifiers like <pre class="code">to_string</pre>, <pre class="code">__init__</pre>, or <pre class="code">name_</pre>.
Camel-case names of fields, method parameters, local variables, and functions should start with a lower case letter,
for example: <pre class="code">length</pre>, <pre class="code">flatMap</pre>, and <pre class="code">s</pre>. Camel-case names of classes and traits should start with an upper
case letter, for example: <pre class="code">BigInt</pre>, <pre class="code">List</pre>, and <pre class="code">UnbalancedTreeMap</pre>.<a href="functional-objects.html#footnotemain6-6">[6]</a></p>

<div class="note">
<h4>Note</h4>


<p>One consequence of using a trailing underscore in an identifier is that if you attempt, for example, to write a declaration like this, "<pre class="code">val</pre>&nbsp;<pre class="code">name_:</pre>&nbsp;<pre class="code">Int</pre>&nbsp;<pre class="code">=</pre>&nbsp;<pre class="code">1</pre>", you'll
get a compiler error. The compiler will think you are trying to declare a <pre class="code">val</pre> named "<pre class="code">name_:</pre>". To get this to compile, you would need to insert
an extra space before the colon, as in: "<pre class="code">val</pre>&nbsp;<pre class="code">name_</pre>&nbsp;<pre class="code">:</pre>&nbsp;<pre class="code">Int</pre>&nbsp;<pre class="code">=</pre>&nbsp;<pre class="code">1</pre>".</p>

</div>


<p>One way in which Scala's conventions depart from Java's involves constant names.<a id="i-422276785-1"/> In Scala, the word <em>constant</em> does not just
mean <pre class="code">val</pre>. Even though a <pre class="code">val</pre> does remain constant after it is initialized, it is still a variable. For example, method parameters
are <pre class="code">val</pre>s, but each time the method is called those <pre class="code">val</pre>s can hold different values. A constant is more permanent.
For example, <pre class="code">scala.math.Pi</pre> is defined to be the
double value closest to the real value of &pi;, the ratio of a circle's circumference to its diameter. 
This value is unlikely to change ever; thus, <pre class="code">Pi</pre> is clearly a constant. You can also use constants to give names to values
that would otherwise be <em>magic numbers</em> in your code:<a id="i1838929623-1"/> literal values with no explanation, which in the worst case appear
in multiple places. You may also want to define constants for use in pattern matching, a use case that
will be described in <a href="case-classes-and-pattern-matching.html#subsec-kinds-of-patterns-variables">Section 15.2</a>. In Java, the convention is to give constants names that
are all upper case, with underscores separating the words, such as <pre class="code">MAX_VALUE</pre> or <pre class="code">PI</pre>. In Scala, the convention is merely that
the first character should be upper case. Thus, constants named
in the Java style, such as <pre class="code">X_OFFSET</pre>, will work as Scala constants, but the Scala convention is to use
camel case for constants, such as <pre class="code">XOffset</pre>.</p>

<p>An <span style="font-style:italic">operator identifier</span> consists of one or more 
operator characters.<a id="i1206563604-1"/><a id="i-12268236-1"/> Operator characters are printable ASCII 
characters such as <pre class="code">+</pre>, <pre class="code">:</pre>, <pre class="code">?</pre>, <span class="code"><span style="font-size:large">~</span></span> or <pre class="code">#</pre>.<a href="functional-objects.html#footnotemain6-7">[7]</a>
Here are some examples of operator identifiers:</p>

<div style="text-align: center">


<p><pre class="code">+</pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code">++</pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code">:::</pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code">&lt;?&gt;</pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code">:-&gt;</pre></p>

</div>


<p>The Scala compiler will internally "mangle" operator identifiers to turn
them into legal Java identifiers with embedded <pre class="code">$</pre> characters. For instance, 
the identifier <pre class="code">:-&gt;</pre> would be represented internally 
as <pre class="code">$colon$minus$greater</pre>. If you ever wanted to access this identifier from Java code, 
you'd need to use this internal representation.</p>

<p>Because operator identifiers in Scala can become arbitrarily long,
there is a small difference between Java and Scala.  In Java,
the input <pre class="code">x&lt;-y</pre> would be parsed as four lexical symbols, so it would be
equivalent to <pre class="code">x</pre>&nbsp;<pre class="code">&lt;</pre>&nbsp;<pre class="code">-</pre>&nbsp;<pre class="code">y</pre>. In Scala, <pre class="code">&lt;-</pre> would be parsed as a single identifier,
giving <pre class="code">x</pre>&nbsp;<pre class="code">&lt;-</pre>&nbsp;<pre class="code">y</pre>. If you want the first interpretation, you need to separate
the <pre class="code">&lt;</pre> and the <pre class="code">-</pre> characters by a space. This is unlikely to 
be a problem in practice, as very few people would write <pre class="code">x&lt;-y</pre> in Java
without inserting spaces or parentheses between the operators.</p>

<p>A <span style="font-style:italic">mixed identifier</span> consists of an alphanumeric identifier, which is followed by
an underscore and an operator
identifier.<a id="i-1955463099-1"/><a id="i1641787755-1"/> For example, <pre class="code">unary_+</pre><a id="i-1088310403-2"/> used as a method
name defines a unary <pre class="code">+</pre> operator. Or, 
<pre class="code">myvar_=</pre> used as method name defines an assignment operator.
In addition, the mixed identifier form
<pre class="code">myvar_=</pre> is generated by the Scala compiler to support <span style="font-style:italic">properties</span> (more on that in <a href="mutable-objects.html">Chapter 18</a><a id="i-926053069-1"/>).</p>

<p><a id="sec-literal-identifier"/>
A <span style="font-style:italic">literal identifier</span> is an arbitrary string enclosed in back ticks
(<pre class="code">`</pre> ...<pre class="code">`</pre>).<a id="i-144177089-1"/><a id="i-1241489226-1"/><a id="i1204364761-1"/> Some examples of literal identifiers are:</p>

<div style="text-align: center">


<p><pre class="code">`x`</pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code">`&lt;clinit&gt;`</pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code"></pre>&nbsp;<pre class="code">`yield`</pre></p>

</div>


<p>The idea is that you can put any string that's accepted by the runtime
as an identifier between back ticks. The result is always a Scala
identifier. This works even if the name contained in the back ticks
would be a Scala reserved word<a id="i1517246665-1"/>.  
A typical use case is accessing the static <pre class="code">yield</pre> method in Java's
<pre class="code">Thread</pre> class. You cannot write <pre class="code">Thread.yield()</pre> because <pre class="code">yield</pre> is
a reserved word in Scala. However, you can still name the method
in back ticks, <i>e.g.</i>, <pre class="code">Thread.`yield`()</pre>.</p>

<h3 id="sec-method-overloading">6.11 Method overloading</h3>


<p>Back to class <pre class="code">Rational</pre>. With the latest changes, you can now do<a id="i-1178969056-1"/><a id="i1636832800-1"/>
addition and multiplication operations in a natural style on rational numbers. But
one thing still missing is mixed arithmetic. For instance, you cannot
multiply a rational number by an integer because the operands of
<pre class="code">*</pre> always have to be <pre class="code">Rational</pre>s. So for a rational number <pre class="code">r</pre> you
can't write <pre class="code">r</pre>&nbsp;<pre class="code">*</pre>&nbsp;<pre class="code">2</pre>. You must write <pre class="code">r</pre>&nbsp;<pre class="code">*</pre>&nbsp;<pre class="code">new</pre>&nbsp;<pre class="code">Rational(2)</pre>, which is not as
nice.</p>

<p>To make <pre class="code">Rational</pre> even more convenient, we'll add new methods
to the class that perform mixed addition and multiplication on rational numbers and integers.
While we're at it, we'll add methods for subtraction and division
too. The result
is shown in <a href="functional-objects.html#lst-overloaded-methods">Listing 6.5</a>.</p>

<p><a id="lst-overloaded-methods"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;require(d&nbsp;!=&nbsp;<code class="literal">0</code>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;g&nbsp;=&nbsp;gcd(n.abs,&nbsp;d.abs)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numer&nbsp;=&nbsp;n&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denom&nbsp;=&nbsp;d&nbsp;/&nbsp;g
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code class="vem">this</code>(n:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;<code class="vem">this</code>(n,&nbsp;<code class="literal">1</code>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;+&nbsp;(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;+&nbsp;(i:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(numer&nbsp;+&nbsp;i&nbsp;*&nbsp;denom,&nbsp;denom)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;-&nbsp;(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;-&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;-&nbsp;(i:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(numer&nbsp;-&nbsp;i&nbsp;*&nbsp;denom,&nbsp;denom)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;*&nbsp;(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(numer&nbsp;*&nbsp;that.numer,&nbsp;denom&nbsp;*&nbsp;that.denom)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;*&nbsp;(i:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(numer&nbsp;*&nbsp;i,&nbsp;denom)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;/&nbsp;(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(numer&nbsp;*&nbsp;that.denom,&nbsp;denom&nbsp;*&nbsp;that.numer)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;/&nbsp;(i:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(numer,&nbsp;denom&nbsp;*&nbsp;i)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;numer&nbsp;+&nbsp;<code class="quotedstring">"/"</code>&nbsp;+&nbsp;denom
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;gcd(a:&nbsp;<code class="typename">Int</code>,&nbsp;b:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(b&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;a&nbsp;<code class="vem">else</code>&nbsp;gcd(b,&nbsp;a&nbsp;<code class="texttt">%</code>&nbsp;b)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 6.5 - <pre class="code">Rational</pre> with overloaded methods.<a id="i-1789856-1"/></h5>


<p>There are now two versions each of the arithmetic methods: one
that takes a rational as its argument and another that takes an integer.
In other words, each of these method names is <em>overloaded</em> because each name is now being used by multiple
methods. For example, the name <pre class="code">+</pre> is used by one method that takes a <pre class="code">Rational</pre> and another that takes an <pre class="code">Int</pre>. In a method call,
the compiler picks the version of an overloaded method that correctly matches the
types of the arguments.  For instance, if the argument <pre class="code">y</pre> in
<pre class="code">x.+(y)</pre> is a <pre class="code">Rational</pre>, the compiler will pick the method <pre class="code">+</pre> that takes a
<pre class="code">Rational</pre> parameter. But if the argument is an integer, 
the compiler will pick the method <pre class="code">+</pre> that takes an <pre class="code">Int</pre> parameter instead.
If you try this:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;x&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">x:&nbsp;Rational&nbsp;=&nbsp;2/3</code>
  <br />  scala&gt;&nbsp;x&nbsp;*&nbsp;x
  <code class="output">res12:&nbsp;Rational&nbsp;=&nbsp;4/9</code>
  <br />  scala&gt;&nbsp;x&nbsp;*&nbsp;<code class="literal">2</code>
  <code class="output">res13:&nbsp;Rational&nbsp;=&nbsp;4/3</code>
</pre>


<p>You'll see that the <pre class="code">*</pre> method invoked is determined in each case by the type of the right operand.</p>

<div class="note">
<h4>Note</h4>


<p>Scala's process of overloaded method resolution is very similar to Java's.
In every case, the chosen overloaded version is the one that
best matches the static types of the arguments. Sometimes there is no unique
best matching version; in that case the compiler will give you an 
"ambiguous reference" error.</p>

</div>


<h3>6.12 Implicit conversions</h3>


<p>Now that you can write <pre class="code">r</pre>&nbsp;<pre class="code">*</pre>&nbsp;<pre class="code">2</pre>, you might also want to swap the operands, as in <pre class="code">2</pre>&nbsp;<pre class="code">*</pre>&nbsp;<pre class="code">r</pre>. Unfortunately this does not work yet:<a id="i869323971-1"/></p>

<pre>
  scala&gt;&nbsp;<code class="literal">2</code>&nbsp;*&nbsp;r
  <code class="output">&lt;console&gt;:10:&nbsp;error:&nbsp;overloaded&nbsp;method&nbsp;value&nbsp;*&nbsp;with&nbsp;</code>
  <code class="output">alternatives:</code>
  <code class="output">&nbsp;&nbsp;(x:&nbsp;Double)Double&nbsp;&lt;and&gt;</code>
  <code class="output">&nbsp;&nbsp;(x:&nbsp;Float)Float&nbsp;&lt;and&gt;</code>
  <code class="output">&nbsp;&nbsp;(x:&nbsp;Long)Long&nbsp;&lt;and&gt;</code>
  <code class="output">&nbsp;&nbsp;(x:&nbsp;Int)Int&nbsp;&lt;and&gt;</code>
  <code class="output">&nbsp;&nbsp;(x:&nbsp;Char)Int&nbsp;&lt;and&gt;</code>
  <code class="output">&nbsp;&nbsp;(x:&nbsp;Short)Int&nbsp;&lt;and&gt;</code>
  <code class="output">&nbsp;&nbsp;(x:&nbsp;Byte)Int</code>
  <code class="output">&nbsp;cannot&nbsp;be&nbsp;applied&nbsp;to&nbsp;(Rational)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;*&nbsp;r</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>The problem here is that <pre class="code">2</pre>&nbsp;<pre class="code">*</pre>&nbsp;<pre class="code">r</pre> is equivalent to <pre class="code">2.*(r)</pre>, so it is
a method call on the number <pre class="code">2</pre>, which is an integer. But the <pre class="code">Int</pre>
class contains no multiplication method that takes a <pre class="code">Rational</pre>
argument&mdash;it couldn't because class <pre class="code">Rational</pre> is 
not a standard class in the Scala library.</p>

<p>However, there is another way to solve this problem in Scala: You can
create an implicit conversion that automatically converts integers to
rational numbers when needed.<a id="i-2127602858-1"/> Try adding this line in the interpreter:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;intToRational(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(x)
</pre>


<p>This defines a conversion method from <pre class="code">Int</pre> to <pre class="code">Rational</pre>. The <pre class="code">implicit</pre> 
modifier in front of the method tells the compiler to apply it automatically
in a number of situations<a id="i-425423387-1"/>. With the conversion defined, you can now retry the example that failed before:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;r&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">2</code>,<code class="literal">3</code>)
  <code class="output">r:&nbsp;Rational&nbsp;=&nbsp;2/3</code>
  <br />  scala&gt;&nbsp;<code class="literal">2</code>&nbsp;*&nbsp;r
  <code class="output">res15:&nbsp;Rational&nbsp;=&nbsp;4/3</code>
</pre>


<p>For an implicit conversion to work, it needs to be in scope. If you place the implicit method definition
inside class <pre class="code">Rational</pre>, it won't be in scope in the interpreter. For now, you'll need to define it directly in the interpreter.</p>

<p>As you can glimpse from this example, implicit conversions are
a very powerful technique for making libraries more flexible and more
convenient to use. Because they are so powerful, they can also 
be easily misused. You'll find out more on implicit
conversions, including ways to  bring them into scope where they are needed, in <a href="implicit-conversions-and-parameters.html">Chapter 21</a>.</p>

<h3>6.13 A word of caution</h3>


<p>As this chapter has demonstrated, creating methods with operator names<a id="i771080752-1"/>
and defining implicit conversions can help you design libraries for
which client code is concise and easy to understand. Scala gives
you a great deal of power to design such easy-to-use libraries. But
please bear in mind that with power comes responsibility.</p>

<p>If used unartfully, both operator methods and implicit conversions can give rise to
client code that is hard to read and understand. Because implicit conversions are applied
implicitly by the compiler, not explicitly written down in the source code, it can be
non-obvious to client programmers what implicit conversions are being applied. And although
operator methods will usually make client code more concise, they will only make it more
readable to the extent client programmers will be able to recognize and remember
the meaning of each operator.</p>

<p>The goal you should keep in mind as you design libraries is not merely<a id="i-506868082-1"/>
enabling concise client code, but readable, understandable client
code. Conciseness will often be a big part of that readability, but
you can take conciseness too far. By designing libraries that enable
tastefully concise and at the same time understandable client code,
you can help those client programmers work productively.</p>

<h3>6.14 Conclusion</h3>


<p>In this chapter, you saw more aspects of classes in Scala.  You
saw how to add parameters to a class, define several
constructors, define operators as methods, and customize
classes so that they are natural to use.  Maybe most importantly, you saw that defining and using immutable
objects is a quite natural way to code in Scala.</p>

<p>Although the final version of <pre class="code">Rational</pre> shown in this chapter
fulfills the requirements set forth at the beginning of the chapter,
it could still be improved. We will in fact return to this example
later in the book. For example, in
<a href="object-equality.html">Chapter 30</a>, you'll learn how to
override <pre class="code">equals</pre> and <pre class="code">hashcode</pre> to allow <pre class="code">Rational</pre>s to behave
better when compared with <pre class="code">==</pre> or placed into hash tables.
In <a href="implicit-conversions-and-parameters.html">Chapter 21</a>, you'll learn
how to place implicit method definitions in a companion object for
<pre class="code">Rational</pre>, so they can be more easily placed into scope when client
programmers are working with <pre class="code">Rational</pre>s.</p>

<hr/>
<h4>Footnotes for Chapter 6:</h4>


<p><a id="footnotemain6-1"/>[1] The <pre class="code">require</pre> method is defined in standalone
object, <pre class="code">Predef</pre>. As mentioned in <a href="classes-and-objects.html#sec-a-scala-application">Section 4.4</a>, <pre class="code">Predef</pre>'s members are imported automatically
into every Scala source file.</p>

<p><a id="footnotemain6-2"/>[2] Actually, you could add
a <pre class="code">Rational</pre> to itself, in which case <pre class="code">that</pre> would refer to the object on which <pre class="code">add</pre> was invoked. But because 
you can pass any <pre class="code">Rational</pre> object to <pre class="code">add</pre>, the compiler still won't let you say <pre class="code">that.n</pre>.</p>

<p><a id="footnotemain6-3"/>[3] In <a href="composition-and-inheritance.html#sec-parametric-fields">Section 10.6</a>
you'll find out about <em>parametric fields</em>, which provide a
shorthand for writing the same code.</p>

<p><a id="footnotemain6-4"/>[4] Even though <pre class="code">n</pre> and <pre class="code">d</pre> are used
in the body of the class, given they are only used inside
constructors, the Scala compiler will not emit fields for them. Thus, given this code the Scala compiler will
generate a class with two <pre class="code">Int</pre> fields, one for <pre class="code">numer</pre> and one for <pre class="code">denom</pre>.</p>

<p><a id="footnotemain6-5"/>[5] This style of naming identifiers is called <em>camel case</em> because the identifiersHaveHumps consisting of the embedded capital letters.</p>

<p><a id="footnotemain6-6"/>[6] In <a href="working-with-lists.html#sec-list-patterns">Section 16.5</a>, you'll see that sometimes
you may want to give a special kind of class known as a <em>case class</em> a name consisting solely of operator characters. For example,
the Scala API contains a class named <pre class="code">::</pre>, which facilitates pattern matching on <pre class="code">List</pre>s.</p>

<p><a id="footnotemain6-7"/>[7] More precisely, an operator character
belongs to the Unicode set of mathematical symbols(Sm) or other symbols(So), 
or to the 7-bit ASCII characters that are not letters, digits, 
parentheses, square brackets, curly braces, single or double quote, or an underscore, period, semi-colon, comma,
or back tick character.</p>

<div style="page-break-after:always"/>


<div style="page-break-after:always"/>

</body>
</html>
