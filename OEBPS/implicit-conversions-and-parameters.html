<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8"/>
    <title>Programming in Scala, 3rd Edition</title>

    <link rel="stylesheet" type="text/css" href="book.css" />
  </head>
<body>
<h2><a id="chap-implicit-conversions-and-parameters">Chapter 21</a></h2>
<h1>Implicit Conversions and Parameters</h1>


<p>There's a fundamental difference between your own code and other people's libraries: You can change or extend your own code as you wish,
but if you want to use someone else's libraries, you usually have to
take them as they are. A number of constructs have sprung up in programming languages to
alleviate this problem. Ruby<a id="i-1999895874-3"/> has
modules, and Smalltalk<a id="i-817657147-2"/> lets packages add to each other's classes.
These are very powerful but also dangerous, in that you can modify the behavior of a class for an entire application, some parts
of which you might not know.
C# 3.0 has static extension methods<a id="i1246302635-1"/>, which are more local but also more
restrictive, in that you can only add methods, not fields, to a class, and you can't make a class
implement new interfaces.</p>

<p>Scala's answer is implicit conversions and parameters.<a id="i-174456078-1"/><a id="i-1068906551-2"/> These can make existing
libraries much more pleasant to deal with by letting you leave out
tedious, obvious details that obscure the interesting parts of your code.
Used tastefully, this
results in code that is focused on the interesting, non-trivial parts
of your program.  This chapter shows you how implicits work, and
it presents some of the most common ways they are used.</p>

<h3 id="sec-implicit-conversions">21.1 Implicit conversions</h3>


<p>Before delving into the details of implicit conversions, take a look
at a typical example of their use.  Implicit conversions are often
helpful for working with two bodies of software that were developed
without each other in mind. Each library has its own way to encode a
concept that is essentially the same thing.  Implicit conversions help
by reducing the number of explicit conversions that are needed from
one type to another.</p>

<p>Java includes a library named Swing for implementing cross-platform
user interfaces. One of the things Swing does is process events from
the operating system, convert them to platform-independent event
objects, and pass those events to parts of an application called
event listeners.</p>

<p>If Swing had been written with Scala in mind, event listeners would
probably have been represented by a function type. Callers could then
use the function literal syntax as a lightweight way to specify what
should happen for a certain class of events. Since Java doesn't have
function literals, Swing uses the next best thing, an inner class that
implements a one-method interface. In the case of action listeners,
the interface is <pre class="code">ActionListener</pre>.</p>

<p>Without the use of implicit conversions, a Scala program that uses
Swing must use inner classes just like in Java. Here's an example that
creates a button and hooks up an action listener to it.  The action
listener is invoked whenever the button is pressed, at which point it
prints the string <pre class="code">"pressed!"</pre>:</p>

<pre>
  <code class="vem">val</code>&nbsp;button&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">JButton</code>
  button.addActionListener(
  &nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ActionListener</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;actionPerformed(event:&nbsp;<code class="typename">ActionEvent</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"pressed!"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  )
</pre>


<p>This code has a lot of information-free boilerplate. The fact that
this listener is an <pre class="code">ActionListener</pre>, the fact that the callback method
is named <pre class="code">actionPerformed</pre>, and the fact that the argument is an
<pre class="code">ActionEvent</pre> are all implied for any argument to
<pre class="code">addActionListener</pre>. The only new information here is the code to be
performed, namely the call to <pre class="code">println</pre>. This new information is
drowned out by the boilerplate. Someone reading this code will need to have an
eagle's eye to pick through the noise and find the informative part.</p>

<p>A more Scala-friendly version would take a function as an argument,
greatly reducing the amount of boilerplate:</p>

<pre>
  button.addActionListener(&nbsp;<code class="comment">//&nbsp;Type&nbsp;mismatch!</code>
  &nbsp;&nbsp;(_:&nbsp;<code class="typename">ActionEvent</code>)&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"pressed!"</code>)
  )
</pre>


<p>As written so far, this code doesn't work.<a href="implicit-conversions-and-parameters.html#footnotemain21-1">[1]</a> The <pre class="code">addActionListener</pre>
method wants an action listener but is getting a function. With
implicit conversions, however, this code can be made to work.</p>

<p>The first step is to write an implicit conversion between the two
types.  Here is an implicit conversion from functions to action
listeners:</p>

<pre>
  <code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;function2ActionListener(f:&nbsp;<code class="typename">ActionEvent</code>&nbsp;=&gt;&nbsp;<code class="typename">Unit</code>)&nbsp;=
  &nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ActionListener</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;actionPerformed(event:&nbsp;<code class="typename">ActionEvent</code>)&nbsp;=&nbsp;f(event)
  &nbsp;&nbsp;}
</pre>


<p>This is a one-argument method that takes a function and returns an
action listener. Like any other one-argument method, it can be called
directly and have its result passed on to another expression:</p>

<pre>
  button.addActionListener(
  &nbsp;&nbsp;function2ActionListener(
  &nbsp;&nbsp;&nbsp;&nbsp;(_:&nbsp;<code class="typename">ActionEvent</code>)&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"pressed!"</code>)
  &nbsp;&nbsp;)
  )
</pre>


<p>This is already an improvement on the version with the inner class. Note
how arbitrary amounts of boilerplate end up replaced by a function
literal and a call to a method. It gets better, though, with implicit
conversions. Because <pre class="code">function2ActionListener</pre> is marked as
implicit, it can be left out and the compiler will insert it
automatically. 
Here is the result:</p>

<pre>
  <code class="comment">//&nbsp;Now&nbsp;this&nbsp;works</code>
  button.addActionListener(
  &nbsp;&nbsp;(_:&nbsp;<code class="typename">ActionEvent</code>)&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"pressed!"</code>)
  )
</pre>


<p>The way this code works is that the compiler first tries to compile it
as is, but it sees a type error. Before giving up, it looks for an
implicit conversion that can repair the problem. In this case, it
finds <pre class="code">function2ActionListener</pre>. It tries that conversion method,
sees that it works, and moves on. The compiler works hard here so that
the developer can ignore one more fiddly detail. Action listener?
Action event function? Either one will work&mdash;use the one that's more
convenient.</p>

<p>In this section, we illustrated some some of the power of implicit conversions
and how they let you dress up existing libraries. 
In the next sections, you'll learn the rules that determine when 
implicit conversions are tried and how they are found.</p>

<h3 id="sec-rules-for-implicits">21.2 Rules for implicits</h3>


<p>Implicit definitions are those that the compiler is allowed to insert
into a program in order to fix any of its type errors.  For example,
if <pre class="code">x</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">y</pre> does not type check, then the compiler might change it to
<pre class="code">convert(x)</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">y</pre>, where <pre class="code">convert</pre> is some available implicit
conversion.  If <pre class="code">convert</pre> changes <pre class="code">x</pre> into something that has
a <pre class="code">+</pre> method, then this change might fix a program so that it type
checks and runs correctly.  If <pre class="code">convert</pre> really is just a simple
conversion function, then leaving it out of the source code can be a
clarification.</p>

<p>Implicit conversions are governed by the following general rules:</p>

<p><b>Marking rule: Only definitions marked <pre class="code">implicit</pre> are
available.</b>  The <pre class="code">implicit</pre> keyword is used to mark which
declarations the compiler may use as implicits.  You can use it to
mark any variable, function, or object definition. Here's
an example of an implicit function definition:<a href="implicit-conversions-and-parameters.html#footnotemain21-2">[2]</a></p>

<pre>
  <code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;intToString(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;x.toString
</pre>


<p>The compiler will only change <pre class="code">x</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">y</pre> to <pre class="code">convert(x)</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">y</pre> if
<pre class="code">convert</pre> is marked as <pre class="code">implicit</pre>.  This way, you avoid the
confusion that would result if the compiler picked random functions
that happen to be in scope and inserted them as "conversions."  The
compiler will only select among the definitions you have explicitly marked
as implicit.</p>

<p><b>Scope rule: An inserted implicit conversion must 
be in scope as a single identifier, or be associated with the source or 
target type of the conversion.</b> 
The Scala compiler will only consider implicit conversions that are in
scope.<a id="i1011304421-1"/> To make
an implicit conversion available, therefore, you must in some way bring it into scope. Moreover, with one exception,
the implicit conversion must be in scope <em>as a single identifier</em>.
The compiler will not insert a conversion of the form
<pre class="code">someVariable.convert</pre>. For example, it will not expand <pre class="code">x</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">y</pre> to <pre class="code">someVariable.convert(x)</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">y</pre>. 
If you want to make <pre class="code">someVariable.convert</pre> available
as an implicit, you would need to import it, which would make it available as a single identifier. Once imported, the compiler would be free to
apply it as <pre class="code">convert(x)</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">y</pre>.
In fact, it is common for libraries to include a <pre class="code">Preamble</pre> object
including a number of useful implicit conversions.  Code that
uses the library can then do a single "<pre class="code">import</pre>&nbsp;<pre class="code">Preamble._</pre>" to access
the library's implicit conversions.</p>

<p>There's one exception to the "single identifier" rule.
The compiler will also look for implicit definitions in the companion object of the source 
or expected target types of the conversion<a id="i1755659460-1"/>. For example, if you're attempting to pass a <pre class="code">Dollar</pre> object to a method that takes a <pre class="code">Euro</pre>,
the source type is <pre class="code">Dollar</pre> and the target type is <pre class="code">Euro</pre>.  You could, therefore, package
an implicit conversion from <pre class="code">Dollar</pre> to <pre class="code">Euro</pre> in
the companion object of either class, <pre class="code">Dollar</pre> or <pre class="code">Euro</pre>.</p>

<p>Here's an example in which the implicit definition is placed
in <pre class="code">Dollar</pre>'s companion object:</p>

<pre>
  <code class="vem">object</code>&nbsp;<code class="typename">Dollar</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;dollarToEuro(x:&nbsp;<code class="typename">Dollar</code>):&nbsp;<code class="typename">Euro</code>&nbsp;=&nbsp;...
  }
  <code class="vem">class</code>&nbsp;<code class="typename">Dollar</code>&nbsp;{&nbsp;...&nbsp;}
</pre>


<p>In this case, the conversion <pre class="code">dollarToEuro</pre> is said to be <span style="font-style:italic">associated</span> to the 
type <pre class="code">Dollar</pre>. The compiler will find such an associated conversion every time
it needs to convert from an instance of type <pre class="code">Dollar</pre>. There's no need to
import the conversion separately into your program.</p>

<p>The Scope Rule helps with modular reasoning.  When you read code in
a file, the only things you need to consider from other files are
those that are either imported or are explicitly referenced through a
fully qualified name.  This benefit is at least as important for
implicits as for explicitly written code.  If implicits took
effect system-wide, then to understand a file you would have to know
about every implicit introduced anywhere in the program!</p>

<p><b>One-at-a-time rule: Only one implicit is inserted.</b>  The compiler
will never rewrite <pre class="code">x</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">y</pre> to <pre class="code">convert1(convert2(x))</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">y</pre>.  Doing so
would cause compile times to increase dramatically on erroneous code,
and it would increase the difference between what the programmer
writes and what the program actually does.  For sanity's sake, the
compiler does not insert further implicit conversions when it is
already in the middle of trying another implicit. However, it's
possible to circumvent this restriction by having implicits take
implicit parameters, which will be described later in this
chapter<a id="i-568821387-2"/>.</p>

<p><b>Explicits-first rule: Whenever code type checks as it is
written, no implicits are attempted.</b>  The compiler will not change
code that already works.  A corollary of this rule is that you can
always replace implicit identifiers by explicit ones, thus making the
code longer but with less apparent ambiguity.  You can trade between
these choices on a case-by-case basis.  Whenever you see code that
seems repetitive and verbose, implicit conversions can help you
decrease the tedium.  Whenever code seems terse to the point of
obscurity, you can insert conversions explicitly.  The amount of
implicits you leave the compiler to insert is ultimately a matter of
style.</p>

<h4>Naming an implicit conversion</h4>


<p>Implicit conversions can have arbitrary names. The name of an implicit
conversion matters only in two situations: If you want to write it
explicitly in a method application and
for determining which implicit conversions are available at 
any place in the program.
To illustrate the second point, say you have an object with two 
implicit conversions:</p>

<pre>
  <code class="vem">object</code>&nbsp;<code class="typename">MyConversions</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;stringWrapper(s:&nbsp;<code class="typename">String</code>):
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">IndexedSeq[Char]</code>&nbsp;=&nbsp;...
  &nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;intToString(x:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;...
  }
</pre>


<p>In your application, you want to make use of the <pre class="code">stringWrapper</pre> conversion,
but you don't want integers to be converted automatically to strings 
by means of the <pre class="code">intToString</pre> conversion. You can achieve this by importing
only one conversion, but not the other:</p>

<pre>
  <code class="vem">import</code>&nbsp;MyConversions.stringWrapper
  ...&nbsp;<code class="comment">//&nbsp;code&nbsp;making&nbsp;use&nbsp;of&nbsp;stringWrapper</code>
</pre>


<p>In this example, it was important that the implicit conversions had
names, because only that way could you selectively import one and not the other.</p>

<h4>Where implicits are tried</h4>


<p>There are three places implicits are used in the language: conversions
to an expected type, conversions of the receiver of a selection, and
implicit parameters. Implicit conversions to an expected type let you
use one type in a context where a different type is expected.  For
example, you might have a <pre class="code">String</pre> and want to pass it to a method that requires an
<pre class="code">IndexedSeq[Char]</pre>.
Conversions of the receiver let you adapt
the receiver of a method call (<i>i.e.</i>, the object on which a method is invoked), if the method is not applicable on the
original type. An example is <pre class="code">"abc".exists</pre>, which is converted to
<pre class="code">stringWrapper("abc").exists</pre> because the <pre class="code">exists</pre> method is not
available on <pre class="code">String</pre>s but is available on <pre class="code">IndexedSeq</pre>s.  
Implicit parameters, on the other hand, are
usually used to provide more information to the called function about what the
caller wants.  Implicit parameters are especially useful with generic
functions, where the called function might otherwise know nothing at all about
the type of one or more arguments. We will examine each of these three kinds of implicits in the next sections.</p>

<h3>21.3 Implicit conversion to an expected type</h3>


<p>Implicit conversion to an expected type is the first place 
the compiler will use implicits.  
The rule is simple.  Whenever the compiler sees an X, but
needs a Y, it will look for an implicit function that converts X to
Y.
For example, normally a double cannot be used as an integer because
it loses precision:<a id="i-677980410-7"/></p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;i:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;<code class="literal">3.5</code>
  <code class="output">&lt;console&gt;:7:&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Double(3.5)</code>
  <code class="output">&nbsp;required:&nbsp;Int</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;i:&nbsp;Int&nbsp;=&nbsp;3.5</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>However, you can define an implicit conversion to smooth this over:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;doubleToInt(x:&nbsp;<code class="typename">Double</code>)&nbsp;=&nbsp;x.toInt
  <code class="output">doubleToInt:&nbsp;(x:&nbsp;Double)Int</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;i:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;<code class="literal">3.5</code>
  <code class="output">i:&nbsp;Int&nbsp;=&nbsp;3</code>
</pre>


<p>What happens here is that the compiler sees a <pre class="code">Double</pre>, specifically
<pre class="code">3.5</pre>, in a context where it requires an <pre class="code">Int</pre>.
So far, the compiler is looking at an ordinary type error.
Before giving up, though, it
searches for an implicit conversion from <pre class="code">Double</pre> to <pre class="code">Int</pre>.  In this
case, it finds one: <pre class="code">doubleToInt</pre>, because <pre class="code">doubleToInt</pre> is in scope as a single identifier. (Outside the interpreter, you might
bring <pre class="code">doubleToInt</pre> into scope via an <pre class="code">import</pre> or possibly through inheritance.) The compiler then inserts a call
to <pre class="code">doubleToInt</pre> automatically.  Behind the scenes, the code becomes:</p>

<pre>
  <code class="vem">val</code>&nbsp;i:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;doubleToInt(<code class="literal">3.5</code>)
</pre>


<p>This is literally an <em>implicit</em> conversion.  You did 
not explicitly ask for conversion.  Instead, you marked <pre class="code">doubleToInt</pre> as
an available implicit conversion by bringing it into scope as a single identifier, and then the compiler automatically
used it when it needed to convert from a <pre class="code">Double</pre> to an <pre class="code">Int</pre>.</p>

<p>Converting <pre class="code">Double</pre>s to <pre class="code">Int</pre>s might raise some eyebrows because,
it's a dubious idea to have something that causes a loss in precision
happen invisibly. So this is not really a conversion we recommend. It
makes much more sense to go the other way, from some more constrained
type to a more general one. For instance, an <pre class="code">Int</pre> can be converted
without loss of precision to a <pre class="code">Double</pre>, so an implicit conversion
from <pre class="code">Int</pre> to <pre class="code">Double</pre> makes sense. In fact, that's exactly
what happens. The <pre class="code">scala.Predef</pre> object, which is implicitly imported into
every Scala program, defines implicit conversions that convert
"smaller" numeric types to "larger" ones. 
For instance, you will find in
<pre class="code">Predef</pre> the following conversion:</p>

<pre>
  <code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;int2double(x:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Double</code>&nbsp;=&nbsp;x.toDouble
</pre>


<p>That's why in Scala <pre class="code">Int</pre> values can be stored in variables of type <pre class="code">Double</pre>. There's no special rule in the type system for this; it's just an implicit 
conversion that gets applied.<a href="implicit-conversions-and-parameters.html#footnotemain21-3">[3]</a></p>

<h3>21.4 Converting the receiver</h3>


<p>Implicit conversions also apply to the receiver of a method call, the object on which the method is invoked.
This kind of implicit conversion has two main uses.  First,
receiver conversions allow smoother integration of a new class
into an existing class hierarchy. And second, they support writing
domain-specific languages (DSLs) within the language.<a id="i49254319-1"/></p>

<p>To see how it works, suppose you write down 
<pre class="code">obj.doIt</pre>, and <pre class="code">obj</pre>
does not have a member named <pre class="code">doIt</pre>.  The compiler will try to insert
conversions before giving up.  In this case, the conversion needs to
apply to the receiver, <pre class="code">obj</pre>.  The compiler will act as if the
expected "type" of <pre class="code">obj</pre> was "has a member named <pre class="code">doIt</pre>."  This
"has a <pre class="code">doIt</pre>" type is not a normal Scala type, but it
is there conceptually and is why the compiler will insert an implicit
conversion in this case.</p>

<h4>Interoperating with new types</h4>


<p>As mentioned previously, one major use of receiver conversions is allowing smoother integration
of new types with existing types. In particular, they allow you to enable client programmers to use
instances of existing types as if they were instances of your new type.
Take,
for example, class <pre class="code">Rational</pre>
shown in <a href="functional-objects.html#lst-overloaded-methods">Listing 6.5</a>  <a href="functional-objects.html#lst-overloaded-methods">here</a>.
Here's a snippet of that
class again:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;...
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;+&nbsp;(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=&nbsp;...
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;+&nbsp;(that:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=&nbsp;...
  }
</pre>


<p>Class <pre class="code">Rational</pre> has two overloaded variants of the <pre class="code">+</pre> method,
which take <pre class="code">Rational</pre>s and <pre class="code">Int</pre>s, respectively, as arguments.
So you can either add two rational numbers or a rational number and an integer:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;oneHalf&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">oneHalf:&nbsp;Rational&nbsp;=&nbsp;1/2</code>
  <br />  scala&gt;&nbsp;oneHalf&nbsp;+&nbsp;oneHalf
  <code class="output">res0:&nbsp;Rational&nbsp;=&nbsp;1/1</code>
  <br />  scala&gt;&nbsp;oneHalf&nbsp;+&nbsp;<code class="literal">1</code>
  <code class="output">res1:&nbsp;Rational&nbsp;=&nbsp;3/2</code>
</pre>


<p>What about an expression like <pre class="code">1</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">oneHalf</pre>?  This expression is
tricky because the receiver, <pre class="code">1</pre>, does not have a suitable <pre class="code">+</pre>
method.  So the following gives an error:<a id="i1859455133-1"/></p>

<pre>
  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;+&nbsp;oneHalf
  <code class="output">&lt;console&gt;:6:&nbsp;error:&nbsp;overloaded&nbsp;method&nbsp;value&nbsp;+&nbsp;with</code>
  <code class="output">alternatives&nbsp;(Double)Double&nbsp;&lt;and&gt;&nbsp;...&nbsp;cannot&nbsp;be&nbsp;applied</code>
  <code class="output">to&nbsp;(Rational)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+&nbsp;oneHalf</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>To allow this kind of mixed arithmetic, you need to define an 
implicit conversion from <pre class="code">Int</pre> to <pre class="code">Rational</pre>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;intToRational(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(x,&nbsp;<code class="literal">1</code>)
  <code class="output">intToRational:&nbsp;(x:&nbsp;Int)Rational</code>
</pre>


<p>With the conversion in place, converting the receiver does the trick:</p>

<pre>
  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;+&nbsp;oneHalf
  <code class="output">res2:&nbsp;Rational&nbsp;=&nbsp;3/2</code>
</pre>


<p>What happens behind the scenes here is that the Scala compiler first tries to
type check the expression <pre class="code">1</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">oneHalf</pre> as it is. This fails
because <pre class="code">Int</pre> has several <pre class="code">+</pre> methods, but none that takes 
a <pre class="code">Rational</pre> argument. Next, the compiler searches for
an implicit conversion from <pre class="code">Int</pre> to another type that has a <pre class="code">+</pre> method 
which can be applied to a <pre class="code">Rational</pre>. 
It finds your conversion
and applies it, which yields:</p>

<pre>
  intToRational(<code class="literal">1</code>)&nbsp;+&nbsp;oneHalf
</pre>


<p>In this case, the compiler found the implicit conversion function because
you entered its definition into the interpreter, which 
brought it into scope for the remainder of the interpreter session.</p>

<h4>Simulating new syntax</h4>


<p><a id="sec-simulating-new-syntax"/></p>

<p>The other major use of implicit conversions 
is to simulate adding new syntax.
Recall that you can
make a <pre class="code">Map</pre> using syntax like this:</p>

<pre>
  <code class="typename">Map</code>(<code class="literal">1</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"one"</code>,&nbsp;<code class="literal">2</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"two"</code>,&nbsp;<code class="literal">3</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"three"</code>)
</pre>


<p>Have you wondered how the <pre class="code">-&gt;</pre> is supported?<a id="i483527409-1"/>  It's not syntax!
Instead, <pre class="code">-&gt;</pre> is a method of the class <pre class="code">ArrowAssoc</pre>, a class defined
inside the standard Scala preamble (<pre class="code">scala.Predef</pre>).  The preamble
also defines an implicit conversion from <pre class="code">Any</pre> to <pre class="code">ArrowAssoc</pre>.
When you write <pre class="code">1</pre>&nbsp;<pre class="code">-&gt;</pre>&nbsp;<pre class="code">"one"</pre>, the compiler inserts a conversion from
<pre class="code">1</pre> to <pre class="code">ArrowAssoc</pre> so that the <pre class="code">-&gt;</pre> method can be found. 
Here are the relevant definitions:</p>

<pre>
  <code class="vem">package</code>&nbsp;scala
  <code class="vem">object</code>&nbsp;<code class="typename">Predef</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ArrowAssoc[A]</code>(x:&nbsp;A)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;-&gt;&nbsp;[B](y:&nbsp;B):&nbsp;<code class="typename">Tuple2[A,&nbsp;B]</code>&nbsp;=&nbsp;<code class="typename">Tuple2</code>(x,&nbsp;y)
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;any2ArrowAssoc[A](x:&nbsp;A):&nbsp;<code class="typename">ArrowAssoc[A]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrowAssoc</code>(x)
  &nbsp;&nbsp;...
  }
</pre>


<p>This "rich wrappers" pattern is common in libraries that provide
syntax-like extensions to the language, so you should be ready to
recognize the pattern when you see it.<a id="i807731316-2"/><a id="i681737575-2"/>  Whenever you see someone calling
methods that appear not to exist in the receiver class, 
they are probably using implicits.
Similarly, if you see a class named <pre class="code">RichSomething</pre> (<i>e.g.</i>, <pre class="code">RichInt</pre> or
<pre class="code">RichBoolean</pre>),  that class is likely adding syntax-like methods to
type <pre class="code">Something</pre>.</p>

<p>You have already seen this rich wrappers pattern 
for the basic types described in
<a href="basic-types-and-operations.html">Chapter 5</a>.
As you can now see, these rich wrappers apply more widely,
often letting you get by with an internal DSL defined as a library where programmers in
other languages might feel the need to develop an external DSL.<a id="i367427817-1"/></p>

<h4>Implicit classes</h4>


<p>Implicit classes<a id="i-1972624620-1"/><a id="i-2080002837-1"/><a id="i1275741881-1"/> were
added in Scala 2.10 to make it easier to write rich wrapper
classes. An implicit class is a class that is preceded by the
<pre class="code">implicit</pre> keyword. For any such class, the compiler generates an
implicit conversion from the class's constructor parameter to the
class itself. Such a conversion is just what you need if you plan to
use the class for the rich wrappers pattern.</p>

<p>For example, suppose you have a class named <pre class="code">Rectangle</pre> for
representing the width and height of a rectangle on the screen:</p>

<pre>
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Rectangle</code>(width:&nbsp;<code class="typename">Int</code>,&nbsp;height:&nbsp;<code class="typename">Int</code>)
</pre>


<p>If you use this class very frequently, you might want to use the rich
wrappers pattern so you can more easily construct it. Here's one way
to do so.</p>

<pre>
  <code class="vem">implicit</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">RectangleMaker</code>(width:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;x(height:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;<code class="typename">Rectangle</code>(width,&nbsp;height)
  }
</pre>


<p>The above definition defines a <pre class="code">RectangleMaker</pre> class in the usual manner. In
addition, it causes the following conversion to be automatically
generated:</p>

<pre>
  <code class="comment">//&nbsp;Automatically&nbsp;generated</code>
  <code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;<code class="typename">RectangleMaker</code>(width:&nbsp;<code class="typename">Int</code>)&nbsp;=
  &nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">RectangleMaker</code>(width)
</pre>


<p>As a result, you can create points by putting an <pre class="code">x</pre> in between
two integers:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;myRectangle&nbsp;=&nbsp;<code class="literal">3</code>&nbsp;x&nbsp;<code class="literal">4</code>
  <code class="output">&nbsp;&nbsp;myRectangle:&nbsp;Rectangle&nbsp;=&nbsp;Rectangle(3,4)</code>
</pre>


<p>This is how it works: Since type <pre class="code">Int</pre> has no method
named <pre class="code">x</pre>, the compiler will look for an implicit conversion from
<pre class="code">Int</pre> to something that does. It will find the generated
<pre class="code">RectangleMaker</pre> conversion, and <pre class="code">RectangleMaker</pre> does have a method
named <pre class="code">x</pre>. The compiler inserts a call to this conversion, after
which the call to <pre class="code">x</pre> type checks and does what is desired.</p>

<p>As a warning to the adventurous, it might be tempting to think that
any class can have <pre class="code">implicit</pre> put in front of it. It's not so. An
implicit class cannot be a case class, and its constructor must have
exactly one parameter. Also, an implicit class must be located
within some other object, class, or trait. In practice, so long as you
use implicit classes as rich wrappers to add a few methods onto an
existing class, these restrictions should not matter.</p>

<h3>21.5 Implicit parameters</h3>


<p>The remaining place the compiler inserts implicits is within argument
lists.<a id="i-568821387-3"/><a id="i-1127720187-1"/>
The compiler will sometimes replace <pre class="code">someCall(a)</pre> with <pre class="code">someCall(a)(b)</pre>, or
<pre class="code">new</pre>&nbsp;<pre class="code">SomeClass(a)</pre> with <pre class="code">new</pre>&nbsp;<pre class="code">SomeClass(a)(b)</pre>, thereby adding a missing parameter
list to complete a function call. It is the entire last curried parameter list that's supplied, not just the last parameter. For example, if <pre class="code">someCall</pre>'s missing
last parameter list takes three parameters, the compiler might replace <pre class="code">someCall(a)</pre> with <pre class="code">someCall(a)(b,</pre>&nbsp;<pre class="code">c,</pre>&nbsp;<pre class="code">d)</pre>.  For this usage, not only must the inserted
identifiers, such as <pre class="code">b</pre>, <pre class="code">c</pre>, and <pre class="code">d</pre> in <pre class="code">(b,</pre>&nbsp;<pre class="code">c,</pre>&nbsp;<pre class="code">d)</pre>, be marked <pre class="code">implicit</pre> where they are defined, but also the last parameter
list in <pre class="code">someCall</pre>'s or <pre class="code">someClass</pre>'s definition must be marked <pre class="code">implicit</pre>.</p>

<p>Here's a simple example.  Suppose you have a class <pre class="code">PreferredPrompt</pre>, which encapsulates
a shell prompt string (such as, say <pre class="code">"$</pre>&nbsp;<pre class="code">"</pre> or <pre class="code">"&gt;</pre>&nbsp;<pre class="code">"</pre>) that is preferred by a user:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">PreferredPrompt</code>(<code class="vem">val</code>&nbsp;preference:&nbsp;<code class="typename">String</code>)
</pre>


<p>Also, suppose you have a <pre class="code">Greeter</pre> object with a <pre class="code">greet</pre> method, which takes two parameter lists. The first
parameter list takes a string user name, and the second parameter list takes a <pre class="code">PreferredPrompt</pre>:</p>

<pre>
  <code class="vem">object</code>&nbsp;<code class="typename">Greeter</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;greet(name:&nbsp;<code class="typename">String</code>)(<code class="vem">implicit</code>&nbsp;prompt:&nbsp;<code class="typename">PreferredPrompt</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"Welcome,&nbsp;"</code>&nbsp;+&nbsp;name&nbsp;+&nbsp;<code class="quotedstring">".&nbsp;The&nbsp;system&nbsp;is&nbsp;ready."</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;println(prompt.preference)
  &nbsp;&nbsp;}
  }
</pre>


<p>The last parameter list is marked <pre class="code">implicit</pre>, which means it can be supplied implicitly. But you can still
provide the <pre class="code">prompt</pre> explicitly, like this:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bobsPrompt&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PreferredPrompt</code>(<code class="quotedstring">"relax&gt;&nbsp;"</code>)
  <code class="output">bobsPrompt:&nbsp;PreferredPrompt&nbsp;=&nbsp;PreferredPrompt@714d36d6</code>
  <br />  scala&gt;&nbsp;Greeter.greet(<code class="quotedstring">"Bob"</code>)(bobsPrompt)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">Welcome,&nbsp;Bob.&nbsp;The&nbsp;system&nbsp;is&nbsp;ready.</code>
  <code class="output">relax&gt;&nbsp;</code>
</pre>


<p>To let the compiler supply the parameter implicitly, you must first define a variable of the expected
type, which in this case is <pre class="code">PreferredPrompt</pre>. You could do this, for example, in a preferences object:</p>

<pre>
  <code class="vem">object</code>&nbsp;<code class="typename">JoesPrefs</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">val</code>&nbsp;prompt&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PreferredPrompt</code>(<code class="quotedstring">"Yes,&nbsp;master&gt;&nbsp;"</code>)
  }
</pre>


<p>Note that the <pre class="code">val</pre> itself is marked implicit. If it wasn't, the compiler would not use it to supply the
missing parameter list. It will also not use it if it isn't in scope as a single identifier, as shown in this example:<a id="i-1437022486-1"/></p>

<pre>
  scala&gt;&nbsp;Greeter.greet(<code class="quotedstring">"Joe"</code>)
  <code class="output">&lt;console&gt;:13:&nbsp;error:&nbsp;could&nbsp;not&nbsp;find&nbsp;implicit&nbsp;value&nbsp;for&nbsp;</code>
  <code class="output">parameter&nbsp;prompt:&nbsp;PreferredPrompt</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Greeter.greet("Joe")</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>Once you bring it into scope via an import, however, it will be used to supply the missing parameter list:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;JoesPrefs._&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">import&nbsp;JoesPrefs._</code>
  <br />  scala&gt;&nbsp;Greeter.greet(<code class="quotedstring">"Joe"</code>)
  <code class="output">Welcome,&nbsp;Joe.&nbsp;The&nbsp;system&nbsp;is&nbsp;ready.</code>
  <code class="output">Yes,&nbsp;master&gt;&nbsp;</code>
</pre>


<p>Note that the <pre class="code">implicit</pre> keyword applies to an entire parameter list,
not to individual parameters.  <a href="implicit-conversions-and-parameters.html#lst-multiple-implicit-params">Listing 21.1</a> shows an example in which the last parameter
list of <pre class="code">Greeter</pre>'s <pre class="code">greet</pre> method, which is again marked <pre class="code">implicit</pre>, has two parameters: <pre class="code">prompt</pre> (of type <pre class="code">PreferredPrompt</pre>) and <pre class="code">drink</pre>
(of type <pre class="code">PreferredDrink</pre>).</p>

<p>Singleton object <pre class="code">JoesPrefs</pre> declares two implicit <pre class="code">val</pre>s, <pre class="code">prompt</pre> of
type <pre class="code">PreferredPrompt</pre> and <pre class="code">drink</pre> of type <pre class="code">PreferredDrink</pre>. As before, however,
so long as these are not in scope as single identifiers, they won't be used to fill
in a missing parameter list to <pre class="code">greet</pre>:<a id="i-1437022486-2"/></p>

<pre>
  scala&gt;&nbsp;Greeter.greet(<code class="quotedstring">"Joe"</code>)&nbsp;
  <code class="output">&lt;console&gt;:19:&nbsp;error:&nbsp;could&nbsp;not&nbsp;find&nbsp;implicit&nbsp;value&nbsp;for&nbsp;</code>
  <code class="output">parameter&nbsp;prompt:&nbsp;PreferredPrompt</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Greeter.greet("Joe")</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>You can bring both implicit <pre class="code">val</pre>s into scope with an import:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;JoesPrefs._
  <code class="output">import&nbsp;JoesPrefs._</code>
</pre>


<p>Because both <pre class="code">prompt</pre> and <pre class="code">drink</pre> are now in scope as single identifiers,
you can use them to supply the last parameter list explicitly, like this:</p>

<pre>
  scala&gt;&nbsp;Greeter.greet(<code class="quotedstring">"Joe"</code>)(prompt,&nbsp;drink)
  <code class="output">Welcome,&nbsp;Joe.&nbsp;The&nbsp;system&nbsp;is&nbsp;ready.</code>
  <code class="output">But&nbsp;while&nbsp;you&nbsp;work,&nbsp;why&nbsp;not&nbsp;enjoy&nbsp;a&nbsp;cup&nbsp;of&nbsp;tea?</code>
  <code class="output">Yes,&nbsp;master&gt;&nbsp;</code>
</pre>


<p>And because all the rules for implicit parameters are now met, you can alternatively let the Scala compiler
supply <pre class="code">prompt</pre> and <pre class="code">drink</pre> for you by leaving off the last parameter list:</p>

<pre>
  scala&gt;&nbsp;Greeter.greet(<code class="quotedstring">"Joe"</code>)
  <code class="output">Welcome,&nbsp;Joe.&nbsp;The&nbsp;system&nbsp;is&nbsp;ready.</code>
  <code class="output">But&nbsp;while&nbsp;you&nbsp;work,&nbsp;why&nbsp;not&nbsp;enjoy&nbsp;a&nbsp;cup&nbsp;of&nbsp;tea?</code>
  <code class="output">Yes,&nbsp;master&gt;&nbsp;</code>
</pre>


<p><a id="lst-multiple-implicit-params"/></p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">PreferredPrompt</code>(<code class="vem">val</code>&nbsp;preference:&nbsp;<code class="typename">String</code>)
  <code class="vem">class</code>&nbsp;<code class="typename">PreferredDrink</code>(<code class="vem">val</code>&nbsp;preference:&nbsp;<code class="typename">String</code>)
  <br />  <code class="vem">object</code>&nbsp;<code class="typename">Greeter</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;greet(name:&nbsp;<code class="typename">String</code>)(<code class="vem">implicit</code>&nbsp;prompt:&nbsp;<code class="typename">PreferredPrompt</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drink:&nbsp;<code class="typename">PreferredDrink</code>)&nbsp;=&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"Welcome,&nbsp;"</code>&nbsp;+&nbsp;name&nbsp;+&nbsp;<code class="quotedstring">".&nbsp;The&nbsp;system&nbsp;is&nbsp;ready."</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;print(<code class="quotedstring">"But&nbsp;while&nbsp;you&nbsp;work,&nbsp;"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"why&nbsp;not&nbsp;enjoy&nbsp;a&nbsp;cup&nbsp;of&nbsp;"</code>&nbsp;+&nbsp;drink.preference&nbsp;+&nbsp;<code class="quotedstring">"?"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;println(prompt.preference)
  &nbsp;&nbsp;}
  }
  <br />  <code class="vem">object</code>&nbsp;<code class="typename">JoesPrefs</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">val</code>&nbsp;prompt&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PreferredPrompt</code>(<code class="quotedstring">"Yes,&nbsp;master&gt;&nbsp;"</code>)
  &nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">val</code>&nbsp;drink&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PreferredDrink</code>(<code class="quotedstring">"tea"</code>)
  }
</pre>


<h5>Listing 21.1 - An implicit parameter list with multiple parameters.</h5>


<p>One thing to note about the previous examples is that we didn't use <pre class="code">String</pre> as the type
of <pre class="code">prompt</pre> or <pre class="code">drink</pre>, even though ultimately it was a <pre class="code">String</pre> that each
of them provided through their <pre class="code">preference</pre> fields. Because the compiler selects implicit parameters
by matching types of parameters against types of values in scope, implicit parameters usually have "rare"
or "special" enough types that accidental matches are unlikely. 
For example, the types <pre class="code">PreferredPrompt</pre> and
<pre class="code">PreferredDrink</pre> in <a href="implicit-conversions-and-parameters.html#lst-multiple-implicit-params">Listing 21.1</a> were defined solely to serve as implicit parameter types.
As a result, it is unlikely that implicit variables of these types will be in scope if they
aren't intended to be used as implicit parameters to <pre class="code">Greeter.greet</pre>.</p>

<p>Another thing to know about implicit parameters is that they are perhaps most often used to provide
information about a type mentioned <em>explicitly</em> in an earlier parameter list,
similar to the type classes of Haskell.</p>

<p>As an example, consider the <pre class="code">maxListOrdering</pre> function shown in <a href="implicit-conversions-and-parameters.html#lst-max-list-take-one">Listing 21.2</a>, 
which returns the maximum element of the passed list.</p>

<p><a id="lst-max-list-take-one"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;maxListOrdering[T](elements:&nbsp;<code class="typename">List[T]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ordering:&nbsp;<code class="typename">Ordering[T]</code>):&nbsp;T&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;elements&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>()&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IllegalArgumentException</code>(<code class="quotedstring">"empty&nbsp;list!"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x)&nbsp;=&gt;&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;x&nbsp;::&nbsp;rest&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;maxRest&nbsp;=&nbsp;maxListOrdering(rest)(ordering)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(ordering.gt(x,&nbsp;maxRest))&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;maxRest
  &nbsp;&nbsp;&nbsp;&nbsp;}
</pre>


<h5>Listing 21.2 - A function with an upper bound.</h5>


<p>The signature of <pre class="code">maxListOrdering</pre> is similar to that of <pre class="code">orderedMergeSort</pre>,
shown in <a href="type-parameterization.html#lst-upper-bound-sort">Listing 19.12</a>  <a href="type-parameterization.html#lst-upper-bound-sort">here</a>: It takes
a <pre class="code">List[T]</pre> as its argument, and now it takes an additional argument of type <pre class="code">Ordering[T]</pre>.
This additional argument specifies which ordering to use when comparing elements of type
<pre class="code">T</pre>. As such, this version can be used for types that don't have a built-in ordering.
Additionally, this version can be used for types that <em>do</em> have a built-in ordering, but
for which you occasionally want to use some other ordering.</p>

<p>This version is more general, but it's also more cumbersome to
use. Now a caller must specify an explicit ordering even if <pre class="code">T</pre> is
something like <pre class="code">String</pre> or <pre class="code">Int</pre> that has an obvious default
ordering. To make the new method more convenient, it helps to make the
second argument implicit. This approach is shown in <a href="implicit-conversions-and-parameters.html#lst-max-list-take-two">Listing 21.3</a>.</p>

<p>The <pre class="code">ordering</pre> parameter in this example is used to describe the
ordering of <pre class="code">T</pre>s.
 In the body of <pre class="code">maxListImpParm</pre>, this ordering is used
in two places: a recursive call to <pre class="code">maxListImpParm</pre>, and an
<pre class="code">if</pre> expression that checks whether the head of the list is larger than the
maximum element of the rest of the list.</p>

<p><a id="lst-max-list-take-two"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;maxListImpParm[T](elements:&nbsp;<code class="typename">List[T]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">implicit</code>&nbsp;ordering:&nbsp;<code class="typename">Ordering[T]</code>):&nbsp;T&nbsp;=
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;elements&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>()&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IllegalArgumentException</code>(<code class="quotedstring">"empty&nbsp;list!"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x)&nbsp;=&gt;&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;x&nbsp;::&nbsp;rest&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;maxRest&nbsp;=&nbsp;maxListImpParm(rest)(ordering)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(ordering.gt(x,&nbsp;maxRest))&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;maxRest
  &nbsp;&nbsp;&nbsp;&nbsp;}
</pre>


<h5>Listing 21.3 - A function with an implicit parameter.</h5>


<p>The <pre class="code">maxListImpParm</pre> function is an example of an implicit parameter used to provide more information
about a type mentioned explicitly in an earlier parameter list. To be specific,
the implicit parameter <pre class="code">ordering</pre>, of type <pre class="code">Ordering[T]</pre>, provides
more information about type <pre class="code">T</pre>&mdash;in this case, how to order <pre class="code">T</pre>s. Type <pre class="code">T</pre> is mentioned in <pre class="code">List[T]</pre>, the type
of parameter <pre class="code">elements</pre>, which appears in the earlier parameter list. Because <pre class="code">elements</pre> must always be provided
explicitly in any invocation of <pre class="code">maxListImpParm</pre>, the compiler will know <pre class="code">T</pre> at compile time and can therefore determine
whether an implicit definition of type <pre class="code">Ordering[T]</pre> is available. If so, it can pass in the second parameter list, <pre class="code">ordering</pre>, implicitly.</p>

<p>This pattern is so common that the standard Scala library
provides implicit "ordering" methods for many common types.  You could therefore use
this <pre class="code">maxListImpParm</pre> method with a variety of types:</p>

<pre>
  scala&gt;&nbsp;maxListImpParm(<code class="typename">List</code>(<code class="literal">1</code>,<code class="literal">5</code>,<code class="literal">10</code>,<code class="literal">3</code>))
  <code class="output">res9:&nbsp;Int&nbsp;=&nbsp;10</code>
  <br />  scala&gt;&nbsp;maxListImpParm(<code class="typename">List</code>(<code class="literal">1.5</code>,&nbsp;<code class="literal">5.2</code>,&nbsp;<code class="literal">10.7</code>,&nbsp;<code class="literal">3.14159</code>))
  <code class="output">res10:&nbsp;Double&nbsp;=&nbsp;10.7</code>
  <br />  scala&gt;&nbsp;maxListImpParm(<code class="typename">List</code>(<code class="quotedstring">"one"</code>,&nbsp;<code class="quotedstring">"two"</code>,&nbsp;<code class="quotedstring">"three"</code>))
  <code class="output">res11:&nbsp;String&nbsp;=&nbsp;two</code>
</pre>


<p>In the first case, the compiler inserted an <pre class="code">ordering</pre> for
<pre class="code">Int</pre>s; in the second case, for
<pre class="code">Double</pre>s; in the third case, for <pre class="code">String</pre>s.</p>

<h4>A style rule for implicit parameters</h4>


<p>As a style rule, it is best to use a custom named type in the
types of implicit parameters. For example, the types of <pre class="code">prompt</pre> and <pre class="code">drink</pre> in the previous example
was not <pre class="code">String</pre>, but <pre class="code">PreferredPrompt</pre> and <pre class="code">PreferredDrink</pre>, respectively. As a
counterexample, consider that the <pre class="code">maxListImpParm</pre> function could just as
well have been written with the following type signature:</p>

<pre>
  <code class="vem">def</code>&nbsp;maxListPoorStyle[T](elements:&nbsp;<code class="typename">List[T]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">implicit</code>&nbsp;orderer:&nbsp;(T,&nbsp;T)&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>):&nbsp;T
</pre>


<p>To use this version of the function, though, the caller would have to
supply an <pre class="code">orderer</pre> parameter of type <pre class="code">(T,</pre>&nbsp;<pre class="code">T)</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">Boolean</pre>.  This is a
fairly generic type that includes any function from two <pre class="code">T</pre>s to a
<pre class="code">Boolean</pre>.  It does not indicate anything at all about what the type is
for; it could be an equality test, a less-than test, a greater-than
test, or something else entirely.</p>

<p>The actual code for <pre class="code">maxListImpParm</pre>, given in <a href="implicit-conversions-and-parameters.html#lst-max-list-take-two">Listing 21.3</a>, shows better style.  It uses an <pre class="code">ordering</pre>
parameter of type <pre class="code">Ordering[T]</pre>.  The word <pre class="code">Ordering</pre> in this type
indicates exactly what the implicit parameter is used for: it is for
ordering elements of <pre class="code">T</pre>.  Because this <pre class="code">ordering</pre> type is more
explicit, it's no trouble to add implicit providers for this
type in the standard library.  To contrast, imagine the chaos that
would ensue if you added an implicit of type <pre class="code">(T,</pre>&nbsp;<pre class="code">T)</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">Boolean</pre> in the
standard library, and the compiler started sprinkling it around in
people's code.  You would end up with code that compiles and runs, but
that does fairly arbitrary tests against pairs of items! Thus the style rule: Use at least one role-determining name within the
type of an implicit parameter.</p>

<h3 id="sec-context-bounds">21.6 Context bounds</h3>


<p>The previous example showed an opportunity to use an implicit but did
not.  Note that when you use <pre class="code">implicit</pre> on a parameter, not only will the
compiler try to <em>supply</em> that parameter with an implicit value,
but the compiler will also <em>use</em> that parameter as an available
implicit in the body of the method!  Thus, the first use of <pre class="code">ordering</pre>
within the body of the method
can be left out.</p>

<p><a id="lst-max-list-take-three"/></p>

<pre>
  <code class="vem">def</code>&nbsp;maxList[T](elements:&nbsp;<code class="typename">List[T]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">implicit</code>&nbsp;ordering:&nbsp;<code class="typename">Ordering[T]</code>):&nbsp;T&nbsp;=
  <br />  &nbsp;&nbsp;elements&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>()&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IllegalArgumentException</code>(<code class="quotedstring">"empty&nbsp;list!"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x)&nbsp;=&gt;&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;x&nbsp;::&nbsp;rest&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;maxRest&nbsp;=&nbsp;maxList(rest)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;(ordering)&nbsp;is&nbsp;implicit</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(ordering.gt(x,&nbsp;maxRest))&nbsp;x&nbsp;&nbsp;<code class="comment">//&nbsp;this&nbsp;ordering&nbsp;is</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;maxRest&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;still&nbsp;explicit</code>
  &nbsp;&nbsp;}
</pre>


<h5>Listing 21.4 - A function that uses an implicit parameter internally.</h5>


<p>When the compiler examines the code in <a href="implicit-conversions-and-parameters.html#lst-max-list-take-three">Listing 21.4</a>, it will see that the
types do not match up.  The expression <pre class="code">maxList(rest)</pre> only
supplies one parameter list, but <pre class="code">maxList</pre> requires two.
Since the second parameter list is implicit, the compiler
does not give up type checking immediately. Instead, it looks
for an implicit parameter of the appropriate type, in this case
<pre class="code">Ordering[T]</pre>. In this case, it finds one and rewrites the
call to <pre class="code">maxList(rest)(ordering)</pre>, after which the code type checks.</p>

<p>There is also a way to eliminate the second use of <pre class="code">ordering</pre>. It
involves the following method defined in the standard library:</p>

<pre>
  <code class="vem">def</code>&nbsp;implicitly[T](<code class="vem">implicit</code>&nbsp;t:&nbsp;T)&nbsp;=&nbsp;t
</pre>


<p>The effect of calling <pre class="code">implicitly[Foo]</pre> is that the compiler will
look for an implicit definition of type <pre class="code">Foo</pre>. It will then call the
<pre class="code">implicitly</pre> method with that object, which in turn returns the
object right back. Thus you can write <pre class="code">implicitly[Foo]</pre> whenever you
want to find an implicit object of type <pre class="code">Foo</pre> in the current scope.
For example, <a href="implicit-conversions-and-parameters.html#lst-max-list-take-three-b">Listing 21.5</a> shows a use of
<pre class="code">implicitly[Ordering[T]]</pre> to retrieve the <pre class="code">ordering</pre> parameter by its
type.</p>

<p>Look closely at this last version of <pre class="code">maxList</pre>. There is not a single
mention of the <pre class="code">ordering</pre> parameter in the text of the method. The
second parameter could just as well be named "<pre class="code">comparator</pre>":</p>

<div style="page-break-after:always"/>


<pre>
  <code class="vem">def</code>&nbsp;maxList[T](elements:&nbsp;<code class="typename">List[T]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">implicit</code>&nbsp;comparator:&nbsp;<code class="typename">Ordering[T]</code>):&nbsp;T&nbsp;=&nbsp;<code class="comment">//&nbsp;same&nbsp;body...</code>
</pre>


<p><a id="lst-max-list-take-three-b"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;maxList[T](elements:&nbsp;<code class="typename">List[T]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">implicit</code>&nbsp;ordering:&nbsp;<code class="typename">Ordering[T]</code>):&nbsp;T&nbsp;=
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;elements&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>()&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IllegalArgumentException</code>(<code class="quotedstring">"empty&nbsp;list!"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x)&nbsp;=&gt;&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;x&nbsp;::&nbsp;rest&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;maxRest&nbsp;=&nbsp;maxList(rest)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(implicitly[<code class="typename">Ordering[T]</code>].gt(x,&nbsp;maxRest))&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;maxRest
  &nbsp;&nbsp;&nbsp;&nbsp;}
</pre>


<h5>Listing 21.5 - A function that uses <pre class="code">implicitly</pre>.</h5>


<p>For that matter, this version works as well:</p>

<pre>
  <code class="vem">def</code>&nbsp;maxList[T](elements:&nbsp;<code class="typename">List[T]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">implicit</code>&nbsp;iceCream:&nbsp;<code class="typename">Ordering[T]</code>):&nbsp;T&nbsp;=&nbsp;<code class="comment">//&nbsp;same&nbsp;body...</code>
</pre>


<p>Because this pattern is common, Scala lets you
leave out the name of this parameter and shorten
the method header by using a <em>context bound</em>.<a id="i-956942778-2"/>
Using a context bound, you would write the signature of <pre class="code">maxList</pre> as shown
in <a href="implicit-conversions-and-parameters.html#lst-max-list-context-bound">Listing 21.6</a>. The syntax <pre class="code">[T</pre>&nbsp;<pre class="code">:</pre>&nbsp;<pre class="code">Ordering]</pre> is a context bound, and it does two
things. First, it introduces a type parameter <pre class="code">T</pre> as normal. Second,
it adds an implicit parameter of type <pre class="code">Ordering[T]</pre>. In previous
versions of <pre class="code">maxList</pre>, that parameter was called <pre class="code">ordering</pre>, but
when using a context bound you don't know what the parameter will be
called. As shown earlier, you often don't need to know what the
parameter is called.</p>

<p>Intuitively, you can think of a context bound as saying something
<em>about</em> a type parameter. When you write <pre class="code">[T</pre>&nbsp;<pre class="code">&lt;:</pre>&nbsp;<pre class="code">Ordered[T]]</pre> you
are saying that a <pre class="code">T</pre> <em>is</em> an <pre class="code">Ordered[T]</pre>. To contrast, when
you write <pre class="code">[T</pre>&nbsp;<pre class="code">:</pre>&nbsp;<pre class="code">Ordering]</pre> you are not so much saying what <pre class="code">T</pre> is;
rather, you are saying that there is some form of ordering associated
with <pre class="code">T</pre>. Thus, a context bound is quite flexible. It allows you to
use code that requires orderings&mdash;or any other property of a
type&mdash;without having to change the definition of that type.</p>

<p><a id="lst-max-list-context-bound"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;maxList[T&nbsp;:&nbsp;<code class="typename">Ordering</code>](elements:&nbsp;<code class="typename">List[T]</code>):&nbsp;T&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;elements&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>()&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IllegalArgumentException</code>(<code class="quotedstring">"empty&nbsp;list!"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x)&nbsp;=&gt;&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;x&nbsp;::&nbsp;rest&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;maxRest&nbsp;=&nbsp;maxList(rest)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(implicitly[<code class="typename">Ordering[T]</code>].gt(x,&nbsp;maxRest))&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;maxRest
  &nbsp;&nbsp;&nbsp;&nbsp;}
</pre>


<h5>Listing 21.6 - A function with a context bound.</h5>


<h3 id="sec-when-multiple-conversions-apply">21.7 When multiple conversions apply</h3>


<p>It can happen that multiple implicit conversions are in scope and each would work.<a id="i2142988268-1"/> For the most part, Scala refuses to insert a
conversion in such a case. Implicits work well when the conversion
left out is completely obvious and pure boilerplate. If
multiple conversions apply, then the choice isn't so obvious after all.</p>

<p>Here's a simple example. There is a method that takes a sequence,
a conversion that turns an integer into a range, and a conversion
that turns an integer into a list of digits:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;printLength(seq:&nbsp;<code class="typename">Seq[Int]</code>)&nbsp;=&nbsp;println(seq.length)
  <code class="output">printLength:&nbsp;(seq:&nbsp;Seq[Int])Unit</code>
  <br />  scala&gt;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;intToRange(i:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;i
  <code class="output">intToRange:&nbsp;(i:&nbsp;</code>
  <code class="output">Int)scala.collection.immutable.Range.Inclusive</code>
  <br />  scala&gt;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;intToDigits(i:&nbsp;<code class="typename">Int</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.toString.toList.map(_.toInt)
  <code class="output">intToDigits:&nbsp;(i:&nbsp;Int)List[Int]</code>
  <br />  scala&gt;&nbsp;printLength(<code class="literal">12</code>)
  <code class="output">&lt;console&gt;:26:&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Int(12)</code>
  <code class="output">&nbsp;required:&nbsp;Seq[Int]</code>
  <code class="output">Note&nbsp;that&nbsp;implicit&nbsp;conversions&nbsp;are&nbsp;not&nbsp;applicable&nbsp;because&nbsp;</code>
  <code class="output">they&nbsp;are&nbsp;ambiguous:</code>
  <code class="output">&nbsp;both&nbsp;method&nbsp;intToRange&nbsp;of&nbsp;type&nbsp;(i:&nbsp;</code>
  <code class="output">Int)scala.collection.immutable.Range.Inclusive</code>
  <code class="output">&nbsp;and&nbsp;method&nbsp;intToDigits&nbsp;of&nbsp;type&nbsp;(i:&nbsp;Int)List[Int]</code>
  <code class="output">&nbsp;are&nbsp;possible&nbsp;conversion&nbsp;functions&nbsp;from&nbsp;Int(12)&nbsp;to&nbsp;Seq[Int]</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printLength(12)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>The ambiguity here is real. Converting an integer to a sequence of
digits is completely different from converting it to a range. In this
case, the programmer should specify which one is intended and be
explicit. Up through Scala 2.7, that was the end of the story. Whenever multiple
implicit conversions applied, the compiler refused to choose between
them. The situation was just as with method overloading. If you try
to call <pre class="code">foo(null)</pre> and there are two different <pre class="code">foo</pre> overloads
that accept <pre class="code">null</pre>, the compiler will refuse. It will say that the
method call's target is ambiguous.</p>

<p>Scala 2.8 loosened this rule. If one of the available conversions is
strictly <em>more specific</em> than the others, then the compiler
will choose the more specific one. The idea is that whenever there is a
reason to believe a programmer would always choose one of the
conversions over the others, don't require the programmer to write it
explicitly. After all, method overloading has the same relaxation.
Continuing the previous example, if one of the available <pre class="code">foo</pre>
methods takes a <pre class="code">String</pre> while the other takes an <pre class="code">Any</pre>, then choose
the <pre class="code">String</pre> version. It's clearly more specific.</p>

<p>To be more precise, one implicit conversion is <em>more specific</em>
than another if one of the following applies:</p>

<ul>


<li>The argument type of the former is a subtype of the latter's.


</li>
<li>Both conversions are methods, and the enclosing class of the
  former extends the enclosing class of the latter.


</li></ul>


<p>The motivation to revisit this issue and revise the rule was to improve
interoperation between Java collections, Scala collections, and
strings.</p>

<p>Here's a simple example:</p>

<pre>
  <code class="vem">val</code>&nbsp;cba&nbsp;=&nbsp;<code class="quotedstring">"abc"</code>.reverse
</pre>


<p>What is the type inferred for <pre class="code">cba</pre>? Intuitively, the type should be
<pre class="code">String</pre>.  Reversing a string should yield another string, right?
However, in Scala 2.7, what happened was that "abc" was converted to a
Scala collection. Reversing a Scala collection yields a Scala
collection, so the type of <pre class="code">cba</pre> would be a collection. There's also
an implicit conversion back to a string, but that didn't patch up
every problem. For example, in versions prior to Scala 2.8, <pre class="code">"abc"</pre>&nbsp;<pre class="code">==</pre>&nbsp;<pre class="code">"abc".reverse.reverse</pre> was
false!</p>

<p>With Scala 2.8, the type of <pre class="code">cba</pre> is <pre class="code">String</pre>. The old implicit
conversion to a Scala collection (now named <pre class="code">WrappedString</pre>)<a id="i-260905957-1"/><a id="i-61010514-1"/> is retained. However, there is a more
specific conversion supplied from <pre class="code">String</pre> to a new type called
<pre class="code">StringOps</pre>.<a id="i1341725017-2"/><a id="i-1007334645-2"/> <pre class="code">StringOps</pre> has many methods such as <pre class="code">reverse</pre>, but
instead of returning a collection, they return a <pre class="code">String</pre>. The
conversion to <pre class="code">StringOps</pre> is defined directly in <pre class="code">Predef</pre>, whereas
the conversion to a Scala collection is defined in a new class,
<pre class="code">LowPriorityImplicits</pre>,<a id="i-486218258-1"/> which is extended by <pre class="code">Predef</pre>. Whenever a choice exists between these two conversions, the compiler chooses the
conversion to <pre class="code">StringOps</pre>, because it's defined in a subclass of
the class where the other conversion is defined.</p>

<h3>21.8 Debugging implicits</h3>


<p>Implicits are a powerful feature in Scala, but one that's sometimes difficult to get right. This section contains a few tips for debugging implicits.</p>

<p>Sometimes you might wonder why the compiler did not find an implicit
conversion that you think should apply. In that case it helps to write
the conversion out explicitly. If that also gives an error message,
you then know why the compiler could not apply your implicit.</p>

<p>For instance, assume that you mistakenly took
<pre class="code">wrapString</pre> to be a conversion from <pre class="code">String</pre>s to <pre class="code">List</pre>s,
instead of <pre class="code">IndexedSeq</pre>s. You would wonder why the following code
does not work:<a id="i-677980410-8"/></p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;chars:&nbsp;<code class="typename">List[Char]</code>&nbsp;=&nbsp;<code class="quotedstring">"xyz"</code>
  <code class="output">&lt;console&gt;:24:&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;String("xyz")</code>
  <code class="output">&nbsp;required:&nbsp;List[Char]</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;chars:&nbsp;List[Char]&nbsp;=&nbsp;"xyz"</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>Again, it helps to write the <pre class="code">wrapString</pre> conversion explicitly to find out what went wrong:<a id="i-677980410-9"/></p>

<div style="page-break-after:always"/>


<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;chars:&nbsp;<code class="typename">List[Char]</code>&nbsp;=&nbsp;wrapString(<code class="quotedstring">"xyz"</code>)
  <code class="output">&lt;console&gt;:24:&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;scala.collection.immutable.WrappedString</code>
  <code class="output">&nbsp;required:&nbsp;List[Char]</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;chars:&nbsp;List[Char]&nbsp;=&nbsp;wrapString("xyz")</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>With this, you have found the cause of the error: <pre class="code">wrapString</pre> has
the wrong return type. On the other hand, it's also possible 
that inserting the conversion
explicitly will make the error go away. In that case you know that one
of the other rules
(such as the Scope Rule)
was preventing the implicit conversion
from being applied.</p>

<p>When you are debugging a program, it can sometimes help to see what implicit
conversions the compiler is inserting.  The <pre class="code">-Xprint:typer</pre> option to
the compiler is useful for this.  If you run <pre class="code">scalac</pre> with this
option, the compiler will show you what your code looks like
after all implicit conversions have been added by the type checker.
An example is shown in <a href="implicit-conversions-and-parameters.html#lst-example">Listing 21.7</a> and <a href="implicit-conversions-and-parameters.html#lst-print-typer">Listing 21.8</a>.
If you look at the last statement in each of these listings, you'll see that the second parameter
list to <pre class="code">enjoy</pre>, which was left off in the code in <a href="implicit-conversions-and-parameters.html#lst-example">Listing 21.7</a>,
"<pre class="code">enjoy("reader")</pre>,"
was inserted by the compiler, as shown in <a href="implicit-conversions-and-parameters.html#lst-print-typer">Listing 21.8</a>:</p>

<pre>
  <code class="output">Mocha.this.enjoy("reader")(Mocha.this.pref)</code>
</pre>


<p>If you are brave, try <pre class="code">scala</pre>&nbsp;<pre class="code">-Xprint:typer</pre> to get an interactive
shell that prints out the post-typing source code it uses internally.
If you do so, be prepared to see an enormous amount of boilerplate
surrounding the meat of your code.</p>

<p><a id="lst-example"/></p>

<pre>
  <code class="vem">object</code>&nbsp;<code class="typename">Mocha</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">App</code>&nbsp;{
  <br />  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">PreferredDrink</code>(<code class="vem">val</code>&nbsp;preference:&nbsp;<code class="typename">String</code>)
  <br />  &nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">val</code>&nbsp;pref&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PreferredDrink</code>(<code class="quotedstring">"mocha"</code>)
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;enjoy(name:&nbsp;<code class="typename">String</code>)(<code class="vem">implicit</code>&nbsp;drink:&nbsp;<code class="typename">PreferredDrink</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;print(<code class="quotedstring">"Welcome,&nbsp;"</code>&nbsp;+&nbsp;name)
  &nbsp;&nbsp;&nbsp;&nbsp;print(<code class="quotedstring">".&nbsp;Enjoy&nbsp;a&nbsp;"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;print(drink.preference)
  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"!"</code>)
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;enjoy(<code class="quotedstring">"reader"</code>)
  }
</pre>


<h5>Listing 21.7 - Sample code that uses an implicit parameter.</h5>


<p><a id="lst-print-typer"/></p>

<pre>
  $&nbsp;scalac&nbsp;-<code class="typename">Xprint</code>:typer&nbsp;mocha.scala
  <code class="output">[[syntax&nbsp;trees&nbsp;at&nbsp;end&nbsp;of&nbsp;typer]]<code class="comment"></code>
//&nbsp;Scala&nbsp;source:&nbsp;mocha.scala</code>
  <code class="output">package&nbsp;&lt;empty&gt;&nbsp;{</code>
  <code class="output">&nbsp;&nbsp;final&nbsp;object&nbsp;Mocha&nbsp;extends&nbsp;java.lang.Object&nbsp;with&nbsp;Application</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;ScalaObject&nbsp;{</code>
  <br />  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment"></code>
//&nbsp;...</code>
  <br />  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;private[this]&nbsp;val&nbsp;pref:&nbsp;Mocha.PreferredDrink&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Mocha.this.PreferredDrink("mocha");</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;implicit&nbsp;&lt;stable&gt;&nbsp;&lt;accessor&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;pref:&nbsp;Mocha.PreferredDrink&nbsp;=&nbsp;Mocha.this.pref;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;enjoy(name:&nbsp;String)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(implicit&nbsp;drink:&nbsp;Mocha.PreferredDrink):&nbsp;Unit&nbsp;=&nbsp;{</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scala.this.Predef.print("Welcome,&nbsp;".+(name));</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scala.this.Predef.print(".&nbsp;Enjoy&nbsp;a&nbsp;");</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scala.this.Predef.print(drink.preference);</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scala.this.Predef.println("!")</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;};</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Mocha.this.enjoy("reader")(Mocha.this.pref)</code>
  <code class="output">&nbsp;&nbsp;}</code>
  <code class="output">}</code>
</pre>


<h5>Listing 21.8 - Sample code after type checking and insertion of implicits.</h5>


<h3>21.9 Conclusion</h3>


<p>Implicits are a powerful, code-condensing feature of Scala.  This
chapter has shown you Scala's rules about implicits and several common programming situations where you can profit from
using implicits.</p>

<p>As a word of warning, implicits can make code confusing if
they are used too frequently.  Thus, before adding a new implicit
conversion, first ask whether you can achieve a similar effect through
other means, such as inheritance, mixin composition, or method
overloading.  If all of these fail, however, and you feel like a lot
of your code is still tedious and redundant, then implicits might just
be able to help you out.</p>

<hr/>
<h4>Footnotes for Chapter 21:</h4>


<p><a id="footnotemain21-1"/>[1] As will be explained in <a href="combining-scala-and-java.html#sec-java-8-and-scala-212">Section 31.5</a>, it does work in Scala 2.12.<a id="i88737196-3"/></p>

<p><a id="footnotemain21-2"/>[2] Variables and singleton objects marked implicit can be
used as <em>implicit parameters</em>. This use case will be described later in this chapter.</p>

<p><a id="footnotemain21-3"/>[3] The Scala compiler backend will treat the conversion specially, however, 
translating it to a special "<pre class="code">i2d</pre>" bytecode. 
So the compiled image is the same as in Java.</p>

<div style="page-break-after:always"/>


<div style="page-break-after:always"/>

</body>
</html>
