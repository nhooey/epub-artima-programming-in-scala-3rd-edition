<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8"/>
    <title>Programming in Scala, 3rd Edition</title>

    <link rel="stylesheet" type="text/css" href="book.css" />
  </head>
<body>
<h2><a id="chap-functions-and-closures">Chapter 8</a></h2>
<h1>Functions and Closures</h1>


<p>When programs get larger, you need some way to divide them into
smaller, more manageable pieces.  For dividing up control flow, Scala
offers an approach familiar to all experienced programmers: divide the
code into functions.  In fact, Scala offers several ways to define
functions that are not present in Java. Besides methods, which are
functions that are members of some object,
there are also functions nested within functions,
function literals, and function values.
This chapter takes you on a tour through all of these flavors
of functions in Scala.</p>

<h3>8.1 Methods</h3>


<p>The most common way to define a function is as a member of some
object; such a function is called a <span style="font-style:italic">method</span><a id="i955534258-2"/>. As an example, <a href="functions-and-closures.html#lst-longlines-methods">Listing 8.1</a> shows two methods that together read a file with a given name and print out
all lines whose length exceeds a given width. Every printed line is
prefixed with the name of the file it appears in.</p>

<p><a id="lst-longlines-methods"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.io.Source
  <br />  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">LongLines</code>&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;processFile(filename:&nbsp;<code class="typename">String</code>,&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;source&nbsp;=&nbsp;Source.fromFile(filename)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(line&nbsp;&lt;-&nbsp;source.getLines())&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processLine(filename,&nbsp;width,&nbsp;line)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;processLine(filename:&nbsp;<code class="typename">String</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;<code class="typename">Int</code>,&nbsp;line:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(line.length&nbsp;&gt;&nbsp;width)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(filename&nbsp;+&nbsp;<code class="quotedstring">":&nbsp;"</code>&nbsp;+&nbsp;line.trim)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 8.1 - <pre class="code">LongLines</pre> with a private <pre class="code">processLine</pre> method.</h5>


<p>The <pre class="code">processFile</pre> method takes a <pre class="code">filename</pre> and <pre class="code">width</pre> as parameters. 
It creates a <pre class="code">Source</pre> object from the file name and, in the generator of the <pre class="code">for</pre> expression, calls
<pre class="code">getLines</pre> on the source. As mentioned in <a href="next-steps-in-scala.html#step12">Step 12</a> of
<a href="next-steps-in-scala.html">Chapter 3</a>,
<pre class="code">getLines</pre> returns an iterator that provides one
line from the file on each iteration, excluding the end-of-line character. The <pre class="code">for</pre> expression processes
each of these lines by calling the helper method, <pre class="code">processLine</pre>.
The <pre class="code">processLine</pre> 
method takes three parameters: a <pre class="code">filename</pre>, a <pre class="code">width</pre>, and a <pre class="code">line</pre>.
It tests whether the length of the line is greater than the given width, and, if so,
it prints the filename, a colon, and the line.</p>

<p>To use <pre class="code">LongLines</pre> from the command line, we'll create an application that
expects the line width as the first command-line argument, and interprets subsequent arguments as filenames:<a href="functions-and-closures.html#footnotemain8-1">[1]</a></p>

<pre>
  <code class="vem">object</code>&nbsp;<code class="typename">FindLongLines</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;main(args:&nbsp;<code class="typename">Array[String]</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;width&nbsp;=&nbsp;args(<code class="literal">0</code>).toInt
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(arg&nbsp;&lt;-&nbsp;args.drop(<code class="literal">1</code>))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LongLines.processFile(arg,&nbsp;width)
  &nbsp;&nbsp;}&nbsp;
  }&nbsp;
</pre>


<p>Here's how you'd use this application to find the lines in <pre class="code">LongLines.scala</pre> that are over
45 characters in length (there's just one):</p>

<pre>
  $&nbsp;scala&nbsp;FindLongLines&nbsp;45&nbsp;LongLines.scala
  <code class="output">LongLines.scala:&nbsp;def&nbsp;processFile(filename:&nbsp;String,&nbsp;width:&nbsp;Int)&nbsp;=&nbsp;{</code>
</pre>


<p>So far, this is very similar to what you would do in any
object-oriented language.  However, the concept of a function in Scala
is more general than a method. Scala's other ways to express functions will be explained in the following sections.</p>

<h3>8.2 Local functions</h3>


<p>The construction of the <pre class="code">processFile</pre> method in the previous
section demonstrated an important design principle of the
functional programming style: programs should be decomposed into many
small functions that each do a well-defined task. Individual
functions are often quite small. The advantage of this style is that
it gives a programmer many building blocks that can be flexibly
composed to do more difficult things.  Each building block should be
simple enough to be understood individually.</p>

<p>One problem with this approach is that all the helper
function names can pollute the program namespace. In
the interpreter this is not so much of a problem, but once
functions are packaged in reusable classes and objects, it's desirable
to hide the helper functions from clients of a class.  They
often do not make sense individually, and you often want to keep
enough flexibility to delete the helper functions if you later 
rewrite the class a different way.</p>

<p>In Java, your main tool for this purpose is the private
method. This private-method approach works in Scala as well, 
as demonstrated in <a href="functions-and-closures.html#lst-longlines-methods">Listing 8.1</a>,
but Scala offers an additional approach: you can define functions inside other
functions. Just like local variables, such <a href="glossary.html#g43293933"><em>local function</em>s</a> are
visible only in their enclosing block.<a id="i1082301132-1"/><a id="i1342112038-1"/> Here's an example:<a id="i-1153551486-1"/></p>

<pre>
  <code class="vem">def</code>&nbsp;processFile(filename:&nbsp;<code class="typename">String</code>,&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;processLine(filename:&nbsp;<code class="typename">String</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;<code class="typename">Int</code>,&nbsp;line:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(line.length&nbsp;&gt;&nbsp;width)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(filename&nbsp;+&nbsp;<code class="quotedstring">":&nbsp;"</code>&nbsp;+&nbsp;line.trim)
  &nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;
  <br />  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;source&nbsp;=&nbsp;Source.fromFile(filename)
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(line&nbsp;&lt;-&nbsp;source.getLines())&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;processLine(filename,&nbsp;width,&nbsp;line)
  &nbsp;&nbsp;}
  }
</pre>


<p>In this example, we refactored the original <pre class="code">LongLines</pre> version, shown in <a href="functions-and-closures.html#lst-longlines-methods">Listing 8.1</a>,
by transforming private method, <pre class="code">processLine</pre>, into a local function of <pre class="code">processFile</pre>. To do so we removed the
<pre class="code">private</pre> modifier, which can only be applied (and is only needed) for members, and placed the definition
of <pre class="code">processLine</pre> inside the definition of <pre class="code">processFile</pre>.
As a local function, <pre class="code">processLine</pre> is in scope inside <pre class="code">processFile</pre>, but inaccessible outside.</p>

<p>Now that <pre class="code">processLine</pre> is defined inside <pre class="code">processFile</pre>, however,
another improvement becomes possible. 
Notice how <pre class="code">filename</pre> and <pre class="code">width</pre> are 
passed unchanged into the helper function? This is not necessary because 
local functions can access the parameters of their enclosing function.
You can just
use the parameters of the outer <pre class="code">processLine</pre> function, as shown in <a href="functions-and-closures.html#lst-longlines-function">Listing 8.2</a>.</p>

<p><a id="lst-longlines-function"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.io.Source
  <br />  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">LongLines</code>&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;processFile(filename:&nbsp;<code class="typename">String</code>,&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;processLine(line:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(line.length&nbsp;&gt;&nbsp;width)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(filename&nbsp;+&nbsp;<code class="quotedstring">":&nbsp;"</code>&nbsp;+&nbsp;line.trim)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;source&nbsp;=&nbsp;Source.fromFile(filename)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(line&nbsp;&lt;-&nbsp;source.getLines())
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processLine(line)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 8.2 - <pre class="code">LongLines</pre> with a local <pre class="code">processLine</pre> function.</h5>


<p>Simpler, isn't it?  
This use of an enclosing function's parameters is
a common and useful example of the general nesting Scala provides.
The nesting and scoping described in <a href="builtin-control-structures.html#sec-variable-scope">Section 7.7</a>
applies to all Scala constructs, including functions.
It's a simple principle, but very powerful, 
especially in a language with first-class functions.</p>

<h3>8.3 First-class functions</h3>


<p>Scala has <a href="glossary.html#g1589563862"><em>first-class functions</em></a>.<a id="i-1098728772-2"/> Not only can you define
functions and call them, but you can write down functions as unnamed
<em>literals</em> and then pass them around as <em>values</em>.
We introduced function literals
in <a href="first-steps-in-scala.html">Chapter 2</a>
and showed the basic syntax in <a href="first-steps-in-scala.html#fig-function-literal">Figure 2.2</a>  <a href="first-steps-in-scala.html#fig-function-literal">here</a>.</p>

<p>A function literal<a id="i-132187383-1"/> is compiled into a class that<a id="i-1850091418-1"/><a id="i2141458026-1"/>
when instantiated at runtime is a <a href="glossary.html#g1731647273"><em>function value</em></a>.<a href="functions-and-closures.html#footnotemain8-2">[2]</a>
Thus the distinction between
function literals and values is that function literals exist in the source code, whereas function values
exist as objects at runtime.
The distinction is much like that between classes (source code) 
and objects (runtime).</p>

<p>Here is a simple example of a function literal that adds one to a number:</p>

<pre>
  (x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;<code class="literal">1</code>
</pre>


<p>The <pre class="code">=&gt;</pre> designates that this function converts the thing on the left
(any integer <pre class="code">x</pre>) to the thing on the right (<pre class="code">x</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">1</pre>).  So, this is a
function mapping any integer <pre class="code">x</pre> to <pre class="code">x</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">1</pre>.</p>

<p>Function values are objects, so you can store them in variables if you like.
They are functions, too, so you can invoke them using the
usual parentheses
function-call notation.  Here is an example of both activities:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">var</code>&nbsp;increase&nbsp;=&nbsp;(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;<code class="literal">1</code>
  <code class="output">increase:&nbsp;Int&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function1&gt;</code>
  <br />  scala&gt;&nbsp;increase(<code class="literal">10</code>)
  <code class="output">res0:&nbsp;Int&nbsp;=&nbsp;11</code>
</pre>


<p>Because <pre class="code">increase</pre>, in this example, is a <pre class="code">var</pre>, you can assign a different function value to it later on.</p>

<pre>
  scala&gt;&nbsp;increase&nbsp;=&nbsp;(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;<code class="literal">9999</code>
  <code class="output">increase:&nbsp;Int&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function1&gt;</code>
  <br />  scala&gt;&nbsp;increase(<code class="literal">10</code>)
  <code class="output">res1:&nbsp;Int&nbsp;=&nbsp;10009</code>
</pre>


<p>If you want to have more than one statement in the function literal, 
surround its body by curly braces and put one statement per line, thus
forming a <a href="glossary.html#g93832333">block</a>.  Just like
a method, when the function value is invoked, all of the statements will
be executed, and the value returned from the function is whatever
results from evaluating the last expression.</p>

<pre>
  scala&gt;&nbsp;increase&nbsp;=&nbsp;(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"We"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"are"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"here!"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;+&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">increase:&nbsp;Int&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function1&gt;</code>
  <br />  scala&gt;&nbsp;increase(<code class="literal">10</code>)
  <code class="output">We</code>
  <code class="output">are</code>
  <code class="output">here!</code>
  <code class="output">res2:&nbsp;Int&nbsp;=&nbsp;11</code>
</pre>


<p>So now you have seen the nuts and bolts of function literals and
function values.
Many Scala libraries give you opportunities to use them.  For example, a <pre class="code">foreach</pre> method is available for all
collections.<a href="functions-and-closures.html#footnotemain8-3">[3]</a>
It takes a function as an argument and invokes that
function on each of its elements.  Here is how it can be used
to print out all of the elements of a list:
<a id="exa-someNumbers-def"/></p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;someNumbers&nbsp;=&nbsp;<code class="typename">List</code>(-<code class="literal">11</code>,&nbsp;-<code class="literal">10</code>,&nbsp;-<code class="literal">5</code>,&nbsp;<code class="literal">0</code>,&nbsp;<code class="literal">5</code>,&nbsp;<code class="literal">10</code>)
  <code class="output">someNumbers:&nbsp;List[Int]&nbsp;=&nbsp;List(-11,&nbsp;-10,&nbsp;-5,&nbsp;0,&nbsp;5,&nbsp;10)</code>
  <br />  scala&gt;&nbsp;someNumbers.foreach((x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;println(x))
  <code class="output">-11</code>
  <code class="output">-10</code>
  <code class="output">-5</code>
  <code class="output">0</code>
  <code class="output">5</code>
  <code class="output">10</code>
</pre>


<p>As another example, collection types also have a <pre class="code">filter</pre> method.
This method selects those elements of a collection that pass a test
the user supplies.  That test is supplied using a function.  For
example, the function <pre class="code">(x:</pre>&nbsp;<pre class="code">Int)</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">x</pre>&nbsp;<pre class="code">&gt;</pre>&nbsp;<pre class="code">0</pre> could be used for filtering.
This function maps positive integers to true and all others to
false.  Here is how to use it with <pre class="code">filter</pre>:</p>

<pre>
  scala&gt;&nbsp;someNumbers.filter((x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;&gt;&nbsp;<code class="literal">0</code>)
  <code class="output">res4:&nbsp;List[Int]&nbsp;=&nbsp;List(5,&nbsp;10)</code>
</pre>


<p>Methods like <pre class="code">foreach</pre> and <pre class="code">filter</pre> are described further
later in the book.  <a href="working-with-lists.html">Chapter 16</a> talks about their
use in class <pre class="code">List</pre>. <a href="working-with-other-collections.html">Chapter 17</a>
discusses their use with other collection types.</p>

<h3>8.4 Short forms of function literals</h3>


<p>Scala provides a number of ways to leave out redundant information and
write function literals more briefly.  Keep your eyes open for these
opportunities, because they allow you to remove clutter from your
code.</p>

<p>One way to make a function literal more brief is to leave off the 
parameter types.  Thus, the previous example with filter could
be written like this:</p>

<pre>
  scala&gt;&nbsp;someNumbers.filter((x)&nbsp;=&gt;&nbsp;x&nbsp;&gt;&nbsp;<code class="literal">0</code>)
  <code class="output">res5:&nbsp;List[Int]&nbsp;=&nbsp;List(5,&nbsp;10)</code>
</pre>


<p>The Scala compiler knows that <pre class="code">x</pre> must be an integer, because it sees
that you are immediately using the function to filter a list of
integers (referred to by <pre class="code">someNumbers</pre>).  This is called <a href="glossary.html#g-1884158234"><em>target typing</em></a>
because the targeted usage of an expression (in this case, an
argument to <pre class="code">someNumbers.filter()</pre>) is allowed to influence
the typing of that expression (in this case to determine
the type of the <pre class="code">x</pre> parameter).<a id="i-1884158234-1"/><a id="i1428968692-1"/>
The precise details of target typing are not important.
You can simply start by writing 
a function literal without the argument type, and if the compiler gets
confused, add in the type.  Over time you'll get a feel for
which situations the compiler can and cannot puzzle out.</p>

<p>A second way to remove useless characters is to leave out parentheses
around a parameter whose type is inferred.  In the previous
example, the parentheses around <pre class="code">x</pre> are unnecessary:</p>

<pre>
  scala&gt;&nbsp;someNumbers.filter(x&nbsp;=&gt;&nbsp;x&nbsp;&gt;&nbsp;<code class="literal">0</code>)
  <code class="output">res6:&nbsp;List[Int]&nbsp;=&nbsp;List(5,&nbsp;10)</code>
</pre>


<h3 id="sec-placeholder-syntax">8.5 Placeholder syntax</h3>


<p>To make a function literal even more concise, you can use underscores as<a id="i603770043-1"/><a id="i-383997826-1"/><a id="i-372979206-1"/>
placeholders for one or more parameters, so long
as each parameter appears only one time within the function
literal<a id="i788093512-1"/>.  For example,
<pre class="code">_</pre>&nbsp;<pre class="code">&gt;</pre>&nbsp;<pre class="code">0</pre> is very short notation for a function that checks whether a
value is greater than zero:</p>

<pre>
  scala&gt;&nbsp;someNumbers.filter(_&nbsp;&gt;&nbsp;<code class="literal">0</code>)
  <code class="output">res7:&nbsp;List[Int]&nbsp;=&nbsp;List(5,&nbsp;10)</code>
</pre>


<p>You can think of the underscore as a "blank" in the expression that needs
to be "filled in." This blank will be filled in with an argument to the function
each time the function is invoked. For example, given that <pre class="code">someNumbers</pre> was
initialized  <a href="functions-and-closures.html#exa-someNumbers-def">here</a> to 
the value <pre class="code">List(-11,</pre>&nbsp;<pre class="code">-10,</pre>&nbsp;<pre class="code">-5,</pre>&nbsp;<pre class="code">0,</pre>&nbsp;<pre class="code">5,</pre>&nbsp;<pre class="code">10)</pre>, the <pre class="code">filter</pre> method will replace
the blank in <pre class="code">_</pre>&nbsp;<pre class="code">&gt;</pre>&nbsp;<pre class="code">0</pre> first with <pre class="code">-11</pre>, as in <pre class="code">-11</pre>&nbsp;<pre class="code">&gt;</pre>&nbsp;<pre class="code">0</pre>, then
with <pre class="code">-10</pre>, as in <pre class="code">-10</pre>&nbsp;<pre class="code">&gt;</pre>&nbsp;<pre class="code">0</pre>, then with <pre class="code">-5</pre>, as in <pre class="code">-5</pre>&nbsp;<pre class="code">&gt;</pre>&nbsp;<pre class="code">0</pre>, and so on
to the end of the <pre class="code">List</pre>. The function literal <pre class="code">_</pre>&nbsp;<pre class="code">&gt;</pre>&nbsp;<pre class="code">0</pre>, therefore, is equivalent
to the slightly more verbose <pre class="code">x</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">x</pre>&nbsp;<pre class="code">&gt;</pre>&nbsp;<pre class="code">0</pre>, as demonstrated here:</p>

<pre>
  scala&gt;&nbsp;someNumbers.filter(x&nbsp;=&gt;&nbsp;x&nbsp;&gt;&nbsp;<code class="literal">0</code>)
  <code class="output">res8:&nbsp;List[Int]&nbsp;=&nbsp;List(5,&nbsp;10)</code>
</pre>


<p>Sometimes when you use underscores as placeholders for parameters, the compiler might
not have enough information to infer missing parameter types.  For example,
suppose you write <pre class="code">_</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">_</pre> by itself:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;f&nbsp;=&nbsp;_&nbsp;+&nbsp;_
  <code class="output">&lt;console&gt;:7:&nbsp;error:&nbsp;missing&nbsp;parameter&nbsp;type&nbsp;for&nbsp;expanded&nbsp;</code>
  <code class="output">function&nbsp;((x$1,&nbsp;x$2)&nbsp;=&gt;&nbsp;x$1.$plus(x$2))</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;f&nbsp;=&nbsp;_&nbsp;+&nbsp;_</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>In such cases, you can specify the types using a colon, like this:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;f&nbsp;=&nbsp;(_:&nbsp;<code class="typename">Int</code>)&nbsp;+&nbsp;(_:&nbsp;<code class="typename">Int</code>)
  <code class="output">f:&nbsp;(Int,&nbsp;Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function2&gt;</code>
  <br />  scala&gt;&nbsp;f(<code class="literal">5</code>,&nbsp;<code class="literal">10</code>)
  <code class="output">res9:&nbsp;Int&nbsp;=&nbsp;15</code>
</pre>


<p>Note that <pre class="code">_</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">_</pre> expands into a literal for a function that
takes two parameters. This is why you can 
use this short form only if each parameter appears in the function literal exactly once.
Multiple underscores mean multiple parameters, not
reuse of a single parameter repeatedly.
The first underscore represents the first parameter,
the second underscore the second parameter, the third underscore the
third parameter, and so on.</p>

<h3 id="sec-partially-applied-functions">8.6 Partially applied functions</h3>


<p>Although the previous examples substitute underscores in place of
individual parameters, you can also replace an entire parameter
list with an underscore.<a id="i1834060518-1"/><a id="i1842232449-1"/><a id="i1128745740-1"/>
For example, rather than writing <pre class="code">println(_)</pre>,
you could write <pre class="code">println _</pre>. Here's an example:</p>

<pre>
  someNumbers.foreach(println&nbsp;_)
</pre>


<p>Scala treats this short form exactly as if you had written the following:</p>

<pre>
  someNumbers.foreach(x&nbsp;=&gt;&nbsp;println(x))
</pre>


<p>Thus, the underscore in this case is not a placeholder for a single parameter. It is a placeholder for an entire parameter list.
Remember that you need to leave a space between the function name and the
underscore; otherwise, the compiler will think you are referring to
a different symbol, such as, for example, a method named <pre class="code">println_</pre>, which likely
does not exist.</p>

<p>When you use an underscore in this way, you are writing a <a href="glossary.html#g-1880499411"><em>partially applied function</em></a>.
In Scala, when you invoke a function, passing in any needed arguments, you <em>apply</em> that function <em>to</em> the arguments.<a id="i1914165903-1"/>
For example, given the following function:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;sum(a:&nbsp;<code class="typename">Int</code>,&nbsp;b:&nbsp;<code class="typename">Int</code>,&nbsp;c:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;a&nbsp;+&nbsp;b&nbsp;+&nbsp;c
  <code class="output">sum:&nbsp;(a:&nbsp;Int,&nbsp;b:&nbsp;Int,&nbsp;c:&nbsp;Int)Int</code>
</pre>


<p>You could apply the function <pre class="code">sum</pre> to the arguments <pre class="code">1</pre>, <pre class="code">2</pre>, and <pre class="code">3</pre> like this:</p>

<pre>
  scala&gt;&nbsp;sum(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res10:&nbsp;Int&nbsp;=&nbsp;6</code>
</pre>


<p>A partially applied function is an expression in which you don't supply all of the arguments
needed by the function. Instead, you supply some, or none, of the needed arguments.
For example, to create a partially applied function expression involving <pre class="code">sum</pre>, in which you supply none
of the three required arguments, you just place an underscore after "<pre class="code">sum</pre>". The resulting function can
then be stored in a variable. Here's an example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;sum&nbsp;_
  <code class="output">a:&nbsp;(Int,&nbsp;Int,&nbsp;Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function3&gt;</code>
</pre>


<p>Given this code, the Scala compiler instantiates a function value
that takes the three integer parameters missing from the partially applied function expression, <pre class="code">sum _</pre>,
and assigns a reference to that new function value to the variable <pre class="code">a</pre>. When you apply three arguments
to this new function value, it will turn around and invoke <pre class="code">sum</pre>, passing in those
same three arguments:</p>

<pre>
  scala&gt;&nbsp;a(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res11:&nbsp;Int&nbsp;=&nbsp;6</code>
</pre>


<p>Here's what just happened: The variable named <pre class="code">a</pre> refers to a function value object. This function value is an instance of a class generated automatically by the Scala compiler from <pre class="code">sum _</pre>,
the partially applied function expression. The class generated by the compiler has an <pre class="code">apply</pre> method
that takes three arguments.<a href="functions-and-closures.html#footnotemain8-4">[4]</a>
The generated class's <pre class="code">apply</pre> method takes three arguments because three is the number of arguments missing in the
<pre class="code">sum _</pre> expression. The Scala compiler translates the expression <pre class="code">a(1,</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">3)</pre> into an invocation of
the function value's <pre class="code">apply</pre> method, passing in the three arguments <pre class="code">1</pre>, <pre class="code">2</pre>, and <pre class="code">3</pre>. Thus, <pre class="code">a(1,</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">3)</pre>
is a short form for:</p>

<pre>
  scala&gt;&nbsp;a.apply(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res12:&nbsp;Int&nbsp;=&nbsp;6</code>
</pre>


<p>This <pre class="code">apply</pre> method, defined in the class generated automatically by the Scala compiler from
the expression <pre class="code">sum _</pre>, simply forwards those three missing parameters to <pre class="code">sum</pre>, and returns the result.
In this case <pre class="code">apply</pre> invokes <pre class="code">sum(1,</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">3)</pre>, and returns what <pre class="code">sum</pre> returns, which is <pre class="code">6</pre>.</p>

<p>Another way to think about this kind of expression, in which an underscore is used to represent an entire parameter list,
is as a way to transform a <pre class="code">def</pre> into a function value. For example, if you have a local function,
such as <pre class="code">sum(a:</pre>&nbsp;<pre class="code">Int,</pre>&nbsp;<pre class="code">b:</pre>&nbsp;<pre class="code">Int,</pre>&nbsp;<pre class="code">c:</pre>&nbsp;<pre class="code">Int):</pre>&nbsp;<pre class="code">Int</pre>, you can "wrap" it in a function value whose <pre class="code">apply</pre> method has
the same parameter list and result types. When you apply this function value to some arguments, it in turn applies <pre class="code">sum</pre> to those 
same arguments and returns the result. Although you can't assign a method or nested function to a variable, or pass it as
an argument to another function, you
can do these things if you wrap the method or nested function in a function value by placing an underscore after
its name.</p>

<p>Now, although <pre class="code">sum _</pre> is indeed a partially applied function, it may not be obvious to you why it is called this.
It has this name because you are not applying that function to all of its arguments. In the case of <pre class="code">sum _</pre>, you
are applying it to <em>none</em> of its arguments. But you can also express a partially applied function by supplying only <em>some</em> of the required arguments. Here's 
an example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;b&nbsp;=&nbsp;sum(<code class="literal">1</code>,&nbsp;_:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">b:&nbsp;Int&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function1&gt;</code>
</pre>


<p>In this case, you've supplied the first and last argument to <pre class="code">sum</pre>, but not the middle argument. Since only one argument is missing, the Scala compiler generates a new function class whose <pre class="code">apply</pre> method takes
one argument. When invoked with that one argument, this generated function's <pre class="code">apply</pre> method invokes <pre class="code">sum</pre>, passing in <pre class="code">1</pre>,
the argument passed to the function, and <pre class="code">3</pre>. Here are some examples:</p>

<pre>
  scala&gt;&nbsp;b(<code class="literal">2</code>)
  <code class="output">res13:&nbsp;Int&nbsp;=&nbsp;6</code>
</pre>


<p>In this case, <pre class="code">b.apply</pre> invoked <pre class="code">sum(1,</pre>&nbsp;<pre class="code">2,</pre>&nbsp;<pre class="code">3)</pre>.</p>

<pre>
  scala&gt;&nbsp;b(<code class="literal">5</code>)
  <code class="output">res14:&nbsp;Int&nbsp;=&nbsp;9</code>
</pre>


<p>And in this case, <pre class="code">b.apply</pre> invoked <pre class="code">sum(1,</pre>&nbsp;<pre class="code">5,</pre>&nbsp;<pre class="code">3)</pre>.</p>

<p>If you are writing a partially applied function expression in which you leave off all parameters,
such as <pre class="code">println _</pre> or <pre class="code">sum _</pre>, you can express it more concisely by leaving off the underscore if a function is required
at that point in the code.
For example, instead of printing out each of the numbers in <pre class="code">someNumbers</pre> (defined 
 <a href="functions-and-closures.html#exa-someNumbers-def">here</a>) like this:</p>

<pre>
  someNumbers.foreach(println&nbsp;_)
</pre>


<p>You could just write:</p>

<pre>
  someNumbers.foreach(println)
</pre>


<p>This last form is allowed only in places where a function is
required, such as the invocation of <pre class="code">foreach</pre> in this example. The compiler
knows a function is required in this case, because <pre class="code">foreach</pre> requires that a function
be passed as an argument.
In situations where a function is not required, attempting to use this form will cause a compilation error.
Here's an example:<a id="i732535273-1"/></p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;c&nbsp;=&nbsp;sum
  <code class="output">&lt;console&gt;:8:&nbsp;error:&nbsp;missing&nbsp;arguments&nbsp;for&nbsp;method&nbsp;sum;</code>
  <code class="output">follow&nbsp;this&nbsp;method&nbsp;with&nbsp;`_'&nbsp;if&nbsp;you&nbsp;want&nbsp;to&nbsp;treat&nbsp;it&nbsp;as&nbsp;a&nbsp;</code>
  <code class="output">partially&nbsp;applied&nbsp;function</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;c&nbsp;=&nbsp;sum</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;d&nbsp;=&nbsp;sum&nbsp;_
  <code class="output">d:&nbsp;(Int,&nbsp;Int,&nbsp;Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function3&gt;</code>
  <br />  scala&gt;&nbsp;d(<code class="literal">10</code>,&nbsp;<code class="literal">20</code>,&nbsp;<code class="literal">30</code>)
  <code class="output">res14:&nbsp;Int&nbsp;=&nbsp;60</code>
</pre>


<h3>8.7 Closures</h3>


<p>So far in this chapter, all the examples of function literals
have referred only to passed parameters.<a id="i1093320088-1"/> For example, in 
<pre class="code">(x:</pre>&nbsp;<pre class="code">Int)</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">x</pre>&nbsp;<pre class="code">&gt;</pre>&nbsp;<pre class="code">0</pre>, the only variable used in the function body, <pre class="code">x</pre>&nbsp;<pre class="code">&gt;</pre>&nbsp;<pre class="code">0</pre>,
is <pre class="code">x</pre>, which is defined as a parameter to the function. You can, however,
refer to variables defined elsewhere:</p>

<pre>
  (x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;more&nbsp;&nbsp;<code class="comment">//&nbsp;how&nbsp;much&nbsp;more?</code>
</pre>


<p>This function adds "<pre class="code">more</pre>" to its argument, but what is <pre class="code">more</pre>?
From the point of view of this function, <pre class="code">more</pre> is a <a href="glossary.html#g-761850448"><em>free variable</em></a> because<a id="i-2142527293-1"/><a id="i-968704369-1"/> the function literal does not itself give a meaning to it.
The <pre class="code">x</pre> variable, by contrast, is a <a href="glossary.html#g183453406"><em>bound variable</em></a> because<a id="i31167931-2"/><a id="i1392088405-2"/> it
does have a meaning in the context of the function: it is defined as the function's lone parameter, an <pre class="code">Int</pre>.
If you try using this function literal by itself, without any <pre class="code">more</pre> defined in its scope,
the compiler will complain:<a id="i138103638-2"/></p>

<pre>
  scala&gt;&nbsp;(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;more
  <code class="output">&lt;console&gt;:8:&nbsp;error:&nbsp;not&nbsp;found:&nbsp;value&nbsp;more</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x:&nbsp;Int)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;more</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<div class="aside">
<h3>Why the trailing underscore?</h3>


<p>Scala's syntax for partially applied functions highlights a difference in the design trade-offs of Scala and
classical functional languages, such as Haskell or ML. 
In these languages, partially applied functions are considered the normal
case. Furthermore, these languages have a fairly strict static
type system that will usually highlight every error with partial
applications that you can make.  Scala bears a much closer relation to
imperative languages, such as Java, 
where a method that's not applied to all its arguments is
considered an error. Furthermore, the object-oriented tradition of
subtyping and a universal root type accepts some
programs that would be considered erroneous in classical functional
languages.</p>

<p>For instance, say you mistook the <pre class="code">drop(n:</pre>&nbsp;<pre class="code">Int)</pre> method of <pre class="code">List</pre>
for <pre class="code">tail()</pre>, and therefore forgot you need to pass a number to
<pre class="code">drop</pre>. You might write, "<pre class="code">println(drop)</pre>".
Had Scala adopted the classical functional tradition that partially applied
functions are OK everywhere, this code would type check. However, you
might be surprised to find out that the output printed by this <pre class="code">println</pre> statement
would always be <pre class="code">&lt;function&gt;</pre>! What would have happened is that the expression
<pre class="code">drop</pre> would have been treated as a function object.  Because <pre class="code">println</pre> takes
objects of any type, this would have compiled OK, but it would have given an
unexpected result.</p>

<p>To avoid situations like this, Scala normally requires you to specify
function arguments that are left out explicitly, even if the
indication is as simple as a `<pre class="code">_</pre>'.  Scala allows you to
leave off even the <pre class="code">_</pre> only when a function type is expected.</p>

</div>


<p>On the other hand, the same function literal will work fine so long as there is
something available named <pre class="code">more</pre>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">var</code>&nbsp;more&nbsp;=&nbsp;<code class="literal">1</code>
  <code class="output">more:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;addMore&nbsp;=&nbsp;(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;more
  <code class="output">addMore:&nbsp;Int&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function1&gt;</code>
  <br />  scala&gt;&nbsp;addMore(<code class="literal">10</code>)
  <code class="output">res16:&nbsp;Int&nbsp;=&nbsp;11</code>
</pre>


<p>The function value (the object) that's created at runtime from this function
literal is called a <a href="glossary.html#g866552379"><em>closure</em></a>.<a id="i-940840561-1"/><a id="i-698028847-1"/> The name arises from the act of "closing"
the function literal by "capturing" the bindings of its free variables.
A function literal with no free variables, such as <pre class="code">(x:</pre>&nbsp;<pre class="code">Int)</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">x</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">1</pre>,
is called a <em>closed term</em>, where a <em>term</em> is a bit of source
code<a id="i1045501329-1"/>. Thus a function value created at runtime from this function
literal is not a closure in the strictest sense, because <pre class="code">(x:</pre>&nbsp;<pre class="code">Int)</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">x</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">1</pre>  is already closed as written. But any function literal with free variables,
such as <pre class="code">(x:</pre>&nbsp;<pre class="code">Int)</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">x</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">more</pre>, is an <em>open term</em>. Therefore, any function value created at
runtime from <pre class="code">(x:</pre>&nbsp;<pre class="code">Int)</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">x</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">more</pre> will, by definition, require that a binding for
its free variable, <pre class="code">more</pre>, be captured. The resulting function value, which will contain
a reference to the captured <pre class="code">more</pre>  variable, is called a closure because the function value is
the end product of the act of closing the open term, <pre class="code">(x:</pre>&nbsp;<pre class="code">Int)</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">x</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">more</pre>.</p>

<p>This example brings up a question: What happens if
<pre class="code">more</pre> changes after the closure is created?  In Scala, the
answer is that the closure sees the change.  For example:</p>

<pre>
  scala&gt;&nbsp;more&nbsp;=&nbsp;<code class="literal">9999</code>
  <code class="output">more:&nbsp;Int&nbsp;=&nbsp;9999</code>
  <br />  scala&gt;&nbsp;addMore(<code class="literal">10</code>)
  <code class="output">res17:&nbsp;Int&nbsp;=&nbsp;10009</code>
</pre>


<p>Intuitively, Scala's closures capture variables themselves, not the
value to which variables refer.<a href="functions-and-closures.html#footnotemain8-5">[5]</a>
As the previous example shows, the closure created for <pre class="code">(x:</pre>&nbsp;<pre class="code">Int)</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">x</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">more</pre>
sees the change to <pre class="code">more</pre> made outside the closure. The same is true in the
opposite direction. Changes made by a closure to a captured variable are
visible outside the closure. Here's an example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;someNumbers&nbsp;=&nbsp;<code class="typename">List</code>(-<code class="literal">11</code>,&nbsp;-<code class="literal">10</code>,&nbsp;-<code class="literal">5</code>,&nbsp;<code class="literal">0</code>,&nbsp;<code class="literal">5</code>,&nbsp;<code class="literal">10</code>)
  <code class="output">someNumbers:&nbsp;List[Int]&nbsp;=&nbsp;List(-11,&nbsp;-10,&nbsp;-5,&nbsp;0,&nbsp;5,&nbsp;10)</code>
  <br />  scala&gt;&nbsp;<code class="vem">var</code>&nbsp;sum&nbsp;=&nbsp;<code class="literal">0</code>
  <code class="output">sum:&nbsp;Int&nbsp;=&nbsp;0</code>
  <br />  scala&gt;&nbsp;someNumbers.foreach(sum&nbsp;+=&nbsp;&nbsp;_)
</pre>


<pre>
  scala&gt;&nbsp;sum
  <code class="output">res19:&nbsp;Int&nbsp;=&nbsp;-11</code>
</pre>


<p>This example uses a roundabout way to sum the numbers in a <pre class="code">List</pre>.
Variable <pre class="code">sum</pre> is in a surrounding scope from the function literal <pre class="code">sum</pre>&nbsp;<pre class="code">+=</pre>&nbsp;<pre class="code">_</pre>,
which adds numbers to <pre class="code">sum</pre>.
Even though it is the closure modifying <pre class="code">sum</pre> at runtime, the resulting total, <pre class="code">-11</pre>, is still
visible outside the closure.</p>

<p>What if a closure accesses some variable that has several different copies as the program runs?
For example, what if a closure uses a local variable of some function,
and the function is invoked many times?  Which instance of that
variable gets used at each access?</p>

<p>Only one answer is consistent with the rest of the
language: the instance used is the one that was active at the time the
closure was created.  For example, here is a function that creates
and returns "increase" closures:</p>

<pre>
  <code class="vem">def</code>&nbsp;makeIncreaser(more:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;more
</pre>


<p>Each time this function is called it will create a new closure.  Each closure will access the <pre class="code">more</pre> variable that
was active when the closure was created.</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;inc1&nbsp;=&nbsp;makeIncreaser(<code class="literal">1</code>)
  <code class="output">inc1:&nbsp;Int&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function1&gt;</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;inc9999&nbsp;=&nbsp;makeIncreaser(<code class="literal">9999</code>)
  <code class="output">inc9999:&nbsp;Int&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function1&gt;</code>
</pre>


<p>When you call <pre class="code">makeIncreaser(1)</pre>, a closure is created and returned that captures
the value <pre class="code">1</pre> as the binding for <pre class="code">more</pre>. Similarly, when you call <pre class="code">makeIncreaser(9999)</pre>,
a closure that captures the value <pre class="code">9999</pre> for <pre class="code">more</pre> is returned. When you apply these
closures to arguments (in this case, there's just one argument, <pre class="code">x</pre>, which must be
passed in), the result that comes back depends on how <pre class="code">more</pre> was defined when the
closure was created:</p>

<pre>
  scala&gt;&nbsp;inc1(<code class="literal">10</code>)
  <code class="output">res20:&nbsp;Int&nbsp;=&nbsp;11</code>
  <br />  scala&gt;&nbsp;inc9999(<code class="literal">10</code>)
  <code class="output">res21:&nbsp;Int&nbsp;=&nbsp;10009</code>
</pre>


<p>It makes no difference that the <pre class="code">more</pre> in this case is a parameter to
a method call that has already returned.  The Scala compiler
rearranges things in cases like these so that the captured parameter
lives out on the heap, instead of the stack, and thus can outlive the<a id="i-243919082-1"/><a id="i-1976863198-1"/>
method call that created it.  This rearrangement is all taken care of
automatically, so you don't have to worry about it.  Capture any
variable you like: <pre class="code">val</pre>, <pre class="code">var</pre>, or parameter.</p>

<h3 id="sec-fancy-parameters">8.8 Special function call forms</h3>


<p>Most functions and function calls you encounter will be as you have
seen so far in this chapter.  The function will have a fixed number of
parameters, the call will have an equal number of arguments, and the
arguments will be specified in the same order and number as the
parameters.</p>

<p>Since function calls are so central to programming in Scala, however,
a few special forms of function definitions and function calls have
been added to the language to address some special needs.  Scala
supports repeated parameters, named arguments, and default arguments.</p>

<h4>Repeated parameters</h4>


<p>Scala<a id="i1567203046-1"/><a id="i-580179190-2"/><a id="i2051741460-1"/><a id="i-1544402352-2"/> allows you to indicate that the last parameter to a function may be repeated. This allows
clients to pass variable length argument lists to the function. To denote a repeated parameter,
place an asterisk after the type of the parameter. For example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;echo(args:&nbsp;<code class="typename">String</code>*)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(arg&nbsp;&lt;-&nbsp;args)&nbsp;println(arg)
  <code class="output">echo:&nbsp;(args:&nbsp;String*)Unit</code>
</pre>


<p>Defined this way, <pre class="code">echo</pre> can be called with zero to many <pre class="code">String</pre> arguments:</p>

<pre>
  scala&gt;&nbsp;echo()
  <br />  scala&gt;&nbsp;echo(<code class="quotedstring">"one"</code>)
  <code class="output">one</code>
  <br />  scala&gt;&nbsp;echo(<code class="quotedstring">"hello"</code>,&nbsp;<code class="quotedstring">"world!"</code>)
  <code class="output">hello</code>
  <code class="output">world!</code>
</pre>


<p>Inside the function, the type of the repeated parameter is an <pre class="code">Array</pre> of the declared type of the parameter. Thus, the type of <pre class="code">args</pre> inside the <pre class="code">echo</pre> function, which is declared as type "<pre class="code">String*</pre>" is actually <pre class="code">Array[String]</pre>. Nevertheless, if you have an
array of the appropriate type, and you attempt to pass it as a repeated parameter, you'll get a compiler
error:<a id="i-677980410-1"/></p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;arr&nbsp;=&nbsp;<code class="typename">Array</code>(<code class="quotedstring">"What's"</code>,&nbsp;<code class="quotedstring">"up"</code>,&nbsp;<code class="quotedstring">"doc?"</code>)
  <code class="output">arr:&nbsp;Array[String]&nbsp;=&nbsp;Array(What's,&nbsp;up,&nbsp;doc?)</code>
  <br />  scala&gt;&nbsp;echo(arr)
  <code class="output">&lt;console&gt;:10:&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Array[String]</code>
  <code class="output">&nbsp;required:&nbsp;String</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo(arr)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>To accomplish this, you'll need to append the array argument with a colon and an _* symbol,<a id="i-170392618-1"/> like this:<a id="i433377555-1"/><a id="i2101376046-1"/></p>

<pre>
  scala&gt;&nbsp;echo(arr:&nbsp;_*)
  <code class="output">What's</code>
  <code class="output">up</code>
  <code class="output">doc?</code>
</pre>


<p>This notation tells the compiler to pass each element of
<pre class="code">arr</pre> as its own argument to <pre class="code">echo</pre>, rather than all of
it as a single argument.</p>

<h4>Named arguments</h4>


<p>In a normal function call, the arguments in the call are matched one
by one in the order of the parameters of the called function:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;speed(distance:&nbsp;<code class="typename">Float</code>,&nbsp;time:&nbsp;<code class="typename">Float</code>):&nbsp;<code class="typename">Float</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance&nbsp;/&nbsp;time
  <code class="output">speed:&nbsp;(distance:&nbsp;Float,&nbsp;time:&nbsp;Float)Float</code>
  <br />  scala&gt;&nbsp;speed(<code class="literal">100</code>,&nbsp;<code class="literal">10</code>)
  <code class="output">res27:&nbsp;Float&nbsp;=&nbsp;10.0</code>
</pre>


<p>In this call, the 100 is matched to <pre class="code">distance</pre> and the 10 
to <pre class="code">time</pre>.  The 100 and 10 are matched in the same order as the
formal parameters are listed.</p>

<p>Named arguments<a id="i1416238505-1"/><a id="i-700806123-1"/><a id="i23167279-1"/>
allow you to pass arguments to a function in a different order.  The
syntax is simply that each argument is preceded by a parameter name
and an equals sign.  For example, the following call to speed is
equivalent to <pre class="code">speed(100,10)</pre>:</p>

<pre>
  scala&gt;&nbsp;speed(distance&nbsp;=&nbsp;<code class="literal">100</code>,&nbsp;time&nbsp;=&nbsp;<code class="literal">10</code>)
  <code class="output">res28:&nbsp;Float&nbsp;=&nbsp;10.0</code>
</pre>


<p>Called with named arguments, the arguments can be reversed without
changing the meaning:</p>

<pre>
  scala&gt;&nbsp;speed(time&nbsp;=&nbsp;<code class="literal">10</code>,&nbsp;distance&nbsp;=&nbsp;<code class="literal">100</code>)
  <code class="output">res29:&nbsp;Float&nbsp;=&nbsp;10.0</code>
</pre>


<p>It is also possible to mix positional and named arguments. In that case, the 
positional arguments come first. Named arguments are most frequently used in combination with default
parameter values.</p>

<h4>Default parameter values</h4>


<p>Scala lets you specify default values<a id="i869856667-1"/> for function parameters. 
The argument for such a parameter can optionally
be omitted from a function call, in which case the corresponding
argument will be filled in with the default.</p>

<p>An example is shown in <a href="functions-and-closures.html#lst-default">Listing 8.3</a>.  Function
<pre class="code">printTime</pre> has one parameter, <pre class="code">out</pre>, and it has a default value of
<pre class="code">Console.out</pre>.
<a id="lst-default"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;printTime(out:&nbsp;<code class="typename">java.io.PrintStream</code>&nbsp;=&nbsp;Console.out)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;out.println(<code class="quotedstring">"time&nbsp;=&nbsp;"</code>&nbsp;+&nbsp;System.currentTimeMillis())
</pre>


<h5>Listing 8.3 - A parameter with a default value.</h5>


<p>If you call the function as <pre class="code">printTime()</pre>, thus specifying no
argument to be used for <pre class="code">out</pre>, then <pre class="code">out</pre> will be set to its
default value of <pre class="code">Console.out</pre>. 
You could also call the function with an explicit output stream.
For example, you could send logging to the standard error output by calling the
function as <pre class="code">printTime(Console.err)</pre>.</p>

<p>Default parameters are especially helpful when used in combination
with named parameters.  In <a href="functions-and-closures.html#lst-default2">Listing 8.4</a>, function
<pre class="code">printTime2</pre> has two optional parameters.  The <pre class="code">out</pre> parameter has a
default of <pre class="code">Console.out</pre>, and the <pre class="code">divisor</pre> parameter has a default
value of <pre class="code">1</pre>.
<a id="lst-default2"/></p>

<pre>
  <code class="vem">def</code>&nbsp;printTime2(out:&nbsp;<code class="typename">java.io.PrintStream</code>&nbsp;=&nbsp;Console.out,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;divisor:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;<code class="literal">1</code>)&nbsp;=
  &nbsp;&nbsp;out.println(<code class="quotedstring">"time&nbsp;=&nbsp;"</code>&nbsp;+&nbsp;System.currentTimeMillis()/divisor)
</pre>


<h5>Listing 8.4 - A function with two parameters that have defaults.</h5>


<p>Function <pre class="code">printTime2</pre> can be called as <pre class="code">printTime2()</pre> to have both
parameters filled in with their default values.  Using named
arguments, however, either one of the parameters can be specified
while leaving the other as the default.  To specify the output stream,
call it like this:</p>

<pre>
  printTime2(out&nbsp;=&nbsp;Console.err)
</pre>


<p>To specify the time divisor, call it like this:</p>

<pre>
  printTime2(divisor&nbsp;=&nbsp;<code class="literal">1000</code>)
</pre>


<h3 id="sec-tail-recursion">8.9 Tail recursion</h3>


<p>In <a href="builtin-control-structures.html#sec-while-loops">Section 7.2</a>, we<a id="i1651241320-1"/><a id="i1113229075-1"/><a id="i2133301138-1"/>
mentioned that to transform a <pre class="code">while</pre> loop that updates <pre class="code">var</pre>s into
a more functional style that uses only <pre class="code">val</pre>s, you may sometimes need
to use recursion.
Here's an example of a
recursive function that approximates a value by repeatedly improving
a guess until it is good enough:</p>

<pre>
  <code class="vem">def</code>&nbsp;approximate(guess:&nbsp;<code class="typename">Double</code>):&nbsp;<code class="typename">Double</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(isGoodEnough(guess))&nbsp;guess
  &nbsp;&nbsp;<code class="vem">else</code>&nbsp;approximate(improve(guess))
</pre>


<p>A function like this is often used in search problems, with appropriate implementations
for <pre class="code">isGoodEnough</pre> and <pre class="code">improve</pre>.
If you want the <pre class="code">approximate</pre> function to run faster, you might be tempted to write it with a
<pre class="code">while</pre> loop to try and speed it up, like this:</p>

<pre>
  <code class="vem">def</code>&nbsp;approximateLoop(initialGuess:&nbsp;<code class="typename">Double</code>):&nbsp;<code class="typename">Double</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;guess&nbsp;=&nbsp;initialGuess
  &nbsp;&nbsp;<code class="vem">while</code>&nbsp;(!isGoodEnough(guess))
  &nbsp;&nbsp;&nbsp;&nbsp;guess&nbsp;=&nbsp;improve(guess)
  &nbsp;&nbsp;guess
  }
</pre>


<p>Which of the two versions of <pre class="code">approximate</pre> is
preferable? In terms of brevity and <pre class="code">var</pre> avoidance, the first, functional one
wins. But is the imperative approach perhaps more
efficient? In fact, if we measure execution times, it turns out that<a id="i1671917386-1"/>
they are almost exactly the same!</p>

<p>This might seem surprising because a recursive call looks much more
"expansive" than a simple jump from the end of a loop to its beginning. However, in the case of <pre class="code">approximate</pre> above, the Scala compiler is able to
apply an important optimization. Note that the recursive call is the last thing that happens in the evaluation of function <pre class="code">approximate</pre>'s
body. Functions like <pre class="code">approximate</pre>, which call themselves as their
last action, are called <a href="glossary.html#g2133301346"><em>tail recursive</em></a>.<a id="i-2133336344-1"/><a id="i1640045089-1"/> The Scala compiler detects
tail recursion and replaces it with a jump back to the beginning of
the function, after updating the function parameters with the new
values.</p>

<p>The moral is that you should not shy away from using
recursive algorithms to solve your problem. Often, a recursive
solution is more elegant and concise than a loop-based one. If the
solution is tail recursive, there won't be any runtime overhead
to be paid.</p>

<h4>Tracing tail-recursive functions</h4>


<p>A tail-recursive function will not build a new stack frame for
each call; all calls will execute in a single frame. 
This may surprise a programmer inspecting a stack trace of a program that failed. For example, this<a id="i10962622-1"/>
function calls itself some number of times then throws an exception:</p>

<pre>
  <code class="vem">def</code>&nbsp;boom(x:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(x&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Exception</code>(<code class="quotedstring">"boom!"</code>)
  &nbsp;&nbsp;<code class="vem">else</code>&nbsp;boom(x&nbsp;-&nbsp;<code class="literal">1</code>)&nbsp;+&nbsp;<code class="literal">1</code>
</pre>


<p>This function is <span style="font-style:italic">not</span> tail recursive, because it performs an increment
operation after the recursive call. You'll get what you expect when you run it:</p>

<pre>
  scala&gt;&nbsp;&nbsp;boom(<code class="literal">3</code>)
  <code class="output">java.lang.Exception:&nbsp;boom!</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.boom(&lt;console&gt;:5)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.boom(&lt;console&gt;:6)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.boom(&lt;console&gt;:6)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.boom(&lt;console&gt;:6)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.&lt;init&gt;(&lt;console&gt;:6)</code>
  <code class="output">...</code>
</pre>


<div class="aside">
<h3>Tail call optimization</h3>


<p>The compiled code for <pre class="code">approximate</pre> is essentially the same as
the compiled code for <pre class="code">approximateLoop</pre>. Both functions compile down to the 
same thirteen instructions of Java bytecodes. If you look through the bytecodes
generated by the Scala compiler for the tail recursive method, <pre class="code">approximate</pre>, you'll see that although
both <pre class="code">isGoodEnough</pre> and <pre class="code">improve</pre> are invoked in the body of the
method, <pre class="code">approximate</pre> is not. The Scala compiler optimized away
the recursive call<a id="i46846037-1"/>:</p>

<pre>
  public&nbsp;double&nbsp;approximate(double);
  &nbsp;&nbsp;Code:
  &nbsp;&nbsp;&nbsp;0:&nbsp;&nbsp;&nbsp;aload_0
  &nbsp;&nbsp;&nbsp;1:&nbsp;&nbsp;&nbsp;astore_3
  &nbsp;&nbsp;&nbsp;2:&nbsp;&nbsp;&nbsp;aload_0
  &nbsp;&nbsp;&nbsp;3:&nbsp;&nbsp;&nbsp;dload_1
  &nbsp;&nbsp;&nbsp;4:&nbsp;&nbsp;&nbsp;invokevirtual&nbsp;&nbsp;&nbsp;#24;&nbsp;//Method&nbsp;isGoodEnough:(D)Z
  &nbsp;&nbsp;&nbsp;7:&nbsp;&nbsp;&nbsp;ifeq&nbsp;&nbsp;&nbsp;&nbsp;12
  &nbsp;&nbsp;&nbsp;10:&nbsp;&nbsp;dload_1
  &nbsp;&nbsp;&nbsp;11:&nbsp;&nbsp;dreturn
  &nbsp;&nbsp;&nbsp;12:&nbsp;&nbsp;aload_0
  &nbsp;&nbsp;&nbsp;13:&nbsp;&nbsp;dload_1
  &nbsp;&nbsp;&nbsp;14:&nbsp;&nbsp;invokevirtual&nbsp;&nbsp;&nbsp;#27;&nbsp;//Method&nbsp;improve:(D)D
  &nbsp;&nbsp;&nbsp;17:&nbsp;&nbsp;dstore_1
  &nbsp;&nbsp;&nbsp;18:&nbsp;&nbsp;goto&nbsp;&nbsp;&nbsp;&nbsp;2
</pre>


</div>


<p>If you now modify <pre class="code">boom</pre> so that it does become tail recursive:</p>

<pre>
  <code class="vem">def</code>&nbsp;bang(x:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(x&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Exception</code>(<code class="quotedstring">"bang!"</code>)
  &nbsp;&nbsp;<code class="vem">else</code>&nbsp;bang(x&nbsp;-&nbsp;<code class="literal">1</code>)
</pre>


<p>You'll get:</p>

<pre>
  scala&gt;&nbsp;bang(<code class="literal">5</code>)
  <code class="output">java.lang.Exception:&nbsp;bang!</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.&lt;init&gt;(&lt;console&gt;:6)&nbsp;...</code>
</pre>


<p>This time, you see only a single stack frame for <pre class="code">bang</pre>. You might
think that <pre class="code">bang</pre> crashed before it called itself, but this is not
the case.  If you think you might be confused by tail-call
optimizations when looking at a stack trace, you can turn them off by
giving the following argument to the <pre class="code">scala</pre> shell or to the <pre class="code">scalac</pre> compiler:<a id="i-1882129636-1"/><a id="i2131054531-1"/></p>

<pre>
  -g:notailcalls
</pre>


<p>With that option specified, you will get a longer stack trace:</p>

<pre>
  scala&gt;&nbsp;bang(<code class="literal">5</code>)
  <code class="output">java.lang.Exception:&nbsp;bang!</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.&lt;init&gt;(&lt;console&gt;:6)&nbsp;...</code>
</pre>


<h4>Limits of tail recursion</h4>


<p>The use of tail recursion in Scala is fairly limited because the JVM<a id="i2022023743-1"/><a id="i1086960686-1"/>
instruction set makes implementing more advanced forms of tail
recursion very difficult. Scala only optimizes directly recursive calls back
to the same function making the call.  If the recursion is indirect, as in the
following example of two mutually recursive functions, no
optimization is possible:</p>

<pre>
  <code class="vem">def</code>&nbsp;isEven(x:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(x&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;<code class="vem">true</code>&nbsp;<code class="vem">else</code>&nbsp;isOdd(x&nbsp;-&nbsp;<code class="literal">1</code>)
  <code class="vem">def</code>&nbsp;isOdd(x:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(x&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;<code class="vem">false</code>&nbsp;<code class="vem">else</code>&nbsp;isEven(x&nbsp;-&nbsp;<code class="literal">1</code>)
</pre>


<p>You also won't get a tail-call optimization if the final call 
goes to a function value. Consider for instance the following recursive code:</p>

<pre>
  <code class="vem">val</code>&nbsp;funValue&nbsp;=&nbsp;nestedFun&nbsp;_
  <code class="vem">def</code>&nbsp;nestedFun(x:&nbsp;<code class="typename">Int</code>)&nbsp;:&nbsp;<code class="typename">Unit</code>&nbsp;=&nbsp;{&nbsp;
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(x&nbsp;!=&nbsp;<code class="literal">0</code>)&nbsp;{&nbsp;println(x);&nbsp;funValue(x&nbsp;-&nbsp;<code class="literal">1</code>)&nbsp;}
  }
</pre>


<p>The <pre class="code">funValue</pre> variable refers to a function value that essentially wraps a call to <pre class="code">nestedFun</pre>. When you
apply the function value to an argument, it turns around and applies <pre class="code">nestedFun</pre> to that same
argument, and returns the result.
Therefore, you might hope the Scala compiler would perform a tail-call optimization,
but in this case it would not. Tail-call optimization is limited to situations where a method or nested function calls itself directly as its last operation, without going through a function value or some other intermediary.
(If you don't fully understand tail recursion yet, see <a href="functions-and-closures.html#sec-tail-recursion">Section 8.9</a>).</p>

<h3>8.10 Conclusion</h3>


<p>This chapter has given you a grand tour of functions in Scala.
In addition to methods, Scala provides local functions, function
literals, and function values.  In addition to normal function calls,
Scala provides partially applied functions and functions with repeated
parameters.  When possible, function calls are implemented as optimized
tail calls, and thus many nice-looking recursive functions run just
as quickly as hand-optimized versions that use <pre class="code">while</pre> loops.
The next chapter will build on these foundations and show
how Scala's rich support for functions helps you abstract
over control.</p>

<hr/>
<h4>Footnotes for Chapter 8:</h4>


<p><a id="footnotemain8-1"/>[1] In this book,
we usually won't check command-line arguments for validity in example applications, both to save trees and reduce boilerplate code that can obscure the
example's important code. The trade-off is that instead of producing a helpful error message when given bad input, our example
applications will throw an exception.</p>

<p><a id="footnotemain8-2"/>[2] Every function value is an instance of some class that extends one of several <pre class="code">FunctionN</pre> traits in package
<pre class="code">scala</pre>, such as <pre class="code">Function0</pre> for functions with no parameters, <pre class="code">Function1</pre> for
functions with one parameter, and so on. Each <pre class="code">FunctionN</pre> trait has an <pre class="code">apply</pre> method
used to invoke the function.</p>

<p><a id="footnotemain8-3"/>[3] A <pre class="code">foreach</pre> method is defined in trait <pre class="code">Traversable</pre>, a common supertrait of <pre class="code">List</pre>, <pre class="code">Set</pre>, <pre class="code">Array</pre>, and <pre class="code">Map</pre>. See <a href="working-with-other-collections.html">Chapter 17</a>
for the details.</p>

<p><a id="footnotemain8-4"/>[4] The generated class extends trait <pre class="code">Function3</pre>, which declares a three-arg <pre class="code">apply</pre> method.</p>

<p><a id="footnotemain8-5"/>[5] By contrast, Java's inner classes<a id="i706520282-1"/>
do not allow you to access modifiable variables in surrounding scopes
at all, so there is no difference between capturing a variable
and capturing its currently held value.</p>

<div style="page-break-after:always"/>


<div style="page-break-after:always"/>

</body>
</html>
