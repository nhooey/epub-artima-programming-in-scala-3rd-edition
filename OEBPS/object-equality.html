<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8"/>
    <title>Programming in Scala, 3rd Edition</title>

    <link rel="stylesheet" type="text/css" href="book.css" />
  </head>
<body>
<h2><a id="chap-object-equality">Chapter 30</a></h2>
<h1>Object Equality</h1>


<p>Comparing two values for equality is ubiquitous in programming.  It is
also more tricky than it looks at first glance. This chapter looks at
object equality in detail and gives some recommendations to consider
when you design your own equality tests.</p>

<h3>30.1 Equality in Scala</h3>


<p>As mentioned in <a href="scalas-hierarchy.html#sec-impl-primitives">Section 11.2</a>,
the definition of equality is different in Scala and
Java.  Java has
two equality comparisons: the <pre class="code">==</pre>
operator,<a id="i-2046772853-1"/><a id="i-1785676493-1"/> which is the natural equality for value
types and object identity for reference types, and the <pre class="code">equals</pre> method, which is
(user-defined) canonical equality for reference
types.<a id="i-342464093-2"/> This convention
is problematic because the more natural symbol, <pre class="code">==</pre>, does not
always correspond to the natural notion of equality. When programming
in Java, a common pitfall for beginners is to compare
objects with <pre class="code">==</pre> when they should be compared with
<pre class="code">equals</pre>.  For instance, comparing two strings <pre class="code">x</pre> and <pre class="code">y</pre> using
"<pre class="code">x</pre>&nbsp;<pre class="code">==</pre>&nbsp;<pre class="code">y</pre>" might yield <pre class="code">false</pre> in Java, even if <pre class="code">x</pre> and <pre class="code">y</pre>
have exactly the same characters in
the same order.</p>

<p>Scala also has an equality method signifying object identity, but it is not used
much.  That kind of equality, written "<pre class="code">x</pre>&nbsp;<pre class="code">eq</pre>&nbsp;<pre class="code">y</pre>", is 
true if <pre class="code">x</pre> and <pre class="code">y</pre> reference the same object.<a id="i-795280463-3"/><a id="i2030434891-3"/><a id="i1544052809-3"/><a id="i-644344128-1"/>
The <pre class="code">==</pre> equality<a id="i-1583721442-3"/><a id="i1095465388-3"/>
is reserved in Scala for the "natural" equality of each type.  For
value types, <pre class="code">==</pre> is value comparison, just like in Java.
For reference types, <pre class="code">==</pre> is
the same as <pre class="code">equals</pre> in Scala.
You can redefine the behavior of <pre class="code">==</pre> for new
types by overriding the <pre class="code">equals</pre> method, which is always inherited
from class <pre class="code">Any</pre>. The inherited <pre class="code">equals</pre>, which takes effect unless
overridden, is object identity, as is the case in Java.  So <pre class="code">equals</pre>
(and with it, <pre class="code">==</pre>) is by default the same as <pre class="code">eq</pre>, but you can
change its behavior by overriding the <pre class="code">equals</pre> method in the classes
you define.  It is not possible to override <pre class="code">==</pre> directly, as it is
defined as a final method in class <pre class="code">Any</pre>.
 That is, Scala treats
<pre class="code">==</pre> as if it were defined as follows in class <pre class="code">Any</pre>:</p>

<pre>
  <code class="vem">final</code>&nbsp;<code class="vem">def</code>&nbsp;==&nbsp;(that:&nbsp;<code class="typename">Any</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(<code class="vem">null</code>&nbsp;eq&nbsp;<code class="vem">this</code>)&nbsp;{<code class="vem">null</code>&nbsp;eq&nbsp;that}&nbsp;<code class="vem">else</code>&nbsp;{<code class="vem">this</code>&nbsp;equals&nbsp;that}
</pre>


<h3 id="sec-writing-an-equality-method">30.2 Writing an equality method</h3>


<p>How should the <pre class="code">equals</pre> method be defined? It turns out that writing
a correct equality method is surprisingly difficult in object-oriented
languages. In fact, after studying a large body of Java code, the authors of a 2007 paper concluded that
almost all implementations of <pre class="code">equals</pre> methods are faulty.<a href="object-equality.html#footnotemain30-1">[1]</a> This is problematic because equality is at the basis of many other
things. For one, a faulty equality method for a type <pre class="code">C</pre> might mean
that you cannot reliably put an object of type <pre class="code">C</pre> in a
collection.</p>

<p>For example, you might have two elements, <pre class="code">elem1</pre> and <pre class="code">elem2</pre>, of type
<pre class="code">C</pre> which are equal (<i>i.e.</i>, "<pre class="code">elem1</pre>&nbsp;<pre class="code">equals</pre>&nbsp;<pre class="code">elem2</pre>" yields <pre class="code">true</pre>).  Nevertheless,
with commonly occurring faulty implementations of the <pre class="code">equals</pre> method,
you could still see behavior like the following:</p>

<pre>
  <code class="vem">var</code>&nbsp;hashSet:&nbsp;<code class="typename">Set[C]</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">collection.immutable.HashSet</code>
  hashSet&nbsp;+=&nbsp;elem1
  hashSet&nbsp;contains&nbsp;elem2&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;returns&nbsp;false!</code>
</pre>


<p>Here are four common pitfalls<a href="object-equality.html#footnotemain30-2">[2]</a>
that can cause inconsistent behavior when overriding <pre class="code">equals</pre>:</p>

<ol>


<li>Defining <pre class="code">equals</pre> with the wrong signature.


</li>
<li>Changing <pre class="code">equals</pre> without also changing <pre class="code">hashCode</pre>.


</li>
<li>Defining <pre class="code">equals</pre> in terms of mutable fields.


</li>
<li>Failing to define <pre class="code">equals</pre> as an equivalence relation.


</li></ol>


<p>These four pitfalls
are discussed in the remainder of this section.</p>

<h4>Pitfall #1: Defining <pre class="code">equals</pre> with the wrong signature</h4>


<p>Consider adding an equality method to the following class of simple points:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">Point</code>(<code class="vem">val</code>&nbsp;x:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;y:&nbsp;<code class="typename">Int</code>)&nbsp;{&nbsp;...&nbsp;}
</pre>


<p>A seemingly obvious but wrong way would be to define it like this:</p>

<pre>
  <code class="comment">//&nbsp;An&nbsp;utterly&nbsp;wrong&nbsp;definition&nbsp;of&nbsp;equals</code>
  <code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Point</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=
  &nbsp;&nbsp;<code class="vem">this</code>.x&nbsp;==&nbsp;other.x&nbsp;&amp;&amp;&nbsp;<code class="vem">this</code>.y&nbsp;==&nbsp;other.y
</pre>


<p>What's wrong with this method? At first glance, it seems to work OK:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;p1,&nbsp;p2&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Point</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">p1:&nbsp;Point&nbsp;=&nbsp;Point@37d7d90f</code>
  <code class="output">p2:&nbsp;Point&nbsp;=&nbsp;Point@3beb846d</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;q&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Point</code>(<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">q:&nbsp;Point&nbsp;=&nbsp;Point@e0cf182</code>
  <br />  scala&gt;&nbsp;p1&nbsp;equals&nbsp;p2
  <code class="output">res0:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br />  scala&gt;&nbsp;p1&nbsp;equals&nbsp;q
  <code class="output">res1:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>


<p>However, trouble starts once you start putting points into a collection:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.mutable
  <code class="output">import&nbsp;scala.collection.mutable</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;coll&nbsp;=&nbsp;<code class="typename">mutable.HashSet</code>(p1)
  <code class="output">coll:&nbsp;scala.collection.mutable.HashSet[Point]&nbsp;=&nbsp;</code>
  <code class="output">Set(Point@37d7d90f)</code>
  <br />  scala&gt;&nbsp;coll&nbsp;contains&nbsp;p2
  <code class="output">res2:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>


<p>How to explain that <pre class="code">coll</pre> does not contain <pre class="code">p2</pre>, even though <pre class="code">p1</pre> was added to
it, and <pre class="code">p1</pre> and <pre class="code">p2</pre> are equal objects? The reason becomes clear
in the following interaction, where the precise type of one of the compared points is masked. Define <pre class="code">p2a</pre> as an alias of <pre class="code">p2</pre>, but with type <pre class="code">Any</pre> instead of <pre class="code">Point</pre>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;p2a:&nbsp;<code class="typename">Any</code>&nbsp;=&nbsp;p2
  <code class="output">p2a:&nbsp;Any&nbsp;=&nbsp;Point@3beb846d</code>
</pre>


<p>Now, were you to repeat the first comparison, but with the alias <pre class="code">p2a</pre> instead of <pre class="code">p2</pre>, you would get:</p>

<pre>
  scala&gt;&nbsp;p1&nbsp;equals&nbsp;p2a
  <code class="output">res3:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>


<p>What went wrong? The version of <pre class="code">equals</pre> given previously does not override
the standard method <pre class="code">equals</pre> because its type is different. Here is the 
type of the <pre class="code">equals</pre> method as it is defined in the root class
<pre class="code">Any</pre>:<a href="object-equality.html#footnotemain30-3">[3]</a></p>

<pre>
  <code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>):&nbsp;<code class="typename">Boolean</code>
</pre>


<p>Because the <pre class="code">equals</pre> method in <pre class="code">Point</pre> takes a <pre class="code">Point</pre> instead of
an <pre class="code">Any</pre> as an argument, it does not override <pre class="code">equals</pre> in
<pre class="code">Any</pre>.<a id="i1623576437-1"/> Instead, it is just an overloaded alternative. Now,
overloading in Scala and in Java is resolved by the static type of the
argument, not the run-time type. So as long as the static type of the
argument is <pre class="code">Point</pre>, the <pre class="code">equals</pre> method in <pre class="code">Point</pre> is
called. However, once the static argument is of type <pre class="code">Any</pre>, the
<pre class="code">equals</pre> method in <pre class="code">Any</pre> is called instead.  This method has
not been overridden, so it is still implemented by comparing object identity.</p>

<p>That's why the
comparison "<pre class="code">p1</pre>&nbsp;<pre class="code">equals</pre>&nbsp;<pre class="code">p2a</pre>" yields <pre class="code">false</pre> even though points <pre class="code">p1</pre>
and <pre class="code">p2a</pre> have the same <pre class="code">x</pre> and <pre class="code">y</pre> values. That's also why the <pre class="code">contains</pre> method
in <pre class="code">HashSet</pre> returned <pre class="code">false</pre>. Since that method operates on generic sets, it calls
the generic <pre class="code">equals</pre> method in <pre class="code">Object</pre> instead of the overloaded variant in <pre class="code">Point</pre>. Here's a better <pre class="code">equals</pre> method:</p>

<pre>
  <code class="comment">//&nbsp;A&nbsp;better&nbsp;definition,&nbsp;but&nbsp;still&nbsp;not&nbsp;perfect</code>
  <code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Point</code>&nbsp;=&gt;&nbsp;<code class="vem">this</code>.x&nbsp;==&nbsp;that.x&nbsp;&amp;&amp;&nbsp;<code class="vem">this</code>.y&nbsp;==&nbsp;that.y
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  }
</pre>


<p>Now <pre class="code">equals</pre> has the correct type.  It takes a value of type <pre class="code">Any</pre>
as parameter and it yields a <pre class="code">Boolean</pre> result. The implementation of
this method uses a pattern match.<a id="i-1742228676-1"/>  It first tests whether the <pre class="code">other</pre>
object is also of type <pre class="code">Point</pre>. If it is, it compares the
coordinates of the two points and returns the result. Otherwise the result is <pre class="code">false</pre>.</p>

<p>A related pitfall is to define <pre class="code">==</pre> with a wrong
signature. Normally, 
if you try to redefine <pre class="code">==</pre> with the correct signature, which 
takes an argument of type <pre class="code">Any</pre>, the compiler will 
give you an error because you try to override a <pre class="code">final</pre> method of type
<pre class="code">Any</pre>.</p>

<p>Newcomers to Scala sometimes make two errors at once:
They try to override <pre class="code">==</pre> <span style="font-style:italic">and</span> 
they give it the wrong signature. For instance:</p>

<pre>
  <code class="vem">def</code>&nbsp;==(other:&nbsp;<code class="typename">Point</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;<code class="comment">//&nbsp;Don't&nbsp;do&nbsp;this!</code>
</pre>


<p>In this case, the user-defined <pre class="code">==</pre> method is treated as 
an overloaded variant of the same-named method class <pre class="code">Any</pre> and the program compiles.
However, the behavior of the program would be just as dubious as if you had 
defined <pre class="code">equals</pre> with the wrong signature.</p>

<h4>Pitfall #2: Changing <pre class="code">equals</pre> without also changing <pre class="code">hashCode</pre></h4>


<p>We'll continue to use the example from pitfall #1. If you repeat the comparison of <pre class="code">p1</pre> and <pre class="code">p2a</pre> with the latest
definition of <pre class="code">Point</pre>, you will get <pre class="code">true</pre>, as
expected.<a id="i-579193195-1"/>
However, if you repeat
the <pre class="code">HashSet.contains</pre> test, you will probably still get <pre class="code">false</pre>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;p1,&nbsp;p2&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Point</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">p1:&nbsp;Point&nbsp;=&nbsp;Point@122c1533</code>
  <code class="output">p2:&nbsp;Point&nbsp;=&nbsp;Point@c23d097</code>
  <br />  scala&gt;&nbsp;<code class="typename">collection.mutable.HashSet</code>(p1)&nbsp;contains&nbsp;p2
  <code class="output">res4:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>


<p>But this outcome is not 100% certain.
You might also get <pre class="code">true</pre> from the experiment. If you do,
you can try with some other points with coordinates 1 and
2. Eventually, you'll get one that is not contained in the set.
What goes wrong here is that <pre class="code">Point</pre> redefined <pre class="code">equals</pre> without 
also redefining <pre class="code">hashCode</pre>.</p>

<p>Note that the collection in the example here is a <pre class="code">HashSet</pre>. This
means elements of the collection are put in "hash buckets"
determined by their hash code.  The <pre class="code">contains</pre> test first determines
a hash bucket to look in and then compares the given elements with all
elements in that bucket. Now, the last version of class <pre class="code">Point</pre>
did redefine <pre class="code">equals</pre>, but it did not redefine
<pre class="code">hashCode</pre> at the same time. So <pre class="code">hashCode</pre> is still what it was in its version in
class <pre class="code">AnyRef</pre>: some transformation of the address of the allocated object.</p>

<p>The hash codes of <pre class="code">p1</pre> and <pre class="code">p2</pre> are almost certainly different, even
though the fields of both points are the same. Different hash codes
mean, with high probability, different hash buckets in the set.  The
<pre class="code">contains</pre> test will look for a matching element in the bucket which
corresponds to <pre class="code">p2</pre>'s hash code. In most cases, point <pre class="code">p1</pre> will be
in another bucket, so it will never be found. <pre class="code">p1</pre> and <pre class="code">p2</pre> might
also end up by chance in the same hash bucket. In that case the test
would return <pre class="code">true</pre>. The problem is that the last implementation of <pre class="code">Point</pre><a id="i668953714-1"/>
violated the contract on <pre class="code">hashCode</pre> as defined for class <pre class="code">Any</pre>:<a href="object-equality.html#footnotemain30-4">[4]</a></p>

<p><span style="font-style:italic">If two objects are equal according to the <pre class="code">equals</pre>  method, 
then calling the <pre class="code">hashCode</pre> method on each of the two objects must 
produce the same integer result.</span></p>

<p>In fact, it's well known in Java that <pre class="code">hashCode</pre> and <pre class="code">equals</pre> should always
be redefined together. Furthermore, <pre class="code">hashCode</pre> may only depend on fields that
<pre class="code">equals</pre> depends on. For the <pre class="code">Point</pre> class, the following would be a suitable
definition of <pre class="code">hashCode</pre>:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">Point</code>(<code class="vem">val</code>&nbsp;x:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;y:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode&nbsp;=&nbsp;(x,&nbsp;y).##
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Point</code>&nbsp;=&gt;&nbsp;<code class="vem">this</code>.x&nbsp;==&nbsp;that.x&nbsp;&amp;&amp;&nbsp;<code class="vem">this</code>.y&nbsp;==&nbsp;that.y&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>&nbsp;
  &nbsp;&nbsp;}
  }
</pre>


<p>This is just one of many possible implementations of
<pre class="code">hashCode</pre>. Recall that the <pre class="code">##</pre> method is a shorthand for computing
hash codes that works for primitive values, reference types, and
<pre class="code">null</pre>. When invoked on a collection or a tuple, it computes a mixed hash that is
sensitive to the hash codes of all the elements in the collection.
We'll
provide more guidance on writing <pre class="code">hashCode</pre> later in this chapter.</p>

<p>Adding <pre class="code">hashCode</pre> fixes the problems of equality when defining classes like <pre class="code">Point</pre>; however, there are other trouble spots to watch out for.</p>

<h4>Pitfall #3: Defining <pre class="code">equals</pre> in terms of mutable fields</h4>


<p>Consider the following slight variation of class <pre class="code">Point</pre>:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">Point</code>(<code class="vem">var</code>&nbsp;x:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">var</code>&nbsp;y:&nbsp;<code class="typename">Int</code>)&nbsp;{&nbsp;<code class="comment">//&nbsp;Problematic</code>
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode&nbsp;=&nbsp;(x,&nbsp;y).##
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Point</code>&nbsp;=&gt;&nbsp;<code class="vem">this</code>.x&nbsp;==&nbsp;that.x&nbsp;&amp;&amp;&nbsp;<code class="vem">this</code>.y&nbsp;==&nbsp;that.y&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>&nbsp;
  &nbsp;&nbsp;}
  }
</pre>


<p>The only difference is that the fields <pre class="code">x</pre> and <pre class="code">y</pre> are now <pre class="code">var</pre>s
instead of <pre class="code">val</pre>s.<a id="i-1325523688-1"/>
The <pre class="code">equals</pre> and <pre class="code">hashCode</pre> methods are now defined 
in terms of these mutable fields, so their results change when the fields change.
This can have strange effects once you put points in collections:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;p&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Point</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">p:&nbsp;Point&nbsp;=&nbsp;Point@5428bd62</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;coll&nbsp;=&nbsp;<code class="typename">collection.mutable.HashSet</code>(p)
  <code class="output">coll:&nbsp;scala.collection.mutable.HashSet[Point]&nbsp;=&nbsp;</code>
  <code class="output">Set(Point@5428bd62)</code>
  <br />  scala&gt;&nbsp;coll&nbsp;contains&nbsp;p
  <code class="output">res5:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>


<p>Now, if you change a field in point <pre class="code">p</pre>, does the collection
still contain the point? We'll try it:</p>

<pre>
  scala&gt;&nbsp;p.x&nbsp;+=&nbsp;<code class="literal">1</code>
  <br />  scala&gt;&nbsp;coll&nbsp;contains&nbsp;p
  <code class="output">res7:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>


<p>This looks strange. Where did <pre class="code">p</pre> go? More strangeness results if you check whether the 
iterator of the set contains <pre class="code">p</pre>:</p>

<pre>
  scala&gt;&nbsp;coll.iterator&nbsp;contains&nbsp;p
  <code class="output">res8:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>


<p>So here's a set that does not contain <pre class="code">p</pre>, yet <pre class="code">p</pre> is among the elements of the set!
What happened is that after the change to the <pre class="code">x</pre> field, the point <pre class="code">p</pre> ended
up in the wrong hash bucket of the set <pre class="code">coll</pre>. That is, its original hash bucket
no longer corresponded to the new value of its hash code. 
In a manner of speaking, point <pre class="code">p</pre> "dropped out of sight" 
in the set <pre class="code">coll</pre> even though it still belonged to its elements.</p>

<p>The lesson to be drawn from this example is that when <pre class="code">equals</pre> and
<pre class="code">hashCode</pre> depend on mutable state, it causes problems for
potential users.  If you put such objects into collections, you have to be careful to never modify the depended-on state, and this is tricky.
If
you need a comparison that takes the current state of an object into
account, you should usually name it something else, not <pre class="code">equals</pre>.</p>

<p>Considering the last definition of <pre class="code">Point</pre>, it would have been
preferable to omit a redefinition of <pre class="code">hashCode</pre> and name the
comparison method <pre class="code">equalContents</pre> or some other name different from
<pre class="code">equals</pre>.  <pre class="code">Point</pre> would then have inherited the default
implementation of <pre class="code">equals</pre> and <pre class="code">hashCode</pre>; <pre class="code">p</pre> would have stayed
locatable in <pre class="code">coll</pre> even after the modification to its <pre class="code">x</pre>
field.</p>

<h4>Pitfall #4: Failing to define <pre class="code">equals</pre> as an equivalence relation</h4>


<p>The contract of the <pre class="code">equals</pre> method in <pre class="code">scala.Any</pre> specifies that <pre class="code">equals</pre> must<a id="i358320206-1"/>
implement an equivalence relation on non-<pre class="code">null</pre> objects:<a href="object-equality.html#footnotemain30-5">[5]</a></p>

<div style="font-style:italic">


<ul>


<li>It is <span style="font-style:italic">reflexive</span>: For any non-null value <pre class="code">x</pre> , the
expression <pre class="code">x.equals(x)</pre> should return <pre class="code">true</pre>.


</li>
<li>It is <span style="font-style:italic">symmetric</span>: For any non-null values <pre class="code">x</pre> and
<pre class="code">y</pre>, <pre class="code">x.equals(y)</pre> should return <pre class="code">true</pre> if and only if
<pre class="code">y.equals(x)</pre> returns <pre class="code">true</pre>.


</li>
<li>It is <span style="font-style:italic">transitive</span>: For any non-null values <pre class="code">x</pre>, <pre class="code">y</pre>, and
<pre class="code">z</pre>, if <pre class="code">x.equals(y)</pre> returns <pre class="code">true</pre> and <pre class="code">y.equals(z)</pre>
returns <pre class="code">true</pre>, then <pre class="code">x.equals(z)</pre> should return
<pre class="code">true</pre>.


</li>
<li>It is <span style="font-style:italic">consistent</span>: For any non-null values <pre class="code">x</pre> and <pre class="code">y</pre>, multiple invocations of <pre class="code">x.equals(y)</pre> should consistently return <pre class="code">true</pre> or consistently return <pre class="code">false</pre>, provided no information used in equals comparisons on the objects is modified.


</li>
<li>For any non-null value <pre class="code">x</pre>, <pre class="code">x.equals(null)</pre> should return
<pre class="code">false</pre>.<a id="i-677123658-1"/> 


</li></ul>


</div>


<p>The definition of <pre class="code">equals</pre> developed for class <pre class="code">Point</pre> up to now satisfies
the contract for <pre class="code">equals</pre>. However, things become more complicated once
subclasses are considered. Say there is a subclass <pre class="code">ColoredPoint</pre> of
<pre class="code">Point</pre> that adds a field <pre class="code">color</pre> of type <pre class="code">Color</pre>. 
Assume <pre class="code">Color</pre> is defined as an enumeration, as presented in 
<a href="abstract-members.html#sec-enums">Section 20.9</a>:</p>

<pre>
  <code class="vem">object</code>&nbsp;<code class="typename">Color</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Enumeration</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Red</code>,&nbsp;<code class="typename">Orange</code>,&nbsp;<code class="typename">Yellow</code>,&nbsp;<code class="typename">Green</code>,&nbsp;<code class="typename">Blue</code>,&nbsp;<code class="typename">Indigo</code>,&nbsp;<code class="typename">Violet</code>&nbsp;=&nbsp;<code class="typename">Value</code>
  }
</pre>


<p><pre class="code">ColoredPoint</pre> overrides <pre class="code">equals</pre> to take the new <pre class="code">color</pre> field into account:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">ColoredPoint</code>(x:&nbsp;<code class="typename">Int</code>,&nbsp;y:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;color:&nbsp;<code class="typename">Color.Value</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Point</code>(x,&nbsp;y)&nbsp;{&nbsp;<code class="comment">//&nbsp;Problem:&nbsp;equals&nbsp;not&nbsp;symmetric</code>
  <br />  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">ColoredPoint</code>&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.color&nbsp;==&nbsp;that.color&nbsp;&amp;&amp;&nbsp;<code class="vem">super</code>.equals(that)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;}
  }
</pre>


<p>This is what many programmers would likely write.<a id="i-591223748-1"/> Note that in this case,
class <pre class="code">ColoredPoint</pre> 
need not override <pre class="code">hashCode</pre>. Because the new definition of <pre class="code">equals</pre> 
on <pre class="code">ColoredPoint</pre>
is stricter than the overridden definition in <pre class="code">Point</pre> (meaning it equates fewer pairs of objects), the contract for <pre class="code">hashCode</pre> stays 
valid. If two colored points are equal, they must have the same coordinates, so their hash codes are guaranteed to be equal as well.</p>

<p>Taking the class <pre class="code">ColoredPoint</pre> by itself, its definition of <pre class="code">equals</pre> looks OK. 
However, the contract for
<pre class="code">equals</pre> is broken once points and colored points are mixed. Consider:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;p&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Point</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">p:&nbsp;Point&nbsp;=&nbsp;Point@5428bd62</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;cp&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ColoredPoint</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="typename">Color.Red</code>)
  <code class="output">cp:&nbsp;ColoredPoint&nbsp;=&nbsp;ColoredPoint@5428bd62</code>
  <br />  scala&gt;&nbsp;p&nbsp;equals&nbsp;cp
  <code class="output">res9:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br />  scala&gt;&nbsp;cp&nbsp;equals&nbsp;p
  <code class="output">res10:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>


<p>The comparison "<pre class="code">p</pre>&nbsp;<pre class="code">equals</pre>&nbsp;<pre class="code">cp</pre>" invokes <pre class="code">p</pre>'s <pre class="code">equals</pre> method, which
is defined in class <pre class="code">Point</pre>. This method only takes into account the
coordinates of the two points. Consequently, the comparison yields
<pre class="code">true</pre>. On the other hand, the comparison "<pre class="code">cp</pre>&nbsp;<pre class="code">equals</pre>&nbsp;<pre class="code">p</pre>" invokes
<pre class="code">cp</pre>'s <pre class="code">equals</pre> method, which is defined in class
<pre class="code">ColoredPoint</pre>. This method returns <pre class="code">false</pre> because <pre class="code">p</pre> is not a
<pre class="code">ColoredPoint</pre>. So the relation defined by <pre class="code">equals</pre> is not
symmetric.</p>

<p>The loss in symmetry can have unexpected consequences for collections.
Here's an example:</p>

<pre>
  scala&gt;&nbsp;<code class="typename">collection.mutable.HashSet[Point]</code>(p)&nbsp;contains&nbsp;cp
  <code class="output">res11:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br />  scala&gt;&nbsp;<code class="typename">collection.mutable.HashSet[Point]</code>(cp)&nbsp;contains&nbsp;p
  <code class="output">res12:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>


<p>Even though <pre class="code">p</pre> and <pre class="code">cp</pre> are equal, one <pre class="code">contains</pre> test succeeds 
whereas the other one fails:</p>

<p>How can you change the definition of <pre class="code">equals</pre> so that it becomes symmetric?
Essentially there are two ways. You can either make the relation more general or 
more strict. Making it more general means that a pair of two objects, <pre class="code">x</pre> and <pre class="code">y</pre>,
is taken to be equal if either comparing <pre class="code">x</pre> with <pre class="code">y</pre> or comparing <pre class="code">y</pre> with <pre class="code">x</pre> 
yields <pre class="code">true</pre>. Here's code that does this:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">ColoredPoint</code>(x:&nbsp;<code class="typename">Int</code>,&nbsp;y:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;color:&nbsp;<code class="typename">Color.Value</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Point</code>(x,&nbsp;y)&nbsp;{&nbsp;<code class="comment">//&nbsp;Problem:&nbsp;equals&nbsp;not&nbsp;transitive</code>
  <br />  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">ColoredPoint</code>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">this</code>.color&nbsp;==&nbsp;that.color)&nbsp;&amp;&amp;&nbsp;<code class="vem">super</code>.equals(that)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Point</code>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that&nbsp;equals&nbsp;<code class="vem">this</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;}
  }
</pre>


<p>The new definition of <pre class="code">equals</pre> in <pre class="code">ColoredPoint</pre> has one more case than the old one: 
If the <pre class="code">other</pre> object is
a <pre class="code">Point</pre> but not a <pre class="code">ColoredPoint</pre>, the method forwards to the <pre class="code">equals</pre> method
of <pre class="code">Point</pre>. This has the desired effect of making <pre class="code">equals</pre> symmetric. Now, 
both "<pre class="code">cp</pre>&nbsp;<pre class="code">equals</pre>&nbsp;<pre class="code">p</pre>" and "<pre class="code">p</pre>&nbsp;<pre class="code">equals</pre>&nbsp;<pre class="code">cp</pre>" result in <pre class="code">true</pre>.
However, the contract for <pre class="code">equals</pre> is still broken. The problem is that
the new relation is no longer transitive!</p>

<p>Here's a sequence of statements
that demonstrates this. Define a point and two colored points of different colors, all at the same position:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;redp&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ColoredPoint</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="typename">Color.Red</code>)
  <code class="output">redp:&nbsp;ColoredPoint&nbsp;=&nbsp;ColoredPoint@5428bd62</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bluep&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ColoredPoint</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="typename">Color.Blue</code>)
  <code class="output">bluep:&nbsp;ColoredPoint&nbsp;=&nbsp;ColoredPoint@5428bd62</code>
</pre>


<p>Taken individually, <pre class="code">redp</pre> is equal to <pre class="code">p</pre> and <pre class="code">p</pre> is equal to <pre class="code">bluep</pre>:</p>

<pre>
  scala&gt;&nbsp;redp&nbsp;==&nbsp;p
  <code class="output">res13:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br />  scala&gt;&nbsp;p&nbsp;==&nbsp;bluep
  <code class="output">res14:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>


<p>However, comparing <pre class="code">redp</pre> and <pre class="code">bluep</pre> yields <pre class="code">false</pre>:</p>

<pre>
  scala&gt;&nbsp;redp&nbsp;==&nbsp;bluep
  <code class="output">res15:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>


<p>Hence, the transitivity clause of the <pre class="code">equals</pre>'s contract is violated.</p>

<p>Making the <pre class="code">equals</pre> relation more general seems to lead to a dead end. We'll try to make it stricter instead. One way to make <pre class="code">equals</pre> stricter is 
to always treat objects of different classes as different. This could be achieved by
modifying the <pre class="code">equals</pre> methods in classes <pre class="code">Point</pre> and <pre class="code">ColoredPoint</pre>. 
In class <pre class="code">Point</pre>, you
could add an extra comparison that checks whether the run-time class of the other <pre class="code">Point</pre> is exactly the same
as this <pre class="code">Point</pre>'s class:</p>

<pre>
  <code class="comment">//&nbsp;A&nbsp;technically&nbsp;valid,&nbsp;but&nbsp;unsatisfying,&nbsp;equals&nbsp;method</code>
  <code class="vem">class</code>&nbsp;<code class="typename">Point</code>(<code class="vem">val</code>&nbsp;x:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;y:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode&nbsp;=&nbsp;(x,&nbsp;y).##
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Point</code>&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.x&nbsp;==&nbsp;that.x&nbsp;&amp;&amp;&nbsp;<code class="vem">this</code>.y&nbsp;==&nbsp;that.y&nbsp;&amp;&amp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.getClass&nbsp;==&nbsp;that.getClass
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;}
  }
</pre>


<p>You can then revert class <pre class="code">ColoredPoint</pre>'s implementation back to the version that previously had violated the
symmetry requirement:<a href="object-equality.html#footnotemain30-6">[6]</a></p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">ColoredPoint</code>(x:&nbsp;<code class="typename">Int</code>,&nbsp;y:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;color:&nbsp;<code class="typename">Color.Value</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Point</code>(x,&nbsp;y)&nbsp;{
  <br />  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">ColoredPoint</code>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">this</code>.color&nbsp;==&nbsp;that.color)&nbsp;&amp;&amp;&nbsp;<code class="vem">super</code>.equals(that)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;}
  }
</pre>


<p>Here, an instance of class <pre class="code">Point</pre> 
is considered to be equal to some other instance of the same class, only if
the objects have the same coordinates and they have the same run-time class, 
meaning <pre class="code">getClass</pre> on either object returns the same value.
The new definitions satisfy symmetry and transitivity because now every
comparison between objects of different classes yields
<pre class="code">false</pre>. So a colored point can never be equal to a point. This
convention looks reasonable, but one could argue that the new
definition is too strict.</p>

<p>Consider the following slightly roundabout way to define 
a point at coordinates <pre class="code">(1,</pre>&nbsp;<pre class="code">2)</pre>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;pAnon&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Point</code>(<code class="literal">1</code>,&nbsp;<code class="literal">1</code>)&nbsp;{&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">val</code>&nbsp;y&nbsp;=&nbsp;<code class="literal">2</code>&nbsp;}
  <code class="output">pAnon:&nbsp;Point&nbsp;=&nbsp;$anon$1@5428bd62</code>
</pre>


<p>Is <pre class="code">pAnon</pre> equal to <pre class="code">p</pre>?
The answer is no because the <pre class="code">java.lang.Class</pre> objects associated with <pre class="code">p</pre> and
<pre class="code">pAnon</pre> are different. For <pre class="code">p</pre> it is <pre class="code">Point</pre>, whereas for <pre class="code">pAnon</pre> it
is an anonymous subclass of <pre class="code">Point</pre>.<a id="i-8484895-1"/> But clearly, <pre class="code">pAnon</pre> is just
another point at coordinates <pre class="code">(1,</pre>&nbsp;<pre class="code">2)</pre>. It does not seem reasonable
to treat it as being different from <pre class="code">p</pre>.</p>

<p>So it seems we are stuck. Is there a sane way to redefine equality on
several levels of the class hierarchy while keeping its contract?  In
fact, there is such a way, but it requires one more method to redefine
together with <pre class="code">equals</pre> and <pre class="code">hashCode</pre>. The idea is that as soon as a
class redefines <pre class="code">equals</pre> (and <pre class="code">hashCode</pre>), it should also explicitly
state that objects of this class are never equal to objects of some
superclass that implement a different equality method. This is
achieved by adding a method <pre class="code">canEqual</pre> to every class that redefines <pre class="code">equals</pre>. 
Here's the method's signature:</p>

<pre>
  <code class="vem">def</code>&nbsp;canEqual(other:&nbsp;<code class="typename">Any</code>):&nbsp;<code class="typename">Boolean</code>
</pre>


<p>The method should return <pre class="code">true</pre> if the 
<pre class="code">other</pre> object is an instance of the class in which <pre class="code">canEqual</pre> is (re)defined,
<pre class="code">false</pre> otherwise. It is called from <pre class="code">equals</pre> to make sure
that the objects are comparable both ways. <a href="object-equality.html#lst-satisfying-equals">Listing 30.1</a> shows a new (and final) implementation of class
<pre class="code">Point</pre> along these lines:
<a id="lst-satisfying-equals"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Point</code>(<code class="vem">val</code>&nbsp;x:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;y:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode&nbsp;=&nbsp;(x,&nbsp;y).##
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Point</code>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(that&nbsp;canEqual&nbsp;<code class="vem">this</code>)&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">this</code>.x&nbsp;==&nbsp;that.x)&nbsp;&amp;&amp;&nbsp;(<code class="vem">this</code>.y&nbsp;==&nbsp;that.y)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;canEqual(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other.isInstanceOf[<code class="typename">Point</code>]
  &nbsp;&nbsp;}
</pre>


<h5>Listing 30.1 - A superclass <pre class="code">equals</pre> method that calls <pre class="code">canEqual</pre>.</h5>


<p>The <pre class="code">equals</pre> method in this version of class <pre class="code">Point</pre> contains the 
additional requirement that 
the other object <em>can equal</em> this one, as determined by
the <pre class="code">canEqual</pre> method. The implementation of <pre class="code">canEqual</pre> in 
<pre class="code">Point</pre> states that all instances of <pre class="code">Point</pre> can be equal.</p>

<p><a href="object-equality.html#lst-subclass-can-equal">Listing 30.2</a> shows the
corresponding implementation of <pre class="code">ColoredPoint</pre>.
<a id="lst-subclass-can-equal"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ColoredPoint</code>(x:&nbsp;<code class="typename">Int</code>,&nbsp;y:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;color:&nbsp;<code class="typename">Color.Value</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Point</code>(x,&nbsp;y)&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode&nbsp;=&nbsp;(<code class="vem">super</code>.hashCode,&nbsp;color).##
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">ColoredPoint</code>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(that&nbsp;canEqual&nbsp;<code class="vem">this</code>)&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">super</code>.equals(that)&nbsp;&amp;&amp;&nbsp;<code class="vem">this</code>.color&nbsp;==&nbsp;that.color
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;canEqual(other:&nbsp;<code class="typename">Any</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other.isInstanceOf[<code class="typename">ColoredPoint</code>]
  &nbsp;&nbsp;}
</pre>


<h5>Listing 30.2 - A subclass <pre class="code">equals</pre> method that calls <pre class="code">canEqual</pre>.</h5>


<p>It can be shown that the new definition of <pre class="code">Point</pre> and
<pre class="code">ColoredPoint</pre> keeps the contract of <pre class="code">equals</pre>. Equality is symmetric
and transitive.  Comparing a <pre class="code">Point</pre> to a <pre class="code">ColoredPoint</pre> always
yields <pre class="code">false</pre>.  Indeed, for any point <pre class="code">p</pre> and colored point <pre class="code">cp</pre>,
"<pre class="code">p</pre>&nbsp;<pre class="code">equals</pre>&nbsp;<pre class="code">cp</pre>" will return <pre class="code">false</pre> because 
"<pre class="code">cp</pre>&nbsp;<pre class="code">canEqual</pre>&nbsp;<pre class="code">p</pre>" will return <pre class="code">false</pre>.  The reverse comparison, "<pre class="code">cp</pre>&nbsp;<pre class="code">equals</pre>&nbsp;<pre class="code">p</pre>",
will also return <pre class="code">false</pre> because <pre class="code">p</pre> is not a <pre class="code">ColoredPoint</pre>, so
the first pattern match in the body of <pre class="code">equals</pre> in <pre class="code">ColoredPoint</pre> will fail.</p>

<p>On the other hand, instances of different subclasses of <pre class="code">Point</pre> can
be equal, as long as none of the classes redefines the equality
method. For instance, with the new class definitions, the comparison of 
<pre class="code">p</pre> and <pre class="code">pAnon</pre> would yield true. Here are some examples:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;p&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Point</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">p:&nbsp;Point&nbsp;=&nbsp;Point@5428bd62</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;cp&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ColoredPoint</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="typename">Color.Indigo</code>)
  <code class="output">cp:&nbsp;ColoredPoint&nbsp;=&nbsp;ColoredPoint@e6230d8f</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;pAnon&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Point</code>(<code class="literal">1</code>,&nbsp;<code class="literal">1</code>)&nbsp;{&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">val</code>&nbsp;y&nbsp;=&nbsp;<code class="literal">2</code>&nbsp;}
  <code class="output">pAnon:&nbsp;Point&nbsp;=&nbsp;$anon$1@5428bd62</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;coll&nbsp;=&nbsp;<code class="typename">List</code>(p)
  <code class="output">coll:&nbsp;List[Point]&nbsp;=&nbsp;List(Point@5428bd62)</code>
  <br />  scala&gt;&nbsp;coll&nbsp;contains&nbsp;p&nbsp;
  <code class="output">res16:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br />  scala&gt;&nbsp;coll&nbsp;contains&nbsp;cp
  <code class="output">res17:&nbsp;Boolean&nbsp;=&nbsp;false</code>
  <br />  scala&gt;&nbsp;coll&nbsp;contains&nbsp;pAnon
  <code class="output">res18:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>


<p>These examples demonstrate that if a superclass <pre class="code">equals</pre> implementation defines and calls <pre class="code">canEqual</pre>, then programmers
who implement subclasses can decide whether or not their subclasses may be equal to instances of the superclass.
Because <pre class="code">ColoredPoint</pre> overrides <pre class="code">canEqual</pre>, for example, a colored point may never be equal to a plain-old point. But because
the anonymous subclass referenced from <pre class="code">pAnon</pre> does not override <pre class="code">canEqual</pre>, its instance can be
equal to a <pre class="code">Point</pre> instance.</p>

<p>One potential criticism of the <pre class="code">canEqual</pre> approach is that it violates the Liskov Substitution 
Principle<a id="i1527452340-1"/>. For example, the technique of implementing <pre class="code">equals</pre> by comparing run-time classes, which
led to the inability
to define a subclass whose instances can equal instances of the superclass, 
has been described as a violation of the LSP.<a href="object-equality.html#footnotemain30-7">[7]</a> The LSP states you should be able to use (substitute) a
subclass instance where a superclass instance is required.</p>

<p>In the previous example, however,
"coll contains cp" returned <pre class="code">false</pre> even though <pre class="code">cp</pre>'s <pre class="code">x</pre> and <pre class="code">y</pre> values matched those of
the point in the collection. Thus, it may seem like a violation of the LSP because
you can't use a <pre class="code">ColoredPoint</pre> here where a <pre class="code">Point</pre> is expected. We believe this is the wrong interpretation, because the LSP doesn't require that a subclass behaves identically to its superclass, just that it
behaves in a way that fulfills the contract of its superclass.</p>

<p>The problem with writing an <pre class="code">equals</pre> method that compares run-time classes is not that it violates the LSP, but
that it doesn't give you a way to create a subclass whose
instances can equal superclass instances.
For example, had we used the run-time class technique in the previous example, "<pre class="code">coll</pre>&nbsp;<pre class="code">contains</pre>&nbsp;<pre class="code">pAnon</pre>" would have 
returned <pre class="code">false</pre>, and that's not what we wanted. By contrast, we really did want "<pre class="code">coll</pre>&nbsp;<pre class="code">contains</pre>&nbsp;<pre class="code">cp</pre>" to
return <pre class="code">false</pre>, because by overriding <pre class="code">equals</pre> in <pre class="code">ColoredPoint</pre>, we were basically saying that an indigo-colored
point at coordinates (1, 2) is <em>not the same thing</em> as an uncolored point at (1, 2). Thus, in the
previous example we
were able to pass two different <pre class="code">Point</pre> subclass instances to the collection's <pre class="code">contains</pre> method, and we got
back two different answers, both correct.</p>

<h3>30.3 Defining equality for parameterized types</h3>


<p>The <pre class="code">equals</pre> methods in the previous examples all started with a
pattern match that tested whether the type of the operand conformed to
the type of the class containing the <pre class="code">equals</pre>
method.<a id="i511396682-1"/> When classes
are parameterized, this scheme needs to be adapted a little bit.</p>

<p>As an
example, consider binary trees. The class hierarchy shown in <a href="object-equality.html#lst-binary-tree">Listing 30.3</a> defines an
abstract class <pre class="code">Tree</pre> for a binary tree, with two alternative
implementations: an <pre class="code">EmptyTree</pre> object and a <pre class="code">Branch</pre> class
representing non-empty trees. A non-empty tree is made up of some
element <pre class="code">elem</pre>, and a <pre class="code">left</pre> and <pre class="code">right</pre> child tree. The type of its element 
is given by a type parameter <pre class="code">T</pre>.</p>

<p><a id="lst-binary-tree"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">Tree[+T]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;elem:&nbsp;T
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;left:&nbsp;<code class="typename">Tree[T]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;right:&nbsp;<code class="typename">Tree[T]</code>
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">EmptyTree</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Tree[Nothing]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;elem&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">NoSuchElementException</code>(<code class="quotedstring">"EmptyTree.elem"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;left&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">NoSuchElementException</code>(<code class="quotedstring">"EmptyTree.left"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;right&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">NoSuchElementException</code>(<code class="quotedstring">"EmptyTree.right"</code>)
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Branch[+T]</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;elem:&nbsp;T,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;left:&nbsp;<code class="typename">Tree[T]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;right:&nbsp;<code class="typename">Tree[T]</code>
  &nbsp;&nbsp;)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Tree[T]</code>
</pre>


<h5>Listing 30.3 - Hierarchy for binary trees.</h5>


<p>We'll now add <pre class="code">equals</pre> and <pre class="code">hashCode</pre> methods to these classes.  For
class <pre class="code">Tree</pre> itself there's nothing to do because we assume that
these methods are implemented separately for each implementation of
the abstract class. For object <pre class="code">EmptyTree</pre>, there's still nothing to
do because the default implementations of <pre class="code">equals</pre> and <pre class="code">hashCode</pre>
that <pre class="code">EmptyTree</pre> inherits from <pre class="code">AnyRef</pre> work just fine. After all,
an <pre class="code">EmptyTree</pre> is only equal to itself, so equality should be
reference equality, which is what's inherited from <pre class="code">AnyRef</pre>.</p>

<p>But adding <pre class="code">equals</pre> and <pre class="code">hashCode</pre> to <pre class="code">Branch</pre> requires some work. 
A <pre class="code">Branch</pre> value should only be equal to other <pre class="code">Branch</pre> values, 
and only if the two values have equal <pre class="code">elem</pre>, <pre class="code">left</pre> and <pre class="code">right</pre> fields.
It's natural to apply the schema for <pre class="code">equals</pre> that was developed in the 
previous sections of this chapter. This would give you:</p>

<pre>
  <code class="vem">class</code>&nbsp;<code class="typename">Branch[T]</code>(
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;elem:&nbsp;T,
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;left:&nbsp;<code class="typename">Tree[T]</code>,
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;right:&nbsp;<code class="typename">Tree[T]</code>
  )&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Tree[T]</code>&nbsp;{
  <br />  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Branch[T]</code>&nbsp;=&gt;&nbsp;<code class="vem">this</code>.elem&nbsp;==&nbsp;that.elem&nbsp;&amp;&amp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.left&nbsp;==&nbsp;that.left&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.right&nbsp;==&nbsp;that.right
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;}
  }
</pre>


<p>Compiling this example, however, gives an indication that
"<pre class="code">unchecked</pre>" warnings occurred. Compiling again with the
<pre class="code">-unchecked</pre> option reveals the following problem:<a id="i-1285804133-1"/></p>

<pre>
  &nbsp;$&nbsp;fsc&nbsp;-unchecked&nbsp;Tree.scala
  <code class="output">Tree.scala:14:&nbsp;warning:&nbsp;non&nbsp;variable&nbsp;type-argument&nbsp;T&nbsp;in&nbsp;type&nbsp;</code>
  <code class="output">pattern&nbsp;is&nbsp;unchecked&nbsp;since&nbsp;it&nbsp;is&nbsp;eliminated&nbsp;by&nbsp;erasure</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;that:&nbsp;Branch[T]&nbsp;=&gt;&nbsp;this.elem&nbsp;==&nbsp;that.elem&nbsp;&amp;&amp;&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>As the warning says, there is a pattern match against a <pre class="code">Branch[T]</pre> type,
yet the system can only check that the <pre class="code">other</pre> reference is (some
kind of) <pre class="code">Branch</pre>; it cannot check that the element type of the tree
is <pre class="code">T</pre>.  You encountered in <a href="type-parameterization.html">Chapter 19</a> the 
reason for this: Element types of parameterized types are eliminated 
by the compiler's erasure phase; they are not available to be inspected 
at run-time.<a id="i-237149939-1"/><a id="i101369192-1"/><a id="i-735891161-1"/></p>

<p>So what can you do? Fortunately, it turns out that you need not necessarily check
that two <pre class="code">Branch</pre>es have the same element types when comparing them. It's
quite possible that two <pre class="code">Branch</pre>es with different element types are
equal, as long as their fields are the same. A simple example 
of this would be the <pre class="code">Branch</pre> that consists of a single <pre class="code">Nil</pre> element
and two empty subtrees. It's plausible to consider any two such <pre class="code">Branch</pre>es
to be equal, no matter what static types they have:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;b1&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Branch[List[String]]</code>(<code class="typename">Nil</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">EmptyTree</code>,&nbsp;<code class="typename">EmptyTree</code>)
  <code class="output">b1:&nbsp;Branch[List[String]]&nbsp;=&nbsp;Branch@9d5fa4f</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;b2&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Branch[List[Int]]</code>(<code class="typename">Nil</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">EmptyTree</code>,&nbsp;<code class="typename">EmptyTree</code>)
  <code class="output">b2:&nbsp;Branch[List[Int]]&nbsp;=&nbsp;Branch@56cdfc29</code>
  <br />  scala&gt;&nbsp;b1&nbsp;==&nbsp;b2
  <code class="output">res19:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>


<p>The positive result of the comparison above was obtained with the implementation of <pre class="code">equals</pre> on <pre class="code">Branch</pre> shown
previously. This demonstrates that
the element type of the <pre class="code">Branch</pre> was not checked&mdash;if it had been
checked, the result would have been <pre class="code">false</pre>.</p>

<p>We can disagree on which of the two possible outcomes of the
comparison would be more natural. In the end, this depends on the
mental model of how classes are represented. In a model where
type-parameters are present only at compile-time, it's natural to
consider the two <pre class="code">Branch</pre> values <pre class="code">b1</pre> and <pre class="code">b2</pre> to be equal. In
an alternative model where a type parameter forms part of an object's
value, it's equally natural to consider them different. Since Scala
adopts the type erasure model, type parameters are not preserved at
run time, so that <pre class="code">b1</pre> and <pre class="code">b2</pre> are naturally considered to be equal.</p>

<p>There's only a tiny change needed to formulate an <pre class="code">equals</pre> method
that does not produce an <pre class="code">unchecked</pre> warning. Instead of 
an element type <pre class="code">T</pre>, use a lower case letter, such as <pre class="code">t</pre>:</p>

<pre>
  <code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Branch[t]</code>&nbsp;=&gt;&nbsp;<code class="vem">this</code>.elem&nbsp;==&nbsp;that.elem&nbsp;&amp;&amp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.left&nbsp;==&nbsp;that.left&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.right&nbsp;==&nbsp;that.right
</pre>


<p>Recall from <a href="case-classes-and-pattern-matching.html#sec-kinds-of-patterns">Section 15.2</a> that
a type parameter in a pattern starting with a lower-case letter
represents an unknown type. Now the pattern match:</p>

<pre>
  <code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Branch[t]</code>&nbsp;=&gt;&nbsp;
</pre>


<p>will succeed for <pre class="code">Branch</pre> values of any type. The type parameter <pre class="code">t</pre>
represents the unknown element type of the <pre class="code">Branch</pre>. It can also be replaced
by an underscore, as in the following case, which is equivalent 
to the previous one:</p>

<pre>
  <code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Branch[_]</code>&nbsp;=&gt;
</pre>


<p>The only thing that remains is
to define for class <pre class="code">Branch</pre> 
the other two methods, <pre class="code">hashCode</pre> and <pre class="code">canEqual</pre>, which go with <pre class="code">equals</pre>.
Here's a possible implementation of <pre class="code">hashCode</pre>:</p>

<pre>
  <code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;(elem,&nbsp;left,&nbsp;right).##
</pre>


<p>This is only one of many possible implementations. As shown previously,
the principle is to take <pre class="code">hashCode</pre> values of all fields and combine them.
Here's an implementation of method <pre class="code">canEqual</pre> in class <pre class="code">Branch</pre>:</p>

<pre>
  <code class="vem">def</code>&nbsp;canEqual(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Branch[_]</code>&nbsp;=&gt;&nbsp;<code class="vem">true</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  }
</pre>


<p>The implementation of the <pre class="code">canEqual</pre> method used a typed pattern match.
It would also be possible to formulate it with <pre class="code">isInstanceOf</pre>:</p>

<pre>
  <code class="vem">def</code>&nbsp;canEqual(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other.isInstanceOf[<code class="typename">Branch[_]</code>]
</pre>


<p>If you feel like nit-picking&mdash;and we encourage you to do so!&mdash;you might wonder what the occurrence of
the underscore in the type above signifies. After all, <pre class="code">Branch[_]</pre> is
technically a type parameter of a method, not a type pattern. So how
is it possible to leave some parts of it undefined?<a id="i1628802775-1"/></p>

<p>The answer to
this question is discussed in the next chapter. <pre class="code">Branch[_]</pre> is shorthand for a so-called <span style="font-style:italic">wildcard
type</span>,<a id="i1056209851-1"/><a id="i165566131-1"/> which is, roughly speaking, 
a type with some unknown parts in it. So even though technically the 
underscore stands for two different things in a pattern match 
and in a type parameter of a method call, in essence, the meaning
is the same: It lets you label something that is unknown. The final version
of <pre class="code">Branch</pre> is shown in <a href="object-equality.html#lst-a-good-branch">Listing 30.4</a>.</p>

<p><a id="lst-a-good-branch"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Branch[T]</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;elem:&nbsp;T,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;left:&nbsp;<code class="typename">Tree[T]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;right:&nbsp;<code class="typename">Tree[T]</code>
  &nbsp;&nbsp;)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Tree[T]</code>&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Branch[_]</code>&nbsp;=&gt;&nbsp;(that&nbsp;canEqual&nbsp;<code class="vem">this</code>)&nbsp;&amp;&amp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.elem&nbsp;==&nbsp;that.elem&nbsp;&amp;&amp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.left&nbsp;==&nbsp;that.left&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.right&nbsp;==&nbsp;that.right
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;canEqual(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other.isInstanceOf[<code class="typename">Branch[_]</code>]
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;(elem,&nbsp;left,&nbsp;right).##
  &nbsp;&nbsp;}
</pre>


<h5>Listing 30.4 - A parameterized type with <pre class="code">equals</pre> and <pre class="code">hashCode</pre>.</h5>


<h3>30.4 Recipes for <pre class="code">equals</pre> and <pre class="code">hashCode</pre></h3>


<p>In this section, we'll provide step-by-step recipes for creating <pre class="code">equals</pre> and <pre class="code">hashCode</pre> methods that
should suffice for most situations.  As an illustration, we'll use the methods of
class <pre class="code">Rational</pre>, shown in <a href="object-equality.html#lst-rational-equals-hashcode">Listing 30.5</a>.</p>

<p>To create this class, we removed the mathematical operator methods from the version
of class <pre class="code">Rational</pre> shown in <a href="functional-objects.html#lst-overloaded-methods">Listing 6.5</a>  <a href="functional-objects.html#lst-overloaded-methods">here</a>.
We also made a minor enhancement to <pre class="code">toString</pre>, and modified the initializers of <pre class="code">numer</pre> and <pre class="code">denom</pre> to normalize all
fractions to have a positive denominator (<i>i.e.</i>, to transform <sup>1</sup>/<sub>-2</sub> to <sup>-1</sup>/<sub>2</sub>).</p>

<h4>Recipe for <pre class="code">equals</pre></h4>


<p>Here's the recipe for overriding <pre class="code">equals</pre>:<a id="i-145701109-1"/></p>

<ol>


<li>To override <pre class="code">equals</pre> in a non-final class, create a <pre class="code">canEqual</pre> method.
If the inherited definition of <pre class="code">equals</pre> is from <pre class="code">AnyRef</pre> (that is,
<pre class="code">equals</pre> was not redefined higher up in the class hierarchy), the
definition of <pre class="code">canEqual</pre> should be new; otherwise, it will override a
previous definition of a method with the same name.
The only exception to this requirement is for final classes that redefine 
the <pre class="code">equals</pre> method inherited from <pre class="code">AnyRef</pre>. For them the subclass
anomalies described in <a href="object-equality.html#sec-writing-an-equality-method">Section 30.2</a> cannot arise; consequently
they need not define <pre class="code">canEqual</pre>. The type of object passed to <pre class="code">canEqual</pre> should be <pre class="code">Any</pre>:


<pre>
  <code class="vem">def</code>&nbsp;canEqual(other:&nbsp;<code class="typename">Any</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=
</pre>


</li>
<li>
The <pre class="code">canEqual</pre> method should yield <pre class="code">true</pre> if the argument object is an instance
of the current class (<i>i.e.</i>, the class in which <pre class="code">canEqual</pre> is defined), and <pre class="code">false</pre> otherwise:


<pre>
  other.isInstanceOf[<code class="typename">Rational</code>]
</pre>


</li>
<li>In the <pre class="code">equals</pre> method, make sure you declare the type of the object passed as an <pre class="code">Any</pre>:


<pre>
  <code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=
</pre>


</li>
<li>
Write the body of the <pre class="code">equals</pre> method as a single <pre class="code">match</pre> expression. The selector of the <pre class="code">match</pre> should be the
object passed to <pre class="code">equals</pre>:


<pre>
  other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="comment">//&nbsp;...</code>
  }
</pre>


</li>
<li>
The <pre class="code">match</pre> expression should have two cases. The first case should declare a typed pattern for the type
of the class on which you're defining the <pre class="code">equals</pre> method:


<pre>
  <code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Rational</code>&nbsp;=&gt;
</pre>


</li>
<li>
In the body of this case, write an expression that logical-ands together the individual expressions that must be true
for the objects to be equal. If the <pre class="code">equals</pre> method you are overriding is not that of <pre class="code">AnyRef</pre>, you will most likely
want to include an invocation of the superclass's <pre class="code">equals</pre> method:


<pre>
  <code class="vem">super</code>.equals(that)&nbsp;&amp;&amp;
</pre>


<p>If you are defining <pre class="code">equals</pre> for a class that first introduced <pre class="code">canEqual</pre>, you should invoke <pre class="code">canEqual</pre> on the
argument to the equality method, passing <pre class="code">this</pre> as the argument:</p>

<pre>
  (that&nbsp;canEqual&nbsp;<code class="vem">this</code>)&nbsp;&amp;&amp;
</pre>


<p>Overriding redefinitions of <pre class="code">equals</pre> should also include the <pre class="code">canEqual</pre> invocation, unless they contain 
a call to <pre class="code">super.equals</pre>. In the latter case, the <pre class="code">canEqual</pre> test will already be
done by the superclass call.
Lastly, for each field relevant to equality, verify that the field in this object is equal to the corresponding field in the passed object:</p>

<pre>
  numer&nbsp;==&nbsp;that.numer&nbsp;&amp;&amp;
  denom&nbsp;==&nbsp;that.denom
</pre>


</li>
<li>
For the second case, use a wildcard pattern that yields false:


<pre>
  <code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
</pre>


</li></ol>


<p>If you adhere to this recipe for <pre class="code">equals</pre>, equality is guaranteed to be an equivalence relation, as
is required by the <pre class="code">equals</pre> contract.</p>

<p><a id="lst-rational-equals-hashcode"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;require(d&nbsp;!=&nbsp;<code class="literal">0</code>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;g&nbsp;=&nbsp;gcd(n.abs,&nbsp;d.abs)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numer&nbsp;=&nbsp;(<code class="vem">if</code>&nbsp;(d&nbsp;&lt;&nbsp;<code class="literal">0</code>)&nbsp;-n&nbsp;<code class="vem">else</code>&nbsp;n)&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denom&nbsp;=&nbsp;d.abs&nbsp;/&nbsp;g
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;gcd(a:&nbsp;<code class="typename">Int</code>,&nbsp;b:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(b&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;a&nbsp;<code class="vem">else</code>&nbsp;gcd(b,&nbsp;a&nbsp;<code class="texttt">%</code>&nbsp;b)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Rational</code>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(that&nbsp;canEqual&nbsp;<code class="vem">this</code>)&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;==&nbsp;that.numer&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;==&nbsp;that.denom
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;canEqual(other:&nbsp;<code class="typename">Any</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other.isInstanceOf[<code class="typename">Rational</code>]
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;(numer,&nbsp;denom).##
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(denom&nbsp;==&nbsp;<code class="literal">1</code>)&nbsp;numer.toString&nbsp;<code class="vem">else</code>&nbsp;numer&nbsp;+&nbsp;<code class="quotedstring">"/"</code>&nbsp;+&nbsp;denom
  &nbsp;&nbsp;}
</pre>


<h5>Listing 30.5 - Class <pre class="code">Rational</pre> with <pre class="code">equals</pre> and <pre class="code">hashCode</pre>.</h5>


<h4>Recipe for <pre class="code">hashCode</pre></h4>


<p>For <pre class="code">hashCode</pre>, you can usually achieve satisfactory results if you use the following recipe, which<a id="i-1457981337-1"/>
is similar to a recipe recommended for Java classes in <em>Effective Java</em>.<a href="object-equality.html#footnotemain30-8">[8]</a>
Include in the calculation each field in your object that is used to determine equality in the <pre class="code">equals</pre> method (the "relevant" fields).
Make a tuple containing the values of all those fields. Then, invoke <pre class="code">##</pre> on the resulting tuple.</p>

<p>For example, to implement the hash code for an object that has five relevant fields named <pre class="code">a</pre>, <pre class="code">b</pre>, <pre class="code">c</pre>, <pre class="code">d</pre>, and <pre class="code">e</pre>, you would write:</p>

<pre>
  <code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e).##
</pre>


<p>If the <pre class="code">equals</pre> method invokes <pre class="code">super.equals(that)</pre> as part of its calculation, you should start your <pre class="code">hashCode</pre> calculation with 
an invocation of <pre class="code">super.hashCode</pre>. For example, had <pre class="code">Rational</pre>'s <pre class="code">equals</pre> method invoked <pre class="code">super.equals(that)</pre>, its <pre class="code">hashCode</pre> would
have been:</p>

<pre>
  <code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;(<code class="vem">super</code>.hashCode,&nbsp;numer,&nbsp;denom).##
</pre>


<p>One thing to keep in mind as you write <pre class="code">hashCode</pre> methods using this approach is that your hash code will
only be as good as the hash codes you build out of it, namely the hash codes you obtain by calling <pre class="code">hashCode</pre> on
the relevant fields of your object. Sometimes you may need to do something extra besides just calling <pre class="code">hashCode</pre>
on the field to get a useful hash code for that field. For example, if one of your fields is a collection, you
probably want a hash code for that field that is based on all the elements contained in the collection.
If the
field is a <pre class="code">Vector</pre>, <pre class="code">List</pre>, <pre class="code">Set</pre>, <pre class="code">Map</pre>, or tuple, you can simply include it in the list of items you are hashing
over, because <pre class="code">equals</pre> and <pre class="code">hashCode</pre>
are overridden in those classes to take into account the contained elements. However the same is not true for <pre class="code">Array</pre>s, which
do not take elements into account when calculating a hash code. Thus for an array, you should treat each element of the
array like an individual field of your object, calling <pre class="code">##</pre> on each element explicitly or passing the array to
one of the <pre class="code">hashCode</pre> methods in singleton object <pre class="code">java.util.Arrays</pre>.</p>

<p>Lastly, if you find that a particular hash code calculation is harming the performance of your program, consider caching the hash code. If the object is immutable, you can calculate the hash
code when the object is created and store it in a field. You can do this by simply overriding <pre class="code">hashCode</pre> with a <pre class="code">val</pre>
instead of a <pre class="code">def</pre>, like this:<a id="i1757872331-1"/></p>

<pre>
  <code class="vem">override</code>&nbsp;<code class="vem">val</code>&nbsp;hashCode:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;(numer,&nbsp;denom).##
</pre>


<p>This approach trades off memory for computation time, because each instance of the immutable class will have one
more field to hold the cached hash code value.</p>

<h3>30.5 Conclusion</h3>


<p>In retrospect, defining a correct implementation of <pre class="code">equals</pre> has been
surprisingly subtle.  You must be careful about the type signature;
you must override <pre class="code">hashCode</pre>; you should avoid dependencies on
mutable state; and you should implement and use a <pre class="code">canEqual</pre>
method if your class is non-final.</p>

<p>Given how difficult it is to
implement a correct equality method, you might prefer to define your
classes of comparable objects as case classes.
That way, the Scala
compiler will add <pre class="code">equals</pre> and <pre class="code">hashCode</pre> methods with the right properties
automatically.</p>

<hr/>
<h4>Footnotes for Chapter 30:</h4>


<p><a id="footnotemain30-1"/>[1] Vaziri, <i>et. al.</i>, "Declarative Object Identity Using Relation Types"  <a href="bibliography.html#vaziri-tip-2007">[Vaz07]</a></p>

<p><a id="footnotemain30-2"/>[2] All but the third pitfall are described in the context of Java in
the book, <em>Effective Java Second Edition</em>, by Joshua
Bloch.<a id="i-64318620-1"/><a id="i186753339-1"/>  <a href="bibliography.html#bloch-effective-java">[Blo08]</a></p>

<p><a id="footnotemain30-3"/>[3] If you write a lot of Java, you might expect
the argument to this method to be type <pre class="code">Object</pre> instead of type
<pre class="code">Any</pre>.  Don't worry about it; it is the same <pre class="code">equals</pre>
method.  The compiler simply makes it appear to have type <pre class="code">Any</pre>.</p>

<p><a id="footnotemain30-4"/>[4] The text of <pre class="code">Any</pre>'s <pre class="code">hashCode</pre>
contract is inspired by the Javadoc documentation of class <pre class="code">java.lang.Object</pre>.</p>

<p><a id="footnotemain30-5"/>[5] As with <pre class="code">hashCode</pre>,
<pre class="code">Any</pre>'s <pre class="code">equals</pre> method contract is based on <pre class="code">java.lang.Object</pre>'s <pre class="code">equals</pre> method contract.</p>

<p><a id="footnotemain30-6"/>[6] Given the new implementation of <pre class="code">equals</pre> in <pre class="code">Point</pre>, this version of <pre class="code">ColoredPoint</pre> no longer violates the symmetry requirement.</p>

<p><a id="footnotemain30-7"/>[7] Bloch, <em>Effective Java Second Edition</em>,
p. 39  <a href="bibliography.html#bloch-effective-java">[Blo08]</a><a id="i-64318620-2"/><a id="i166435877-1"/></p>

<p><a id="footnotemain30-8"/>[8] Bloch,
<em>Effective Java Second Edition</em>.
 <a href="bibliography.html#bloch-effective-java">[Blo08]</a><a id="i-64318620-3"/><a id="i166435877-2"/></p>

<div style="page-break-after:always"/>


<div style="page-break-after:always"/>

</body>
</html>
