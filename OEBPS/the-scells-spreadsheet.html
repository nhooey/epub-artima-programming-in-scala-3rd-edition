<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8"/>
    <title>Programming in Scala, 3rd Edition</title>

    <link rel="stylesheet" type="text/css" href="book.css" />
  </head>
<body>
<h2><a id="chap-the-scells-spreadsheet">Chapter 35</a></h2>
<h1>The <pre class="code">SCells</pre> Spreadsheet</h1>


<p>In the previous chapters you saw many different constructs of
the Scala programming language.  In this chapter you'll see how these
constructs play together in the implementation of a sizable
application. The task is to write a spreadsheet application, which
will be named <pre class="code">SCells</pre>.<a id="i-1325982169-1"/></p>

<p>There are several reasons why this task is
interesting. First, everybody knows spreadsheets, so it is easy to
understand what the application should do. Second, spreadsheets are
programs that exercise a large range of different computing
tasks. There's the visual aspect, where a spreadsheet is seen as a
rich GUI application.<a id="i1275390415-2"/> There's the symbolic aspect, having to do with
formulas and how to parse and interpret them. There's the
calculational aspect, dealing with how to update possibly large tables
incrementally. There's the reactive aspect, where spreadsheets are
seen as programs that react in intricate ways to events. Finally,
there's the component aspect where the application is constructed as a
set of reusable components.<a id="i-421431555-1"/> All these aspects will be treated in
depth in this chapter.</p>

<div class="figure"><a id="fig-scells1"/>


<p><img src="images/scells1Gray96.png" alt="image images/scells1Gray96.png"/></p>

</div>
<h5> Figure 35.1 - A simple spreadsheet table.</h5>


<h3>35.1 The visual framework</h3>


<p>We'll start by writing the basic visual framework of the application.
<a href="the-scells-spreadsheet.html#fig-scells1">Figure 35.1</a> shows the first iteration of the user interface.
You can see that a spreadsheet is a scrollable table.  It has rows
going from <pre class="code">0</pre> to <pre class="code">99</pre> and columns going from <pre class="code">A</pre> to <pre class="code">Z</pre>.  You
express this in Swing by defining a spreadsheet as a <pre class="code">ScrollPane</pre>
containing a <pre class="code">Table</pre>. <a href="the-scells-spreadsheet.html#lst-scells-Spreadsheet1">Listing 35.1</a> shows the
code.<a id="i870227341-1"/><a id="i455478918-1"/></p>

<p><a id="lst-scells-Spreadsheet1"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;org.stairwaybook.scells
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;swing._
  <br />  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Spreadsheet</code>(<code class="vem">val</code>&nbsp;height:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">ScrollPane</code>&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;table&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Table</code>(height,&nbsp;width)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rowHeight&nbsp;=&nbsp;<code class="literal">25</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autoResizeMode&nbsp;=&nbsp;<code class="typename">Table.AutoResizeMode.Off</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showGrid&nbsp;=&nbsp;<code class="vem">true</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gridColor&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">java.awt.Color</code>(<code class="literal">150</code>,&nbsp;<code class="literal">150</code>,&nbsp;<code class="literal">150</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;rowHeader&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ListView</code>((<code class="literal">0</code>&nbsp;until&nbsp;height)&nbsp;map&nbsp;(_.toString))&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixedCellWidth&nbsp;=&nbsp;<code class="literal">30</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixedCellHeight&nbsp;=&nbsp;table.rowHeight
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;viewportView&nbsp;=&nbsp;table
  &nbsp;&nbsp;&nbsp;&nbsp;rowHeaderView&nbsp;=&nbsp;rowHeader
  &nbsp;&nbsp;}
</pre>


<h5>Listing 35.1 - Code for spreadsheet in <a href="the-scells-spreadsheet.html#fig-scells1">Figure 35.1</a>.</h5>


<p>The spreadsheet component shown in <a href="the-scells-spreadsheet.html#lst-scells-Spreadsheet1">Listing 35.1</a> is defined in package <pre class="code">org.stairwaybook.scells</pre>, which 
will contain all classes, traits, and objects needed for the application. It imports
from package <pre class="code">scala.swing</pre> 
essential elements of Scala's Swing wrapper. <pre class="code">Spreadsheet</pre> itself is a class that takes
<pre class="code">height</pre> and <pre class="code">width</pre> (in numbers of cells) as parameters. The class extends <pre class="code">ScrollPane</pre>, 
which gives it the scroll-bars at the bottom and right in <a href="the-scells-spreadsheet.html#fig-scells1">Figure 35.1</a>.
It contains two sub-components named <pre class="code">table</pre> and <pre class="code">rowHeader</pre>.</p>

<p>The <pre class="code">table</pre> component is an instance of an anonymous subclass of class <pre class="code">scala.swing.Table</pre>. The four lines in
its body set some of its attributes: <pre class="code">rowHeight</pre> for the height of a
table row in points, <pre class="code">autoResizeMode</pre> to turn auto-sizing the table
off, <pre class="code">showGrid</pre> to show a grid of lines between cells, and
<pre class="code">gridColor</pre> to set the color of the grid to a dark gray.</p>

<p>The <pre class="code">rowHeader</pre> component, which contains the row-number headers at the left of the
spreadsheet in <a href="the-scells-spreadsheet.html#fig-scells1">Figure 35.1</a>, is a <pre class="code">ListView</pre> that
displays in its elements the strings <pre class="code">0</pre> through
<pre class="code">99</pre>.<a id="i1410352259-1"/> The two
lines in its body fix the width of a cell to be 30 points
and the height to be the same as the <pre class="code">table</pre>'s <pre class="code">rowHeight</pre>.</p>

<p>The whole spreadsheet is assembled by setting two fields in
<pre class="code">ScrollPane</pre>.  The field <pre class="code">viewportView</pre> is set to the <pre class="code">table</pre>, and
the field <pre class="code">rowHeaderView</pre> is set to the <pre class="code">rowHeader</pre>
list.<a id="i-184785362-1"/><a id="i-1248398867-1"/><a id="i870227341-2"/>
The difference
between the two views is that a view port of a scroll pane
is the area that scrolls with the two bars, whereas the row header
on the left stays fixed when you move the horizontal scroll bar.  By
some quirk, Swing already supplies by default a column header
at the top of the table, so there's no need to define one explicitly.</p>

<p><a id="lst-scells-Main"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;org.stairwaybook.scells
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;swing._
  <br />  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Main</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">SimpleSwingApplication</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;top&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">MainFrame</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;=&nbsp;<code class="quotedstring">"ScalaSheet"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contents&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Spreadsheet</code>(<code class="literal">100</code>,&nbsp;<code class="literal">26</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 35.2 - The main program for the spreadsheet application.</h5>


<p>To try out the rudimentary spreadsheet shown in <a href="the-scells-spreadsheet.html#lst-scells-Spreadsheet1">Listing 35.1</a>, you 
just need to define a main program that creates the <pre class="code">Spreadsheet</pre> component. Such a program is shown in <a href="the-scells-spreadsheet.html#lst-scells-Main">Listing 35.2</a>.</p>

<p>Program <pre class="code">Main</pre> inherits from <pre class="code">SimpleSwingApplication</pre>, which takes care of all the 
low-level details that need to be set up before a Swing application can
be run.<a id="i980116412-2"/>
You only need to define the top-level window of the application in the 
<pre class="code">top</pre> method. In our example, <pre class="code">top</pre> is a <pre class="code">MainFrame</pre> that has two elements defined:  
its <pre class="code">title</pre>, set to "ScalaSheet," and its <pre class="code">contents</pre>, set to
an instance of class <pre class="code">Spreadsheet</pre> with <pre class="code">100</pre> rows and <pre class="code">26</pre> columns. 
That's all. 
If you launch this application with <pre class="code">scala</pre>&nbsp;<pre class="code">org.stairwaybook.scells.Main</pre>,
you should see the spreadsheet in <a href="the-scells-spreadsheet.html#fig-scells1">Figure 35.1</a>.</p>

<h3>35.2 Disconnecting data entry and display</h3>


<p>If you play a bit with the spreadsheet written so far, you'll quickly notice
that the output that's displayed in a cell is always exactly what you
entered in the cell. A real spreadsheet does not behave like that.  In
a real spreadsheet, you would enter a formula and you'd see its value. So
what is entered into a cell is different from what is displayed.</p>

<p><a id="lst-scells-Spreadsheet2"/></p>

<pre>
  <code class="vem">package</code>&nbsp;org.stairwaybook.scells
  <code class="vem">import</code>&nbsp;swing._
  <br />  <code class="vem">class</code>&nbsp;<code class="typename">Spreadsheet</code>(<code class="vem">val</code>&nbsp;height:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">ScrollPane</code>&nbsp;{
  <br />  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;cellModel&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Model</code>(height,&nbsp;width)
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;cellModel._
  <br />  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;table&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Table</code>(height,&nbsp;width)&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;settings&nbsp;as&nbsp;before...&nbsp;</code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;rendererComponent(isSelected:&nbsp;<code class="typename">Boolean</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasFocus:&nbsp;<code class="typename">Boolean</code>,&nbsp;row:&nbsp;<code class="typename">Int</code>,&nbsp;column:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Component</code>&nbsp;=
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(hasFocus)&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">TextField</code>(userData(row,&nbsp;column))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Label</code>(cells(row)(column).toString)&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xAlignment&nbsp;=&nbsp;<code class="typename">Alignment.Right</code>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;userData(row:&nbsp;<code class="typename">Int</code>,&nbsp;column:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;v&nbsp;=&nbsp;<code class="vem">this</code>(row,&nbsp;column)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(v&nbsp;==&nbsp;<code class="vem">null</code>)&nbsp;<code class="quotedstring">""</code>&nbsp;<code class="vem">else</code>&nbsp;v.toString
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<code class="comment">//&nbsp;rest&nbsp;as&nbsp;before...&nbsp;</code>
  }&nbsp;
</pre>


<h5>Listing 35.3 - A spreadsheet with a <pre class="code">rendererComponent</pre> method.</h5>


<p>As a first step to a real spreadsheet application, you should
concentrate on disentangling data entry and display. The basic
mechanism for display is contained in the <pre class="code">rendererComponent</pre> method of class
<pre class="code">Table</pre>.<a id="i455478918-2"/><a id="i-1871849869-1"/> By default, <pre class="code">rendererComponent</pre> always displays what's entered. If you
want to change that, you need to override <pre class="code">rendererComponent</pre> to do something
different. <a href="the-scells-spreadsheet.html#lst-scells-Spreadsheet2">Listing 35.3</a> shows
a new version of <pre class="code">Spreadsheet</pre> with a <pre class="code">rendererComponent</pre> method.</p>

<p>The <pre class="code">rendererComponent</pre> method overrides a default method in
class <pre class="code">Table</pre>. It takes four parameters. The <pre class="code">isSelected</pre> and <pre class="code">hasFocus</pre> parameters are <pre class="code">Boolean</pre>s
that indicate whether the cell has been selected and whether it has
focus, meaning that keyboard events will go into the cell.
The remaining two parameters, <pre class="code">row</pre> and <pre class="code">column</pre>, give the cell's coordinates.</p>

<p>The new <pre class="code">rendererComponent</pre> method checks whether the cell has input
focus.
If <pre class="code">hasFocus</pre> is true, the cell is used for editing. In this case
you want to display an editable <pre class="code">TextField</pre> that contains the data the 
user has entered so far.<a id="i942981037-1"/> This data is returned by the helper method <pre class="code">userData</pre>,
which displays the contents of the table at a given <pre class="code">row</pre> and
<pre class="code">column</pre>. The contents are retrieved by the call 
<pre class="code">this(row,</pre>&nbsp;<pre class="code">column)</pre>.<a href="the-scells-spreadsheet.html#footnotemain35-1">[1]</a>
The <pre class="code">userData</pre> method also takes care to display
a <pre class="code">null</pre> element as the empty string instead of "<pre class="code">null</pre>."</p>

<div style="page-break-after:always"/>


<p>So far so good. But what should be displayed if the cell does not have
focus? In a real spreadsheet this would be the value of a cell. Thus, there are really two tables at work. The first table, named
<pre class="code">table</pre> contains what the user entered. A second "shadow" table
contains the internal representation of cells and what should be
displayed. In the spreadsheet example, this table is a two-dimensional
array called <pre class="code">cells</pre>.
If a cell at a given <pre class="code">row</pre> and <pre class="code">column</pre> does not have editing focus,
the <pre class="code">rendererComponent</pre> method will display the element
<pre class="code">cells(row)(column)</pre>. The element cannot be edited, so it should be
displayed in a <pre class="code">Label</pre> instead of in an editable
<pre class="code">TextField</pre>.<a id="i73174740-1"/></p>

<p>It remains to define the internal array of cells. You could do this
directly in the <pre class="code">Spreadsheet</pre> class, but it's generally preferable
to separate the view of a GUI component from its internal model.
That's why in the example above the <pre class="code">cells</pre> array is defined in a
separate class named <pre class="code">Model</pre>. The model is integrated into the
<pre class="code">Spreadsheet</pre> by defining a value <pre class="code">cellModel</pre> of type <pre class="code">Model</pre>.  The
<pre class="code">import</pre> clause that follows this <pre class="code">val</pre> definition makes the
members of <pre class="code">cellModel</pre> available inside <pre class="code">Spreadsheet</pre> without having to prefix them.
<a href="the-scells-spreadsheet.html#lst-scells-Model1">Listing 35.4</a> shows 
a first simplified version of a <pre class="code">Model</pre> class.
The class defines an inner class,<a id="i178325035-1"/> <pre class="code">Cell</pre>, and a two-dimensional array, <pre class="code">cells</pre>, of 
<pre class="code">Cell</pre> elements. Each element is initialized to be a fresh <pre class="code">Cell</pre>.</p>

<p><a id="lst-scells-Model1"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;org.stairwaybook.scells
  <br />  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Model</code>(<code class="vem">val</code>&nbsp;height:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;{&nbsp;
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Cell</code>(row:&nbsp;<code class="typename">Int</code>,&nbsp;column:&nbsp;<code class="typename">Int</code>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;cells&nbsp;=&nbsp;Array.ofDim[<code class="typename">Cell</code>](height,&nbsp;width)&nbsp;
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;height;&nbsp;j&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;width)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cells(i)(j)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Cell</code>(i,&nbsp;j)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 35.4 - First version of the <pre class="code">Model</pre> class.</h5>


<div class="figure"><a id="fig-scells2"/>


<p><img src="images/scells2Gray96.png" alt="image images/scells2Gray96.png"/></p>

</div>
<h5> Figure 35.2 - Cells displaying themselves.</h5>


<p>That's it. If you compile the modified <pre class="code">Spreadsheet</pre> class with the
<pre class="code">Model</pre> class and run the <pre class="code">Main</pre> application you should see a window
as in <a href="the-scells-spreadsheet.html#fig-scells2">Figure 35.2</a>.</p>

<p>The objective of this section was to arrive at a design where the
displayed value of a cell is different from the string that was
entered into it. This objective has clearly been met, albeit in a very
crude way. In the new spreadsheet you can enter anything you want into
a cell, but it will always display just its coordinates once it loses
focus.  Clearly, we are not done yet.</p>

<h3>35.3 Formulas</h3>


<p>In reality, a spreadsheet cell holds two things: An actual <span style="font-style:italic">value</span>
and a <span style="font-style:italic">formula</span> to compute this value. There are three types of formulas
in a spreadsheet:</p>

<ol>


<li>Numeric values such as <pre class="code">1.22</pre>, <pre class="code">-3</pre>, or <pre class="code">0</pre>.


</li>
<li>Textual labels such as <pre class="code">Annual</pre>&nbsp;<pre class="code">sales</pre>, <pre class="code">Deprecation</pre>, or <pre class="code">total</pre>.


</li>
<li>Formulas that compute a new value from the contents of cells, such as
"<pre class="code">=add(A1,B2)</pre>", or "<pre class="code">=sum(mul(2,</pre>&nbsp;<pre class="code">A2),</pre>&nbsp;<pre class="code">C1:D16)</pre>"


</li></ol>


<p>A formula that computes a value always starts with an equals sign and
is followed by an arithmetic expression. The <pre class="code">SCells</pre> spreadsheet has
a particularly simple and uniform convention for
arithmetic expressions: every expression is an application of some function to a
list of arguments. The function name is an identifier such as <pre class="code">add</pre>
for binary addition, or <pre class="code">sum</pre> for summation of an arbitrary number of
operands. A function argument can be a number, a reference to a cell,
a reference to a range of cells such as <pre class="code">C1:D16</pre>, or another function
application. You'll see later that <pre class="code">SCells</pre> has an open architecture
that makes it easy to install your own functions via mixin
composition.</p>

<p>The first step to handling formulas is writing down the types that
represent them. As you might expect, the different kinds of formulas
are represented by case classes. <a href="the-scells-spreadsheet.html#lst-scells-Formulas">Listing 35.5</a> shows the contents of a file
named <pre class="code">Formulas.scala</pre>, where these case classes are defined:<a id="i1927236622-1"/></p>

<p><a id="lst-scells-Formulas"/></p>

<pre>
  <code class="vem">package</code>&nbsp;org.stairwaybook.scells
  <br />  <code class="vem">trait</code>&nbsp;<code class="typename">Formula</code>&nbsp;&nbsp;
  <br />  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Coord</code>(row:&nbsp;<code class="typename">Int</code>,&nbsp;column:&nbsp;<code class="typename">Int</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Formula</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;(<code class="quotedstring">'A'</code>&nbsp;+&nbsp;column).toChar.toString&nbsp;+&nbsp;row
  }
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Range</code>(c1:&nbsp;<code class="typename">Coord</code>,&nbsp;c2:&nbsp;<code class="typename">Coord</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Formula</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;c1.toString&nbsp;+&nbsp;<code class="quotedstring">":"</code>&nbsp;+&nbsp;c2.toString
  }
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Number</code>(value:&nbsp;<code class="typename">Double</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Formula</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;value.toString&nbsp;
  }
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Textual</code>(value:&nbsp;<code class="typename">String</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Formula</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;value
  }
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Application</code>(function:&nbsp;<code class="typename">String</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;arguments:&nbsp;<code class="typename">List[Formula]</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Formula</code>&nbsp;{&nbsp;
  <br />  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;+&nbsp;arguments.mkString(<code class="quotedstring">"("</code>,&nbsp;<code class="quotedstring">","</code>,&nbsp;<code class="quotedstring">")"</code>)
  }
  <code class="vem">object</code>&nbsp;<code class="typename">Empty</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Textual</code>(<code class="quotedstring">""</code>)
</pre>


<h5>Listing 35.5 - Classes representing formulas.</h5>


<p>Trait <pre class="code">Formula</pre>, shown in <a href="the-scells-spreadsheet.html#lst-scells-Formulas">Listing 35.5</a>, has five case classes
as children:</p>

<table style="border-collapse: collapse">
<tr>
  <td>
    <pre class="code">Coord</pre>
  </td>
  <td>
    for cell coordinates such as <pre class="code">A3</pre>,
  </td>
</tr>
<tr>
  <td>
    <pre class="code">Range</pre>
  </td>
  <td>
    for cell ranges such as <pre class="code">A3:B17</pre>,
  </td>
</tr>
<tr>
  <td>
    <pre class="code">Number</pre>
  </td>
  <td>
    for floating-point numbers such as <pre class="code">3.1415</pre>,
  </td>
</tr>
<tr>
  <td>
    <pre class="code">Textual</pre>
  </td>
  <td>
    for textual labels such as <pre class="code">Deprecation</pre>,
  </td>
</tr>
<tr>
  <td>
    <pre class="code">Application</pre>
  </td>
  <td>
    for function applications such as <pre class="code">sum(A1,A2)</pre>.
  </td>
</tr>
</table>


<p>Each case class overrides the <pre class="code">toString</pre> method so that it displays
its kind of formula in the standard way shown above. For convenience
there's also an <pre class="code">Empty</pre> object that represents the contents of an
empty cell.  The <pre class="code">Empty</pre> object is an instance
of the <pre class="code">Textual</pre> class with an empty string argument.</p>

<h3>35.4 Parsing formulas</h3>


<p>In the previous section you saw the different kinds of formulas
and how they display as strings.<a id="i-2095840458-2"/> In this section you'll see how to
reverse the process: to transform a user input string into
a <pre class="code">Formula</pre> tree. The rest of this section explains one by one the
different elements of a class <pre class="code">FormulaParsers</pre>, which contains the
parsers that do the transformation. The class builds on the combinator
framework given in <a href="combinator-parsing.html">Chapter 33</a>. Specifically,
formula parsers are an instance of the <pre class="code">RegexParsers</pre> class explained
in that chapter:<a id="i519257659-3"/></p>

<pre>
  <code class="vem">package</code>&nbsp;org.stairwaybook.scells
  <code class="vem">import</code>&nbsp;scala.util.parsing.combinator._
  <br />  <code class="vem">object</code>&nbsp;<code class="typename">FormulaParsers</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">RegexParsers</code>&nbsp;{&nbsp;
</pre>


<p>The first two elements of object <pre class="code">FormulaParsers</pre> are
auxiliary parsers for identifiers and decimal numbers:</p>

<pre>
  <code class="vem">def</code>&nbsp;ident:&nbsp;<code class="typename">Parser[String]</code>&nbsp;=&nbsp;<code class="quotedstring">"""[a-zA-Z_]\w*"""</code>.r
  <code class="vem">def</code>&nbsp;decimal:&nbsp;<code class="typename">Parser[String]</code>&nbsp;=&nbsp;<code class="quotedstring">"""-?\d+(\.\d*)?"""</code>.r
</pre>


<p>As you can see from the first regular expression above, an identifier starts
with a letter or underscore.<a id="i-2139156663-2"/> This is followed by an arbitrary number
of "word" characters represented by the regular expression code <pre class="code">\w</pre>, which recognizes letters, digits or
underscores.  The second regular expression describes decimal numbers, which consist
of an optional minus sign, one or more digits that are represented by regular expression code <pre class="code">\d</pre>, 
and an optional decimal part consisting of a period followed by zero or more digits.</p>

<p>The next element of object <pre class="code">FormulaParsers</pre> is the <pre class="code">cell</pre> parser,
which recognizes the coordinates of a cell, such as <pre class="code">C11</pre> or <pre class="code">B2</pre>. It first
calls a regular expression parser that determines the form of a
coordinate: a single letter followed by one or more digits.  The
string returned from that parser is then converted to a cell
coordinate by separating the letter from the numerical part and
converting the two parts to indices for the cell's column and row:</p>

<pre>
  <code class="vem">def</code>&nbsp;cell:&nbsp;<code class="typename">Parser[Coord]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="quotedstring">"""[A-Za-z]\d+"""</code>.r&nbsp;^^&nbsp;{&nbsp;s&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;column&nbsp;=&nbsp;s.charAt(<code class="literal">0</code>).toUpper&nbsp;-&nbsp;<code class="quotedstring">'A'</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;row&nbsp;=&nbsp;s.substring(<code class="literal">1</code>).toInt
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Coord</code>(row,&nbsp;column)
  &nbsp;&nbsp;}
</pre>


<p>Note that the <pre class="code">cell</pre> parser is a bit restrictive in that it allows
only column coordinates consisting of a single letter. Hence the number of
spreadsheet columns is in effect restricted to be at most 26, because
further columns cannot be parsed. It's a good idea to generalize the
parser so that it accepts cells with several leading letters. This is
left as an exercise to you.</p>

<p>The <pre class="code">range</pre> parser recognizes a range of cells. Such a range is composed
of two cell coordinates with a colon between them:</p>

<pre>
  <code class="vem">def</code>&nbsp;range:&nbsp;<code class="typename">Parser[Range]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;cell<code style="font-size:large">~</code><code class="quotedstring">":"</code><code style="font-size:large">~</code>cell&nbsp;^^&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;c1<code style="font-size:large">~</code><code class="quotedstring">":"</code><code style="font-size:large">~</code>c2&nbsp;=&gt;&nbsp;<code class="typename">Range</code>(c1,&nbsp;c2)&nbsp;
  &nbsp;&nbsp;}
</pre>


<p>The <pre class="code">number</pre> parser recognizes a decimal number, which is converted to
a <pre class="code">Double</pre> and wrapped in an instance of the <pre class="code">Number</pre> class:</p>

<pre>
  <code class="vem">def</code>&nbsp;number:&nbsp;<code class="typename">Parser[Number]</code>&nbsp;=
  &nbsp;&nbsp;decimal&nbsp;^^&nbsp;(d&nbsp;=&gt;&nbsp;<code class="typename">Number</code>(d.toDouble))
</pre>


<p>The <pre class="code">application</pre> parser recognizes a function application. Such an
application is composed of an identifier followed by a list of
argument expressions in parentheses:</p>

<pre>
  <code class="vem">def</code>&nbsp;application:&nbsp;<code class="typename">Parser[Application]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;ident<code style="font-size:large">~</code><code class="quotedstring">"("</code><code style="font-size:large">~</code>repsep(expr,&nbsp;<code class="quotedstring">","</code>)<code style="font-size:large">~</code><code class="quotedstring">")"</code>&nbsp;^^&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;f<code style="font-size:large">~</code><code class="quotedstring">"("</code><code style="font-size:large">~</code>ps<code style="font-size:large">~</code><code class="quotedstring">")"</code>&nbsp;=&gt;&nbsp;<code class="typename">Application</code>(f,&nbsp;ps)&nbsp;
  &nbsp;&nbsp;}
</pre>


<p>The <pre class="code">expr</pre> parser recognizes a formula expression&mdash;either a top-level formula
following an `<pre class="code">=</pre>', or an argument to a function. Such a formula expression
is defined to be a cell, a range of cells, a number, or an application:</p>

<pre>
  <code class="vem">def</code>&nbsp;expr:&nbsp;<code class="typename">Parser[Formula]</code>&nbsp;=
  &nbsp;&nbsp;range&nbsp;|&nbsp;cell&nbsp;|&nbsp;number&nbsp;|&nbsp;application
</pre>


<p>This definition of the <pre class="code">expr</pre> parser contains a slight
oversimplification because ranges of cells should
only appear as function arguments; they should not be allowed as
top-level formulas. You could change the formula grammar so that the
two uses of expressions are separated, and ranges are excluded
syntactically from top-level formulas. In the spreadsheet presented
here such an error is instead detected once an expression is
evaluated.</p>

<p>The <pre class="code">textual</pre> parser recognizes an arbitrary input string, as long
as it does not start with an equals sign (recall that strings that
start with `<pre class="code">=</pre>' are considered to be formulas):</p>

<pre>
  <code class="vem">def</code>&nbsp;textual:&nbsp;<code class="typename">Parser[Textual]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="quotedstring">"""[^=].*"""</code>.r&nbsp;^^&nbsp;<code class="typename">Textual</code>
</pre>


<p>The <pre class="code">formula</pre> parser recognizes all kinds of legal inputs into a cell.
A formula is either a <pre class="code">number</pre>, or a <pre class="code">textual</pre> entry, or a formula starting 
with an equals sign:</p>

<pre>
  <code class="vem">def</code>&nbsp;formula:&nbsp;<code class="typename">Parser[Formula]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;number&nbsp;|&nbsp;textual&nbsp;|&nbsp;<code class="quotedstring">"="</code><code style="font-size:large">~</code>&gt;expr
</pre>


<p>This concludes the grammar for spreadsheet cells. The final method
<pre class="code">parse</pre> uses this grammar in a method that converts an input string into a 
<pre class="code">Formula</pre> tree:</p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;parse(input:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Formula</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;parseAll(formula,&nbsp;input)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Success</code>(e,&nbsp;_)&nbsp;=&gt;&nbsp;e
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;f:&nbsp;<code class="typename">NoSuccess</code>&nbsp;=&gt;&nbsp;<code class="typename">Textual</code>(<code class="quotedstring">"["</code>&nbsp;+&nbsp;f.msg&nbsp;+&nbsp;<code class="quotedstring">"]"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  }&nbsp;<code class="comment">//end&nbsp;FormulaParsers</code>
</pre>


<p>The <pre class="code">parse</pre> method parses all of the input with the <pre class="code">formula</pre> parser.
If that succeeds, the resulting formula is returned. If it fails,
a <pre class="code">Textual</pre> object with an error message is returned instead.</p>

<p><a id="lst-spreadsheet-parses-formulas"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;org.stairwaybook.scells
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;swing._
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;event._
  <br />  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Spreadsheet</code>(<code class="vem">val</code>&nbsp;height:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;...&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;table&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Table</code>(height,&nbsp;width)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reactions&nbsp;+=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">TableUpdated</code>(table,&nbsp;rows,&nbsp;column)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(row&nbsp;&lt;-&nbsp;rows)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cells(row)(column).formula&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FormulaParsers.parse(userData(row,&nbsp;column))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 35.6 - A spreadsheet that parses formulas.</h5>


<p>That's everything there is to parsing formulas. The only thing that remains is to
integrate the parser into the spreadsheet. To do this, you can enrich
the <pre class="code">Cell</pre> class in class <pre class="code">Model</pre> by a <pre class="code">formula</pre> field:</p>

<pre>
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Cell</code>(row:&nbsp;<code class="typename">Int</code>,&nbsp;column:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;formula:&nbsp;<code class="typename">Formula</code>&nbsp;=&nbsp;<code class="typename">Empty</code>
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;formula.toString
  }
</pre>


<p>In the new version of the <pre class="code">Cell</pre> class, the <pre class="code">toString</pre> method is
defined to display the cell's <pre class="code">formula</pre>. That way you can check
whether formulas have been correctly parsed.</p>

<p>The last step in this section is to integrate the parser into the
spreadsheet. Parsing a formula happens as a reaction to the user's
input into a cell. A completed cell input is modeled in the Swing
library by a <pre class="code">TableUpdated</pre>
event.<a id="i1392790829-1"/> The <pre class="code">TableUpdated</pre> class is
contained in package <pre class="code">scala.swing.event</pre>.
The event is of the form:</p>

<pre>
  <code class="typename">TableUpdated</code>(table,&nbsp;rows,&nbsp;column)
</pre>


<p>It contains the <pre class="code">table</pre> that was changed, as well as a set of coordinates of
affected cells given by <pre class="code">rows</pre> and <pre class="code">column</pre>.  The <pre class="code">rows</pre> parameter
is a range value of type <pre class="code">Range[Int]</pre>.<a href="the-scells-spreadsheet.html#footnotemain35-2">[2]</a> The <pre class="code">column</pre> parameter is an integer.  
So in general a <pre class="code">TableUpdated</pre> event can refer to several affected cells,
but they would be on a consecutive range of rows and share the same
column.</p>

<div class="figure"><a id="fig-scells3"/>


<p><img src="images/scells3Gray96.png" alt="image images/scells3Gray96.png"/></p>

</div>
<h5> Figure 35.3 - Cells displaying their formulas.</h5>


<p>Once a table is changed, the affected cells need to be re-parsed.  To
react to a <pre class="code">TableUpdated</pre> event, you add a case to the <pre class="code">reactions</pre>
value of the <pre class="code">table</pre> component, as is shown in
<a href="the-scells-spreadsheet.html#lst-spreadsheet-parses-formulas">Listing 35.6</a>.<a id="i-1242645043-1"/>
Now, whenever the table is edited the formulas of all affected cells
will be updated by parsing the corresponding user data.
When compiling the classes discussed so far and launching the
<pre class="code">scells.Main</pre> application you should see a spreadsheet application like the one
shown in <a href="the-scells-spreadsheet.html#fig-scells3">Figure 35.3</a>.  You can edit cells by typing into
them. After editing is done, a cell displays the formula it
contains. You can also try to type some illegal input such as the one
reading <pre class="code">=add(1,</pre>&nbsp;<pre class="code">X)</pre> in the field that has the editing focus in
<a href="the-scells-spreadsheet.html#fig-scells3">Figure 35.3</a>. Illegal input will show up as an error
message. For instance, once you'd leave the edited field in
<a href="the-scells-spreadsheet.html#fig-scells3">Figure 35.3</a>
you should see the error message <pre class="code">[`('</pre>&nbsp;<pre class="code">expected]</pre> in the cell (to see
all of the error message you
might need to widen the column by dragging the separation between the
column headers to the right).</p>

<h3>35.5 Evaluation</h3>


<p>Of course, in the end a spreadsheet should evaluate formulas, not just
display them. In this section, we'll add the necessary components to
achieve this.</p>

<p>What's needed is a method, <pre class="code">evaluate</pre>, which takes a formula and returns
the value of that formula in the current spreadsheet, represented as a
<pre class="code">Double</pre>. We'll place this method in a new trait, <pre class="code">Evaluator</pre>.  The
method needs to access the <pre class="code">cells</pre> field in class <pre class="code">Model</pre> to find
out about the current values of cells that are referenced in a
formula. On the other hand, the <pre class="code">Model</pre> class needs to call
<pre class="code">evaluate</pre>. Hence, there's a mutual dependency between the <pre class="code">Model</pre>
and the <pre class="code">Evaluator</pre>. A good way to express such mutual dependencies
between classes was shown in <a href="modular-programming-using-objects.html">Chapter 29</a>:
you use inheritance in one direction and self types in the
other.<a id="i1009253694-1"/><a id="i1609470629-1"/><a id="i-560124499-2"/></p>

<p>In the spreadsheet example, class <pre class="code">Model</pre> inherits from
<pre class="code">Evaluator</pre> and thus gains access to its <pre class="code">evaluation</pre> method.  To go
the other way, class <pre class="code">Evaluator</pre> defines its self type to be
<pre class="code">Model</pre>, like this:</p>

<pre>
  <code class="vem">package</code>&nbsp;org.stairwaybook.scells
  <code class="vem">trait</code>&nbsp;<code class="typename">Evaluator</code>&nbsp;{&nbsp;<code class="vem">this</code>:&nbsp;<code class="typename">Model</code>&nbsp;=&gt;&nbsp;...
</pre>


<p>That way, the <pre class="code">this</pre> value inside class <pre class="code">Evaluator</pre> is assumed to be
<pre class="code">Model</pre> and the <pre class="code">cells</pre> array is accessible by writing either <pre class="code">cells</pre> or
<pre class="code">this.cells</pre>.</p>

<p>Now that the wiring is done, we'll concentrate on defining the
contents of class <pre class="code">Evaluator</pre>. <a href="the-scells-spreadsheet.html#lst-evaluate-method">Listing 35.7</a> shows the implementation of the
<pre class="code">evaluate</pre> method.
As you might expect,  the method contains a pattern match over the
different types of formulas.<a id="i1154860961-2"/> For a coordinate <pre class="code">Coord(row,</pre>&nbsp;<pre class="code">column)</pre>,
it returns the value of the <pre class="code">cells</pre> array at that coordinate.
For a number <pre class="code">Number(v)</pre>, it returns the value <pre class="code">v</pre>. For a textual
label <pre class="code">Textual(s)</pre>, it returns zero. Finally, for an application
<pre class="code">Application(function,</pre>&nbsp;<pre class="code">arguments)</pre>, it computes the values of
all arguments, retrieves a function object corresponding to the
<pre class="code">function</pre> name from an <pre class="code">operations</pre> table and applies that
function to all argument values. 
<a id="lst-evaluate-method"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;evaluate(e:&nbsp;<code class="typename">Formula</code>):&nbsp;<code class="typename">Double</code>&nbsp;=&nbsp;<code class="vem">try</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;e&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Coord</code>(row,&nbsp;column)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cells(row)(column).value
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Number</code>(v)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Textual</code>(_)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Application</code>(function,&nbsp;arguments)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;argvals&nbsp;=&nbsp;arguments&nbsp;flatMap&nbsp;evalList
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;operations(function)(argvals)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}&nbsp;<code class="vem">catch</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;ex:&nbsp;<code class="typename">Exception</code>&nbsp;=&gt;&nbsp;<code class="typename">Double.NaN</code>
  &nbsp;&nbsp;}
</pre>


<h5>Listing 35.7 - The <pre class="code">evaluate</pre> method of trait <pre class="code">Evaluator</pre>.</h5>


<p>The <pre class="code">operations</pre> table maps function names
to function objects. It is defined as follows:</p>

<pre>
  <code class="vem">type</code>&nbsp;<code class="typename">Op</code>&nbsp;=&nbsp;<code class="typename">List[Double]</code>&nbsp;=&gt;&nbsp;<code class="typename">Double</code>
  <code class="vem">val</code>&nbsp;operations&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">collection.mutable.HashMap[String,&nbsp;Op]</code>
</pre>


<p>As you can see from this definition, operations are modeled as
functions from lists of values to values. The <pre class="code">Op</pre> type introduces a
convenient alias for the type of an operation.</p>

<p>The computation in <pre class="code">evaluate</pre> is wrapped in a try-catch to guard
against input errors. There are actually quite a few things that can
go wrong when evaluating a cell formula: coordinates might be out of
range; function names might be undefined; functions might have the
wrong number of arguments; arithmetic operations might be illegal or
overflow.  The reaction to any of these errors is the same: a
"not-a-number" value is returned. The returned value,
<pre class="code">Double.NaN</pre>, is the IEEE representation for a computation that
does not have a representable floating-point
value.<a id="i995050225-1"/> This might happen
because of an overflow or a division by zero, for example. The
<pre class="code">evaluate</pre> method of <a href="the-scells-spreadsheet.html#lst-evaluate-method">Listing 35.7</a> chooses to return the same value also for all
other kinds of errors. The advantage of this scheme is that it's
simple to understand and doesn't require much code to
implement. Its disadvantage is that all kinds of errors are lumped
together, so a spreadsheet user does not get any detailed
feedback on what went wrong.  If you wish you can experiment with more
refined ways of representing errors in the <pre class="code">SCells</pre> application.</p>

<p>The evaluation of arguments is different from the evaluation of
top-level formulas. Arguments may be lists whereas top-level
functions may not. For instance, the argument expression <pre class="code">A1:A3</pre> in
<pre class="code">sum(A1:A3)</pre> returns the values of cells <pre class="code">A1</pre>, <pre class="code">A2</pre>, <pre class="code">A3</pre> in a
list. This list is then passed to the <pre class="code">sum</pre> operation. It's also
possible to mix lists and single values in argument expressions, for
instance the operation <pre class="code">sum(A1:A3,</pre>&nbsp;<pre class="code">1.0,</pre>&nbsp;<pre class="code">C7)</pre>, which would sum up five
values. To handle arguments that might evaluate to lists, there's
another evaluation function, called <pre class="code">evalList</pre>, which
takes a formula and returns a list of values:</p>

<pre>
  <code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;evalList(e:&nbsp;<code class="typename">Formula</code>):&nbsp;<code class="typename">List[Double]</code>&nbsp;=&nbsp;e&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Range</code>(_,&nbsp;_)&nbsp;=&gt;&nbsp;references(e)&nbsp;map&nbsp;(_.value)
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="typename">List</code>(evaluate(e))
  }
</pre>


<p>If the formula argument passed to <pre class="code">evalList</pre> is a <pre class="code">Range</pre>, the
returned value is a list consisting of the values of all cells
referenced by the range. For every other formula the result is a list
consisting of the single result value of that formula.
The  cells referenced by a formula are computed by a third function,
<pre class="code">references</pre>. Here is its definition:</p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;references(e:&nbsp;<code class="typename">Formula</code>):&nbsp;<code class="typename">List[Cell]</code>&nbsp;=&nbsp;e&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Coord</code>(row,&nbsp;column)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">List</code>(cells(row)(column))
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Range</code>(<code class="typename">Coord</code>(r1,&nbsp;c1),&nbsp;<code class="typename">Coord</code>(r2,&nbsp;c2))&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(row&nbsp;&lt;-&nbsp;(r1&nbsp;to&nbsp;r2).toList;&nbsp;column&nbsp;&lt;-&nbsp;c1&nbsp;to&nbsp;c2)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;cells(row)(column)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Application</code>(function,&nbsp;arguments)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments&nbsp;flatMap&nbsp;references
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">List</code>()
  &nbsp;&nbsp;}
  }&nbsp;<code class="comment">//&nbsp;end&nbsp;Evaluator</code>
</pre>


<p>The <pre class="code">references</pre> method is actually more general than needed right now in that
it computes the list of cells referenced by any sort of formula, not
just a <pre class="code">Range</pre> formula. It will turn out later that the added
functionality is needed to compute the sets of cells that need
updating. The body of the method is a straightforward pattern match on 
kinds of formulas. For a coordinate <pre class="code">Coord(row,</pre>&nbsp;<pre class="code">column)</pre>, it returns
a single-element list containing the cell at that coordinate. For a range expression
<pre class="code">Range(coord1,</pre>&nbsp;<pre class="code">coord2)</pre>, it returns all cells
between the two coordinates, computed by a <pre class="code">for</pre> expression. For a
function application <pre class="code">Application(function,</pre>&nbsp;<pre class="code">arguments)</pre>, it returns
the cells referenced by each argument expression, concatenated via
<pre class="code">flatMap</pre> into a single list. For the other two types of formulas,
<pre class="code">Textual</pre> and <pre class="code">Number</pre>, it returns an empty list.</p>

<h3>35.6 Operation libraries</h3>


<p>The class <pre class="code">Evaluator</pre> itself defines no operations that can be
performed on cells: its <pre class="code">operations</pre> table is initially empty.
The idea is to define such operations in other traits, which are then
mixed into the <pre class="code">Model</pre> class.<a id="i464307868-1"/> <a href="the-scells-spreadsheet.html#lst-scells-Arithmetic">Listing 35.8</a>
shows an example trait that implements 
common arithmetic operations:</p>

<p><a id="lst-scells-Arithmetic"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;org.stairwaybook.scells
  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">Arithmetic</code>&nbsp;{&nbsp;<code class="vem">this</code>:&nbsp;<code class="typename">Evaluator</code>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;operations&nbsp;+=&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"add"</code>&nbsp;&nbsp;-&gt;&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;y&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"sub"</code>&nbsp;&nbsp;-&gt;&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;-&nbsp;y&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"div"</code>&nbsp;&nbsp;-&gt;&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;/&nbsp;y&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"mul"</code>&nbsp;&nbsp;-&gt;&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;*&nbsp;y&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"mod"</code>&nbsp;&nbsp;-&gt;&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;<code class="texttt">%</code>&nbsp;y&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"sum"</code>&nbsp;&nbsp;-&gt;&nbsp;{&nbsp;xs&nbsp;=&gt;&nbsp;(<code class="literal">0.0</code>&nbsp;/:&nbsp;xs)(_&nbsp;+&nbsp;_)&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"prod"</code>&nbsp;-&gt;&nbsp;{&nbsp;xs&nbsp;=&gt;&nbsp;(<code class="literal">1.0</code>&nbsp;/:&nbsp;xs)(_&nbsp;*&nbsp;_)&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 35.8 - A library for arithmetic operations.</h5>


<p>Interestingly, this trait has no exported members. The only thing it
does is populate the <pre class="code">operations</pre> table during its initialization. It
gets access to that table by using a self type <pre class="code">Evaluator</pre>, <i>i.e.</i>, by the
same technique the <pre class="code">Arithmetic</pre> class uses to get access to the
model.<a id="i1609470629-2"/><a id="i-560124499-3"/></p>

<p>Of the seven operations that are defined by the <pre class="code">Arithmetic</pre>
trait, five are binary operations and two take an arbitrary
number of arguments.  The binary operations all follow the same
schema. For instance, the addition operation <pre class="code">add</pre> is defined by
the expression:</p>

<pre>
  {&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;y&nbsp;}
</pre>


<p>That is, it expects an argument list consisting of two elements <pre class="code">x</pre>
and <pre class="code">y</pre> and returns the sum of <pre class="code">x</pre> and <pre class="code">y</pre>. If the argument list
contains a number of elements different from two, a <pre class="code">MatchError</pre> is
thrown. This corresponds to the general "let it crash" philosophy 
of <pre class="code">SCell</pre>'s evaluation model, where incorrect input is expected to lead to a
runtime exception that then gets caught by the try-catch inside the <pre class="code">evaluation</pre>
method.</p>

<p>The last two operations, <pre class="code">sum</pre> and <pre class="code">prod</pre>, take a list of arguments
of arbitrary length and insert a binary operation between successive
elements. So they are instances of the "fold left" schema that's
expressed in class <pre class="code">List</pre> by the <pre class="code">/:</pre> operation. For instance, to
<pre class="code">sum</pre> a list of numbers <pre class="code">List(x,</pre>&nbsp;<pre class="code">y,</pre>&nbsp;<pre class="code">z)</pre>, the operation
computes <pre class="code">0</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">x</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">y</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">z</pre>. The first operand, <pre class="code">0</pre>, is the result
 if the list is empty.</p>

<p>You can integrate this operation library into the spreadsheet
application by mixing the <pre class="code">Arithmetic</pre> trait into the <pre class="code">Model</pre> class, like this:</p>

<pre>
  <code class="vem">package</code>&nbsp;org.stairwaybook.scells
  <br />  <code class="vem">class</code>&nbsp;<code class="typename">Model</code>(<code class="vem">val</code>&nbsp;height:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Evaluator</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">Arithmetic</code>&nbsp;{&nbsp;
  <br />  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Cell</code>(row:&nbsp;<code class="typename">Int</code>,&nbsp;column:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;formula:&nbsp;<code class="typename">Formula</code>&nbsp;=&nbsp;<code class="typename">Empty</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;value&nbsp;=&nbsp;evaluate(formula)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;formula&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Textual</code>(s)&nbsp;=&gt;&nbsp;s
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;value.toString
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;...&nbsp;<code class="comment">//&nbsp;rest&nbsp;as&nbsp;before</code>
  }
</pre>


<p>Another change in the <pre class="code">Model</pre> class concerns the way cells display
themselves. In the new version, the displayed value of a cell depends
on its formula. If the formula is a <pre class="code">Textual</pre> field, the contents of
the field are displayed literally. In all other cases, the formula is
evaluated and the result <pre class="code">value</pre> of that evaluation is displayed.</p>

<div class="figure"><a id="fig-scells4"/>


<p><img src="images/scells4Gray96.png" alt="image images/scells4Gray96.png"/></p>

</div>
<h5> Figure 35.4 - Cells that evaluate.</h5>


<p>If you compile the changed traits and classes and relaunch the
<pre class="code">Main</pre> program you get something that starts to resemble a real
spreadsheet. <a href="the-scells-spreadsheet.html#fig-scells4">Figure 35.4</a> shows an example.
You can enter formulas into cells and get them to evaluate themselves. For instance,
once you close the editing focus on cell <pre class="code">C5</pre> in
<a href="the-scells-spreadsheet.html#fig-scells4">Figure 35.4</a>, you should see <pre class="code">86.0</pre>, the result of
evaluating the formula <pre class="code">sum(C1:C4)</pre>.</p>

<p>However, there's a crucial element still missing. If you change the
value of cell <pre class="code">C1</pre> in <a href="the-scells-spreadsheet.html#fig-scells4">Figure 35.4</a> from 20 to 100, the
sum in cell <pre class="code">C5</pre> will not be automatically updated to 166. You'll
have to click on <pre class="code">C5</pre> manually to see a change in its value. What's still
missing is a way to have cells recompute their values automatically
after a change.</p>

<h3>35.7 Change propagation</h3>


<p>If a cell's value has changed, all cells that depend on that value
should have their results recomputed and redisplayed. The simplest way
to achieve this would be to recompute the value of every cell in
the spreadsheet after each change. However such an approach does not
scale well as the spreadsheet grows in size.</p>

<p>A better approach is to recompute the values of only those cells that
refer to a changed cell in their formula. The idea is to use an
event-based publish/subscribe framework for change propagation: once a
cell gets assigned a formula, it will subscribe to be notified of all
value changes in cells to which the formula refers. A value
change in one of these cells will trigger a re-evaluation of the
subscriber cell. If such a re-evaluation causes a change in the
value of the cell, it will in turn notify all cells that depend on it.
The process continues until all cell values have stabilized, <i>i.e.</i>,
there are no more changes in the values of any cell.<a href="the-scells-spreadsheet.html#footnotemain35-3">[3]</a></p>

<p>The publish/subscribe framework is implemented in class <pre class="code">Model</pre> using
the standard event mechanism of Scala's Swing framework. Here's a new (and
final) version of this class:</p>

<pre>
  <code class="vem">package</code>&nbsp;org.stairwaybook.scells
  <code class="vem">import</code>&nbsp;swing._
  <br />  <code class="vem">class</code>&nbsp;<code class="typename">Model</code>(<code class="vem">val</code>&nbsp;height:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;
  <code class="vem">extends</code>&nbsp;<code class="typename">Evaluator</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">Arithmetic</code>&nbsp;{&nbsp;
</pre>


<p>Compared to the previous version of <pre class="code">Model</pre>, this version adds a new import of
<pre class="code">swing._</pre>, which makes Swing's event abstractions directly
available.<a id="i1245010859-2"/></p>

<p>The main modifications of class <pre class="code">Model</pre> concern the nested class
<pre class="code">Cell</pre>. Class <pre class="code">Cell</pre> now inherits from <pre class="code">Publisher</pre>, so that it can publish
events.<a id="i-843595300-1"/> The event-handling logic is completely contained in the setters of
two properties: <pre class="code">value</pre> and <pre class="code">formula</pre>.
Here is <pre class="code">Cell</pre>'s new version:</p>

<pre>
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Cell</code>(row:&nbsp;<code class="typename">Int</code>,&nbsp;column:&nbsp;<code class="typename">Int</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Publisher</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;formula&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Textual</code>(s)&nbsp;=&gt;&nbsp;s
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;value.toString
  &nbsp;&nbsp;}
</pre>


<p>To the outside, it looks like
<pre class="code">value</pre> and <pre class="code">formula</pre> are two variables in class <pre class="code">Cell</pre>. Their
actual implementation is in terms of two private fields
that are equipped with public getters, <pre class="code">value</pre> and <pre class="code">formula</pre>, and
setters, <pre class="code">value_=</pre> and <pre class="code">formula_=</pre>. 
Here are the definitions implementing the <pre class="code">value</pre> property:</p>

<pre>
  <code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;v:&nbsp;<code class="typename">Double</code>&nbsp;=&nbsp;<code class="literal">0</code>
  <code class="vem">def</code>&nbsp;value:&nbsp;<code class="typename">Double</code>&nbsp;=&nbsp;v
  <code class="vem">def</code>&nbsp;value_=(w:&nbsp;<code class="typename">Double</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(!(v&nbsp;==&nbsp;w&nbsp;||&nbsp;v.isNaN&nbsp;&amp;&amp;&nbsp;w.isNaN))&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;w
  &nbsp;&nbsp;&nbsp;&nbsp;publish(<code class="typename">ValueChanged</code>(<code class="vem">this</code>))
  &nbsp;&nbsp;}
  }
</pre>


<p>The <pre class="code">value_=</pre> setter assigns a new value <pre class="code">w</pre> to the private field
<pre class="code">v</pre>. If the new value is different from the old one, it also
publishes a <pre class="code">ValueChanged</pre> event with the cell itself as
argument.<a id="i1571974179-1"/>
Note that the test whether the value has changed is a bit tricky
because it involves the value <pre class="code">NaN</pre>.<a id="i995050225-2"/>
The Java spec says that <pre class="code">NaN</pre>
is different from every other value, including itself! Therefore, 
a test whether two values are the same has to treat <pre class="code">NaN</pre> specially:
two values <pre class="code">v</pre>, <pre class="code">w</pre> are the same if they are equal with respect to <pre class="code">==</pre>, or
they are both the value <pre class="code">NaN</pre>, <i>i.e.</i>, <pre class="code">v.isNaN</pre> and <pre class="code">w.isNaN</pre> both
yield <pre class="code">true</pre>.</p>

<p>Whereas the <pre class="code">value_=</pre> setter does the publishing in the
publish/subscribe framework, the <pre class="code">formula_=</pre> setter does the
subscribing:</p>

<pre>
  <code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;f:&nbsp;<code class="typename">Formula</code>&nbsp;=&nbsp;<code class="typename">Empty</code>
  <code class="vem">def</code>&nbsp;formula:&nbsp;<code class="typename">Formula</code>&nbsp;=&nbsp;f
  <code class="vem">def</code>&nbsp;formula_=(f:&nbsp;<code class="typename">Formula</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(c&nbsp;&lt;-&nbsp;references(formula))&nbsp;deafTo(c)
  &nbsp;&nbsp;<code class="vem">this</code>.f&nbsp;=&nbsp;f
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(c&nbsp;&lt;-&nbsp;references(formula))&nbsp;listenTo(c)
  &nbsp;&nbsp;value&nbsp;=&nbsp;evaluate(f)
  }
</pre>


<p>If a cell is assigned a new formula, it first
unsubscribes with <pre class="code">deafTo</pre> from all cells referenced by the previous <pre class="code">formula</pre>
value. It then stores the new formula in the private variable <pre class="code">f</pre> and 
subscribes with <pre class="code">listenTo</pre> to all cells referenced by
it.<a id="i-2118281873-2"/>
Finally, it recomputes its <pre class="code">value</pre> using the new formula.</p>

<p>The last piece of code in the revised class <pre class="code">Cell</pre> specifies how to react to a
<pre class="code">ValueChanged</pre> event:</p>

<pre>
  &nbsp;&nbsp;reactions&nbsp;+=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">ValueChanged</code>(_)&nbsp;=&gt;&nbsp;value&nbsp;=&nbsp;evaluate(formula)
  &nbsp;&nbsp;}
  }&nbsp;<code class="comment">//&nbsp;end&nbsp;class&nbsp;Cell</code>
</pre>


<p>The <pre class="code">ValueChanged</pre> class is also contained in class <pre class="code">Model</pre>:</p>

<pre>
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ValueChanged</code>(cell:&nbsp;<code class="typename">Cell</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">event.Event</code>
</pre>


<p>The rest of class <pre class="code">Model</pre> is as before:</p>

<pre>
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;cells&nbsp;=&nbsp;Array.ofDim[<code class="typename">Cell</code>](height,&nbsp;width)&nbsp;
  <br />  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;height;&nbsp;j&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;width)
  &nbsp;&nbsp;&nbsp;&nbsp;cells(i)(j)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Cell</code>(i,&nbsp;j)
  }&nbsp;<code class="comment">//&nbsp;end&nbsp;class&nbsp;Model</code>
</pre>


<p><a id="lst-scells-Spreadsheet3"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;org.stairwaybook.scells
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;swing._,&nbsp;event._
  <br />  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Spreadsheet</code>(<code class="vem">val</code>&nbsp;height:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">ScrollPane</code>&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;cellModel&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Model</code>(height,&nbsp;width)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">import</code>&nbsp;cellModel._
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;table&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Table</code>(height,&nbsp;width)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;<code class="comment">//&nbsp;settings&nbsp;as&nbsp;in&nbsp;<a href="the-scells-spreadsheet.html#lst-scells-Spreadsheet1">Listing ???</a></code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;rendererComponent(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isSelected:&nbsp;<code class="typename">Boolean</code>,&nbsp;hasFocus:&nbsp;<code class="typename">Boolean</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row:&nbsp;<code class="typename">Int</code>,&nbsp;column:&nbsp;<code class="typename">Int</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;<code class="comment">//&nbsp;as&nbsp;in&nbsp;<a href="the-scells-spreadsheet.html#lst-scells-Spreadsheet2">Listing ???</a></code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;userData(row:&nbsp;<code class="typename">Int</code>,&nbsp;column:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;<code class="comment">//&nbsp;as&nbsp;in&nbsp;<a href="the-scells-spreadsheet.html#lst-scells-Spreadsheet2">Listing ???</a></code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reactions&nbsp;+=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">TableUpdated</code>(table,&nbsp;rows,&nbsp;column)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(row&nbsp;&lt;-&nbsp;rows)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cells(row)(column).formula&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FormulaParsers.parse(userData(row,&nbsp;column))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">ValueChanged</code>(cell)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updateCell(cell.row,&nbsp;cell.column)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(row&nbsp;&lt;-&nbsp;cells;&nbsp;cell&nbsp;&lt;-&nbsp;row)&nbsp;listenTo(cell)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;rowHeader&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ListView</code>(<code class="literal">0</code>&nbsp;until&nbsp;height)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixedCellWidth&nbsp;=&nbsp;<code class="literal">30</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixedCellHeight&nbsp;=&nbsp;table.rowHeight
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;viewportView&nbsp;=&nbsp;table
  &nbsp;&nbsp;&nbsp;&nbsp;rowHeaderView&nbsp;=&nbsp;rowHeader
  &nbsp;&nbsp;}</pre>


<h5>Listing 35.9 - The finished spreadsheet component.</h5>


<p>The spreadsheet code is now almost complete. The final piece missing
is the re-display of modified cells. So far, all value propagation
concerned the internal <pre class="code">Cell</pre> values only; the visible table was not
affected. One way to change this would be to add a redraw command to
the <pre class="code">value_=</pre> setter. However, this would undermine the strict
separation between model and view that you have seen so far. A more modular
solution is to notify the table of all <pre class="code">ValueChanged</pre> events
and let it do the redrawing
itself. <a href="the-scells-spreadsheet.html#lst-scells-Spreadsheet3">Listing 35.9</a> shows the final
spreadsheet component, which implements this scheme.</p>

<p>Class <pre class="code">Spreadsheet</pre> of
<a href="the-scells-spreadsheet.html#lst-scells-Spreadsheet3">Listing 35.9</a> has only two new revisions. First, the <pre class="code">table</pre> component now subscribes with <pre class="code">listenTo</pre> to all cells in
the model. Second, there's a new case in the table's reactions: 
if it is notified of a <pre class="code">ValueChanged(cell)</pre> event, it
demands a redraw of the corresponding cell with a call of
<pre class="code">updateCell(cell.row,</pre>&nbsp;<pre class="code">cell.column)</pre>.</p>

<h3>35.8 Conclusion</h3>


<p>The spreadsheet developed in this chapter
is fully functional, even though at some
points it adopts the simplest solution to implement rather than the most convenient
one for the user. That way, it could be written in just under 200 lines of code.
Nevertheless, the architecture of the spreadsheet makes modifications
and extensions easy. In case you would like to experiment with the
code a bit further, here are some suggestions of what you could change or add:</p>

<ol>


<li>
  You could make the spreadsheet resizable, so that the number of rows and
  columns can be changed interactively.   


</li>
<li>
  You could add new kinds of formulas, for instance binary operations, or other
  functions.


</li>
<li>
  You might think about what to do when cells refer recursively to themselves. 
  For instance, if cell <pre class="code">A1</pre> holds the formula
  <pre class="code">add(B1,</pre>&nbsp;<pre class="code">1)</pre> and cell <pre class="code">B1</pre> holds the formula <pre class="code">mul(A1,</pre>&nbsp;<pre class="code">2)</pre>, a re-evaluation
  of either cell will trigger a stack-overflow. 
  Clearly, that's not a very good solution. As alternatives,
  you could either disallow such a situation, or
  just compute one iteration each time one of the cells is touched. 


</li>
<li>
  You could enhance error handling, giving more detailed messages describing what went
  wrong.


</li>
<li>
  You could add a formula entry field at the top of the spreadsheet, 
  so that long formulas could be entered more conveniently.


</li></ol>


<p>At the beginning of this book we stressed the scalability aspect of
Scala.<a id="i-885663216-3"/><a id="i-2079231610-1"/>  We claimed that the combination of Scala's object-oriented and
functional constructs makes it suitable for programs ranging from
small scripts to very large systems. The spreadsheet presented here
is clearly still a small system, even though it would probably 
take up much more than 200 lines in most other languages. Nevertheless,
you can see many of the details that make Scala scalable at play in
this application.</p>

<p>The spreadsheet uses Scala's classes and traits with their mixin
composition to combine its components in flexible ways.<a id="i1953973959-1"/> Recursive
dependencies between components are expressed using self
types. The
need for static state is completely eliminated&mdash;the only top-level
components that are not classes are formula trees and formula parsers,
and both of these are purely functional.  The application also uses
higher-order functions and pattern matching extensively, both for
accessing formulas and for event handling. So it is a good showcase of
how functional and object-oriented programming can be combined
smoothly.</p>

<p>One important reason why the spreadsheet application is so concise is
that it can base itself on powerful libraries. The parser combinator
library provides in effect an internal domain-specific language for
writing parsers.<a id="i-218658218-1"/><a id="i-640692980-1"/> Without it, parsing formulas would have been much
more difficult. The event handling in Scala's Swing libraries is a good
example of the power of control abstractions. If you know Java's Swing
libraries, you probably appreciate the conciseness of Scala's
reactions concept, particularly when compared to the tedium of
writing notify methods and implementing listener interfaces in the
classical publish/subscribe design pattern.<a id="i851179987-1"/> So the spreadsheet
demonstrates the benefits of extensibility, where high-level libraries
can be made to look just like language extensions.</p>

<hr/>
<h4>Footnotes for Chapter 35:</h4>


<p><a id="footnotemain35-1"/>[1] Although "<pre class="code">this(row,</pre>&nbsp;<pre class="code">column)</pre>" may look similar to a constructor invocation, it is in this case an invocation
of the <pre class="code">apply</pre> method on the current <pre class="code">Table</pre> instance.</p>

<p><a id="footnotemain35-2"/>[2] <pre class="code">Range[Int]</pre> is also the type of a
Scala expression such as "<pre class="code">1</pre>&nbsp;<pre class="code">to</pre>&nbsp;<pre class="code">N</pre>".</p>

<p><a id="footnotemain35-3"/>[3] This
  assumes that there are no cyclic dependencies between cells. We
  discuss dropping this assumption at the end of this chapter.</p>

<div style="page-break-after:always"/>


<div style="page-break-after:always"/>

</body>
</html>
