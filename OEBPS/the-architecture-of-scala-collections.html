<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8"/>
    <title>Programming in Scala, 3rd Edition</title>

    <link rel="stylesheet" type="text/css" href="book.css" />
  </head>
<body>
<h2><a id="chap-the-architecture-of-scala-collections">Chapter 25</a></h2>
<h1>The Architecture of Scala Collections</h1>


<p>This chapter describes the architecture of the Scala collections
framework in detail. Continuing the theme of <a href="collections-in-depth.html">Chapter 24</a>, you will find out more about
the internal workings of the framework. You will also learn how this
architecture helps you define your own collections in a few lines of
code, while reusing the overwhelming part of collection functionality
from the framework.<a id="i-512346344-1"/></p>

<p><a href="collections-in-depth.html">Chapter 24</a> enumerated a large number of
collection operations, which exist uniformly on many different
collection implementations.  Implementing every collection operation
anew for every collection type would lead to an enormous amount of code,
most of which would be copied from somewhere else. Such code
duplication could lead to inconsistencies over time, when an operation is
added or modified in one part of the collection library but not in
others. The principal design objective of the new collections
framework was to avoid any duplication, defining every operation in as
few places as possible.<a href="the-architecture-of-scala-collections.html#footnotemain25-1">[1]</a>  The design approach was to implement most
operations in collection "templates" that can be flexibly inherited
from individual base classes and implementations. In this chapter, we will examine these templates, and other classes and traits that constitute the "building blocks" 
of the framework, as well as the construction principles
they support.</p>

<h3>25.1 Builders</h3>


<p>Almost all collection operations are implemented in terms of <span style="font-style:italic">traversals</span> and
<span style="font-style:italic">builders</span>. Traversals are handled by <span class="code">Traversable</span>'s <span class="code">foreach</span> method,
and building new collections is handled by instances of class
<span class="code">Builder</span>. <a href="the-architecture-of-scala-collections.html#lst-builder">Listing 25.1</a> presents a slightly abbreviated outline 
of this class.</p>

<p><a id="lst-builder"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;scala.collection.generic
  <br />  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Builder[-Elem,&nbsp;+To]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;+=(elem:&nbsp;<code class="typename">Elem</code>):&nbsp;<code class="vem">this</code>.type
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;result():&nbsp;<code class="typename">To</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;clear()
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;mapResult[<code class="typename">NewTo</code>](f:&nbsp;<code class="typename">To</code>&nbsp;=&gt;&nbsp;<code class="typename">NewTo</code>):&nbsp;<code class="typename">Builder[Elem,&nbsp;NewTo]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;...
  &nbsp;&nbsp;}
</pre>


<h5>Listing 25.1 - An outline of the <span class="code">Builder</span> class.</h5>


<p>You can add an element <span class="code">x</span> to a builder <span class="code">b</span> with <span class="code">b</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">x</span>. 
There's also syntax to add more than one element at once: For
instance, <span class="code">b</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">(x,</span>&nbsp;<span class="code">y)</span> and <span class="code">b</span>&nbsp;<span class="code">++=</span>&nbsp;<span class="code">xs</span> work as for buffers. (In fact, 
buffers are an enriched version of builders.)
The <span class="code">result()</span> method returns a collection from a builder.
The state of the builder is undefined after taking its result, but it
can be reset into a new empty state using <span class="code">clear()</span>.
Builders are generic in both the element type, <span class="code">Elem</span>, and in the type, <span class="code">To</span>,
of collections they return.</p>

<p>Often, a builder can refer to some other builder for assembling the
elements of a collection, but then would like to transform the result
of the other builder&mdash;for example, to give it a different type. This task is
simplified by method <span class="code">mapResult</span> in class <span class="code">Builder</span>. Suppose for
instance you have an array buffer <span class="code">buf</span>. Array buffers are builders
for themselves, so taking the <span class="code">result()</span> of an array buffer will
return the same buffer. If you want to use this buffer to produce a
builder that builds arrays, you can use <span class="code">mapResult</span>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrayBuffer[Int]</code>
  <code class="output">buf:&nbsp;scala.collection.mutable.ArrayBuffer[Int]&nbsp;=&nbsp;ArrayBuffer()</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bldr&nbsp;=&nbsp;buf&nbsp;mapResult&nbsp;(_.toArray)
  <code class="output">bldr:&nbsp;scala.collection.mutable.Builder[Int,Array[Int]]</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;ArrayBuffer()</code>
</pre>


<p>The result value, <span class="code">bldr</span>, is a builder that uses the array buffer,
<span class="code">buf</span>, to collect elements. When a result is demanded from <span class="code">bldr</span>, the result of <span class="code">buf</span> 
is computed, which yields the array buffer <span class="code">buf</span> itself. This array buffer is then
mapped with <span class="code">_.toArray</span> to an array. So the end result is that 
<span class="code">bldr</span> is a builder for arrays.</p>

<h3 id="sec-factoring">25.2 Factoring out common operations</h3>


<p>The  main design objectives of the collection library redesign were to
have, at the same time, natural types and maximal sharing of implementation code. In
particular, Scala's collections follow the "same-result-type"
principle: Wherever possible, a transformation method on a collection
will yield a collection of the same type. For instance, the <span class="code">filter</span>
operation should yield, on every collection type, an instance of the
same collection type. Applying <span class="code">filter</span> on a <span class="code">List</span> should give a <span class="code">List</span>; 
applying it on a <span class="code">Map</span> should give a <span class="code">Map</span>; and so on.
In the rest of this section,
you will find out how this is achieved.</p>

<div class="pointofinterest">
<h3>The fast track</h3>


<p>The material in this section
is a bit more dense than usual and might require some time to absorb.
If you want to move ahead quickly, you could skip the remainder of
this section and move on to <a href="the-architecture-of-scala-collections.html#sec-integrating">Section 25.3</a>  <a href="the-architecture-of-scala-collections.html#sec-integrating">here</a> where you
will learn from concrete examples how to integrate your own collection
classes in the framework.</p>

</div>


<p>The Scala collection library avoids code duplication and achieves the
"same-result-type" principle by using generic builders and
traversals over collections in so-called <em>implementation traits</em>.<a id="i173047719-1"/><a id="i247652435-1"/> These
traits are named with a <span class="code">Like</span> suffix; for instance,
<span class="code">IndexedSeqLike</span> is the implementation trait for <span class="code">IndexedSeq</span>,<a id="i1408079579-1"/> and similarly,
<span class="code">TraversableLike</span> is the implementation trait for
<span class="code">Traversable</span>.<a id="i1464143996-1"/> Collection classes such as <span class="code">Traversable</span> or
<span class="code">IndexedSeq</span> inherit all their concrete method implementations from
these traits.  Implementation traits have two type parameters instead
of one for normal collections.  They parameterize not only over the
collection's element type, but also over the 
collection's <span style="font-style:italic">representation type</span> (<i>i.e.</i>,
the type of the underlying collection), such as <span class="code">Seq[I]</span> or <span class="code">List[T]</span>.</p>

<p>For instance, here is the header of trait
<span class="code">TraversableLike</span>:</p>

<pre>
  <code class="vem">trait</code>&nbsp;<code class="typename">TraversableLike[+Elem,&nbsp;+Repr]</code>&nbsp;{&nbsp;...&nbsp;}
</pre>


<p>The type parameter, <span class="code">Elem</span>, stands for the element type of the
traversable whereas the type parameter <span class="code">Repr</span> stands for its
representation. There are no constraints on <span class="code">Repr</span>. In particular
<span class="code">Repr</span> might be instantiated to a type that is itself not a subtype
of <span class="code">Traversable</span>. That way, classes outside the collections hierarchy,
such as <span class="code">String</span> and <span class="code">Array</span>, can still make use of all operations
defined in a collection implementation trait.</p>

<p><a id="lst-TraversableLike"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;scala.collection
  <br />  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">TraversableLike[+Elem,&nbsp;+Repr]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;newBuilder:&nbsp;<code class="typename">Builder[Elem,&nbsp;Repr]</code>&nbsp;<code class="comment">//&nbsp;deferred</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;foreach[U](f:&nbsp;<code class="typename">Elem</code>&nbsp;=&gt;&nbsp;U)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;deferred</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;filter(p:&nbsp;<code class="typename">Elem</code>&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>):&nbsp;<code class="typename">Repr</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;b&nbsp;=&nbsp;newBuilder
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;{&nbsp;elem&nbsp;=&gt;&nbsp;<code class="vem">if</code>&nbsp;(p(elem))&nbsp;b&nbsp;+=&nbsp;elem&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.result
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
  &nbsp;&nbsp;}
</pre>


<h5>Listing 25.2 - Implementation of <span class="code">filter</span> in <span class="code">TraversableLike</span>.</h5>


<p>Taking <span class="code">filter</span> as an example, this operation is defined once for all
collection classes in the trait <span class="code">TraversableLike</span>. An outline of the
relevant code is shown in <a href="the-architecture-of-scala-collections.html#lst-TraversableLike">Listing 25.2</a>. The
trait declares two abstract methods, <span class="code">newBuilder</span> and <span class="code">foreach</span>,
which are implemented in concrete collection classes. The <span class="code">filter</span>
operation is implemented in the same way for all collections using
these methods. It first constructs a new builder for the
representation type <span class="code">Repr</span>, using <span class="code">newBuilder</span>. It then traverses
all elements of the current collection, using <span class="code">foreach</span>. If an
element <span class="code">x</span> satisfies the given predicate <span class="code">p</span>&mdash;<i>i.e.</i>, <span class="code">p(x)</span> is
<span class="code">true</span>&mdash;it is added with the builder.  Finally, the elements
collected in the builder are returned as an instance of the <span class="code">Repr</span>
collection type by calling the builder's <span class="code">result</span> method.</p>

<p>The <span class="code">map</span> operation on collections is a bit more complicated. For
instance, if <span class="code">f</span> is a function from <span class="code">String</span> to <span class="code">Int</span>, and <span class="code">xs</span> is
a <span class="code">List[String]</span>, then <span class="code">xs</span>&nbsp;<span class="code">map</span>&nbsp;<span class="code">f</span> should give a
<span class="code">List[Int]</span>. Likewise, if <span class="code">ys</span> is an <span class="code">Array[String]</span>, then 
<span class="code">ys</span>&nbsp;<span class="code">map</span>&nbsp;<span class="code">f</span> should give a <span class="code">Array[Int]</span>. But how do you achieve that
without duplicating the definition of the <span class="code">map</span> method in lists and
arrays?</p>

<p>The <span class="code">newBuilder</span>/<span class="code">foreach</span> framework shown in
<a href="the-architecture-of-scala-collections.html#lst-TraversableLike">Listing 25.2</a> is not sufficient for this
because it only allows creation of new instances of the same collection
<span style="font-style:italic">type</span>, whereas <span class="code">map</span> needs an instance of the same collection
<span style="font-style:italic">type constructor</span> but possibly with a different element type. What's more, even the result type constructor of a function like
<span class="code">map</span> might depend, in non-trivial ways, on the other argument
types. Here is an example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;collection.immutable.BitSet
  <code class="output">import&nbsp;collection.immutable.BitSet</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bits&nbsp;=&nbsp;<code class="typename">BitSet</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">bits:&nbsp;scala.collection.immutable.BitSet&nbsp;=&nbsp;BitSet(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;bits&nbsp;map&nbsp;(_&nbsp;*&nbsp;<code class="literal">2</code>)
  <code class="output">res13:&nbsp;scala.collection.immutable.BitSet&nbsp;=&nbsp;BitSet(2,&nbsp;4,&nbsp;6)</code>
  <br />  scala&gt;&nbsp;bits&nbsp;map&nbsp;(_.toFloat)
  <code class="output">res14:&nbsp;scala.collection.immutable.Set[Float]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;Set(1.0,&nbsp;2.0,&nbsp;3.0)</code>
</pre>


<p>If you <span class="code">map</span> the doubling function <span class="code">_</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">2</span> over a bit set you 
obtain another bit set. However, if you map the function <span class="code">(_.toFloat)</span>
over the same bit set, the result is a general <span class="code">Set[Float]</span>. Of course, 
it can't be a bit set because bit sets contain <span class="code">Int</span>s, not <span class="code">Float</span>s.</p>

<p>Note that <span class="code">map</span>'s result type depends on the type of function that's
passed to it. If the result type of that function argument is again an <span class="code">Int</span>, 
the result of <span class="code">map</span> is a <span class="code">BitSet</span>. But if the result type of the function argument
is something else, the result of <span class="code">map</span> is just a <span class="code">Set</span>. 
You'll find out soon how this type-flexibility is achieved in Scala.</p>

<p>The problem with <span class="code">BitSet</span> is not an isolated case. Here are two more 
interactions with the interpreter that both map a function over a map:</p>

<pre>
  scala&gt;&nbsp;<code class="typename">Map</code>(<code class="quotedstring">"a"</code>&nbsp;-&gt;&nbsp;<code class="literal">1</code>,&nbsp;<code class="quotedstring">"b"</code>&nbsp;-&gt;&nbsp;<code class="literal">2</code>)&nbsp;map&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;(x,&nbsp;y)&nbsp;=&gt;&nbsp;(y,&nbsp;x)&nbsp;}
  <code class="output">res3:&nbsp;scala.collection.immutable.Map[Int,java.lang.String]&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;Map(1&nbsp;-&gt;&nbsp;a,&nbsp;2&nbsp;-&gt;&nbsp;b)</code>
  <br />  scala&gt;&nbsp;<code class="typename">Map</code>(<code class="quotedstring">"a"</code>&nbsp;-&gt;&nbsp;<code class="literal">1</code>,&nbsp;<code class="quotedstring">"b"</code>&nbsp;-&gt;&nbsp;<code class="literal">2</code>)&nbsp;map&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;(x,&nbsp;y)&nbsp;=&gt;&nbsp;y&nbsp;}
  <code class="output">res4:&nbsp;scala.collection.immutable.Iterable[Int]&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;List(1,&nbsp;2)</code>
</pre>


<p>The first function swaps two arguments of a key/value pair. The
result of mapping this function is again a map, but now going in the
other direction. In fact, the first expression yields the inverse of the
original map, provided it is invertible. The second function, however, 
maps the key/value pair to an integer, namely its value component.
In that case, we cannot form a <span class="code">Map</span> from the results, but we still can
form an <span class="code">Iterable</span>, a supertrait of <span class="code">Map</span>.</p>

<p>You might ask, Why not restrict <span class="code">map</span> so that it can always return
the same kind of collection? For instance, on bit sets <span class="code">map</span> could
accept only <span class="code">Int</span>-to-<span class="code">Int</span> functions and on maps it could only
accept pair-to-pair functions. Not only are such restrictions  
undesirable from an object-oriented modeling point of view, they are
illegal because they would violate the Liskov Substitution Principle:
A <span class="code">Map</span> <span style="font-style:italic">is</span> an <span class="code">Iterable</span>. So every operation that's legal on
an <span class="code">Iterable</span> must also be legal on a <span class="code">Map</span>.</p>

<p>Scala solves this problem instead with overloading: Not the simple form of
overloading inherited by Java (that would not be flexible enough), but
the more systematic form of overloading that's provided by implicit
parameters.</p>

<p><a id="lst-map"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;map[B,&nbsp;<code class="typename">That</code>](f:&nbsp;<code class="typename">Elem</code>&nbsp;=&gt;&nbsp;B)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">implicit</code>&nbsp;bf:&nbsp;<code class="typename">CanBuildFrom[Repr,&nbsp;B,&nbsp;That]</code>):&nbsp;<code class="typename">That</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;b&nbsp;=&nbsp;bf(<code class="vem">this</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(x&nbsp;&lt;-&nbsp;<code class="vem">this</code>)&nbsp;b&nbsp;+=&nbsp;f(x)
  &nbsp;&nbsp;&nbsp;&nbsp;b.result
  &nbsp;&nbsp;}
</pre>


<h5>Listing 25.3 - Implementation of <span class="code">map</span> in <span class="code">TraversableLike</span>.</h5>


<p><a href="the-architecture-of-scala-collections.html#lst-map">Listing 25.3</a> shows trait <span class="code">TraversableLike</span>'s implementation of <span class="code">map</span>.
It's quite similar to the implementation of
<span class="code">filter</span> shown in <a href="the-architecture-of-scala-collections.html#lst-TraversableLike">Listing 25.2</a>. The principal
difference is that where <span class="code">filter</span> used the <span class="code">newBuilder</span> method, which is
abstract in class <span class="code">TraversableLike</span>, <span class="code">map</span> uses a <span style="font-style:italic">builder
factory</span> that's passed as an additional implicit parameter of type
<span class="code">CanBuildFrom</span>.</p>

<p><a id="lst-CanBuildFrom"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;scala.collection.generic
  <br />  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">CanBuildFrom[-From,&nbsp;-Elem,&nbsp;+To]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Creates&nbsp;a&nbsp;new&nbsp;builder&nbsp;</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(from:&nbsp;<code class="typename">From</code>):&nbsp;<code class="typename">Builder[Elem,&nbsp;To]</code>&nbsp;
  &nbsp;&nbsp;}
</pre>


<h5>Listing 25.4 - The <span class="code">CanBuildFrom</span> trait.</h5>


<p><a href="the-architecture-of-scala-collections.html#lst-CanBuildFrom">Listing 25.4</a> shows the definition of the trait
<span class="code">CanBuildFrom</span>,<a id="i815235414-1"/> which represents builder factories.  It
has three type parameters: <span class="code">Elem</span> indicates the element type of the
collection to be built, <span class="code">To</span> indicates the type of collection to
build, and <span class="code">From</span> indicates the type for which this builder factory
applies. By defining the right implicit definitions of builder
factories, you can tailor the right typing behavior as needed.</p>

<p>Take
class <span class="code">BitSet</span> as an example. Its companion object would contain
a builder factory of type <span class="code">CanBuildFrom[BitSet,</span>&nbsp;<span class="code">Int,</span>&nbsp;<span class="code">BitSet]</span>. 
This means that when operating on a <span class="code">BitSet</span> you can
construct another <span class="code">BitSet</span>, provided the type of the collection to
build is <span class="code">Int</span>. If this is not the case, you can always fall back to
a different implicit builder factory, this time implemented in
<span class="code">mutable.Set</span>'s companion object. The type of this more general builder
factory, where <span class="code">A</span> is a generic type parameter, is:</p>

<pre>
  <code class="typename">CanBuildFrom[Set[_],&nbsp;A,&nbsp;Set[A]]</code>
</pre>


<p>This means that when operating
on an arbitrary <span class="code">Set</span>, expressed by the wildcard type
<span class="code">Set[_]</span>, you can build a <span class="code">Set</span> again no matter what the
element type <span class="code">A</span> is. Given these two implicit instances of 
<span class="code">CanBuildFrom</span>, you can then rely on Scala's rules for implicit resolution
to pick the one that's appropriate and maximally specific.</p>

<p>So implicit resolution<a id="i1108480455-1"/> provides the correct static types for tricky
collection operations, such as <span class="code">map</span>. But what about the dynamic
types? Specifically, say you have a list value that has <span class="code">Iterable</span> as its
static type, and you map some function over that value:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;xs:&nbsp;<code class="typename">Iterable[Int]</code>&nbsp;=&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">xs:&nbsp;Iterable[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;ys&nbsp;=&nbsp;xs&nbsp;map&nbsp;(x&nbsp;=&gt;&nbsp;x&nbsp;*&nbsp;x)
  <code class="output">ys:&nbsp;Iterable[Int]&nbsp;=&nbsp;List(1,&nbsp;4,&nbsp;9)</code>
</pre>


<p>The static type of <span class="code">ys</span> above is <span class="code">Iterable</span>, as expected. But its
dynamic type is (and should be) still <span class="code">List</span>! This behavior is
achieved by one more indirection. The <span class="code">apply</span> method in
<span class="code">CanBuildFrom</span> is passed the source collection as argument. Most
builder factories for generic traversables (in fact all except 
builder factories for leaf classes) forward the call to a 
method <span class="code">genericBuilder</span> of a collection.
The <span class="code">genericBuilder</span> method in turn calls the builder
that belongs to the collection in which it is defined. So Scala uses
static implicit resolution to resolve constraints on the types of
<span class="code">map</span>, and virtual dispatch to pick the best dynamic type that
corresponds to these constraints.</p>

<h3 id="sec-integrating">25.3 Integrating new collections</h3>


<p>What needs to be done if you want to integrate a new collection
class, so that it can profit from all predefined operations at the
right types? In this section we'll show you two examples
that do this.</p>

<h4>Integrating sequences</h4>


<p>Say you want to create a new sequence type for RNA strands,
which are sequences of bases A (adenine), T (thymine), G (guanine),
and U (uracil).  The definitions for bases are easily set up as shown
in <a href="the-architecture-of-scala-collections.html#lst-bases">Listing 25.5</a>.</p>

<p>Every base is defined as a case object that inherits from a common
abstract class <span class="code">Base</span>.  The <span class="code">Base</span> class has a companion object
that defines two functions that map between bases and the integers 0
to 3. You can see in the examples two different ways to use
collections to implement these functions.  The <span class="code">toInt</span> function is
implemented as a <span class="code">Map</span> from <span class="code">Base</span> values to integers.  The reverse
function, <span class="code">fromInt</span>, is implemented as an array. This makes use of the
fact that both maps and arrays <span style="font-style:italic">are</span> functions because they inherit from
the <span class="code">Function1</span> trait.</p>

<p>The next task is to define a class for strands of RNA. Conceptually, a
strand of RNA is simply a <span class="code">Seq[Base]</span>. However, RNA strands can get
quite long, so it makes sense to invest some work in a compact
representation. Because there are only four bases, a base can be
identified with two bits, and you can therefore store sixteen bases as two-bit values
in an integer. The idea, then, is to construct a specialized subclass
of <span class="code">Seq[Base]</span>, which uses this packed representation.</p>

<p><a href="the-architecture-of-scala-collections.html#lst-rna1">Listing 25.6</a> presents the first version of this class; it will be refined later. The class <span class="code">RNA1</span> has a constructor that
takes an array of <span class="code">Int</span>s as its first argument. This array contains the
packed RNA data, with sixteen bases in each element, except for the last
array element, which might be partially filled. The second
argument, <span class="code">length</span>, specifies the total number of bases on the array (and in the
sequence). Class <span class="code">RNA1</span> extends <span class="code">IndexedSeq[Base]</span>. Trait <span class="code">IndexedSeq</span>, which comes
from package <span class="code">scala.collection.immutable</span>, defines two abstract methods,
<span class="code">length</span> and <span class="code">apply</span>.</p>

<p><a id="lst-bases"/></p>

<pre>
  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Base</code>
  <code class="vem">case</code>&nbsp;<code class="vem">object</code>&nbsp;A&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Base</code>
  <code class="vem">case</code>&nbsp;<code class="vem">object</code>&nbsp;T&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Base</code>
  <code class="vem">case</code>&nbsp;<code class="vem">object</code>&nbsp;G&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Base</code>
  <code class="vem">case</code>&nbsp;<code class="vem">object</code>&nbsp;U&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Base</code>
  <br />  <code class="vem">object</code>&nbsp;<code class="typename">Base</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;fromInt:&nbsp;<code class="typename">Int</code>&nbsp;=&gt;&nbsp;<code class="typename">Base</code>&nbsp;=&nbsp;<code class="typename">Array</code>(A,&nbsp;T,&nbsp;G,&nbsp;U)
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;toInt:&nbsp;<code class="typename">Base</code>&nbsp;=&gt;&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;<code class="typename">Map</code>(A&nbsp;-&gt;&nbsp;<code class="literal">0</code>,&nbsp;T&nbsp;-&gt;&nbsp;<code class="literal">1</code>,&nbsp;G&nbsp;-&gt;&nbsp;<code class="literal">2</code>,&nbsp;U&nbsp;-&gt;&nbsp;<code class="literal">3</code>)
  }
</pre>


<h5>Listing 25.5 - RNA Bases.</h5>


<p>These need to be implemented in concrete subclasses.
Class <span class="code">RNA1</span> implements <span class="code">length</span> automatically by defining a
parametric field (described in <a href="composition-and-inheritance.html#sec-parametric-fields">Section 10.6</a>)
of the same name. It implements the indexing method <span class="code">apply</span>
with the code given in <a href="the-architecture-of-scala-collections.html#lst-rna1">Listing 25.6</a>. Essentially, <span class="code">apply</span>
first extracts an integer value from the <span class="code">groups</span> array, then extracts
the correct two-bit number from that integer using 
right shift (<span class="code">&gt;&gt;</span>) and mask (<span class="code">&amp;</span>). The private constants <span class="code">S</span>, <span class="code">N</span>, and <span class="code">M</span> come from the <span class="code">RNA1</span> companion object. <span class="code">S</span> specifies the size of each packet (<i>i.e.</i>, two); <span class="code">N</span> specifies the number of two-bit 
packets per integer; and <span class="code">M</span> is a bit mask that isolates the lowest <span class="code">S</span> bits in a word.</p>

<p>Note that the constructor of class <span class="code">RNA1</span> is <span class="code">private</span>. This means
that clients cannot create <span class="code">RNA1</span> sequences by calling <span class="code">new</span>, which
makes sense, because it hides the representation of <span class="code">RNA1</span> sequences
in terms of packed arrays from the user. If clients cannot see what
the representation details of <span class="code">RNA</span> sequences are, it becomes possible
to change these representation details at any point in the future
without affecting client code.</p>

<p>In other words, this design achieves a good
decoupling of the interface of RNA sequences and its implementation.
However, if constructing an RNA sequence with <span class="code">new</span> is impossible,
there must be some other way to create new RNA sequences, or else
the whole class would be rather useless. There are two
alternatives for RNA sequence creation, both provided by the
<span class="code">RNA1</span> companion object. The first way is method
<span class="code">fromSeq</span>, which converts a given sequence of bases (<i>i.e.</i>, a value of type <span class="code">Seq[Base]</span>) 
into an instance of class <span class="code">RNA1</span>. The <span class="code">fromSeq</span> method does this by packing 
all the bases contained in its argument sequence into an array, then 
calling <span class="code">RNA1</span>'s private constructor with that array and the length of the 
original sequence as arguments. This makes use of the fact that a private 
constructor of a class is visible in the class's companion object.</p>

<p><a id="lst-rna1"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;collection.IndexedSeqLike
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;collection.mutable.{<code class="typename">Builder</code>,&nbsp;<code class="typename">ArrayBuffer</code>}
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;collection.generic.CanBuildFrom
  <br />  &nbsp;&nbsp;<code class="vem">final</code>&nbsp;<code class="vem">class</code>&nbsp;RNA1&nbsp;<code class="vem">private</code>&nbsp;(<code class="vem">val</code>&nbsp;groups:&nbsp;<code class="typename">Array[Int]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;length:&nbsp;<code class="typename">Int</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">IndexedSeq[Base]</code>&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">import</code>&nbsp;RNA1._
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(idx:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Base</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(idx&nbsp;&lt;&nbsp;<code class="literal">0</code>&nbsp;||&nbsp;length&nbsp;&lt;=&nbsp;idx)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IndexOutOfBoundsException</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Base.fromInt(groups(idx&nbsp;/&nbsp;N)&nbsp;&gt;&gt;&nbsp;(idx&nbsp;<code class="texttt">%</code>&nbsp;N&nbsp;*&nbsp;S)&nbsp;&amp;&nbsp;M)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;RNA1&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Number&nbsp;of&nbsp;bits&nbsp;necessary&nbsp;to&nbsp;represent&nbsp;group</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;S&nbsp;=&nbsp;<code class="literal">2</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Number&nbsp;of&nbsp;groups&nbsp;that&nbsp;fit&nbsp;in&nbsp;an&nbsp;Int</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;N&nbsp;=&nbsp;<code class="literal">32</code>&nbsp;/&nbsp;S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Bitmask&nbsp;to&nbsp;isolate&nbsp;a&nbsp;group</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;M&nbsp;=&nbsp;(<code class="literal">1</code>&nbsp;&lt;&lt;&nbsp;S)&nbsp;-&nbsp;<code class="literal">1</code>&nbsp;
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;fromSeq(buf:&nbsp;<code class="typename">Seq[Base]</code>):&nbsp;RNA1&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;groups&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[Int]</code>((buf.length&nbsp;+&nbsp;N&nbsp;-&nbsp;<code class="literal">1</code>)&nbsp;/&nbsp;N)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;buf.length)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;groups(i&nbsp;/&nbsp;N)&nbsp;|=&nbsp;Base.toInt(buf(i))&nbsp;&lt;&lt;&nbsp;(i&nbsp;<code class="texttt">%</code>&nbsp;N&nbsp;*&nbsp;S)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;RNA1(groups,&nbsp;buf.length)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(bases:&nbsp;<code class="typename">Base</code>*)&nbsp;=&nbsp;fromSeq(bases)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 25.6 - RNA strands class, first version.</h5>


<p>The second way to create an <span class="code">RNA1</span> value is provided by the <span class="code">apply</span> method
in the <span class="code">RNA1</span> object. It takes a variable number of <span class="code">Base</span> arguments and simply
forwards them as a sequence to <span class="code">fromSeq</span>.</p>

<p>Here are the two creation schemes
in action:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;xs&nbsp;=&nbsp;<code class="typename">List</code>(A,&nbsp;G,&nbsp;T,&nbsp;A)
  <code class="output">xs:&nbsp;List[Product&nbsp;with&nbsp;Base]&nbsp;=&nbsp;List(A,&nbsp;G,&nbsp;T,&nbsp;A)</code>
  <br />  scala&gt;&nbsp;RNA1.fromSeq(xs)
  <code class="output">res1:&nbsp;RNA1&nbsp;=&nbsp;RNA1(A,&nbsp;G,&nbsp;T,&nbsp;A)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;rna1&nbsp;=&nbsp;RNA1(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)
  <code class="output">rna1:&nbsp;RNA1&nbsp;=&nbsp;RNA1(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)</code>
</pre>


<h5>Adapting the result type of <span class="code">RNA</span> methods</h5>


<p>Here are some more interactions with the <span class="code">RNA1</span> abstraction:</p>

<pre>
  scala&gt;&nbsp;rna1.length
  <code class="output">res2:&nbsp;Int&nbsp;=&nbsp;5</code>
  <br />  scala&gt;&nbsp;rna1.last
  <code class="output">res3:&nbsp;Base&nbsp;=&nbsp;T</code>
  <br />  scala&gt;&nbsp;rna1.take(<code class="literal">3</code>)
  <code class="output">res4:&nbsp;IndexedSeq[Base]&nbsp;=&nbsp;Vector(A,&nbsp;U,&nbsp;G)</code>
</pre>


<p>The first two results are as expected, but the last result of taking the first 
three elements of <span class="code">rna1</span> might not be. In fact, you see an <span class="code">IndexedSeq[Base]</span>
as static result type and a <span class="code">Vector</span> as the dynamic type of the result value.
You might have expected to see an <span class="code">RNA1</span> value instead. But this is not possible 
because all that was done in <a href="the-architecture-of-scala-collections.html#lst-rna1">Listing 25.6</a> was make <span class="code">RNA1</span> extend 
<span class="code">IndexedSeq</span>. Class <span class="code">IndexedSeq</span>, on the other hand, has a <span class="code">take</span> method that 
returns an <span class="code">IndexedSeq</span>, and that's implemented in terms of <span class="code">IndexedSeq</span>'s default
implementation, <span class="code">Vector</span>.<a id="i-793070469-1"/></p>

<p>Now that you understand why things are the way they are, the next
question should be what needs to be done to change them? One way to do this would be 
to override the <span class="code">take</span> method in class <span class="code">RNA1</span>, maybe like this:</p>

<pre>
  <code class="vem">def</code>&nbsp;take(count:&nbsp;<code class="typename">Int</code>):&nbsp;RNA1&nbsp;=&nbsp;RNA1.fromSeq(<code class="vem">super</code>.take(count))
</pre>


<p>This would do the job for <span class="code">take</span>. But what about <span class="code">drop</span>, or
<span class="code">filter</span>, or <span class="code">init</span>?  In fact there are over fifty methods on sequences
that return again a sequence. For consistency, all of these would have
to be overridden. This looks less and less like an attractive
option.</p>

<p>Fortunately, there is a much easier way to achieve the same effect.
The RNA class needs to inherit not only from <span class="code">IndexedSeq</span>, but also
from its implementation trait <span class="code">IndexedSeqLike</span>.
This is shown in <a href="the-architecture-of-scala-collections.html#lst-rna2">Listing 25.7</a>.
The new implementation differs from the previous one 
in only two aspects. First, class <span class="code">RNA2</span> now also extends from <span class="code">IndexedSeqLike[Base,</span>&nbsp;<span class="code">RNA2]</span>. The <span class="code">IndexedSeqLike</span> trait implements all concrete methods of <span class="code">IndexedSeq</span> 
in an extensible way.</p>

<p>For instance, the return type 
of methods like <span class="code">take</span>, <span class="code">drop</span>, <span class="code">filter</span> or <span class="code">init</span> is the second type parameter
passed to class <span class="code">IndexedSeqLike</span> (<i>i.e.</i>, <span class="code">RNA2</span> in  <a href="the-architecture-of-scala-collections.html#lst-rna2">Listing 25.7</a>). To do this, <span class="code">IndexedSeqLike</span> bases itself on the
<span class="code">newBuilder</span> abstraction, which creates a builder of the right
kind. Subclasses of trait <span class="code">IndexedSeqLike</span> have to override <span class="code">newBuilder</span>
to return collections of their own kind. In class <span class="code">RNA2</span>, the <span class="code">newBuilder</span> method returns a builder of type
<span class="code">Builder[Base,</span>&nbsp;<span class="code">RNA2]</span>. To construct this builder, it first creates an <span class="code">ArrayBuffer</span>, which itself is 
a <span class="code">Builder[Base,</span>&nbsp;<span class="code">ArrayBuffer]</span>. It then transforms the <span class="code">ArrayBuffer</span>  builder
by calling its <span class="code">mapResult</span> method to an <span class="code">RNA2</span> builder. The <span class="code">mapResult</span> method expects
a transformation function from <span class="code">ArrayBuffer</span> to <span class="code">RNA2</span> as its parameter.
The function given is simply <span class="code">RNA2.fromSeq</span>, which converts an arbitrary
base sequence to an <span class="code">RNA2</span> value (recall that an array buffer is a kind of sequence, so
<span class="code">RNA2.fromSeq</span> can be applied to it).</p>

<p><a id="lst-rna2"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">final</code>&nbsp;<code class="vem">class</code>&nbsp;RNA2&nbsp;<code class="vem">private</code>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;groups:&nbsp;<code class="typename">Array[Int]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;length:&nbsp;<code class="typename">Int</code>
  &nbsp;&nbsp;)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">IndexedSeq[Base]</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">IndexedSeqLike[Base,&nbsp;RNA2]</code>&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">import</code>&nbsp;RNA2._
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;newBuilder:&nbsp;<code class="typename">Builder[Base,&nbsp;RNA2]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrayBuffer[Base]</code>&nbsp;mapResult&nbsp;fromSeq
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(idx:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Base</code>&nbsp;=&nbsp;<code class="comment">//&nbsp;as&nbsp;before</code>
  &nbsp;&nbsp;}
</pre>


<h5>Listing 25.7 - RNA strands class, second version.</h5>


<p>If you had left out the <span class="code">newBuilder</span> definition, you would have gotten an error message 
like the following:</p>

<pre>
  RNA2.scala:5: error: overriding method newBuilder in trait
  TraversableLike of type =&gt; scala.collection.mutable.Builder[Base,RNA2];
   method newBuilder in trait GenericTraversableTemplate of type
   =&gt; scala.collection.mutable.Builder[Base,IndexedSeq[Base]] has
   incompatible type
  class RNA2 private (val groups: Array[Int], val length: Int) 
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
  one error found
</pre>


<p>The error message is quite long and complicated, which reflects the intricate way the 
collection libraries are put together. It's best to ignore the information about where the
methods come from, because in this case it detracts more than it helps. What remains
is that a method <span class="code">newBuilder</span> with result type <span class="code">Builder[Base,</span>&nbsp;<span class="code">RNA2]</span> needed to be defined,
but a method <span class="code">newBuilder</span> with result type <span class="code">Builder[Base,IndexedSeq[Base]]</span> was found.
The latter does not override the former.</p>

<p>The first method, whose result type is <span class="code">Builder[Base,</span>&nbsp;<span class="code">RNA2]</span>,
is an abstract method that got instantiated at this type in <a href="the-architecture-of-scala-collections.html#lst-rna2">Listing 25.7</a> by passing the <span class="code">RNA2</span> type parameter
to <span class="code">IndexedSeqLike</span>. The second method, of result type <span class="code">Builder[Base,IndexedSeq[Base]]</span>, is what's
provided by the inherited <span class="code">IndexedSeq</span> class. In other words, the <span class="code">RNA2</span> class is 
invalid without a definition of <span class="code">newBuilder</span> with the first result type.</p>

<p>With the refined implementation of the RNA class in <a href="the-architecture-of-scala-collections.html#lst-rna2">Listing 25.7</a>, methods like <span class="code">take</span>, <span class="code">drop</span>, or <span class="code">filter</span> 
work now as expected:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;rna2&nbsp;=&nbsp;RNA2(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)
  <code class="output">rna2:&nbsp;RNA2&nbsp;=&nbsp;RNA2(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)</code>
  <br />  scala&gt;&nbsp;rna2&nbsp;take&nbsp;<code class="literal">3</code>
  <code class="output">res5:&nbsp;RNA2&nbsp;=&nbsp;RNA2(A,&nbsp;U,&nbsp;G)</code>
  <br />  scala&gt;&nbsp;rna2&nbsp;filter&nbsp;(U&nbsp;!=)
  <code class="output">res6:&nbsp;RNA2&nbsp;=&nbsp;RNA2(A,&nbsp;G,&nbsp;G,&nbsp;T)</code>
</pre>


<h5>Dealing with <span class="code">map</span> and friends</h5>


<p>There is another class of methods in collections that we haven't dealt with yet.  These methods do not always return the collection
type exactly. They might return the same kind of collection, but
with a different element type. The classical example of this is the
<span class="code">map</span> method.  If <span class="code">s</span> is a <span class="code">Seq[Int]</span>, and <span class="code">f</span> is a function from
<span class="code">Int</span> to <span class="code">String</span>, then <span class="code">s.map(f)</span> would return a
<span class="code">Seq[String]</span>. So the element type changes between the receiver and
the result, but the kind of collection stays the same.</p>

<p>There are a number of other methods that behave like <span class="code">map</span>. For some
of them you would expect this (<i>e.g.</i>, <span class="code">flatMap</span>, <span class="code">collect</span>), but for
others you might not.  For instance, the append method, <span class="code">++</span>, also might
return a result whose type differs from that of its arguments&mdash;appending a list of 
<span class="code">String</span> to a list of <span class="code">Int</span> would give a list of <span class="code">Any</span>. How should these
methods be adapted to RNA strands? Ideally we'd expect that mapping
bases to bases over an RNA strand would yield again an RNA strand:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;rna&nbsp;=&nbsp;RNA(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)
  <code class="output">rna:&nbsp;RNA&nbsp;=&nbsp;RNA(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)</code>
  <br />  scala&gt;&nbsp;rna&nbsp;map&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;A&nbsp;=&gt;&nbsp;T&nbsp;<code class="vem">case</code>&nbsp;b&nbsp;=&gt;&nbsp;b&nbsp;}
  <code class="output">res7:&nbsp;RNA&nbsp;=&nbsp;RNA(T,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)</code>
</pre>


<p>Likewise, appending two RNA strands with <span class="code">++</span> should yield again another RNA strand:</p>

<pre>
  scala&gt;&nbsp;rna&nbsp;++&nbsp;rna
  <code class="output">res8:&nbsp;RNA&nbsp;=&nbsp;RNA(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T,&nbsp;A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)</code>
</pre>


<p>On the other hand, mapping bases to some other type over an RNA strand
cannot yield another RNA strand because the new elements have the
wrong type. It has to yield a sequence instead. In the same vein
appending elements that are not of type <span class="code">Base</span> to an RNA strand can
yield a general sequence, but it cannot yield another RNA strand.</p>

<pre>
  scala&gt;&nbsp;rna&nbsp;map&nbsp;Base.toInt
  <code class="output">res2:&nbsp;IndexedSeq[Int]&nbsp;=&nbsp;Vector(0,&nbsp;3,&nbsp;2,&nbsp;2,&nbsp;1)</code>
  <br />  scala&gt;&nbsp;rna&nbsp;++&nbsp;<code class="typename">List</code>(<code class="quotedstring">"missing"</code>,&nbsp;<code class="quotedstring">"data"</code>)
  <code class="output">res3:&nbsp;IndexedSeq[java.lang.Object]&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;Vector(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T,&nbsp;missing,&nbsp;data)</code>
</pre>


<p>This is what you'd expect in the ideal case. But this is not what the
<span class="code">RNA2</span> class as given in <a href="the-architecture-of-scala-collections.html#lst-rna2">Listing 25.7</a> provides. In fact,
if you ran the first two examples above with instances of this class 
you would obtain:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;rna2&nbsp;=&nbsp;RNA2(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)
  <code class="output">rna2:&nbsp;RNA2&nbsp;=&nbsp;RNA2(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)</code>
  <br />  scala&gt;&nbsp;rna2&nbsp;map&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;A&nbsp;=&gt;&nbsp;T&nbsp;<code class="vem">case</code>&nbsp;b&nbsp;=&gt;&nbsp;b&nbsp;}
  <code class="output">res0:&nbsp;IndexedSeq[Base]&nbsp;=&nbsp;Vector(T,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)</code>
  <br />  scala&gt;&nbsp;rna2&nbsp;++&nbsp;rna2
  <code class="output">res1:&nbsp;IndexedSeq[Base]&nbsp;=&nbsp;Vector(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T,&nbsp;A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)</code>
</pre>


<p>So the result of <span class="code">map</span> and <span class="code">++</span> is never an RNA strand, even if the 
element type of the generated collection is a <span class="code">Base</span>.
To see how to do better, it pays to have a close look at the signature
of the <span class="code">map</span> method (or of <span class="code">++</span>, which has a similar signature).
The <span class="code">map</span> method is originally defined in class <span class="code">scala.collection.TraversableLike</span>
with the following signature:</p>

<pre>
  <code class="vem">def</code>&nbsp;map[B,&nbsp;<code class="typename">That</code>](f:&nbsp;<code class="typename">Elem</code>&nbsp;=&gt;&nbsp;B)
  &nbsp;&nbsp;(<code class="vem">implicit</code>&nbsp;cbf:&nbsp;<code class="typename">CanBuildFrom[Repr,&nbsp;B,&nbsp;That]</code>):&nbsp;<code class="typename">That</code>
</pre>


<p>Here <span class="code">Elem</span> is the type of elements of the collection, and <span class="code">Repr</span> is the
type of the collection itself; that is, the second type parameter that gets
passed to implementation classes such as <span class="code">TraversableLike</span> and 
<span class="code">IndexedSeqLike</span>. The <span class="code">map</span> method takes two more type parameters, <span class="code">B</span> and 
<span class="code">That</span>. The <span class="code">B</span> parameter stands for the result type of the mapping function,
which is also the element type of the new collection. The <span class="code">That</span>
appears as the result type of <span class="code">map</span>, so it represents the type of the new collection
that gets created.</p>

<p>How is the <span class="code">That</span> type determined? It is linked to the other types by an 
implicit parameter <span class="code">cbf</span>, of type <span class="code">CanBuildFrom[Repr,</span>&nbsp;<span class="code">B,</span>&nbsp;<span class="code">That]</span>.
These <span class="code">CanBuildFrom</span> implicits are defined by the individual collection classes. In essence, an implicit value of type <span class="code">CanBuildFrom[From,</span>&nbsp;<span class="code">Elem,</span>&nbsp;<span class="code">To]</span> says: "Here is a way, given a collection of type
<span class="code">From</span>, to build with elements of type <span class="code">Elem</span> a collection of type <span class="code">To</span>."</p>

<p><a id="lst-rna"/></p>

<pre>
  <code class="vem">final</code>&nbsp;<code class="vem">class</code>&nbsp;RNA&nbsp;<code class="vem">private</code>&nbsp;(<code class="vem">val</code>&nbsp;groups:&nbsp;<code class="typename">Array[Int]</code>,&nbsp;<code class="vem">val</code>&nbsp;length:&nbsp;<code class="typename">Int</code>)&nbsp;
  &nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">IndexedSeq[Base]</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">IndexedSeqLike[Base,&nbsp;RNA]</code>&nbsp;{
  <br />  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;RNA._
  <br />  &nbsp;&nbsp;<code class="comment">//&nbsp;Mandatory&nbsp;re-implementation&nbsp;of&nbsp;`newBuilder`&nbsp;in&nbsp;`IndexedSeq`</code>
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">protected</code>[<code class="vem">this</code>]&nbsp;<code class="vem">def</code>&nbsp;newBuilder:&nbsp;<code class="typename">Builder[Base,&nbsp;RNA]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;RNA.newBuilder
  <br />  &nbsp;&nbsp;<code class="comment">//&nbsp;Mandatory&nbsp;implementation&nbsp;of&nbsp;`apply`&nbsp;in&nbsp;`IndexedSeq`</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(idx:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Base</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(idx&nbsp;&lt;&nbsp;<code class="literal">0</code>&nbsp;||&nbsp;length&nbsp;&lt;=&nbsp;idx)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IndexOutOfBoundsException</code>
  &nbsp;&nbsp;&nbsp;&nbsp;Base.fromInt(groups(idx&nbsp;/&nbsp;N)&nbsp;&gt;&gt;&nbsp;(idx&nbsp;<code class="texttt">%</code>&nbsp;N&nbsp;*&nbsp;S)&nbsp;&amp;&nbsp;M)
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<code class="comment">//&nbsp;Optional&nbsp;re-implementation&nbsp;of&nbsp;foreach,&nbsp;</code>
  &nbsp;&nbsp;<code class="comment">//&nbsp;to&nbsp;make&nbsp;it&nbsp;more&nbsp;efficient.</code>
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;foreach[U](f:&nbsp;<code class="typename">Base</code>&nbsp;=&gt;&nbsp;U):&nbsp;<code class="typename">Unit</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;i&nbsp;=&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;b&nbsp;=&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">while</code>&nbsp;(i&nbsp;&lt;&nbsp;length)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;<code class="vem">if</code>&nbsp;(i&nbsp;<code class="texttt">%</code>&nbsp;N&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;groups(i&nbsp;/&nbsp;N)&nbsp;<code class="vem">else</code>&nbsp;b&nbsp;&gt;&gt;&gt;&nbsp;S
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f(Base.fromInt(b&nbsp;&amp;&nbsp;M))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;+=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  }
</pre>


<h5>Listing 25.8 - RNA strands class, final version.</h5>


<p>Now the behavior of <span class="code">map</span> and <span class="code">++</span> on <span class="code">RNA2</span> sequences becomes
clearer.  There is no <span class="code">CanBuildFrom</span> instance that creates <span class="code">RNA2</span>
sequences, so the next best available <span class="code">CanBuildFrom</span> was found in the
companion object of the inherited trait <span class="code">IndexedSeq</span>. That implicit creates <span class="code">IndexedSeq</span>s, 
and that's what you saw when applying <span class="code">map</span> to <span class="code">rna2</span>.</p>

<p>To address this shortcoming, you need to define an implicit instance of
<span class="code">CanBuildFrom</span> in the companion object of the RNA class.
That instance should have type <span class="code">CanBuildFrom[RNA,</span>&nbsp;<span class="code">Base,</span>&nbsp;<span class="code">RNA]</span>.
Hence, this instance states that, given an RNA strand and a new
element type <span class="code">Base</span>, you can build another collection which is again an 
RNA strand. <a href="the-architecture-of-scala-collections.html#lst-rna">Listing 25.8</a> and <a href="the-architecture-of-scala-collections.html#lst-rna-obj">Listing 25.9</a> show the details.</p>

<p><a id="lst-rna-obj"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;RNA&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;S&nbsp;=&nbsp;<code class="literal">2</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;number&nbsp;of&nbsp;bits&nbsp;in&nbsp;group</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;M&nbsp;=&nbsp;(<code class="literal">1</code>&nbsp;&lt;&lt;&nbsp;S)&nbsp;-&nbsp;<code class="literal">1</code>&nbsp;<code class="comment">//&nbsp;bitmask&nbsp;to&nbsp;isolate&nbsp;a&nbsp;group</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;N&nbsp;=&nbsp;<code class="literal">32</code>&nbsp;/&nbsp;S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;number&nbsp;of&nbsp;groups&nbsp;in&nbsp;an&nbsp;Int</code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;fromSeq(buf:&nbsp;<code class="typename">Seq[Base]</code>):&nbsp;RNA&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;groups&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[Int]</code>((buf.length&nbsp;+&nbsp;N&nbsp;-&nbsp;<code class="literal">1</code>)&nbsp;/&nbsp;N)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;buf.length)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;groups(i&nbsp;/&nbsp;N)&nbsp;|=&nbsp;Base.toInt(buf(i))&nbsp;&lt;&lt;&nbsp;(i&nbsp;<code class="texttt">%</code>&nbsp;N&nbsp;*&nbsp;S)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;RNA(groups,&nbsp;buf.length)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(bases:&nbsp;<code class="typename">Base</code>*)&nbsp;=&nbsp;fromSeq(bases)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;newBuilder:&nbsp;<code class="typename">Builder[Base,&nbsp;RNA]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrayBuffer</code>&nbsp;mapResult&nbsp;fromSeq
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;canBuildFrom:&nbsp;<code class="typename">CanBuildFrom[RNA,&nbsp;Base,&nbsp;RNA]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">CanBuildFrom[RNA,&nbsp;Base,&nbsp;RNA]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply():&nbsp;<code class="typename">Builder[Base,&nbsp;RNA]</code>&nbsp;=&nbsp;newBuilder
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(from:&nbsp;RNA):&nbsp;<code class="typename">Builder[Base,&nbsp;RNA]</code>&nbsp;=&nbsp;newBuilder
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 25.9 - RNA companion object&mdash;final version.</h5>


<p>Compared to
class <span class="code">RNA2</span> there are two important differences. First, the <span class="code">newBuilder</span>
implementation has moved from the RNA class to its companion
object. The <span class="code">newBuilder</span> method in class <span class="code">RNA</span> simply forwards to
this definition. Second, there is now an implicit <span class="code">CanBuildFrom</span>
value in object <span class="code">RNA</span>. To create such an object you need to define
two <span class="code">apply</span> methods in the <span class="code">CanBuildFrom</span> trait.  Both create
a new builder for an <span class="code">RNA</span> collection, but they differ in their
argument list. The <span class="code">apply()</span> method simply creates a new builder
of the right type. By contrast, the <span class="code">apply(from)</span> method 
takes the original collection as argument.  This can be
useful to adapt the dynamic type of builder's return type to be the
same as the dynamic type of the receiver. In the case of <span class="code">RNA</span> this 
does not come into play because <span class="code">RNA</span> is a final class, so any receiver
of static type <span class="code">RNA</span> also has <span class="code">RNA</span> as its dynamic type. That's why
<span class="code">apply(from)</span> also simply calls <span class="code">newBuilder</span>, ignoring its argument.</p>

<p>That is it. The <span class="code">RNA</span> class in <a href="the-architecture-of-scala-collections.html#lst-rna">Listing 25.8</a> implements
all collection methods at their natural types. Its implementation
requires a little bit of protocol. In essence, you need to know where
to put the <span class="code">newBuilder</span> factories and the <span class="code">canBuildFrom</span> implicits.
On the plus side, with relatively little code you get a large number
of methods automatically defined. Also, if you don't intend to do bulk
operations like <span class="code">take</span>, <span class="code">drop</span>, <span class="code">map</span>, or <span class="code">++</span> on your collection,
you can choose to not go the extra length and stop at the
implementation shown in <a href="the-architecture-of-scala-collections.html#lst-rna1">Listing 25.6</a>.</p>

<p>The discussion so far centered on the minimal amount of definitions
needed to define new sequences with methods that obey certain types.
But in practice you might also want to add new functionality to your
sequences or override existing methods for better efficiency.  An
example of this is the overridden <span class="code">foreach</span> method in class <span class="code">RNA</span>.<a id="i342746476-1"/>
<span class="code">foreach</span> is an important method in its own right because it
implements loops over collections. Furthermore, many other collection
methods are implemented in terms of <span class="code">foreach</span>. So it makes sense to 
invest some effort optimizing the method's implementation.</p>

<p>The standard
implementation of <span class="code">foreach</span> in <span class="code">IndexedSeq</span> will simply select every
<span class="code">i</span>'th element of the collection using <span class="code">apply</span>, where <span class="code">i</span> ranges
from <span class="code">0</span> to the collection's length minus one. So this standard
implementation selects an array element and unpacks a base from it once
for every element in an RNA strand. The overriding <span class="code">foreach</span> in class
<span class="code">RNA</span> is smarter than that. For every selected array element it
immediately applies the given function to all bases contained in
it.  So the effort for array selection and bit unpacking is much reduced.</p>

<h4>Integrating new sets and maps</h4>


<p>As a second example you'll learn how to integrate a new kind of map
into the collection framework. The idea is to implement a mutable map
with <span class="code">String</span> as the type of keys by a "Patricia trie".<a href="the-architecture-of-scala-collections.html#footnotemain25-2">[2]</a> The term <span style="font-style:italic">Patricia</span> is an abbreviation<a id="i732713786-1"/>
for "Practical Algorithm to Retrieve Information Coded in
Alphanumeric." The idea is to store a set or a map as a tree where
subsequent characters in a search key determines uniquely a descendant
tree.</p>

<p>For instance, a Patricia trie storing the five strings, "<span class="code">abc</span>",
"<span class="code">abd</span>", "<span class="code">al</span>", "<span class="code">all</span>", "<span class="code">xy</span>", would look like the tree given in
<a href="the-architecture-of-scala-collections.html#fig-patrica">Figure 25.1</a>.  To find the node corresponding to the
string "abc" in this trie, simply follow the subtree labeled "<span class="code">a</span>",
proceed from there to the subtree labeled "<span class="code">b</span>" to finally reach its
subtree labeled "<span class="code">c</span>".  If the Patricia trie is used as a map, the
value that's associated with a key is stored in the nodes that can be
reached by the key. If it is a set, you simply store a marker saying
that the node is present in the set.</p>

<p><a id="lst-prefixmap"/></p>

<pre>
  <code class="vem">import</code>&nbsp;collection._
  <br />  <code class="vem">class</code>&nbsp;<code class="typename">PrefixMap[T]</code>
  <code class="vem">extends</code>&nbsp;<code class="typename">mutable.Map[String,&nbsp;T]</code>&nbsp;
  &nbsp;&nbsp;&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">mutable.MapLike[String,&nbsp;T,&nbsp;PrefixMap[T]]</code>&nbsp;{
  <br />  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;suffixes:&nbsp;<code class="typename">immutable.Map[Char,&nbsp;PrefixMap[T]]</code>&nbsp;=&nbsp;Map.empty
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;value:&nbsp;<code class="typename">Option[T]</code>&nbsp;=&nbsp;<code class="typename">None</code>
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;get(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Option[T]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(s.isEmpty)&nbsp;value
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;suffixes&nbsp;get&nbsp;(s(<code class="literal">0</code>))&nbsp;flatMap&nbsp;(_.get(s&nbsp;substring&nbsp;<code class="literal">1</code>))
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;withPrefix(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">PrefixMap[T]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(s.isEmpty)&nbsp;<code class="vem">this</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;leading&nbsp;=&nbsp;s(<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;suffixes&nbsp;get&nbsp;leading&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">None</code>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;suffixes&nbsp;=&nbsp;suffixes&nbsp;+&nbsp;(leading&nbsp;-&gt;&nbsp;empty)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;suffixes(leading)&nbsp;withPrefix&nbsp;(s&nbsp;substring&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;update(s:&nbsp;<code class="typename">String</code>,&nbsp;elem:&nbsp;T)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;withPrefix(s).value&nbsp;=&nbsp;<code class="typename">Some</code>(elem)
  <br />  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;remove(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Option[T]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(s.isEmpty)&nbsp;{&nbsp;<code class="vem">val</code>&nbsp;prev&nbsp;=&nbsp;value;&nbsp;value&nbsp;=&nbsp;<code class="typename">None</code>;&nbsp;prev&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;suffixes&nbsp;get&nbsp;(s(<code class="literal">0</code>))&nbsp;flatMap&nbsp;(_.remove(s&nbsp;substring&nbsp;<code class="literal">1</code>))
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;iterator:&nbsp;<code class="typename">Iterator[(String,&nbsp;T)]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">for</code>&nbsp;(v&nbsp;&lt;-&nbsp;value.iterator)&nbsp;<code class="vem">yield</code>&nbsp;(<code class="quotedstring">""</code>,&nbsp;v))&nbsp;++
  &nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">for</code>&nbsp;((chr,&nbsp;m)&nbsp;&lt;-&nbsp;suffixes.iterator;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(s,&nbsp;v)&nbsp;&lt;-&nbsp;m.iterator)&nbsp;<code class="vem">yield</code>&nbsp;(chr&nbsp;+:&nbsp;s,&nbsp;v))
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;+=&nbsp;(kv:&nbsp;(<code class="typename">String</code>,&nbsp;T)):&nbsp;<code class="vem">this</code>.type&nbsp;=&nbsp;{&nbsp;update(kv._1,&nbsp;kv._2);&nbsp;<code class="vem">this</code>&nbsp;}
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;-=&nbsp;(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="vem">this</code>.type&nbsp;&nbsp;=&nbsp;{&nbsp;remove(s);&nbsp;<code class="vem">this</code>&nbsp;}
  <br />  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;empty&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PrefixMap[T]</code>
  }
</pre>


<h5>Listing 25.10 - An implementation of prefix maps with Patricia tries.</h5>


<div class="figure"><a id="fig-patrica"/>


<p><img src="images/patricia160.png" alt="image images/patricia160.png"/></p>

</div>
<h5> Figure 25.1 - An example Patricia trie.</h5>


<p>Patricia tries support very efficient lookups and updates.
Another nice feature is that they support selecting a subcollection by
giving a prefix. For instance, in the tree in <a href="the-architecture-of-scala-collections.html#fig-patrica">Figure 25.1</a>
you can obtain the sub-collection of all keys that start with an "<span class="code">a</span>"
simply by following the "<span class="code">a</span>" link from the root of the tree.</p>

<p>Based on these ideas we will now walk you through the implementation
of a map that's implemented as a Patricia trie. We call the map a
<span class="code">PrefixMap</span>, which means that it provides a method <span class="code">withPrefix</span> that
selects a submap of all keys starting with a given prefix.</p>

<p>We'll first 
define a prefix map with the keys shown in <a href="the-architecture-of-scala-collections.html#fig-patrica">Figure 25.1</a>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;m&nbsp;=&nbsp;<code class="typename">PrefixMap</code>(<code class="quotedstring">"abc"</code>&nbsp;-&gt;&nbsp;<code class="literal">0</code>,&nbsp;<code class="quotedstring">"abd"</code>&nbsp;-&gt;&nbsp;<code class="literal">1</code>,&nbsp;<code class="quotedstring">"al"</code>&nbsp;-&gt;&nbsp;<code class="literal">2</code>,&nbsp;
  &nbsp;&nbsp;<code class="quotedstring">"all"</code>&nbsp;-&gt;&nbsp;<code class="literal">3</code>,&nbsp;<code class="quotedstring">"xy"</code>&nbsp;-&gt;&nbsp;<code class="literal">4</code>)
  <code class="output">m:&nbsp;PrefixMap[Int]&nbsp;=&nbsp;Map((abc,0),&nbsp;(abd,1),&nbsp;(al,2),&nbsp;(all,3),</code>
  <code class="output">&nbsp;&nbsp;(xy,4))</code>
</pre>


<p>Then calling <span class="code">withPrefix</span> on <span class="code">m</span> will yield another prefix map:</p>

<pre>
  scala&gt;&nbsp;m&nbsp;withPrefix&nbsp;<code class="quotedstring">"a"</code>
  <code class="output">res14:&nbsp;PrefixMap[Int]&nbsp;=&nbsp;Map((bc,0),&nbsp;(bd,1),&nbsp;(l,2),&nbsp;(ll,3))</code>
</pre>


<p><a href="the-architecture-of-scala-collections.html#lst-prefixmap">Listing 25.10</a> shows the definition of 
<span class="code">PrefixMap</span>. This class is parameterized with the type of associated values <span class="code">T</span>, 
and extends <span class="code">mutable.Map[String,</span>&nbsp;<span class="code">T]</span> and <span class="code">mutable.MapLike[String,</span>&nbsp;<span class="code">T,</span>&nbsp;<span class="code">PrefixMap[T]]</span>.
You have seen this pattern already for sequences in the RNA strand example. Then
as now inheriting an implementation class such as <span class="code">MapLike</span> serves to
get the right result type for transformations such as <span class="code">filter</span>.</p>

<p>A prefix map node has two mutable fields: <span class="code">suffixes</span> and <span class="code">value</span>.
The <span class="code">value</span> field contains an optional value that's associated with
the node.  It is initialized to <span class="code">None</span>. The <span class="code">suffixes</span> field
contains a map from characters to <span class="code">PrefixMap</span> values. It is
initialized to the empty map. You might ask, Why did we pick an immutable map as the implementation
type for <span class="code">suffixes</span>? Would not a mutable map been more standard since <span class="code">PrefixMap</span> as a whole is also mutable? The answer is that
immutable maps that contain only a few elements are very efficient in
both space and execution time.</p>

<p>For instance, maps that contain fewer
than 5 elements are represented as a single object. By contrast, as
described in <a href="working-with-other-collections.html#sec-sets-and-maps">Section 17.2</a>, the
standard mutable map is a <span class="code">HashMap</span>, which typically occupies around
80 bytes, even if it is empty. So if small collections are common,
it's better to pick immutable over mutable. In the case of Patricia
tries, we'd expect that most nodes, except the ones at the very top of
the tree, would contain only a few successors. So storing these
successors in an immutable map is likely to be more efficient.</p>

<p>Now have a look at the first method that needs to be implemented
for a map: <span class="code">get</span>. The algorithm is as follows: To get the value
associated with the empty string in a prefix map, simply select the
optional <span class="code">value</span> stored in the root of the tree. Otherwise, if the
key string is not empty, try to select the submap corresponding to the
first character of the string. If that yields a map, follow up by
looking up the remainder of the key string after its first character in
that map. If the selection fails, the key is not stored in the map, so
return with <span class="code">None</span>. The combined selection over an option value is
elegantly expressed using <span class="code">flatMap</span>. When applied to an optional
value, <span class="code">ov</span>, and a closure, <span class="code">f</span>, which in turn returns an optional
value, <span class="code">ov</span>&nbsp;<span class="code">flatMap</span>&nbsp;<span class="code">f</span> will succeed if both <span class="code">ov</span> and <span class="code">f</span> return a
defined value. Otherwise <span class="code">ov</span>&nbsp;<span class="code">flatMap</span>&nbsp;<span class="code">f</span> will return <span class="code">None</span>.</p>

<p>The next two methods to implement for a mutable map are <span class="code">+=</span> and
<span class="code">-=</span>.  In the implementation of <a href="the-architecture-of-scala-collections.html#lst-prefixmap">Listing 25.10</a>, these are
defined in terms of two other methods: <span class="code">update</span> and <span class="code">remove</span>. The <span class="code">remove</span> method is very similar to <span class="code">get</span>, except that before
returning any associated value, the field containing that value is set
to <span class="code">None</span>. The <span class="code">update</span> method first calls <span class="code">withPrefix</span> to
navigate to the tree node that needs to be updated, then sets the
<span class="code">value</span> field of that node to the given value. The <span class="code">withPrefix</span>
method navigates through the tree, creating sub-maps as necessary if
some prefix of characters is not yet contained as a path in the tree.</p>

<p>The last abstract method to implement for a mutable map is
<span class="code">iterator</span>.<a id="i1062529325-1"/>  This method needs to produce an iterator that yields all
key/value pairs stored in the map. For any given prefix map this
iterator is composed of the following parts: First, if the map
contains a defined value, <span class="code">Some(x)</span>, in the <span class="code">value</span> field at its root,
then <span class="code">("",</span>&nbsp;<span class="code">x)</span> is the first element returned from the iterator.
Furthermore, the iterator needs to traverse the iterators of all submaps
stored in the <span class="code">suffixes</span> field, but it needs to add a character in front
of every key string returned by those iterators. More precisely, if 
<span class="code">m</span> is the submap reached from the root through a character <span class="code">chr</span>,
and <span class="code">(s,</span>&nbsp;<span class="code">v)</span> is an element returned from <span class="code">m.iterator</span>, then
the root's iterator will return <span class="code">(chr</span>&nbsp;<span class="code">+:</span>&nbsp;<span class="code">s,</span>&nbsp;<span class="code">v)</span> instead.</p>

<p>This logic 
is implemented quite concisely as a concatenation of two <span class="code">for</span> expressions
in the implementation of the <span class="code">iterator</span> method in <a href="the-architecture-of-scala-collections.html#lst-prefixmap">Listing 25.10</a>. 
The first <span class="code">for</span> expression iterates over <span class="code">value.iterator</span>. This makes
use of the fact that <span class="code">Option</span> values define an iterator method that returns
either no element, if the option value is <span class="code">None</span>,
or exactly one element <span class="code">x</span>, if the option value is <span class="code">Some(x)</span>.
<a id="lst-prefix-obj"/></p>

<pre>
  <code class="vem">import</code>&nbsp;scala.collection.mutable.{<code class="typename">Builder</code>,&nbsp;<code class="typename">MapBuilder</code>}
  <code class="vem">import</code>&nbsp;scala.collection.generic.CanBuildFrom
  <br />  <code class="vem">object</code>&nbsp;<code class="typename">PrefixMap</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;empty[T]&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PrefixMap[T]</code>
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply[T](kvs:&nbsp;(<code class="typename">String</code>,&nbsp;T)*):&nbsp;<code class="typename">PrefixMap[T]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;m:&nbsp;<code class="typename">PrefixMap[T]</code>&nbsp;=&nbsp;empty
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(kv&nbsp;&lt;-&nbsp;kvs)&nbsp;m&nbsp;+=&nbsp;kv
  &nbsp;&nbsp;&nbsp;&nbsp;m
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;newBuilder[T]:&nbsp;<code class="typename">Builder[(String,&nbsp;T),&nbsp;PrefixMap[T]]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">MapBuilder[String,&nbsp;T,&nbsp;PrefixMap[T]]</code>(empty)
  <br />  &nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;canBuildFrom[T]
  &nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<code class="typename">CanBuildFrom[PrefixMap[_],&nbsp;(String,&nbsp;T),&nbsp;PrefixMap[T]]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">CanBuildFrom[PrefixMap[_],&nbsp;(String,&nbsp;T),&nbsp;PrefixMap[T]]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(from:&nbsp;<code class="typename">PrefixMap[_]</code>)&nbsp;=&nbsp;newBuilder[T]
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply()&nbsp;=&nbsp;newBuilder[T]
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  }
</pre>


<h5>Listing 25.11 - The companion object for prefix maps.</h5>


<p>Note that there is no <span class="code">newBuilder</span> method defined in
<span class="code">PrefixMap</span>. There is no need because maps and sets come with
default builders, which are instances of class <span class="code">MapBuilder</span>. For a mutable map
the default builder starts with an empty map and then adds successive
elements using the map's <span class="code">+=</span> method. Mutable sets behave the
same. The default builders for immutable maps and sets use the non-destructive element addition method <span class="code">+</span>, instead of method <span class="code">+=</span>. However, in all these cases, to build the right kind of set or map, 
you need to start with an empty set or map of this kind. This is
provided by the <span class="code">empty</span> method, which is the last method defined in <span class="code">PrefixMap</span>. In
<a href="the-architecture-of-scala-collections.html#lst-prefixmap">Listing 25.10</a>, this method simply returns a fresh <span class="code">PrefixMap</span>.</p>

<p>We'll now turn to the companion object <span class="code">PrefixMap</span>, which is shown in
<a href="the-architecture-of-scala-collections.html#lst-prefix-obj">Listing 25.11</a>. In fact it is not strictly necessary to
define this companion object, as class <span class="code">PrefixMap</span> can stand well on
its own.  The main purpose of object <span class="code">PrefixMap</span> is to define some
convenience factory methods. It also defines a <span class="code">CanBuildFrom</span>
implicit to make typing work out better.</p>

<p>The two convenience methods are <span class="code">empty</span> and <span class="code">apply</span>. The same
methods are present for all other collections in Scala's collection
framework so it makes sense to define them here too.  With the two 
methods, you can write <span class="code">PrefixMap</span> literals like you do for any other
collection:</p>

<pre>
  scala&gt;&nbsp;<code class="typename">PrefixMap</code>(<code class="quotedstring">"hello"</code>&nbsp;-&gt;&nbsp;<code class="literal">5</code>,&nbsp;<code class="quotedstring">"hi"</code>&nbsp;-&gt;&nbsp;<code class="literal">2</code>)
  <code class="output">res0:&nbsp;PrefixMap[Int]&nbsp;=&nbsp;Map((hello,5),&nbsp;(hi,2))</code>
  <br />  scala&gt;&nbsp;PrefixMap.empty[<code class="typename">String</code>]
  <code class="output">res2:&nbsp;PrefixMap[String]&nbsp;=&nbsp;Map()</code>
</pre>


<p>The other member in object <span class="code">PrefixMap</span> is an implicit <span class="code">CanBuildFrom</span> instance.
It has the same purpose as the <span class="code">CanBuildFrom</span>
definition in the last section: to make methods like <span class="code">map</span> return the
best possible type. For instance, consider <span class="code">map</span>ping a function over the 
key/value pairs of a <span class="code">PrefixMap</span>. As long as that function produces
pairs of strings and some second type, the result collection will again
be a <span class="code">PrefixMap</span>. Here's an example:</p>

<pre>
  scala&gt;&nbsp;res0&nbsp;map&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;(k,&nbsp;v)&nbsp;=&gt;&nbsp;(k&nbsp;+&nbsp;<code class="quotedstring">"!"</code>,&nbsp;<code class="quotedstring">"x"</code>&nbsp;*&nbsp;v)&nbsp;}
  <code class="output">res8:&nbsp;PrefixMap[String]&nbsp;=&nbsp;Map((hello!,xxxxx),&nbsp;(hi!,xx))</code>
</pre>


<p>The given function argument takes the key/value bindings of the prefix
map <span class="code">res0</span> and produces pairs of strings. The result of
the <span class="code">map</span> is a <span class="code">PrefixMap</span>, this time with value type
<span class="code">String</span> instead of <span class="code">Int</span>. Without the <span class="code">canBuildFrom</span> implicit in
<span class="code">PrefixMap</span> the result would just have been a general mutable map,
not a prefix map.</p>

<h4>Summary</h4>


<p>If you want to fully integrate a new collection class into
the framework, you need to pay attention to the following points:</p>

<ol>


<li>Decide whether the collection should be mutable or immutable.


</li>
<li>Pick the right base traits for the collection.


</li>
<li>Inherit from the right implementation trait to implement most collection operations.


</li>
<li>If you want <span class="code">map</span> and similar operations to return instances of your collection
  type, provide an implicit <span class="code">CanBuildFrom</span> in your class's companion object.


</li></ol>


<h3>25.4 Conclusion</h3>


<p>You have now seen how Scala's collections are built and how you can
build new kinds of collections. Because of Scala's rich support for
abstraction, each new collection type can have a large number of
methods without having to reimplement them all over again.</p>

<hr/>
<h4>Footnotes for Chapter 25:</h4>


<p><a id="footnotemain25-1"/>[1] Ideally, everything should be defined
  in one place only, but there are a few exceptions where things needed
  to be redefined.</p>

<p><a id="footnotemain25-2"/>[2] Morrison, "PATRICIA&mdash;Practical Algorithm To Retrieve Information Coded in Alphanumeric"  <a href="bibliography.html#patricia">[Mor68]</a></p>

<div style="page-break-after:always"/>


<div style="page-break-after:always"/>

</body>
</html>
