<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8"/>
    <title>Programming in Scala, 3rd Edition</title>

    <link rel="stylesheet" type="text/css" href="book.css" />
  </head>
<body>
<h2><a id="chap-the-architecture-of-scala-collections">Chapter 25</a></h2>
<h1>The Architecture of Scala Collections</h1>


<p>This chapter describes the architecture of the Scala collections
framework in detail. Continuing the theme of <a href="collections-in-depth.html">Chapter 24</a>, you will find out more about
the internal workings of the framework. You will also learn how this
architecture helps you define your own collections in a few lines of
code, while reusing the overwhelming part of collection functionality
from the framework.<a id="i-512346344-1"/></p>

<p><a href="collections-in-depth.html">Chapter 24</a> enumerated a large number of
collection operations, which exist uniformly on many different
collection implementations.  Implementing every collection operation
anew for every collection type would lead to an enormous amount of code,
most of which would be copied from somewhere else. Such code
duplication could lead to inconsistencies over time, when an operation is
added or modified in one part of the collection library but not in
others. The principal design objective of the new collections
framework was to avoid any duplication, defining every operation in as
few places as possible.<a href="the-architecture-of-scala-collections.html#footnotemain25-1">[1]</a>  The design approach was to implement most
operations in collection "templates" that can be flexibly inherited
from individual base classes and implementations. In this chapter, we will examine these templates, and other classes and traits that constitute the "building blocks" 
of the framework, as well as the construction principles
they support.</p>

<h3>25.1 Builders</h3>


<p>Almost all collection operations are implemented in terms of <span style="font-style:italic">traversals</span> and
<span style="font-style:italic">builders</span>. Traversals are handled by <pre class="code">Traversable</pre>'s <pre class="code">foreach</pre> method,
and building new collections is handled by instances of class
<pre class="code">Builder</pre>. <a href="the-architecture-of-scala-collections.html#lst-builder">Listing 25.1</a> presents a slightly abbreviated outline 
of this class.</p>

<p><a id="lst-builder"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;scala.collection.generic
  <br />  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Builder[-Elem,&nbsp;+To]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;+=(elem:&nbsp;<code class="typename">Elem</code>):&nbsp;<code class="vem">this</code>.type
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;result():&nbsp;<code class="typename">To</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;clear()
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;mapResult[<code class="typename">NewTo</code>](f:&nbsp;<code class="typename">To</code>&nbsp;=&gt;&nbsp;<code class="typename">NewTo</code>):&nbsp;<code class="typename">Builder[Elem,&nbsp;NewTo]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;...
  &nbsp;&nbsp;}
</pre>


<h5>Listing 25.1 - An outline of the <pre class="code">Builder</pre> class.</h5>


<p>You can add an element <pre class="code">x</pre> to a builder <pre class="code">b</pre> with <pre class="code">b</pre>&nbsp;<pre class="code">+=</pre>&nbsp;<pre class="code">x</pre>. 
There's also syntax to add more than one element at once: For
instance, <pre class="code">b</pre>&nbsp;<pre class="code">+=</pre>&nbsp;<pre class="code">(x,</pre>&nbsp;<pre class="code">y)</pre> and <pre class="code">b</pre>&nbsp;<pre class="code">++=</pre>&nbsp;<pre class="code">xs</pre> work as for buffers. (In fact, 
buffers are an enriched version of builders.)
The <pre class="code">result()</pre> method returns a collection from a builder.
The state of the builder is undefined after taking its result, but it
can be reset into a new empty state using <pre class="code">clear()</pre>.
Builders are generic in both the element type, <pre class="code">Elem</pre>, and in the type, <pre class="code">To</pre>,
of collections they return.</p>

<p>Often, a builder can refer to some other builder for assembling the
elements of a collection, but then would like to transform the result
of the other builder&mdash;for example, to give it a different type. This task is
simplified by method <pre class="code">mapResult</pre> in class <pre class="code">Builder</pre>. Suppose for
instance you have an array buffer <pre class="code">buf</pre>. Array buffers are builders
for themselves, so taking the <pre class="code">result()</pre> of an array buffer will
return the same buffer. If you want to use this buffer to produce a
builder that builds arrays, you can use <pre class="code">mapResult</pre>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrayBuffer[Int]</code>
  <code class="output">buf:&nbsp;scala.collection.mutable.ArrayBuffer[Int]&nbsp;=&nbsp;ArrayBuffer()</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bldr&nbsp;=&nbsp;buf&nbsp;mapResult&nbsp;(_.toArray)
  <code class="output">bldr:&nbsp;scala.collection.mutable.Builder[Int,Array[Int]]</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;ArrayBuffer()</code>
</pre>


<p>The result value, <pre class="code">bldr</pre>, is a builder that uses the array buffer,
<pre class="code">buf</pre>, to collect elements. When a result is demanded from <pre class="code">bldr</pre>, the result of <pre class="code">buf</pre> 
is computed, which yields the array buffer <pre class="code">buf</pre> itself. This array buffer is then
mapped with <pre class="code">_.toArray</pre> to an array. So the end result is that 
<pre class="code">bldr</pre> is a builder for arrays.</p>

<h3 id="sec-factoring">25.2 Factoring out common operations</h3>


<p>The  main design objectives of the collection library redesign were to
have, at the same time, natural types and maximal sharing of implementation code. In
particular, Scala's collections follow the "same-result-type"
principle: Wherever possible, a transformation method on a collection
will yield a collection of the same type. For instance, the <pre class="code">filter</pre>
operation should yield, on every collection type, an instance of the
same collection type. Applying <pre class="code">filter</pre> on a <pre class="code">List</pre> should give a <pre class="code">List</pre>; 
applying it on a <pre class="code">Map</pre> should give a <pre class="code">Map</pre>; and so on.
In the rest of this section,
you will find out how this is achieved.</p>

<div class="pointofinterest">
<h3>The fast track</h3>


<p>The material in this section
is a bit more dense than usual and might require some time to absorb.
If you want to move ahead quickly, you could skip the remainder of
this section and move on to <a href="the-architecture-of-scala-collections.html#sec-integrating">Section 25.3</a>  <a href="the-architecture-of-scala-collections.html#sec-integrating">here</a> where you
will learn from concrete examples how to integrate your own collection
classes in the framework.</p>

</div>


<p>The Scala collection library avoids code duplication and achieves the
"same-result-type" principle by using generic builders and
traversals over collections in so-called <em>implementation traits</em>.<a id="i173047719-1"/><a id="i247652435-1"/> These
traits are named with a <pre class="code">Like</pre> suffix; for instance,
<pre class="code">IndexedSeqLike</pre> is the implementation trait for <pre class="code">IndexedSeq</pre>,<a id="i1408079579-1"/> and similarly,
<pre class="code">TraversableLike</pre> is the implementation trait for
<pre class="code">Traversable</pre>.<a id="i1464143996-1"/> Collection classes such as <pre class="code">Traversable</pre> or
<pre class="code">IndexedSeq</pre> inherit all their concrete method implementations from
these traits.  Implementation traits have two type parameters instead
of one for normal collections.  They parameterize not only over the
collection's element type, but also over the 
collection's <span style="font-style:italic">representation type</span> (<i>i.e.</i>,
the type of the underlying collection), such as <pre class="code">Seq[I]</pre> or <pre class="code">List[T]</pre>.</p>

<p>For instance, here is the header of trait
<pre class="code">TraversableLike</pre>:</p>

<pre>
  <code class="vem">trait</code>&nbsp;<code class="typename">TraversableLike[+Elem,&nbsp;+Repr]</code>&nbsp;{&nbsp;...&nbsp;}
</pre>


<p>The type parameter, <pre class="code">Elem</pre>, stands for the element type of the
traversable whereas the type parameter <pre class="code">Repr</pre> stands for its
representation. There are no constraints on <pre class="code">Repr</pre>. In particular
<pre class="code">Repr</pre> might be instantiated to a type that is itself not a subtype
of <pre class="code">Traversable</pre>. That way, classes outside the collections hierarchy,
such as <pre class="code">String</pre> and <pre class="code">Array</pre>, can still make use of all operations
defined in a collection implementation trait.</p>

<p><a id="lst-TraversableLike"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;scala.collection
  <br />  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">TraversableLike[+Elem,&nbsp;+Repr]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;newBuilder:&nbsp;<code class="typename">Builder[Elem,&nbsp;Repr]</code>&nbsp;<code class="comment">//&nbsp;deferred</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;foreach[U](f:&nbsp;<code class="typename">Elem</code>&nbsp;=&gt;&nbsp;U)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;deferred</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;filter(p:&nbsp;<code class="typename">Elem</code>&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>):&nbsp;<code class="typename">Repr</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;b&nbsp;=&nbsp;newBuilder
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;{&nbsp;elem&nbsp;=&gt;&nbsp;<code class="vem">if</code>&nbsp;(p(elem))&nbsp;b&nbsp;+=&nbsp;elem&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.result
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
  &nbsp;&nbsp;}
</pre>


<h5>Listing 25.2 - Implementation of <pre class="code">filter</pre> in <pre class="code">TraversableLike</pre>.</h5>


<p>Taking <pre class="code">filter</pre> as an example, this operation is defined once for all
collection classes in the trait <pre class="code">TraversableLike</pre>. An outline of the
relevant code is shown in <a href="the-architecture-of-scala-collections.html#lst-TraversableLike">Listing 25.2</a>. The
trait declares two abstract methods, <pre class="code">newBuilder</pre> and <pre class="code">foreach</pre>,
which are implemented in concrete collection classes. The <pre class="code">filter</pre>
operation is implemented in the same way for all collections using
these methods. It first constructs a new builder for the
representation type <pre class="code">Repr</pre>, using <pre class="code">newBuilder</pre>. It then traverses
all elements of the current collection, using <pre class="code">foreach</pre>. If an
element <pre class="code">x</pre> satisfies the given predicate <pre class="code">p</pre>&mdash;<i>i.e.</i>, <pre class="code">p(x)</pre> is
<pre class="code">true</pre>&mdash;it is added with the builder.  Finally, the elements
collected in the builder are returned as an instance of the <pre class="code">Repr</pre>
collection type by calling the builder's <pre class="code">result</pre> method.</p>

<p>The <pre class="code">map</pre> operation on collections is a bit more complicated. For
instance, if <pre class="code">f</pre> is a function from <pre class="code">String</pre> to <pre class="code">Int</pre>, and <pre class="code">xs</pre> is
a <pre class="code">List[String]</pre>, then <pre class="code">xs</pre>&nbsp;<pre class="code">map</pre>&nbsp;<pre class="code">f</pre> should give a
<pre class="code">List[Int]</pre>. Likewise, if <pre class="code">ys</pre> is an <pre class="code">Array[String]</pre>, then 
<pre class="code">ys</pre>&nbsp;<pre class="code">map</pre>&nbsp;<pre class="code">f</pre> should give a <pre class="code">Array[Int]</pre>. But how do you achieve that
without duplicating the definition of the <pre class="code">map</pre> method in lists and
arrays?</p>

<p>The <pre class="code">newBuilder</pre>/<pre class="code">foreach</pre> framework shown in
<a href="the-architecture-of-scala-collections.html#lst-TraversableLike">Listing 25.2</a> is not sufficient for this
because it only allows creation of new instances of the same collection
<span style="font-style:italic">type</span>, whereas <pre class="code">map</pre> needs an instance of the same collection
<span style="font-style:italic">type constructor</span> but possibly with a different element type. What's more, even the result type constructor of a function like
<pre class="code">map</pre> might depend, in non-trivial ways, on the other argument
types. Here is an example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;collection.immutable.BitSet
  <code class="output">import&nbsp;collection.immutable.BitSet</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bits&nbsp;=&nbsp;<code class="typename">BitSet</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">bits:&nbsp;scala.collection.immutable.BitSet&nbsp;=&nbsp;BitSet(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;bits&nbsp;map&nbsp;(_&nbsp;*&nbsp;<code class="literal">2</code>)
  <code class="output">res13:&nbsp;scala.collection.immutable.BitSet&nbsp;=&nbsp;BitSet(2,&nbsp;4,&nbsp;6)</code>
  <br />  scala&gt;&nbsp;bits&nbsp;map&nbsp;(_.toFloat)
  <code class="output">res14:&nbsp;scala.collection.immutable.Set[Float]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;Set(1.0,&nbsp;2.0,&nbsp;3.0)</code>
</pre>


<p>If you <pre class="code">map</pre> the doubling function <pre class="code">_</pre>&nbsp;<pre class="code">*</pre>&nbsp;<pre class="code">2</pre> over a bit set you 
obtain another bit set. However, if you map the function <pre class="code">(_.toFloat)</pre>
over the same bit set, the result is a general <pre class="code">Set[Float]</pre>. Of course, 
it can't be a bit set because bit sets contain <pre class="code">Int</pre>s, not <pre class="code">Float</pre>s.</p>

<p>Note that <pre class="code">map</pre>'s result type depends on the type of function that's
passed to it. If the result type of that function argument is again an <pre class="code">Int</pre>, 
the result of <pre class="code">map</pre> is a <pre class="code">BitSet</pre>. But if the result type of the function argument
is something else, the result of <pre class="code">map</pre> is just a <pre class="code">Set</pre>. 
You'll find out soon how this type-flexibility is achieved in Scala.</p>

<p>The problem with <pre class="code">BitSet</pre> is not an isolated case. Here are two more 
interactions with the interpreter that both map a function over a map:</p>

<pre>
  scala&gt;&nbsp;<code class="typename">Map</code>(<code class="quotedstring">"a"</code>&nbsp;-&gt;&nbsp;<code class="literal">1</code>,&nbsp;<code class="quotedstring">"b"</code>&nbsp;-&gt;&nbsp;<code class="literal">2</code>)&nbsp;map&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;(x,&nbsp;y)&nbsp;=&gt;&nbsp;(y,&nbsp;x)&nbsp;}
  <code class="output">res3:&nbsp;scala.collection.immutable.Map[Int,java.lang.String]&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;Map(1&nbsp;-&gt;&nbsp;a,&nbsp;2&nbsp;-&gt;&nbsp;b)</code>
  <br />  scala&gt;&nbsp;<code class="typename">Map</code>(<code class="quotedstring">"a"</code>&nbsp;-&gt;&nbsp;<code class="literal">1</code>,&nbsp;<code class="quotedstring">"b"</code>&nbsp;-&gt;&nbsp;<code class="literal">2</code>)&nbsp;map&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;(x,&nbsp;y)&nbsp;=&gt;&nbsp;y&nbsp;}
  <code class="output">res4:&nbsp;scala.collection.immutable.Iterable[Int]&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;List(1,&nbsp;2)</code>
</pre>


<p>The first function swaps two arguments of a key/value pair. The
result of mapping this function is again a map, but now going in the
other direction. In fact, the first expression yields the inverse of the
original map, provided it is invertible. The second function, however, 
maps the key/value pair to an integer, namely its value component.
In that case, we cannot form a <pre class="code">Map</pre> from the results, but we still can
form an <pre class="code">Iterable</pre>, a supertrait of <pre class="code">Map</pre>.</p>

<p>You might ask, Why not restrict <pre class="code">map</pre> so that it can always return
the same kind of collection? For instance, on bit sets <pre class="code">map</pre> could
accept only <pre class="code">Int</pre>-to-<pre class="code">Int</pre> functions and on maps it could only
accept pair-to-pair functions. Not only are such restrictions  
undesirable from an object-oriented modeling point of view, they are
illegal because they would violate the Liskov Substitution Principle:
A <pre class="code">Map</pre> <span style="font-style:italic">is</span> an <pre class="code">Iterable</pre>. So every operation that's legal on
an <pre class="code">Iterable</pre> must also be legal on a <pre class="code">Map</pre>.</p>

<p>Scala solves this problem instead with overloading: Not the simple form of
overloading inherited by Java (that would not be flexible enough), but
the more systematic form of overloading that's provided by implicit
parameters.</p>

<p><a id="lst-map"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;map[B,&nbsp;<code class="typename">That</code>](f:&nbsp;<code class="typename">Elem</code>&nbsp;=&gt;&nbsp;B)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">implicit</code>&nbsp;bf:&nbsp;<code class="typename">CanBuildFrom[Repr,&nbsp;B,&nbsp;That]</code>):&nbsp;<code class="typename">That</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;b&nbsp;=&nbsp;bf(<code class="vem">this</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(x&nbsp;&lt;-&nbsp;<code class="vem">this</code>)&nbsp;b&nbsp;+=&nbsp;f(x)
  &nbsp;&nbsp;&nbsp;&nbsp;b.result
  &nbsp;&nbsp;}
</pre>


<h5>Listing 25.3 - Implementation of <pre class="code">map</pre> in <pre class="code">TraversableLike</pre>.</h5>


<p><a href="the-architecture-of-scala-collections.html#lst-map">Listing 25.3</a> shows trait <pre class="code">TraversableLike</pre>'s implementation of <pre class="code">map</pre>.
It's quite similar to the implementation of
<pre class="code">filter</pre> shown in <a href="the-architecture-of-scala-collections.html#lst-TraversableLike">Listing 25.2</a>. The principal
difference is that where <pre class="code">filter</pre> used the <pre class="code">newBuilder</pre> method, which is
abstract in class <pre class="code">TraversableLike</pre>, <pre class="code">map</pre> uses a <span style="font-style:italic">builder
factory</span> that's passed as an additional implicit parameter of type
<pre class="code">CanBuildFrom</pre>.</p>

<p><a id="lst-CanBuildFrom"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;scala.collection.generic
  <br />  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">CanBuildFrom[-From,&nbsp;-Elem,&nbsp;+To]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Creates&nbsp;a&nbsp;new&nbsp;builder&nbsp;</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(from:&nbsp;<code class="typename">From</code>):&nbsp;<code class="typename">Builder[Elem,&nbsp;To]</code>&nbsp;
  &nbsp;&nbsp;}
</pre>


<h5>Listing 25.4 - The <pre class="code">CanBuildFrom</pre> trait.</h5>


<p><a href="the-architecture-of-scala-collections.html#lst-CanBuildFrom">Listing 25.4</a> shows the definition of the trait
<pre class="code">CanBuildFrom</pre>,<a id="i815235414-1"/> which represents builder factories.  It
has three type parameters: <pre class="code">Elem</pre> indicates the element type of the
collection to be built, <pre class="code">To</pre> indicates the type of collection to
build, and <pre class="code">From</pre> indicates the type for which this builder factory
applies. By defining the right implicit definitions of builder
factories, you can tailor the right typing behavior as needed.</p>

<p>Take
class <pre class="code">BitSet</pre> as an example. Its companion object would contain
a builder factory of type <pre class="code">CanBuildFrom[BitSet,</pre>&nbsp;<pre class="code">Int,</pre>&nbsp;<pre class="code">BitSet]</pre>. 
This means that when operating on a <pre class="code">BitSet</pre> you can
construct another <pre class="code">BitSet</pre>, provided the type of the collection to
build is <pre class="code">Int</pre>. If this is not the case, you can always fall back to
a different implicit builder factory, this time implemented in
<pre class="code">mutable.Set</pre>'s companion object. The type of this more general builder
factory, where <pre class="code">A</pre> is a generic type parameter, is:</p>

<pre>
  <code class="typename">CanBuildFrom[Set[_],&nbsp;A,&nbsp;Set[A]]</code>
</pre>


<p>This means that when operating
on an arbitrary <pre class="code">Set</pre>, expressed by the wildcard type
<pre class="code">Set[_]</pre>, you can build a <pre class="code">Set</pre> again no matter what the
element type <pre class="code">A</pre> is. Given these two implicit instances of 
<pre class="code">CanBuildFrom</pre>, you can then rely on Scala's rules for implicit resolution
to pick the one that's appropriate and maximally specific.</p>

<p>So implicit resolution<a id="i1108480455-1"/> provides the correct static types for tricky
collection operations, such as <pre class="code">map</pre>. But what about the dynamic
types? Specifically, say you have a list value that has <pre class="code">Iterable</pre> as its
static type, and you map some function over that value:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;xs:&nbsp;<code class="typename">Iterable[Int]</code>&nbsp;=&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">xs:&nbsp;Iterable[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;ys&nbsp;=&nbsp;xs&nbsp;map&nbsp;(x&nbsp;=&gt;&nbsp;x&nbsp;*&nbsp;x)
  <code class="output">ys:&nbsp;Iterable[Int]&nbsp;=&nbsp;List(1,&nbsp;4,&nbsp;9)</code>
</pre>


<p>The static type of <pre class="code">ys</pre> above is <pre class="code">Iterable</pre>, as expected. But its
dynamic type is (and should be) still <pre class="code">List</pre>! This behavior is
achieved by one more indirection. The <pre class="code">apply</pre> method in
<pre class="code">CanBuildFrom</pre> is passed the source collection as argument. Most
builder factories for generic traversables (in fact all except 
builder factories for leaf classes) forward the call to a 
method <pre class="code">genericBuilder</pre> of a collection.
The <pre class="code">genericBuilder</pre> method in turn calls the builder
that belongs to the collection in which it is defined. So Scala uses
static implicit resolution to resolve constraints on the types of
<pre class="code">map</pre>, and virtual dispatch to pick the best dynamic type that
corresponds to these constraints.</p>

<h3 id="sec-integrating">25.3 Integrating new collections</h3>


<p>What needs to be done if you want to integrate a new collection
class, so that it can profit from all predefined operations at the
right types? In this section we'll show you two examples
that do this.</p>

<h4>Integrating sequences</h4>


<p>Say you want to create a new sequence type for RNA strands,
which are sequences of bases A (adenine), T (thymine), G (guanine),
and U (uracil).  The definitions for bases are easily set up as shown
in <a href="the-architecture-of-scala-collections.html#lst-bases">Listing 25.5</a>.</p>

<p>Every base is defined as a case object that inherits from a common
abstract class <pre class="code">Base</pre>.  The <pre class="code">Base</pre> class has a companion object
that defines two functions that map between bases and the integers 0
to 3. You can see in the examples two different ways to use
collections to implement these functions.  The <pre class="code">toInt</pre> function is
implemented as a <pre class="code">Map</pre> from <pre class="code">Base</pre> values to integers.  The reverse
function, <pre class="code">fromInt</pre>, is implemented as an array. This makes use of the
fact that both maps and arrays <span style="font-style:italic">are</span> functions because they inherit from
the <pre class="code">Function1</pre> trait.</p>

<p>The next task is to define a class for strands of RNA. Conceptually, a
strand of RNA is simply a <pre class="code">Seq[Base]</pre>. However, RNA strands can get
quite long, so it makes sense to invest some work in a compact
representation. Because there are only four bases, a base can be
identified with two bits, and you can therefore store sixteen bases as two-bit values
in an integer. The idea, then, is to construct a specialized subclass
of <pre class="code">Seq[Base]</pre>, which uses this packed representation.</p>

<p><a href="the-architecture-of-scala-collections.html#lst-rna1">Listing 25.6</a> presents the first version of this class; it will be refined later. The class <pre class="code">RNA1</pre> has a constructor that
takes an array of <pre class="code">Int</pre>s as its first argument. This array contains the
packed RNA data, with sixteen bases in each element, except for the last
array element, which might be partially filled. The second
argument, <pre class="code">length</pre>, specifies the total number of bases on the array (and in the
sequence). Class <pre class="code">RNA1</pre> extends <pre class="code">IndexedSeq[Base]</pre>. Trait <pre class="code">IndexedSeq</pre>, which comes
from package <pre class="code">scala.collection.immutable</pre>, defines two abstract methods,
<pre class="code">length</pre> and <pre class="code">apply</pre>.</p>

<p><a id="lst-bases"/></p>

<pre>
  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Base</code>
  <code class="vem">case</code>&nbsp;<code class="vem">object</code>&nbsp;A&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Base</code>
  <code class="vem">case</code>&nbsp;<code class="vem">object</code>&nbsp;T&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Base</code>
  <code class="vem">case</code>&nbsp;<code class="vem">object</code>&nbsp;G&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Base</code>
  <code class="vem">case</code>&nbsp;<code class="vem">object</code>&nbsp;U&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Base</code>
  <br />  <code class="vem">object</code>&nbsp;<code class="typename">Base</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;fromInt:&nbsp;<code class="typename">Int</code>&nbsp;=&gt;&nbsp;<code class="typename">Base</code>&nbsp;=&nbsp;<code class="typename">Array</code>(A,&nbsp;T,&nbsp;G,&nbsp;U)
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;toInt:&nbsp;<code class="typename">Base</code>&nbsp;=&gt;&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;<code class="typename">Map</code>(A&nbsp;-&gt;&nbsp;<code class="literal">0</code>,&nbsp;T&nbsp;-&gt;&nbsp;<code class="literal">1</code>,&nbsp;G&nbsp;-&gt;&nbsp;<code class="literal">2</code>,&nbsp;U&nbsp;-&gt;&nbsp;<code class="literal">3</code>)
  }
</pre>


<h5>Listing 25.5 - RNA Bases.</h5>


<p>These need to be implemented in concrete subclasses.
Class <pre class="code">RNA1</pre> implements <pre class="code">length</pre> automatically by defining a
parametric field (described in <a href="composition-and-inheritance.html#sec-parametric-fields">Section 10.6</a>)
of the same name. It implements the indexing method <pre class="code">apply</pre>
with the code given in <a href="the-architecture-of-scala-collections.html#lst-rna1">Listing 25.6</a>. Essentially, <pre class="code">apply</pre>
first extracts an integer value from the <pre class="code">groups</pre> array, then extracts
the correct two-bit number from that integer using 
right shift (<pre class="code">&gt;&gt;</pre>) and mask (<pre class="code">&amp;</pre>). The private constants <pre class="code">S</pre>, <pre class="code">N</pre>, and <pre class="code">M</pre> come from the <pre class="code">RNA1</pre> companion object. <pre class="code">S</pre> specifies the size of each packet (<i>i.e.</i>, two); <pre class="code">N</pre> specifies the number of two-bit 
packets per integer; and <pre class="code">M</pre> is a bit mask that isolates the lowest <pre class="code">S</pre> bits in a word.</p>

<p>Note that the constructor of class <pre class="code">RNA1</pre> is <pre class="code">private</pre>. This means
that clients cannot create <pre class="code">RNA1</pre> sequences by calling <pre class="code">new</pre>, which
makes sense, because it hides the representation of <pre class="code">RNA1</pre> sequences
in terms of packed arrays from the user. If clients cannot see what
the representation details of <pre class="code">RNA</pre> sequences are, it becomes possible
to change these representation details at any point in the future
without affecting client code.</p>

<p>In other words, this design achieves a good
decoupling of the interface of RNA sequences and its implementation.
However, if constructing an RNA sequence with <pre class="code">new</pre> is impossible,
there must be some other way to create new RNA sequences, or else
the whole class would be rather useless. There are two
alternatives for RNA sequence creation, both provided by the
<pre class="code">RNA1</pre> companion object. The first way is method
<pre class="code">fromSeq</pre>, which converts a given sequence of bases (<i>i.e.</i>, a value of type <pre class="code">Seq[Base]</pre>) 
into an instance of class <pre class="code">RNA1</pre>. The <pre class="code">fromSeq</pre> method does this by packing 
all the bases contained in its argument sequence into an array, then 
calling <pre class="code">RNA1</pre>'s private constructor with that array and the length of the 
original sequence as arguments. This makes use of the fact that a private 
constructor of a class is visible in the class's companion object.</p>

<p><a id="lst-rna1"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;collection.IndexedSeqLike
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;collection.mutable.{<code class="typename">Builder</code>,&nbsp;<code class="typename">ArrayBuffer</code>}
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;collection.generic.CanBuildFrom
  <br />  &nbsp;&nbsp;<code class="vem">final</code>&nbsp;<code class="vem">class</code>&nbsp;RNA1&nbsp;<code class="vem">private</code>&nbsp;(<code class="vem">val</code>&nbsp;groups:&nbsp;<code class="typename">Array[Int]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;length:&nbsp;<code class="typename">Int</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">IndexedSeq[Base]</code>&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">import</code>&nbsp;RNA1._
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(idx:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Base</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(idx&nbsp;&lt;&nbsp;<code class="literal">0</code>&nbsp;||&nbsp;length&nbsp;&lt;=&nbsp;idx)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IndexOutOfBoundsException</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Base.fromInt(groups(idx&nbsp;/&nbsp;N)&nbsp;&gt;&gt;&nbsp;(idx&nbsp;<code class="texttt">%</code>&nbsp;N&nbsp;*&nbsp;S)&nbsp;&amp;&nbsp;M)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;RNA1&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Number&nbsp;of&nbsp;bits&nbsp;necessary&nbsp;to&nbsp;represent&nbsp;group</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;S&nbsp;=&nbsp;<code class="literal">2</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Number&nbsp;of&nbsp;groups&nbsp;that&nbsp;fit&nbsp;in&nbsp;an&nbsp;Int</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;N&nbsp;=&nbsp;<code class="literal">32</code>&nbsp;/&nbsp;S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Bitmask&nbsp;to&nbsp;isolate&nbsp;a&nbsp;group</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;M&nbsp;=&nbsp;(<code class="literal">1</code>&nbsp;&lt;&lt;&nbsp;S)&nbsp;-&nbsp;<code class="literal">1</code>&nbsp;
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;fromSeq(buf:&nbsp;<code class="typename">Seq[Base]</code>):&nbsp;RNA1&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;groups&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[Int]</code>((buf.length&nbsp;+&nbsp;N&nbsp;-&nbsp;<code class="literal">1</code>)&nbsp;/&nbsp;N)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;buf.length)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;groups(i&nbsp;/&nbsp;N)&nbsp;|=&nbsp;Base.toInt(buf(i))&nbsp;&lt;&lt;&nbsp;(i&nbsp;<code class="texttt">%</code>&nbsp;N&nbsp;*&nbsp;S)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;RNA1(groups,&nbsp;buf.length)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(bases:&nbsp;<code class="typename">Base</code>*)&nbsp;=&nbsp;fromSeq(bases)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 25.6 - RNA strands class, first version.</h5>


<p>The second way to create an <pre class="code">RNA1</pre> value is provided by the <pre class="code">apply</pre> method
in the <pre class="code">RNA1</pre> object. It takes a variable number of <pre class="code">Base</pre> arguments and simply
forwards them as a sequence to <pre class="code">fromSeq</pre>.</p>

<p>Here are the two creation schemes
in action:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;xs&nbsp;=&nbsp;<code class="typename">List</code>(A,&nbsp;G,&nbsp;T,&nbsp;A)
  <code class="output">xs:&nbsp;List[Product&nbsp;with&nbsp;Base]&nbsp;=&nbsp;List(A,&nbsp;G,&nbsp;T,&nbsp;A)</code>
  <br />  scala&gt;&nbsp;RNA1.fromSeq(xs)
  <code class="output">res1:&nbsp;RNA1&nbsp;=&nbsp;RNA1(A,&nbsp;G,&nbsp;T,&nbsp;A)</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;rna1&nbsp;=&nbsp;RNA1(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)
  <code class="output">rna1:&nbsp;RNA1&nbsp;=&nbsp;RNA1(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)</code>
</pre>


<h5>Adapting the result type of <pre class="code">RNA</pre> methods</h5>


<p>Here are some more interactions with the <pre class="code">RNA1</pre> abstraction:</p>

<pre>
  scala&gt;&nbsp;rna1.length
  <code class="output">res2:&nbsp;Int&nbsp;=&nbsp;5</code>
  <br />  scala&gt;&nbsp;rna1.last
  <code class="output">res3:&nbsp;Base&nbsp;=&nbsp;T</code>
  <br />  scala&gt;&nbsp;rna1.take(<code class="literal">3</code>)
  <code class="output">res4:&nbsp;IndexedSeq[Base]&nbsp;=&nbsp;Vector(A,&nbsp;U,&nbsp;G)</code>
</pre>


<p>The first two results are as expected, but the last result of taking the first 
three elements of <pre class="code">rna1</pre> might not be. In fact, you see an <pre class="code">IndexedSeq[Base]</pre>
as static result type and a <pre class="code">Vector</pre> as the dynamic type of the result value.
You might have expected to see an <pre class="code">RNA1</pre> value instead. But this is not possible 
because all that was done in <a href="the-architecture-of-scala-collections.html#lst-rna1">Listing 25.6</a> was make <pre class="code">RNA1</pre> extend 
<pre class="code">IndexedSeq</pre>. Class <pre class="code">IndexedSeq</pre>, on the other hand, has a <pre class="code">take</pre> method that 
returns an <pre class="code">IndexedSeq</pre>, and that's implemented in terms of <pre class="code">IndexedSeq</pre>'s default
implementation, <pre class="code">Vector</pre>.<a id="i-793070469-1"/></p>

<p>Now that you understand why things are the way they are, the next
question should be what needs to be done to change them? One way to do this would be 
to override the <pre class="code">take</pre> method in class <pre class="code">RNA1</pre>, maybe like this:</p>

<pre>
  <code class="vem">def</code>&nbsp;take(count:&nbsp;<code class="typename">Int</code>):&nbsp;RNA1&nbsp;=&nbsp;RNA1.fromSeq(<code class="vem">super</code>.take(count))
</pre>


<p>This would do the job for <pre class="code">take</pre>. But what about <pre class="code">drop</pre>, or
<pre class="code">filter</pre>, or <pre class="code">init</pre>?  In fact there are over fifty methods on sequences
that return again a sequence. For consistency, all of these would have
to be overridden. This looks less and less like an attractive
option.</p>

<p>Fortunately, there is a much easier way to achieve the same effect.
The RNA class needs to inherit not only from <pre class="code">IndexedSeq</pre>, but also
from its implementation trait <pre class="code">IndexedSeqLike</pre>.
This is shown in <a href="the-architecture-of-scala-collections.html#lst-rna2">Listing 25.7</a>.
The new implementation differs from the previous one 
in only two aspects. First, class <pre class="code">RNA2</pre> now also extends from <pre class="code">IndexedSeqLike[Base,</pre>&nbsp;<pre class="code">RNA2]</pre>. The <pre class="code">IndexedSeqLike</pre> trait implements all concrete methods of <pre class="code">IndexedSeq</pre> 
in an extensible way.</p>

<p>For instance, the return type 
of methods like <pre class="code">take</pre>, <pre class="code">drop</pre>, <pre class="code">filter</pre> or <pre class="code">init</pre> is the second type parameter
passed to class <pre class="code">IndexedSeqLike</pre> (<i>i.e.</i>, <pre class="code">RNA2</pre> in  <a href="the-architecture-of-scala-collections.html#lst-rna2">Listing 25.7</a>). To do this, <pre class="code">IndexedSeqLike</pre> bases itself on the
<pre class="code">newBuilder</pre> abstraction, which creates a builder of the right
kind. Subclasses of trait <pre class="code">IndexedSeqLike</pre> have to override <pre class="code">newBuilder</pre>
to return collections of their own kind. In class <pre class="code">RNA2</pre>, the <pre class="code">newBuilder</pre> method returns a builder of type
<pre class="code">Builder[Base,</pre>&nbsp;<pre class="code">RNA2]</pre>. To construct this builder, it first creates an <pre class="code">ArrayBuffer</pre>, which itself is 
a <pre class="code">Builder[Base,</pre>&nbsp;<pre class="code">ArrayBuffer]</pre>. It then transforms the <pre class="code">ArrayBuffer</pre>  builder
by calling its <pre class="code">mapResult</pre> method to an <pre class="code">RNA2</pre> builder. The <pre class="code">mapResult</pre> method expects
a transformation function from <pre class="code">ArrayBuffer</pre> to <pre class="code">RNA2</pre> as its parameter.
The function given is simply <pre class="code">RNA2.fromSeq</pre>, which converts an arbitrary
base sequence to an <pre class="code">RNA2</pre> value (recall that an array buffer is a kind of sequence, so
<pre class="code">RNA2.fromSeq</pre> can be applied to it).</p>

<p><a id="lst-rna2"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">final</code>&nbsp;<code class="vem">class</code>&nbsp;RNA2&nbsp;<code class="vem">private</code>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;groups:&nbsp;<code class="typename">Array[Int]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;length:&nbsp;<code class="typename">Int</code>
  &nbsp;&nbsp;)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">IndexedSeq[Base]</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">IndexedSeqLike[Base,&nbsp;RNA2]</code>&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">import</code>&nbsp;RNA2._
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;newBuilder:&nbsp;<code class="typename">Builder[Base,&nbsp;RNA2]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrayBuffer[Base]</code>&nbsp;mapResult&nbsp;fromSeq
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(idx:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Base</code>&nbsp;=&nbsp;<code class="comment">//&nbsp;as&nbsp;before</code>
  &nbsp;&nbsp;}
</pre>


<h5>Listing 25.7 - RNA strands class, second version.</h5>


<p>If you had left out the <pre class="code">newBuilder</pre> definition, you would have gotten an error message 
like the following:</p>

<pre>
  RNA2.scala:5: error: overriding method newBuilder in trait
  TraversableLike of type =&gt; scala.collection.mutable.Builder[Base,RNA2];
   method newBuilder in trait GenericTraversableTemplate of type
   =&gt; scala.collection.mutable.Builder[Base,IndexedSeq[Base]] has
   incompatible type
  class RNA2 private (val groups: Array[Int], val length: Int) 
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
  one error found
</pre>


<p>The error message is quite long and complicated, which reflects the intricate way the 
collection libraries are put together. It's best to ignore the information about where the
methods come from, because in this case it detracts more than it helps. What remains
is that a method <pre class="code">newBuilder</pre> with result type <pre class="code">Builder[Base,</pre>&nbsp;<pre class="code">RNA2]</pre> needed to be defined,
but a method <pre class="code">newBuilder</pre> with result type <pre class="code">Builder[Base,IndexedSeq[Base]]</pre> was found.
The latter does not override the former.</p>

<p>The first method, whose result type is <pre class="code">Builder[Base,</pre>&nbsp;<pre class="code">RNA2]</pre>,
is an abstract method that got instantiated at this type in <a href="the-architecture-of-scala-collections.html#lst-rna2">Listing 25.7</a> by passing the <pre class="code">RNA2</pre> type parameter
to <pre class="code">IndexedSeqLike</pre>. The second method, of result type <pre class="code">Builder[Base,IndexedSeq[Base]]</pre>, is what's
provided by the inherited <pre class="code">IndexedSeq</pre> class. In other words, the <pre class="code">RNA2</pre> class is 
invalid without a definition of <pre class="code">newBuilder</pre> with the first result type.</p>

<p>With the refined implementation of the RNA class in <a href="the-architecture-of-scala-collections.html#lst-rna2">Listing 25.7</a>, methods like <pre class="code">take</pre>, <pre class="code">drop</pre>, or <pre class="code">filter</pre> 
work now as expected:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;rna2&nbsp;=&nbsp;RNA2(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)
  <code class="output">rna2:&nbsp;RNA2&nbsp;=&nbsp;RNA2(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)</code>
  <br />  scala&gt;&nbsp;rna2&nbsp;take&nbsp;<code class="literal">3</code>
  <code class="output">res5:&nbsp;RNA2&nbsp;=&nbsp;RNA2(A,&nbsp;U,&nbsp;G)</code>
  <br />  scala&gt;&nbsp;rna2&nbsp;filter&nbsp;(U&nbsp;!=)
  <code class="output">res6:&nbsp;RNA2&nbsp;=&nbsp;RNA2(A,&nbsp;G,&nbsp;G,&nbsp;T)</code>
</pre>


<h5>Dealing with <pre class="code">map</pre> and friends</h5>


<p>There is another class of methods in collections that we haven't dealt with yet.  These methods do not always return the collection
type exactly. They might return the same kind of collection, but
with a different element type. The classical example of this is the
<pre class="code">map</pre> method.  If <pre class="code">s</pre> is a <pre class="code">Seq[Int]</pre>, and <pre class="code">f</pre> is a function from
<pre class="code">Int</pre> to <pre class="code">String</pre>, then <pre class="code">s.map(f)</pre> would return a
<pre class="code">Seq[String]</pre>. So the element type changes between the receiver and
the result, but the kind of collection stays the same.</p>

<p>There are a number of other methods that behave like <pre class="code">map</pre>. For some
of them you would expect this (<i>e.g.</i>, <pre class="code">flatMap</pre>, <pre class="code">collect</pre>), but for
others you might not.  For instance, the append method, <pre class="code">++</pre>, also might
return a result whose type differs from that of its arguments&mdash;appending a list of 
<pre class="code">String</pre> to a list of <pre class="code">Int</pre> would give a list of <pre class="code">Any</pre>. How should these
methods be adapted to RNA strands? Ideally we'd expect that mapping
bases to bases over an RNA strand would yield again an RNA strand:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;rna&nbsp;=&nbsp;RNA(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)
  <code class="output">rna:&nbsp;RNA&nbsp;=&nbsp;RNA(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)</code>
  <br />  scala&gt;&nbsp;rna&nbsp;map&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;A&nbsp;=&gt;&nbsp;T&nbsp;<code class="vem">case</code>&nbsp;b&nbsp;=&gt;&nbsp;b&nbsp;}
  <code class="output">res7:&nbsp;RNA&nbsp;=&nbsp;RNA(T,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)</code>
</pre>


<p>Likewise, appending two RNA strands with <pre class="code">++</pre> should yield again another RNA strand:</p>

<pre>
  scala&gt;&nbsp;rna&nbsp;++&nbsp;rna
  <code class="output">res8:&nbsp;RNA&nbsp;=&nbsp;RNA(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T,&nbsp;A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)</code>
</pre>


<p>On the other hand, mapping bases to some other type over an RNA strand
cannot yield another RNA strand because the new elements have the
wrong type. It has to yield a sequence instead. In the same vein
appending elements that are not of type <pre class="code">Base</pre> to an RNA strand can
yield a general sequence, but it cannot yield another RNA strand.</p>

<pre>
  scala&gt;&nbsp;rna&nbsp;map&nbsp;Base.toInt
  <code class="output">res2:&nbsp;IndexedSeq[Int]&nbsp;=&nbsp;Vector(0,&nbsp;3,&nbsp;2,&nbsp;2,&nbsp;1)</code>
  <br />  scala&gt;&nbsp;rna&nbsp;++&nbsp;<code class="typename">List</code>(<code class="quotedstring">"missing"</code>,&nbsp;<code class="quotedstring">"data"</code>)
  <code class="output">res3:&nbsp;IndexedSeq[java.lang.Object]&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;Vector(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T,&nbsp;missing,&nbsp;data)</code>
</pre>


<p>This is what you'd expect in the ideal case. But this is not what the
<pre class="code">RNA2</pre> class as given in <a href="the-architecture-of-scala-collections.html#lst-rna2">Listing 25.7</a> provides. In fact,
if you ran the first two examples above with instances of this class 
you would obtain:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;rna2&nbsp;=&nbsp;RNA2(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)
  <code class="output">rna2:&nbsp;RNA2&nbsp;=&nbsp;RNA2(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)</code>
  <br />  scala&gt;&nbsp;rna2&nbsp;map&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;A&nbsp;=&gt;&nbsp;T&nbsp;<code class="vem">case</code>&nbsp;b&nbsp;=&gt;&nbsp;b&nbsp;}
  <code class="output">res0:&nbsp;IndexedSeq[Base]&nbsp;=&nbsp;Vector(T,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)</code>
  <br />  scala&gt;&nbsp;rna2&nbsp;++&nbsp;rna2
  <code class="output">res1:&nbsp;IndexedSeq[Base]&nbsp;=&nbsp;Vector(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T,&nbsp;A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;T)</code>
</pre>


<p>So the result of <pre class="code">map</pre> and <pre class="code">++</pre> is never an RNA strand, even if the 
element type of the generated collection is a <pre class="code">Base</pre>.
To see how to do better, it pays to have a close look at the signature
of the <pre class="code">map</pre> method (or of <pre class="code">++</pre>, which has a similar signature).
The <pre class="code">map</pre> method is originally defined in class <pre class="code">scala.collection.TraversableLike</pre>
with the following signature:</p>

<pre>
  <code class="vem">def</code>&nbsp;map[B,&nbsp;<code class="typename">That</code>](f:&nbsp;<code class="typename">Elem</code>&nbsp;=&gt;&nbsp;B)
  &nbsp;&nbsp;(<code class="vem">implicit</code>&nbsp;cbf:&nbsp;<code class="typename">CanBuildFrom[Repr,&nbsp;B,&nbsp;That]</code>):&nbsp;<code class="typename">That</code>
</pre>


<p>Here <pre class="code">Elem</pre> is the type of elements of the collection, and <pre class="code">Repr</pre> is the
type of the collection itself; that is, the second type parameter that gets
passed to implementation classes such as <pre class="code">TraversableLike</pre> and 
<pre class="code">IndexedSeqLike</pre>. The <pre class="code">map</pre> method takes two more type parameters, <pre class="code">B</pre> and 
<pre class="code">That</pre>. The <pre class="code">B</pre> parameter stands for the result type of the mapping function,
which is also the element type of the new collection. The <pre class="code">That</pre>
appears as the result type of <pre class="code">map</pre>, so it represents the type of the new collection
that gets created.</p>

<p>How is the <pre class="code">That</pre> type determined? It is linked to the other types by an 
implicit parameter <pre class="code">cbf</pre>, of type <pre class="code">CanBuildFrom[Repr,</pre>&nbsp;<pre class="code">B,</pre>&nbsp;<pre class="code">That]</pre>.
These <pre class="code">CanBuildFrom</pre> implicits are defined by the individual collection classes. In essence, an implicit value of type <pre class="code">CanBuildFrom[From,</pre>&nbsp;<pre class="code">Elem,</pre>&nbsp;<pre class="code">To]</pre> says: "Here is a way, given a collection of type
<pre class="code">From</pre>, to build with elements of type <pre class="code">Elem</pre> a collection of type <pre class="code">To</pre>."</p>

<p><a id="lst-rna"/></p>

<pre>
  <code class="vem">final</code>&nbsp;<code class="vem">class</code>&nbsp;RNA&nbsp;<code class="vem">private</code>&nbsp;(<code class="vem">val</code>&nbsp;groups:&nbsp;<code class="typename">Array[Int]</code>,&nbsp;<code class="vem">val</code>&nbsp;length:&nbsp;<code class="typename">Int</code>)&nbsp;
  &nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">IndexedSeq[Base]</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">IndexedSeqLike[Base,&nbsp;RNA]</code>&nbsp;{
  <br />  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;RNA._
  <br />  &nbsp;&nbsp;<code class="comment">//&nbsp;Mandatory&nbsp;re-implementation&nbsp;of&nbsp;`newBuilder`&nbsp;in&nbsp;`IndexedSeq`</code>
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">protected</code>[<code class="vem">this</code>]&nbsp;<code class="vem">def</code>&nbsp;newBuilder:&nbsp;<code class="typename">Builder[Base,&nbsp;RNA]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;RNA.newBuilder
  <br />  &nbsp;&nbsp;<code class="comment">//&nbsp;Mandatory&nbsp;implementation&nbsp;of&nbsp;`apply`&nbsp;in&nbsp;`IndexedSeq`</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(idx:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Base</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(idx&nbsp;&lt;&nbsp;<code class="literal">0</code>&nbsp;||&nbsp;length&nbsp;&lt;=&nbsp;idx)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IndexOutOfBoundsException</code>
  &nbsp;&nbsp;&nbsp;&nbsp;Base.fromInt(groups(idx&nbsp;/&nbsp;N)&nbsp;&gt;&gt;&nbsp;(idx&nbsp;<code class="texttt">%</code>&nbsp;N&nbsp;*&nbsp;S)&nbsp;&amp;&nbsp;M)
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<code class="comment">//&nbsp;Optional&nbsp;re-implementation&nbsp;of&nbsp;foreach,&nbsp;</code>
  &nbsp;&nbsp;<code class="comment">//&nbsp;to&nbsp;make&nbsp;it&nbsp;more&nbsp;efficient.</code>
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;foreach[U](f:&nbsp;<code class="typename">Base</code>&nbsp;=&gt;&nbsp;U):&nbsp;<code class="typename">Unit</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;i&nbsp;=&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;b&nbsp;=&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">while</code>&nbsp;(i&nbsp;&lt;&nbsp;length)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;<code class="vem">if</code>&nbsp;(i&nbsp;<code class="texttt">%</code>&nbsp;N&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;groups(i&nbsp;/&nbsp;N)&nbsp;<code class="vem">else</code>&nbsp;b&nbsp;&gt;&gt;&gt;&nbsp;S
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f(Base.fromInt(b&nbsp;&amp;&nbsp;M))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;+=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  }
</pre>


<h5>Listing 25.8 - RNA strands class, final version.</h5>


<p>Now the behavior of <pre class="code">map</pre> and <pre class="code">++</pre> on <pre class="code">RNA2</pre> sequences becomes
clearer.  There is no <pre class="code">CanBuildFrom</pre> instance that creates <pre class="code">RNA2</pre>
sequences, so the next best available <pre class="code">CanBuildFrom</pre> was found in the
companion object of the inherited trait <pre class="code">IndexedSeq</pre>. That implicit creates <pre class="code">IndexedSeq</pre>s, 
and that's what you saw when applying <pre class="code">map</pre> to <pre class="code">rna2</pre>.</p>

<p>To address this shortcoming, you need to define an implicit instance of
<pre class="code">CanBuildFrom</pre> in the companion object of the RNA class.
That instance should have type <pre class="code">CanBuildFrom[RNA,</pre>&nbsp;<pre class="code">Base,</pre>&nbsp;<pre class="code">RNA]</pre>.
Hence, this instance states that, given an RNA strand and a new
element type <pre class="code">Base</pre>, you can build another collection which is again an 
RNA strand. <a href="the-architecture-of-scala-collections.html#lst-rna">Listing 25.8</a> and <a href="the-architecture-of-scala-collections.html#lst-rna-obj">Listing 25.9</a> show the details.</p>

<p><a id="lst-rna-obj"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;RNA&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;S&nbsp;=&nbsp;<code class="literal">2</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;number&nbsp;of&nbsp;bits&nbsp;in&nbsp;group</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;M&nbsp;=&nbsp;(<code class="literal">1</code>&nbsp;&lt;&lt;&nbsp;S)&nbsp;-&nbsp;<code class="literal">1</code>&nbsp;<code class="comment">//&nbsp;bitmask&nbsp;to&nbsp;isolate&nbsp;a&nbsp;group</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;N&nbsp;=&nbsp;<code class="literal">32</code>&nbsp;/&nbsp;S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;number&nbsp;of&nbsp;groups&nbsp;in&nbsp;an&nbsp;Int</code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;fromSeq(buf:&nbsp;<code class="typename">Seq[Base]</code>):&nbsp;RNA&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;groups&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[Int]</code>((buf.length&nbsp;+&nbsp;N&nbsp;-&nbsp;<code class="literal">1</code>)&nbsp;/&nbsp;N)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;buf.length)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;groups(i&nbsp;/&nbsp;N)&nbsp;|=&nbsp;Base.toInt(buf(i))&nbsp;&lt;&lt;&nbsp;(i&nbsp;<code class="texttt">%</code>&nbsp;N&nbsp;*&nbsp;S)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;RNA(groups,&nbsp;buf.length)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(bases:&nbsp;<code class="typename">Base</code>*)&nbsp;=&nbsp;fromSeq(bases)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;newBuilder:&nbsp;<code class="typename">Builder[Base,&nbsp;RNA]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrayBuffer</code>&nbsp;mapResult&nbsp;fromSeq
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;canBuildFrom:&nbsp;<code class="typename">CanBuildFrom[RNA,&nbsp;Base,&nbsp;RNA]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">CanBuildFrom[RNA,&nbsp;Base,&nbsp;RNA]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply():&nbsp;<code class="typename">Builder[Base,&nbsp;RNA]</code>&nbsp;=&nbsp;newBuilder
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(from:&nbsp;RNA):&nbsp;<code class="typename">Builder[Base,&nbsp;RNA]</code>&nbsp;=&nbsp;newBuilder
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 25.9 - RNA companion object&mdash;final version.</h5>


<p>Compared to
class <pre class="code">RNA2</pre> there are two important differences. First, the <pre class="code">newBuilder</pre>
implementation has moved from the RNA class to its companion
object. The <pre class="code">newBuilder</pre> method in class <pre class="code">RNA</pre> simply forwards to
this definition. Second, there is now an implicit <pre class="code">CanBuildFrom</pre>
value in object <pre class="code">RNA</pre>. To create such an object you need to define
two <pre class="code">apply</pre> methods in the <pre class="code">CanBuildFrom</pre> trait.  Both create
a new builder for an <pre class="code">RNA</pre> collection, but they differ in their
argument list. The <pre class="code">apply()</pre> method simply creates a new builder
of the right type. By contrast, the <pre class="code">apply(from)</pre> method 
takes the original collection as argument.  This can be
useful to adapt the dynamic type of builder's return type to be the
same as the dynamic type of the receiver. In the case of <pre class="code">RNA</pre> this 
does not come into play because <pre class="code">RNA</pre> is a final class, so any receiver
of static type <pre class="code">RNA</pre> also has <pre class="code">RNA</pre> as its dynamic type. That's why
<pre class="code">apply(from)</pre> also simply calls <pre class="code">newBuilder</pre>, ignoring its argument.</p>

<p>That is it. The <pre class="code">RNA</pre> class in <a href="the-architecture-of-scala-collections.html#lst-rna">Listing 25.8</a> implements
all collection methods at their natural types. Its implementation
requires a little bit of protocol. In essence, you need to know where
to put the <pre class="code">newBuilder</pre> factories and the <pre class="code">canBuildFrom</pre> implicits.
On the plus side, with relatively little code you get a large number
of methods automatically defined. Also, if you don't intend to do bulk
operations like <pre class="code">take</pre>, <pre class="code">drop</pre>, <pre class="code">map</pre>, or <pre class="code">++</pre> on your collection,
you can choose to not go the extra length and stop at the
implementation shown in <a href="the-architecture-of-scala-collections.html#lst-rna1">Listing 25.6</a>.</p>

<p>The discussion so far centered on the minimal amount of definitions
needed to define new sequences with methods that obey certain types.
But in practice you might also want to add new functionality to your
sequences or override existing methods for better efficiency.  An
example of this is the overridden <pre class="code">foreach</pre> method in class <pre class="code">RNA</pre>.<a id="i342746476-1"/>
<pre class="code">foreach</pre> is an important method in its own right because it
implements loops over collections. Furthermore, many other collection
methods are implemented in terms of <pre class="code">foreach</pre>. So it makes sense to 
invest some effort optimizing the method's implementation.</p>

<p>The standard
implementation of <pre class="code">foreach</pre> in <pre class="code">IndexedSeq</pre> will simply select every
<pre class="code">i</pre>'th element of the collection using <pre class="code">apply</pre>, where <pre class="code">i</pre> ranges
from <pre class="code">0</pre> to the collection's length minus one. So this standard
implementation selects an array element and unpacks a base from it once
for every element in an RNA strand. The overriding <pre class="code">foreach</pre> in class
<pre class="code">RNA</pre> is smarter than that. For every selected array element it
immediately applies the given function to all bases contained in
it.  So the effort for array selection and bit unpacking is much reduced.</p>

<h4>Integrating new sets and maps</h4>


<p>As a second example you'll learn how to integrate a new kind of map
into the collection framework. The idea is to implement a mutable map
with <pre class="code">String</pre> as the type of keys by a "Patricia trie".<a href="the-architecture-of-scala-collections.html#footnotemain25-2">[2]</a> The term <span style="font-style:italic">Patricia</span> is an abbreviation<a id="i732713786-1"/>
for "Practical Algorithm to Retrieve Information Coded in
Alphanumeric." The idea is to store a set or a map as a tree where
subsequent characters in a search key determines uniquely a descendant
tree.</p>

<p>For instance, a Patricia trie storing the five strings, "<pre class="code">abc</pre>",
"<pre class="code">abd</pre>", "<pre class="code">al</pre>", "<pre class="code">all</pre>", "<pre class="code">xy</pre>", would look like the tree given in
<a href="the-architecture-of-scala-collections.html#fig-patrica">Figure 25.1</a>.  To find the node corresponding to the
string "abc" in this trie, simply follow the subtree labeled "<pre class="code">a</pre>",
proceed from there to the subtree labeled "<pre class="code">b</pre>" to finally reach its
subtree labeled "<pre class="code">c</pre>".  If the Patricia trie is used as a map, the
value that's associated with a key is stored in the nodes that can be
reached by the key. If it is a set, you simply store a marker saying
that the node is present in the set.</p>

<p><a id="lst-prefixmap"/></p>

<pre>
  <code class="vem">import</code>&nbsp;collection._
  <br />  <code class="vem">class</code>&nbsp;<code class="typename">PrefixMap[T]</code>
  <code class="vem">extends</code>&nbsp;<code class="typename">mutable.Map[String,&nbsp;T]</code>&nbsp;
  &nbsp;&nbsp;&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">mutable.MapLike[String,&nbsp;T,&nbsp;PrefixMap[T]]</code>&nbsp;{
  <br />  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;suffixes:&nbsp;<code class="typename">immutable.Map[Char,&nbsp;PrefixMap[T]]</code>&nbsp;=&nbsp;Map.empty
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;value:&nbsp;<code class="typename">Option[T]</code>&nbsp;=&nbsp;<code class="typename">None</code>
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;get(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Option[T]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(s.isEmpty)&nbsp;value
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;suffixes&nbsp;get&nbsp;(s(<code class="literal">0</code>))&nbsp;flatMap&nbsp;(_.get(s&nbsp;substring&nbsp;<code class="literal">1</code>))
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;withPrefix(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">PrefixMap[T]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(s.isEmpty)&nbsp;<code class="vem">this</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;leading&nbsp;=&nbsp;s(<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;suffixes&nbsp;get&nbsp;leading&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">None</code>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;suffixes&nbsp;=&nbsp;suffixes&nbsp;+&nbsp;(leading&nbsp;-&gt;&nbsp;empty)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;suffixes(leading)&nbsp;withPrefix&nbsp;(s&nbsp;substring&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;update(s:&nbsp;<code class="typename">String</code>,&nbsp;elem:&nbsp;T)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;withPrefix(s).value&nbsp;=&nbsp;<code class="typename">Some</code>(elem)
  <br />  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;remove(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Option[T]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(s.isEmpty)&nbsp;{&nbsp;<code class="vem">val</code>&nbsp;prev&nbsp;=&nbsp;value;&nbsp;value&nbsp;=&nbsp;<code class="typename">None</code>;&nbsp;prev&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;suffixes&nbsp;get&nbsp;(s(<code class="literal">0</code>))&nbsp;flatMap&nbsp;(_.remove(s&nbsp;substring&nbsp;<code class="literal">1</code>))
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;iterator:&nbsp;<code class="typename">Iterator[(String,&nbsp;T)]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">for</code>&nbsp;(v&nbsp;&lt;-&nbsp;value.iterator)&nbsp;<code class="vem">yield</code>&nbsp;(<code class="quotedstring">""</code>,&nbsp;v))&nbsp;++
  &nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">for</code>&nbsp;((chr,&nbsp;m)&nbsp;&lt;-&nbsp;suffixes.iterator;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(s,&nbsp;v)&nbsp;&lt;-&nbsp;m.iterator)&nbsp;<code class="vem">yield</code>&nbsp;(chr&nbsp;+:&nbsp;s,&nbsp;v))
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;+=&nbsp;(kv:&nbsp;(<code class="typename">String</code>,&nbsp;T)):&nbsp;<code class="vem">this</code>.type&nbsp;=&nbsp;{&nbsp;update(kv._1,&nbsp;kv._2);&nbsp;<code class="vem">this</code>&nbsp;}
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;-=&nbsp;(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="vem">this</code>.type&nbsp;&nbsp;=&nbsp;{&nbsp;remove(s);&nbsp;<code class="vem">this</code>&nbsp;}
  <br />  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;empty&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PrefixMap[T]</code>
  }
</pre>


<h5>Listing 25.10 - An implementation of prefix maps with Patricia tries.</h5>


<div class="figure"><a id="fig-patrica"/>


<p><img src="images/patricia160.png" alt="image images/patricia160.png"/></p>

</div>
<h5> Figure 25.1 - An example Patricia trie.</h5>


<p>Patricia tries support very efficient lookups and updates.
Another nice feature is that they support selecting a subcollection by
giving a prefix. For instance, in the tree in <a href="the-architecture-of-scala-collections.html#fig-patrica">Figure 25.1</a>
you can obtain the sub-collection of all keys that start with an "<pre class="code">a</pre>"
simply by following the "<pre class="code">a</pre>" link from the root of the tree.</p>

<p>Based on these ideas we will now walk you through the implementation
of a map that's implemented as a Patricia trie. We call the map a
<pre class="code">PrefixMap</pre>, which means that it provides a method <pre class="code">withPrefix</pre> that
selects a submap of all keys starting with a given prefix.</p>

<p>We'll first 
define a prefix map with the keys shown in <a href="the-architecture-of-scala-collections.html#fig-patrica">Figure 25.1</a>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;m&nbsp;=&nbsp;<code class="typename">PrefixMap</code>(<code class="quotedstring">"abc"</code>&nbsp;-&gt;&nbsp;<code class="literal">0</code>,&nbsp;<code class="quotedstring">"abd"</code>&nbsp;-&gt;&nbsp;<code class="literal">1</code>,&nbsp;<code class="quotedstring">"al"</code>&nbsp;-&gt;&nbsp;<code class="literal">2</code>,&nbsp;
  &nbsp;&nbsp;<code class="quotedstring">"all"</code>&nbsp;-&gt;&nbsp;<code class="literal">3</code>,&nbsp;<code class="quotedstring">"xy"</code>&nbsp;-&gt;&nbsp;<code class="literal">4</code>)
  <code class="output">m:&nbsp;PrefixMap[Int]&nbsp;=&nbsp;Map((abc,0),&nbsp;(abd,1),&nbsp;(al,2),&nbsp;(all,3),</code>
  <code class="output">&nbsp;&nbsp;(xy,4))</code>
</pre>


<p>Then calling <pre class="code">withPrefix</pre> on <pre class="code">m</pre> will yield another prefix map:</p>

<pre>
  scala&gt;&nbsp;m&nbsp;withPrefix&nbsp;<code class="quotedstring">"a"</code>
  <code class="output">res14:&nbsp;PrefixMap[Int]&nbsp;=&nbsp;Map((bc,0),&nbsp;(bd,1),&nbsp;(l,2),&nbsp;(ll,3))</code>
</pre>


<p><a href="the-architecture-of-scala-collections.html#lst-prefixmap">Listing 25.10</a> shows the definition of 
<pre class="code">PrefixMap</pre>. This class is parameterized with the type of associated values <pre class="code">T</pre>, 
and extends <pre class="code">mutable.Map[String,</pre>&nbsp;<pre class="code">T]</pre> and <pre class="code">mutable.MapLike[String,</pre>&nbsp;<pre class="code">T,</pre>&nbsp;<pre class="code">PrefixMap[T]]</pre>.
You have seen this pattern already for sequences in the RNA strand example. Then
as now inheriting an implementation class such as <pre class="code">MapLike</pre> serves to
get the right result type for transformations such as <pre class="code">filter</pre>.</p>

<p>A prefix map node has two mutable fields: <pre class="code">suffixes</pre> and <pre class="code">value</pre>.
The <pre class="code">value</pre> field contains an optional value that's associated with
the node.  It is initialized to <pre class="code">None</pre>. The <pre class="code">suffixes</pre> field
contains a map from characters to <pre class="code">PrefixMap</pre> values. It is
initialized to the empty map. You might ask, Why did we pick an immutable map as the implementation
type for <pre class="code">suffixes</pre>? Would not a mutable map been more standard since <pre class="code">PrefixMap</pre> as a whole is also mutable? The answer is that
immutable maps that contain only a few elements are very efficient in
both space and execution time.</p>

<p>For instance, maps that contain fewer
than 5 elements are represented as a single object. By contrast, as
described in <a href="working-with-other-collections.html#sec-sets-and-maps">Section 17.2</a>, the
standard mutable map is a <pre class="code">HashMap</pre>, which typically occupies around
80 bytes, even if it is empty. So if small collections are common,
it's better to pick immutable over mutable. In the case of Patricia
tries, we'd expect that most nodes, except the ones at the very top of
the tree, would contain only a few successors. So storing these
successors in an immutable map is likely to be more efficient.</p>

<p>Now have a look at the first method that needs to be implemented
for a map: <pre class="code">get</pre>. The algorithm is as follows: To get the value
associated with the empty string in a prefix map, simply select the
optional <pre class="code">value</pre> stored in the root of the tree. Otherwise, if the
key string is not empty, try to select the submap corresponding to the
first character of the string. If that yields a map, follow up by
looking up the remainder of the key string after its first character in
that map. If the selection fails, the key is not stored in the map, so
return with <pre class="code">None</pre>. The combined selection over an option value is
elegantly expressed using <pre class="code">flatMap</pre>. When applied to an optional
value, <pre class="code">ov</pre>, and a closure, <pre class="code">f</pre>, which in turn returns an optional
value, <pre class="code">ov</pre>&nbsp;<pre class="code">flatMap</pre>&nbsp;<pre class="code">f</pre> will succeed if both <pre class="code">ov</pre> and <pre class="code">f</pre> return a
defined value. Otherwise <pre class="code">ov</pre>&nbsp;<pre class="code">flatMap</pre>&nbsp;<pre class="code">f</pre> will return <pre class="code">None</pre>.</p>

<p>The next two methods to implement for a mutable map are <pre class="code">+=</pre> and
<pre class="code">-=</pre>.  In the implementation of <a href="the-architecture-of-scala-collections.html#lst-prefixmap">Listing 25.10</a>, these are
defined in terms of two other methods: <pre class="code">update</pre> and <pre class="code">remove</pre>. The <pre class="code">remove</pre> method is very similar to <pre class="code">get</pre>, except that before
returning any associated value, the field containing that value is set
to <pre class="code">None</pre>. The <pre class="code">update</pre> method first calls <pre class="code">withPrefix</pre> to
navigate to the tree node that needs to be updated, then sets the
<pre class="code">value</pre> field of that node to the given value. The <pre class="code">withPrefix</pre>
method navigates through the tree, creating sub-maps as necessary if
some prefix of characters is not yet contained as a path in the tree.</p>

<p>The last abstract method to implement for a mutable map is
<pre class="code">iterator</pre>.<a id="i1062529325-1"/>  This method needs to produce an iterator that yields all
key/value pairs stored in the map. For any given prefix map this
iterator is composed of the following parts: First, if the map
contains a defined value, <pre class="code">Some(x)</pre>, in the <pre class="code">value</pre> field at its root,
then <pre class="code">("",</pre>&nbsp;<pre class="code">x)</pre> is the first element returned from the iterator.
Furthermore, the iterator needs to traverse the iterators of all submaps
stored in the <pre class="code">suffixes</pre> field, but it needs to add a character in front
of every key string returned by those iterators. More precisely, if 
<pre class="code">m</pre> is the submap reached from the root through a character <pre class="code">chr</pre>,
and <pre class="code">(s,</pre>&nbsp;<pre class="code">v)</pre> is an element returned from <pre class="code">m.iterator</pre>, then
the root's iterator will return <pre class="code">(chr</pre>&nbsp;<pre class="code">+:</pre>&nbsp;<pre class="code">s,</pre>&nbsp;<pre class="code">v)</pre> instead.</p>

<p>This logic 
is implemented quite concisely as a concatenation of two <pre class="code">for</pre> expressions
in the implementation of the <pre class="code">iterator</pre> method in <a href="the-architecture-of-scala-collections.html#lst-prefixmap">Listing 25.10</a>. 
The first <pre class="code">for</pre> expression iterates over <pre class="code">value.iterator</pre>. This makes
use of the fact that <pre class="code">Option</pre> values define an iterator method that returns
either no element, if the option value is <pre class="code">None</pre>,
or exactly one element <pre class="code">x</pre>, if the option value is <pre class="code">Some(x)</pre>.
<a id="lst-prefix-obj"/></p>

<pre>
  <code class="vem">import</code>&nbsp;scala.collection.mutable.{<code class="typename">Builder</code>,&nbsp;<code class="typename">MapBuilder</code>}
  <code class="vem">import</code>&nbsp;scala.collection.generic.CanBuildFrom
  <br />  <code class="vem">object</code>&nbsp;<code class="typename">PrefixMap</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;empty[T]&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PrefixMap[T]</code>
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply[T](kvs:&nbsp;(<code class="typename">String</code>,&nbsp;T)*):&nbsp;<code class="typename">PrefixMap[T]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;m:&nbsp;<code class="typename">PrefixMap[T]</code>&nbsp;=&nbsp;empty
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(kv&nbsp;&lt;-&nbsp;kvs)&nbsp;m&nbsp;+=&nbsp;kv
  &nbsp;&nbsp;&nbsp;&nbsp;m
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;newBuilder[T]:&nbsp;<code class="typename">Builder[(String,&nbsp;T),&nbsp;PrefixMap[T]]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">MapBuilder[String,&nbsp;T,&nbsp;PrefixMap[T]]</code>(empty)
  <br />  &nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;canBuildFrom[T]
  &nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<code class="typename">CanBuildFrom[PrefixMap[_],&nbsp;(String,&nbsp;T),&nbsp;PrefixMap[T]]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">CanBuildFrom[PrefixMap[_],&nbsp;(String,&nbsp;T),&nbsp;PrefixMap[T]]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(from:&nbsp;<code class="typename">PrefixMap[_]</code>)&nbsp;=&nbsp;newBuilder[T]
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply()&nbsp;=&nbsp;newBuilder[T]
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  }
</pre>


<h5>Listing 25.11 - The companion object for prefix maps.</h5>


<p>Note that there is no <pre class="code">newBuilder</pre> method defined in
<pre class="code">PrefixMap</pre>. There is no need because maps and sets come with
default builders, which are instances of class <pre class="code">MapBuilder</pre>. For a mutable map
the default builder starts with an empty map and then adds successive
elements using the map's <pre class="code">+=</pre> method. Mutable sets behave the
same. The default builders for immutable maps and sets use the non-destructive element addition method <pre class="code">+</pre>, instead of method <pre class="code">+=</pre>. However, in all these cases, to build the right kind of set or map, 
you need to start with an empty set or map of this kind. This is
provided by the <pre class="code">empty</pre> method, which is the last method defined in <pre class="code">PrefixMap</pre>. In
<a href="the-architecture-of-scala-collections.html#lst-prefixmap">Listing 25.10</a>, this method simply returns a fresh <pre class="code">PrefixMap</pre>.</p>

<p>We'll now turn to the companion object <pre class="code">PrefixMap</pre>, which is shown in
<a href="the-architecture-of-scala-collections.html#lst-prefix-obj">Listing 25.11</a>. In fact it is not strictly necessary to
define this companion object, as class <pre class="code">PrefixMap</pre> can stand well on
its own.  The main purpose of object <pre class="code">PrefixMap</pre> is to define some
convenience factory methods. It also defines a <pre class="code">CanBuildFrom</pre>
implicit to make typing work out better.</p>

<p>The two convenience methods are <pre class="code">empty</pre> and <pre class="code">apply</pre>. The same
methods are present for all other collections in Scala's collection
framework so it makes sense to define them here too.  With the two 
methods, you can write <pre class="code">PrefixMap</pre> literals like you do for any other
collection:</p>

<pre>
  scala&gt;&nbsp;<code class="typename">PrefixMap</code>(<code class="quotedstring">"hello"</code>&nbsp;-&gt;&nbsp;<code class="literal">5</code>,&nbsp;<code class="quotedstring">"hi"</code>&nbsp;-&gt;&nbsp;<code class="literal">2</code>)
  <code class="output">res0:&nbsp;PrefixMap[Int]&nbsp;=&nbsp;Map((hello,5),&nbsp;(hi,2))</code>
  <br />  scala&gt;&nbsp;PrefixMap.empty[<code class="typename">String</code>]
  <code class="output">res2:&nbsp;PrefixMap[String]&nbsp;=&nbsp;Map()</code>
</pre>


<p>The other member in object <pre class="code">PrefixMap</pre> is an implicit <pre class="code">CanBuildFrom</pre> instance.
It has the same purpose as the <pre class="code">CanBuildFrom</pre>
definition in the last section: to make methods like <pre class="code">map</pre> return the
best possible type. For instance, consider <pre class="code">map</pre>ping a function over the 
key/value pairs of a <pre class="code">PrefixMap</pre>. As long as that function produces
pairs of strings and some second type, the result collection will again
be a <pre class="code">PrefixMap</pre>. Here's an example:</p>

<pre>
  scala&gt;&nbsp;res0&nbsp;map&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;(k,&nbsp;v)&nbsp;=&gt;&nbsp;(k&nbsp;+&nbsp;<code class="quotedstring">"!"</code>,&nbsp;<code class="quotedstring">"x"</code>&nbsp;*&nbsp;v)&nbsp;}
  <code class="output">res8:&nbsp;PrefixMap[String]&nbsp;=&nbsp;Map((hello!,xxxxx),&nbsp;(hi!,xx))</code>
</pre>


<p>The given function argument takes the key/value bindings of the prefix
map <pre class="code">res0</pre> and produces pairs of strings. The result of
the <pre class="code">map</pre> is a <pre class="code">PrefixMap</pre>, this time with value type
<pre class="code">String</pre> instead of <pre class="code">Int</pre>. Without the <pre class="code">canBuildFrom</pre> implicit in
<pre class="code">PrefixMap</pre> the result would just have been a general mutable map,
not a prefix map.</p>

<h4>Summary</h4>


<p>If you want to fully integrate a new collection class into
the framework, you need to pay attention to the following points:</p>

<ol>


<li>Decide whether the collection should be mutable or immutable.


</li>
<li>Pick the right base traits for the collection.


</li>
<li>Inherit from the right implementation trait to implement most collection operations.


</li>
<li>If you want <pre class="code">map</pre> and similar operations to return instances of your collection
  type, provide an implicit <pre class="code">CanBuildFrom</pre> in your class's companion object.


</li></ol>


<h3>25.4 Conclusion</h3>


<p>You have now seen how Scala's collections are built and how you can
build new kinds of collections. Because of Scala's rich support for
abstraction, each new collection type can have a large number of
methods without having to reimplement them all over again.</p>

<hr/>
<h4>Footnotes for Chapter 25:</h4>


<p><a id="footnotemain25-1"/>[1] Ideally, everything should be defined
  in one place only, but there are a few exceptions where things needed
  to be redefined.</p>

<p><a id="footnotemain25-2"/>[2] Morrison, "PATRICIA&mdash;Practical Algorithm To Retrieve Information Coded in Alphanumeric"  <a href="bibliography.html#patricia">[Mor68]</a></p>

<div style="page-break-after:always"/>


<div style="page-break-after:always"/>

</body>
</html>
