<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8"/>
    <title>Programming in Scala, 3rd Edition</title>

    <link rel="stylesheet" type="text/css" href="book.css" />
  </head>
<body>
<h2><a id="chap-built-in-control-structures">Chapter 7</a></h2>
<h1>Built-in Control Structures</h1>


<p>Scala has only a handful of built-in control structures. The only
control structures are <pre class="code">if</pre>, <pre class="code">while</pre>, <pre class="code">for</pre>, <pre class="code">try</pre>,
<pre class="code">match</pre>, and function calls.  The reason Scala has so few is that it has
included function literals since its inception.  Instead of accumulating one
higher-level control structure after another in the base syntax, Scala
accumulates them in libraries. (<a href="control-abstraction.html">Chapter 9</a> will show precisely how that is done.) This chapter will show those few control structures that
are built in.</p>

<p>One thing you will notice is that almost all of Scala's control
structures result in some value.  This is the approach taken by
functional languages, where programs are viewed as computing a value, thus the components of a program should also compute values. You can also view this approach as the logical
conclusion of a trend already present in imperative languages.  In
imperative languages, function calls can return a value, even though 
having the called function update an output variable passed as an argument
would work just as well. In addition, imperative languages often have a ternary
operator (such as the <pre class="code">?:</pre> operator of C, C++, and Java), which behaves exactly like
<pre class="code">if</pre>, but results in a value. Scala adopts this ternary operator model, but calls it <pre class="code">if</pre>. In other words, Scala's <pre class="code">if</pre> can result in a value. Scala then
continues this trend by having <pre class="code">for</pre>, <pre class="code">try</pre>, and <pre class="code">match</pre> also result in values.</p>

<p>Programmers can use these result values to simplify their code, just
as they use return values of functions.  Without this
facility, the programmer must create temporary variables just to hold
results that are calculated inside a control structure.  Removing
these temporary variables makes the code a little simpler, and it also
prevents many bugs where you set the variable in one branch but forget
to set it in another.</p>

<p>Overall, Scala's basic control structures, minimal as they are, provide all of the essentials from imperative languages. Further, they allow you to shorten your code by consistently having result values. To show you how this works, we'll take a closer look at each of Scala's basic control structures.</p>

<h3 id="sec-if-expressions">7.1 If expressions</h3>


<p>Scala's <pre class="code">if</pre> works just like in many other languages.<a id="i-1395149224-3"/> It tests a
condition and then executes one of two code branches depending on
whether the condition holds true.  Here is a common example, written
in an imperative style:</p>

<pre>
  <code class="vem">var</code>&nbsp;filename&nbsp;=&nbsp;<code class="quotedstring">"default.txt"</code>
  <code class="vem">if</code>&nbsp;(!args.isEmpty)
  &nbsp;&nbsp;filename&nbsp;=&nbsp;args(<code class="literal">0</code>)
</pre>


<p>This code declares a variable, <pre class="code">filename</pre>, and initializes it to a
default value.  It then uses an <pre class="code">if</pre> expression to check whether any
arguments were supplied to the program.  If so, it 
changes the variable to hold the value specified in the argument
list.  If no arguments were supplied, it leaves the variable set to
the default value.</p>

<p>This code can be written more nicely because, as mentioned in <a href="first-steps-in-scala.html#step3">Step 3</a> in <a href="first-steps-in-scala.html">Chapter 2</a>, Scala's <pre class="code">if</pre>
is an expression that results in a value.
<a href="builtin-control-structures.html#lst-if-else-init">Listing 7.1</a> shows how you can accomplish the same effect as the
previous example, without using any <pre class="code">var</pre>s:<a id="i1218979943-1"/></p>

<p><a id="lst-if-else-init"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;filename&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(!args.isEmpty)&nbsp;args(<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;<code class="quotedstring">"default.txt"</code>
</pre>


<h5>Listing 7.1 - Scala's idiom for conditional initialization.</h5>


<p>This time, the <pre class="code">if</pre> has two branches.  If <pre class="code">args</pre> is not empty,
the initial element, <pre class="code">args(0)</pre>, is chosen; otherwise, the default value is chosen.<a id="i1150746877-1"/>
The <pre class="code">if</pre> expression results in the chosen value, and the <pre class="code">filename</pre> variable is initialized with 
that value. This code is slightly shorter, but its real advantage is that it uses
a <pre class="code">val</pre> instead of a <pre class="code">var</pre>.  Using a <pre class="code">val</pre> is the functional
style, and it helps you in much the same way
as a <pre class="code">final</pre> variable in Java<a id="i-168967627-1"/>.  It tells readers of the code
that the variable will never change, saving them from
scanning all code in the variable's scope to see if it ever changes.</p>

<p>A second advantage to using a <pre class="code">val</pre> instead of a <pre class="code">var</pre> is that it
better supports <em>equational reasoning</em>.  The introduced
variable is <em>equal</em> to the expression that computes it, assuming
that expression has no side effects.  Thus, any time you are about
to write the variable name, you could instead write the expression.
Instead of <pre class="code">println(filename)</pre>, for example, you could just write this:</p>

<pre>
  println(<code class="vem">if</code>&nbsp;(!args.isEmpty)&nbsp;args(<code class="literal">0</code>)&nbsp;<code class="vem">else</code>&nbsp;<code class="quotedstring">"default.txt"</code>)
</pre>


<p>The choice is yours. You can write it either way.  Using <pre class="code">val</pre>s
helps you safely make this kind of refactoring as your code evolves<a id="i204271861-1"/>
over time.</p>

<div class="callout">


<p><br />
Look for opportunities to use <pre class="code">val</pre>s.  They can make your code both easier to read and
easier to refactor.
<br /></p>

</div>


<h3 id="sec-while-loops">7.2 While loops</h3>


<p>Scala's <pre class="code">while</pre> loop behaves as in other languages.<a id="i852231328-2"/>  It has a condition and a body, and the body is executed
over and over as long as the condition holds
true. <a href="builtin-control-structures.html#lst-gcdloop">Listing 7.2</a> shows an example:</p>

<p><a id="lst-gcdloop"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;gcdLoop(x:&nbsp;<code class="typename">Long</code>,&nbsp;y:&nbsp;<code class="typename">Long</code>):&nbsp;<code class="typename">Long</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;a&nbsp;=&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;b&nbsp;=&nbsp;y
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">while</code>&nbsp;(a&nbsp;!=&nbsp;<code class="literal">0</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;temp&nbsp;=&nbsp;a
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;b&nbsp;<code class="texttt">%</code>&nbsp;a
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;temp
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;b
  &nbsp;&nbsp;}
</pre>


<h5>Listing 7.2 - Calculating greatest common divisor with a <pre class="code">while</pre> loop.</h5>


<p>Scala also has a <pre class="code">do</pre>-<pre class="code">while</pre> loop. This works like the <pre class="code">while</pre> loop except that it tests the condition after the loop body instead of before.<a id="i846768734-1"/>
<a href="builtin-control-structures.html#lst-do-while">Listing 7.3</a> shows a Scala script that uses a <pre class="code">do-while</pre> to echo lines read from the standard input, until
an empty line is entered:
<a id="lst-do-while"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;line&nbsp;=&nbsp;<code class="quotedstring">""</code>
  &nbsp;&nbsp;<code class="vem">do</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;=&nbsp;readLine()
  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"Read:&nbsp;"</code>&nbsp;+&nbsp;line)
  &nbsp;&nbsp;}&nbsp;<code class="vem">while</code>&nbsp;(line&nbsp;!=&nbsp;<code class="quotedstring">""</code>)
</pre>


<h5>Listing 7.3 - Reading from the standard input with <pre class="code">do-while</pre>.<a id="i-504023058-1"/><a id="i-379989681-1"/></h5>


<p>The <pre class="code">while</pre> and <pre class="code">do-while</pre> constructs are called "loops," not expressions, because
they don't result in an interesting value. The type of the result is <pre class="code">Unit</pre>. It turns out
that a value (and in fact, only one value) exists whose type is <pre class="code">Unit</pre>. It is called the <em>unit value</em> and
is written <pre class="code">()</pre>.<a id="i737037269-1"/><a id="i-1932805493-1"/> The existence of <pre class="code">()</pre> is how Scala's <pre class="code">Unit</pre> differs from Java's <pre class="code">void</pre>.
Try this in the interpreter:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;greet()&nbsp;=&nbsp;{&nbsp;println(<code class="quotedstring">"hi"</code>)&nbsp;}
  <code class="output">greet:&nbsp;()Unit</code>
  <br />  scala&gt;&nbsp;()&nbsp;==&nbsp;greet()
  <code class="output">hi</code>
  <code class="output">res0:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>


<p>Because no equals sign precedes its body, <pre class="code">greet</pre> is defined to be a procedure with a result type of <pre class="code">Unit</pre>. Therefore,
<pre class="code">greet</pre> returns the unit value, <pre class="code">()</pre>.
This is confirmed in the next line: comparing the <pre class="code">greet</pre>'s result for equality
with the unit value, <pre class="code">()</pre>, yields <pre class="code">true</pre>.</p>

<p>One other construct that results in the unit value, which is
relevant here,
is reassignment to <pre class="code">var</pre>s. For example, were you to attempt to read lines in Scala using the following
<pre class="code">while</pre> loop idiom from Java (and C and C++), you'll run into trouble:</p>

<pre>
  <code class="vem">var</code>&nbsp;line&nbsp;=&nbsp;<code class="quotedstring">""</code>
  <code class="vem">while</code>&nbsp;((line&nbsp;=&nbsp;readLine())&nbsp;!=&nbsp;<code class="quotedstring">""</code>)&nbsp;<code class="comment">//&nbsp;This&nbsp;doesn't&nbsp;work!</code>
  &nbsp;&nbsp;println(<code class="quotedstring">"Read:&nbsp;"</code>&nbsp;+&nbsp;line)
</pre>


<p>When you compile this code, Scala will give you a warning that comparing values of
type <pre class="code">Unit</pre> and <pre class="code">String</pre> using
<pre class="code">!=</pre> will always yield true. Whereas in Java, assignment results
in the value assigned (in this case a line from the standard input), in Scala assignment<a id="i1918232661-1"/>
always results in the unit value, <pre class="code">()</pre>. Thus, the value of the
assignment "<pre class="code">line</pre>&nbsp;<pre class="code">=</pre>&nbsp;<pre class="code">readLine()</pre>" will always be <pre class="code">()</pre> and never be <pre class="code">""</pre>. As a result,
this <pre class="code">while</pre> loop's condition will never be false, and the loop will, therefore, never terminate.</p>

<p>Because the <pre class="code">while</pre> loop results in no value, it is often left out of pure
functional languages. Such languages have expressions, not loops.
Scala includes the <pre class="code">while</pre> loop nonetheless because sometimes an
imperative solution can be more readable, especially to programmers with
a predominantly imperative background.  For example, if you want to code an
algorithm that repeats a process until some condition changes, a
<pre class="code">while</pre> loop can express it directly while the functional alternative, which
likely uses recursion, may be less obvious to some readers of the code.</p>

<p>For example, <a href="builtin-control-structures.html#lst-gcd-recursive">Listing 7.4</a> shows an alternate way to determine a greatest common divisor
of two numbers.<a href="builtin-control-structures.html#footnotemain7-1">[1]</a>
Given the same two values for <pre class="code">x</pre> and <pre class="code">y</pre>, the <pre class="code">gcd</pre> function shown in <a href="builtin-control-structures.html#lst-gcd-recursive">Listing 7.4</a> will return
the same result as the <pre class="code">gcdLoop</pre> function, shown in <a href="builtin-control-structures.html#lst-gcdloop">Listing 7.2</a>. The difference between these two approaches
is that <pre class="code">gcdLoop</pre> is written in an imperative style, using <pre class="code">var</pre>s and
and a <pre class="code">while</pre> loop, whereas <pre class="code">gcd</pre> is written in  a more functional style that involves
recursion (<pre class="code">gcd</pre> calls itself) and requires no <pre class="code">var</pre>s.</p>

<p><a id="lst-gcd-recursive"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;gcd(x:&nbsp;<code class="typename">Long</code>,&nbsp;y:&nbsp;<code class="typename">Long</code>):&nbsp;<code class="typename">Long</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(y&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;x&nbsp;<code class="vem">else</code>&nbsp;gcd(y,&nbsp;x&nbsp;<code class="texttt">%</code>&nbsp;y)&nbsp;
</pre>


<h5>Listing 7.4 - Calculating greatest common divisor with recursion.</h5>


<p>In general, we recommend you challenge <pre class="code">while</pre> loops in your code
in the same way you challenge <pre class="code">var</pre>s. In fact, <pre class="code">while</pre> loops and <pre class="code">var</pre>s often go hand in hand. 
Because <pre class="code">while</pre> loops don't result in a value, to make any kind of difference to
your program, a <pre class="code">while</pre> loop will usually either need to update <pre class="code">var</pre>s
or perform I/O. You can see
this in action in the <pre class="code">gcdLoop</pre> example shown previously. As that <pre class="code">while</pre> loop
does its business, it updates <pre class="code">var</pre>s <pre class="code">a</pre> and <pre class="code">b</pre>.
Thus, we suggest you be a bit suspicious of <pre class="code">while</pre> loops in your code.
If there isn't a good justification for a particular <pre class="code">while</pre> or <pre class="code">do-while</pre> loop,
try to find a way to do the same thing without it.</p>

<h3 id="sec-for-expressions">7.3 For expressions</h3>


<p>Scala's <pre class="code">for</pre> expression is a Swiss army knife of
iteration<a id="i-207940604-2"/>.  It lets
you combine a few simple ingredients in different ways to express a
wide variety of iterations.  Simple uses enable common tasks such as
iterating through a sequence of integers.  More advanced expressions
can iterate over multiple collections of different kinds, filter
out elements based on arbitrary conditions, and produce new
collections.</p>

<h4>Iteration through collections</h4>


<p>The simplest thing you can do with <pre class="code">for</pre> is to iterate through all
the elements of a collection.  For example, <a href="builtin-control-structures.html#lst-listing-file-names">Listing 7.5</a> shows some code
that prints out all files in the current directory.
The I/O is performed using the Java API.  First, we create a <pre class="code">java.io.File</pre> on the current directory, <pre class="code">"."</pre>, and call its <pre class="code">listFiles</pre> method. This method returns an array of <pre class="code">File</pre> objects, one per directory and file contained in
the current directory. We store the resulting array in the <pre class="code">filesHere</pre> variable.</p>

<p><a id="lst-listing-file-names"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;filesHere&nbsp;=&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">java.io.File</code>(<code class="quotedstring">"."</code>)).listFiles
  <br />  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere)
  &nbsp;&nbsp;&nbsp;&nbsp;println(file)
</pre>


<h5>Listing 7.5 - Listing files in a directory with a <pre class="code">for</pre> expression.</h5>


<p>With the "<pre class="code">file</pre>&nbsp;<pre class="code">&lt;-</pre>&nbsp;<pre class="code">filesHere</pre>" syntax, which is called a <a href="glossary.html#g286956243"><em>generator</em></a>, we 
iterate through the elements of <pre class="code">filesHere</pre>. In each iteration, a new <pre class="code">val</pre> named <pre class="code">file</pre> is initialized with an element value.
The compiler infers the type of <pre class="code">file</pre> to be <pre class="code">File</pre>, because <pre class="code">filesHere</pre> is an <pre class="code">Array[File]</pre>. For each
iteration, the body of the <pre class="code">for</pre> expression, <pre class="code">println(file)</pre>, will be executed. Because <pre class="code">File</pre>'s <pre class="code">toString</pre> method
yields the name of the file or directory, the names of all the files and directories in the current directory will
be printed.</p>

<p>The <pre class="code">for</pre> expression syntax works for any kind of collection, not just arrays.<a href="builtin-control-structures.html#footnotemain7-2">[2]</a> One
convenient special case is the <pre class="code">Range</pre> type, which you briefly saw in
<a href="basic-types-and-operations.html#tab-richops">Table 5.4</a>  <a href="basic-types-and-operations.html#tab-richops">here</a>.  You can create <pre class="code">Range</pre>s using
syntax like "<pre class="code">1</pre>&nbsp;<pre class="code">to</pre>&nbsp;<pre class="code">5</pre>" and can iterate through them with
a <pre class="code">for</pre>.  Here is a simple example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">4</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"Iteration&nbsp;"</code>&nbsp;+&nbsp;i)
  <code class="output">Iteration&nbsp;1</code>
  <code class="output">Iteration&nbsp;2</code>
  <code class="output">Iteration&nbsp;3</code>
  <code class="output">Iteration&nbsp;4</code>
</pre>


<p>If you don't want to include the upper bound of 
the range in the values that are iterated over, use
<pre class="code">until</pre> instead of <pre class="code">to</pre>:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">1</code>&nbsp;until&nbsp;<code class="literal">4</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"Iteration&nbsp;"</code>&nbsp;+&nbsp;i)
  <code class="output">Iteration&nbsp;1</code>
  <code class="output">Iteration&nbsp;2</code>
  <code class="output">Iteration&nbsp;3</code>
</pre>


<p>Iterating through integers like this is common in Scala, but not
nearly as much as in other languages.  In other languages, you might
use this facility to iterate through an array, like this:</p>

<pre>
  <code class="comment">//&nbsp;Not&nbsp;common&nbsp;in&nbsp;Scala...</code>
  <code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;to&nbsp;filesHere.length&nbsp;-&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;println(filesHere(i))
</pre>


<p>This <pre class="code">for</pre> expression introduces a variable <pre class="code">i</pre>, sets it in turn to each integer between
<pre class="code">0</pre> and <pre class="code">filesHere.length</pre>&nbsp;<pre class="code">-</pre>&nbsp;<pre class="code">1</pre>, and executes the body of the <pre class="code">for</pre> expression for
each setting of <pre class="code">i</pre>.  For each setting of <pre class="code">i</pre>, the <pre class="code">i</pre>'th element
of <pre class="code">filesHere</pre> is extracted and processed.</p>

<p>The reason this kind of iteration is less common in Scala is that you
can just iterate over the collection directly. When you do, your code becomes shorter and you sidestep many of the off-by-one errors that can arise when
iterating through arrays.  Should you start at 0 or 1?  Should you add
-1, +1, or nothing to the final index?  Such questions are easily
answered, but also easily answered wrong.  It is safer to avoid such
questions entirely.</p>

<h4>Filtering</h4>


<p>Sometimes you don't want to iterate through a collection in its
entirety;<a id="i1946581356-1"/> you want to filter it down to some subset.  You can do this with a <pre class="code">for</pre> expression by adding a <a href="glossary.html#g-1274492040"><em>filter</em></a>, an <pre class="code">if</pre> clause inside the <pre class="code">for</pre>'s parentheses.  For example, the code shown in <a href="builtin-control-structures.html#lst-list-scala-files">Listing 7.6</a> lists only those
files in the current directory whose names end with "<span class="texttt">.scala</span>":</p>

<p><a id="lst-list-scala-files"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;filesHere&nbsp;=&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">java.io.File</code>(<code class="quotedstring">"."</code>)).listFiles
  <br />  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere&nbsp;<code class="vem">if</code>&nbsp;file.getName.endsWith(<code class="quotedstring">".scala"</code>))
  &nbsp;&nbsp;&nbsp;&nbsp;println(file)
</pre>


<h5>Listing 7.6 - Finding <pre class="code">.scala</pre> files using a <pre class="code">for</pre> with a filter.</h5>


<p>You could alternatively accomplish the same goal with this code:</p>

<pre>
  <code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere)
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(file.getName.endsWith(<code class="quotedstring">".scala"</code>))
  &nbsp;&nbsp;&nbsp;&nbsp;println(file)
</pre>


<p>This code yields the same output as the previous code, and likely
looks more familiar to programmers with an imperative background.
The imperative form, however, is only an option because this
particular <pre class="code">for</pre> expression is executed for its printing side-effects
and results in the unit value <pre class="code">()</pre>. As demonstrated later
in this section, the <pre class="code">for</pre> expression is called an "expression" because
it can result in an interesting value, a collection whose type is
determined by the <pre class="code">for</pre> expression's <pre class="code">&lt;-</pre> clauses.</p>

<p>You can include more filters if you want.  Just keep adding <pre class="code">if</pre> clauses.
For example, to be extra defensive, the code in <a href="builtin-control-structures.html#lst-list-only-files">Listing 7.7</a> prints only
files and not directories.  It does so by adding a filter that
checks the <pre class="code">file</pre>'s <pre class="code">isFile</pre> method.</p>

<p><a id="lst-list-only-files"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;file&nbsp;&lt;-&nbsp;filesHere
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;file.isFile
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;file.getName.endsWith(<code class="quotedstring">".scala"</code>)
  &nbsp;&nbsp;)&nbsp;println(file)
</pre>


<h5>Listing 7.7 - Using multiple filters in a <pre class="code">for</pre> expression.</h5>


<h4>Nested iteration</h4>


<p>If you add multiple <pre class="code">&lt;-</pre> clauses, you will get nested "loops."
For example, the <pre class="code">for</pre> expression shown in <a href="builtin-control-structures.html#lst-nested-iteration">Listing 7.8</a> has two nested loops.  The outer
loop iterates through <pre class="code">filesHere</pre>, and the inner loop iterates through
<pre class="code">fileLines(file)</pre> for any <pre class="code">file</pre> that ends with <span class="texttt">.scala</span>.</p>

<p><a id="lst-nested-iteration"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;fileLines(file:&nbsp;<code class="typename">java.io.File</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;scala.io.Source.fromFile(file).getLines().toList
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;grep(pattern:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file&nbsp;&lt;-&nbsp;filesHere
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;file.getName.endsWith(<code class="quotedstring">".scala"</code>);
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;&lt;-&nbsp;fileLines(file)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;line.trim.matches(pattern)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;println(file&nbsp;+&nbsp;<code class="quotedstring">":&nbsp;"</code>&nbsp;+&nbsp;line.trim)
  <br />  &nbsp;&nbsp;grep(<code class="quotedstring">".*gcd.*"</code>)
</pre>


<h5>Listing 7.8 - Using multiple generators in a <pre class="code">for</pre> expression.</h5>


<p><a id="exa-for-semicolon-explanation"/>
If you prefer, you can use curly braces instead of parentheses
to surround the generators and filters.
One advantage to using curly braces is that you can leave off some of the semicolons that
are needed when you use parentheses because, as explained in <a href="classes-and-objects.html#sec-semicolon-inf">Section 4.2</a>, the Scala compiler will
not infer semicolons while inside parentheses.<a id="i-597205837-1"/><a id="i-1905470655-1"/></p>

<h4>Mid-stream variable bindings</h4>


<p>Note that the previous code repeats the expression <pre class="code">line.trim</pre>.
This is a non-trivial computation, so you might want to
only compute it once.  You can do this by binding the
result to a new variable using an equals sign (<pre class="code">=</pre>).  The bound variable is
introduced and used just like a <pre class="code">val</pre>, only with the <pre class="code">val</pre>
keyword left out.<a id="i1392088405-1"/><a id="i31167931-1"/> <a href="builtin-control-structures.html#lst-mid-stream-assignment">Listing 7.9</a> shows an example.</p>

<p><a id="lst-mid-stream-assignment"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;grep(pattern:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file&nbsp;&lt;-&nbsp;filesHere
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;file.getName.endsWith(<code class="quotedstring">".scala"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;&lt;-&nbsp;fileLines(file)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trimmed&nbsp;=&nbsp;line.trim
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;trimmed.matches(pattern)&nbsp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;println(file&nbsp;+&nbsp;<code class="quotedstring">":&nbsp;"</code>&nbsp;+&nbsp;trimmed)
  <br />  &nbsp;&nbsp;grep(<code class="quotedstring">".*gcd.*"</code>)
</pre>


<h5>Listing 7.9 - Mid-stream assignment in a <pre class="code">for</pre> expression.</h5>


<p>In <a href="builtin-control-structures.html#lst-mid-stream-assignment">Listing 7.9</a>, a variable named <pre class="code">trimmed</pre> is introduced halfway
through the <pre class="code">for</pre> expression.  That variable is initialized to the
result of <pre class="code">line.trim</pre>.  The rest of the <pre class="code">for</pre> expression then uses the
new variable in two places, once in an <pre class="code">if</pre> and once in
<pre class="code">println</pre>.</p>

<h4>Producing a new collection</h4>


<p>While all of the examples so far have operated on the iterated
values and then forgotten them, you can also generate a value to
remember for each iteration.  To do so, you prefix the body of
the <pre class="code">for</pre> expression by the keyword <pre class="code">yield</pre>.<a id="i1145887345-1"/>  For example,
here is a function that identifies the <pre class="code">.scala</pre> files and
stores them in an array:</p>

<pre>
  <code class="vem">def</code>&nbsp;scalaFiles&nbsp;=
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;file&nbsp;&lt;-&nbsp;filesHere
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;file.getName.endsWith(<code class="quotedstring">".scala"</code>)
  &nbsp;&nbsp;}&nbsp;<code class="vem">yield</code>&nbsp;file
</pre>


<p>Each time the body of the <pre class="code">for</pre> expression executes, it produces
one value, in this case simply <pre class="code">file</pre>.  When the <pre class="code">for</pre> expression
completes, the result will include all of the yielded values contained in a single
collection.
The type of the resulting collection is based on the kind of
collections processed in the iteration clauses.  In this case the
result is an <pre class="code">Array[File]</pre>, because <pre class="code">filesHere</pre> is an array and the type of the yielded expression is <pre class="code">File</pre>.</p>

<p>Be careful, by the way, where you place the <pre class="code">yield</pre> keyword.
The syntax of a <pre class="code">for</pre>-<pre class="code">yield</pre> expression is like this:</p>

<pre>
  <code class="vem">for</code>&nbsp;<i>clauses</i>&nbsp;<code class="vem">yield</code>&nbsp;<i>body</i>
</pre>


<p>The <pre class="code">yield</pre> goes before the entire body.  Even if the body is a
block surrounded by curly braces, put the <pre class="code">yield</pre> before the first
curly brace, not before the last expression of the block.  Avoid
the temptation to write things like this:</p>

<pre>
  <code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere&nbsp;<code class="vem">if</code>&nbsp;file.getName.endsWith(<code class="quotedstring">".scala"</code>))&nbsp;{
  &nbsp;&nbsp;<code class="vem">yield</code>&nbsp;file&nbsp;&nbsp;<code class="comment">//&nbsp;Syntax&nbsp;error!</code>
  }
</pre>


<p>For example, the <pre class="code">for</pre> expression shown in <a href="builtin-control-structures.html#lst-transforming-an-array">Listing 7.10</a> first transforms
the <pre class="code">Array[File]</pre> named <pre class="code">filesHere</pre>, which contains all files in the current directory, to one that contains only <pre class="code">.scala</pre> files.
For each of these it generates an <pre class="code">Iterator[String]</pre>, the result of the <pre class="code">fileLines</pre> method, whose definition is shown in
<a href="builtin-control-structures.html#lst-nested-iteration">Listing 7.8</a>. An <pre class="code">Iterator</pre> offers methods <pre class="code">next</pre> and <pre class="code">hasNext</pre> that allow you to iterate over
a collection of elements. This initial iterator is transformed into another <pre class="code">Iterator[String]</pre> containing only trimmed lines that include
the substring <pre class="code">"for"</pre>. Finally, for each of these, an integer length is yielded. The result of this <pre class="code">for</pre> expression is
an <pre class="code">Array[Int]</pre> containing those lengths.</p>

<p><a id="lst-transforming-an-array"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;forLineLengths&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file&nbsp;&lt;-&nbsp;filesHere
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;file.getName.endsWith(<code class="quotedstring">".scala"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;&lt;-&nbsp;fileLines(file)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trimmed&nbsp;=&nbsp;line.trim
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;trimmed.matches(<code class="quotedstring">".*for.*"</code>)&nbsp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<code class="vem">yield</code>&nbsp;trimmed.length
</pre>


<h5>Listing 7.10 - Transforming an <pre class="code">Array[File]</pre> to <pre class="code">Array[Int]</pre> with a <pre class="code">for</pre>.</h5>


<p>At this point, you have seen all the major features of Scala's
<pre class="code">for</pre> expression, but we went through them rather quickly. A
more thorough coverage of <pre class="code">for</pre> expressions is given in
<a href="for-expressions-revisited.html">Chapter 23</a>.</p>

<h3 id="sec-try-expressions">7.4 Exception handling with <pre class="code">try</pre> expressions</h3>


<p>Scala's exceptions behave just like in many other
languages.<a id="i668047766-1"/><a id="i-60007022-1"/>  Instead<a id="i147418614-1"/>
of returning a value in the normal way, a method can terminate by
throwing an exception.  The method's caller can either catch and
handle that exception, or it can itself simply terminate, in which
case the exception propagates to the caller's caller.  The exception
propagates in this way, unwinding the call stack, until a method<a id="i2050330638-1"/>
handles it or there are no more methods left.</p>

<h4>Throwing exceptions</h4>


<p>Throwing an exception in Scala looks the same as in Java. You create an
exception object and then throw it with the <pre class="code">throw</pre> keyword:</p>

<pre>
  <code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IllegalArgumentException</code>
</pre>


<p>Although it may seem somewhat paradoxical, in Scala, <pre class="code">throw</pre> is an expression
that has a result type.<a id="i44952225-1"/><a id="i958036312-1"/>
Here's an example where result type matters:</p>

<pre>
  <code class="vem">val</code>&nbsp;half&nbsp;=
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(n&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">2</code>&nbsp;==&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;/&nbsp;<code class="literal">2</code>
  &nbsp;&nbsp;<code class="vem">else</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">RuntimeException</code>(<code class="quotedstring">"n&nbsp;must&nbsp;be&nbsp;even"</code>)
</pre>


<p>What happens here is that if <pre class="code">n</pre> is even, <pre class="code">half</pre> will be initialized
to half of <pre class="code">n</pre>.  If <pre class="code">n</pre> is not even, an exception will be
thrown before <pre class="code">half</pre> can be initialized to anything at all.  Because
of this, it is safe to treat a thrown exception as any kind of value
whatsoever.  Any context that tries to use the return from a <pre class="code">throw</pre>
will never get to do so, and thus no harm will come.</p>

<p>Technically, an exception throw has type <pre class="code">Nothing</pre>.
You can use
a <pre class="code">throw</pre> as an expression even though it will never actually evaluate
to anything.  This little bit of technical gymnastics might sound
weird, but is frequently useful in cases like the previous example.  One
branch of an <pre class="code">if</pre> computes a value, while the other throws an
exception and computes <pre class="code">Nothing</pre>.  The type of the whole
<pre class="code">if</pre> expression is then the type of that branch which does compute
something.  Type <pre class="code">Nothing</pre> is discussed further in <a href="scalas-hierarchy.html#sec-bottom-types">Section 11.3</a>.</p>

<h4>Catching exceptions</h4>


<p>You catch exceptions using the syntax shown in <a href="builtin-control-structures.html#lst-try-catch-syntax">Listing 7.11</a>
The syntax for <pre class="code">catch</pre> clauses was chosen for its consistency with an important
part of Scala: <em>pattern matching</em>.<a id="i-2116566913-1"/>  Pattern matching, a powerful feature, is described briefly in this chapter and in more detail in
<a href="case-classes-and-pattern-matching.html">Chapter 15</a><a id="i692796846-1"/>.</p>

<p><a id="lst-try-catch-syntax"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;java.io.FileReader
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;java.io.FileNotFoundException
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;java.io.IOException
  <br />  &nbsp;&nbsp;<code class="vem">try</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;f&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">FileReader</code>(<code class="quotedstring">"input.txt"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Use&nbsp;and&nbsp;close&nbsp;file</code>
  &nbsp;&nbsp;}&nbsp;<code class="vem">catch</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;ex:&nbsp;<code class="typename">FileNotFoundException</code>&nbsp;=&gt;&nbsp;<code class="comment">//&nbsp;Handle&nbsp;missing&nbsp;file</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;ex:&nbsp;<code class="typename">IOException</code>&nbsp;=&gt;&nbsp;<code class="comment">//&nbsp;Handle&nbsp;other&nbsp;I/O&nbsp;error</code>
  &nbsp;&nbsp;}
</pre>


<h5>Listing 7.11 - A <pre class="code">try-catch</pre> clause in Scala.</h5>


<p>The behavior of this <pre class="code">try</pre>-<pre class="code">catch</pre> expression is the same as in other<a id="i-1329663144-1"/>
languages with exceptions.
The body is executed, and if it throws an
exception, each <pre class="code">catch</pre> clause is tried in turn.  In this example, if
the exception is of type <pre class="code">FileNotFoundException</pre>, the first clause will
execute.  If it is of type <pre class="code">IOException</pre>, the second clause
will execute.  If the exception is of neither type, the
<pre class="code">try</pre>-<pre class="code">catch</pre> will terminate and the exception will propagate
further.</p>

<div class="note">
<h4>Note</h4>
One difference you'll quickly notice in Scala is that, unlike Java, Scala does not require you
to catch checked exceptions or declare them in a throws clause. You can
declare a throws clause if you wish with the <pre class="code">@</pre><pre class="code">throws</pre> annotation,
but it is not required. See<a id="i1490895901-1"/>
<a href="combining-scala-and-java.html#sec-annotations">Section 31.2</a> for more information on <pre class="code">@</pre><pre class="code">throws</pre>.


</div>


<h4>The <pre class="code">finally</pre> clause</h4>


<p>You can wrap an expression with a <pre class="code">finally</pre> clause
if you want to cause some code to execute no matter how the expression
terminates.<a id="i-86518969-1"/>  For example, you might want to be sure an open file
gets closed even if a method exits by throwing an exception. <a href="builtin-control-structures.html#lst-try-finally-syntax">Listing 7.12</a> shows an example.<a href="builtin-control-structures.html#footnotemain7-3">[3]</a></p>

<p><a id="lst-try-finally-syntax"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;java.io.FileReader
  <br />  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;file&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">FileReader</code>(<code class="quotedstring">"input.txt"</code>)
  &nbsp;&nbsp;<code class="vem">try</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Use&nbsp;the&nbsp;file</code>
  &nbsp;&nbsp;}&nbsp;<code class="vem">finally</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;file.close()&nbsp;&nbsp;<code class="comment">//&nbsp;Be&nbsp;sure&nbsp;to&nbsp;close&nbsp;the&nbsp;file</code>
  &nbsp;&nbsp;}
</pre>


<h5>Listing 7.12 - A <pre class="code">try-finally</pre> clause in Scala.</h5>


<div class="note">
<h4>Note</h4>


<p><a href="builtin-control-structures.html#lst-try-finally-syntax">Listing 7.12</a> shows the idiomatic way to ensure a non-memory resource, such as
a file, socket, or database connection, is closed. First you acquire the resource. Then you start a <pre class="code">try</pre> block in
which you use the resource. Lastly, you close the resource in a <pre class="code">finally</pre> block. This idiom is the same in Scala as
in Java; alternatively, in Scala you can employ a technique called the <em>loan pattern</em><a id="i-531276704-1"/><a id="i850457101-1"/> to achieve the
same goal more concisely. The loan pattern will be described in <a href="control-abstraction.html#sec-control-structures">Section 9.4</a>.<a id="i-1122723055-1"/><a id="i-330150415-1"/><a id="i193663324-1"/></p>

</div>


<h4>Yielding a value</h4>


<p>As with most other Scala control structures,
<pre class="code">try</pre>-<pre class="code">catch</pre>-<pre class="code">finally</pre> results in a value.  For example, <a href="builtin-control-structures.html#lst-catch-yielding-value">Listing 7.13</a> shows how
you can try to parse a URL but use a default value if the URL is badly
formed.
The result is that of the <pre class="code">try</pre> clause if no exception is
thrown, or the relevant <pre class="code">catch</pre> clause if an exception is thrown and
caught.  If an exception is thrown but not caught, the expression
has no result at all.  The value computed in the <pre class="code">finally</pre> clause,
if there is one, is dropped.
Usually <pre class="code">finally</pre> clauses do some kind of
clean up, such as closing a file. Normally, they should not change the value computed in the main body or a <pre class="code">catch</pre> clause of the <pre class="code">try</pre>.</p>

<p><a id="lst-catch-yielding-value"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;java.net.URL
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;java.net.MalformedURLException
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;urlFor(path:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">try</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;URL(path)
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<code class="vem">catch</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;e:&nbsp;<code class="typename">MalformedURLException</code>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;URL(<code class="quotedstring">"http://www.scala-lang.org"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
</pre>


<h5>Listing 7.13 - A <pre class="code">catch</pre> clause that yields a value.</h5>


<p>If you're familiar with Java, it's worth noting that Scala's behavior differs from Java only because
Java's <pre class="code">try-finally</pre> does not result in a value. As in Java, if a <pre class="code">finally</pre> clause includes an explicit
return statement, or throws an exception, that return value or exception will "overrule" any previous
one that originated in the <pre class="code">try</pre> block or one of its <pre class="code">catch</pre> clauses.
For example, given this, rather contrived, function definition:</p>

<pre>
  <code class="vem">def</code>&nbsp;f():&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;<code class="vem">try</code>&nbsp;<code class="vem">return</code>&nbsp;<code class="literal">1</code>&nbsp;<code class="vem">finally</code>&nbsp;<code class="vem">return</code>&nbsp;<code class="literal">2</code>
</pre>


<p>calling <pre class="code">f()</pre> results in 2.  By contrast, given:</p>

<pre>
  <code class="vem">def</code>&nbsp;g():&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;<code class="vem">try</code>&nbsp;<code class="literal">1</code>&nbsp;<code class="vem">finally</code>&nbsp;<code class="literal">2</code>
</pre>


<p>calling <pre class="code">g()</pre> results in 1. Both of these functions exhibit behavior that could surprise most programmers, so it's usually best
to avoid returning values from <pre class="code">finally</pre> clauses.  The best way to think of <pre class="code">finally</pre> clauses is as a way to ensure some
side effect happens, such as closing an open file.</p>

<h3 id="sec-match-expressions">7.5 Match expressions</h3>


<p>Scala's <pre class="code">match</pre> expression lets you select from a number
of <a href="glossary.html#g-196794451"><em>alternatives</em></a>,<a id="i1524854239-1"/> 
just like <pre class="code">switch</pre> statements<a id="i-1502876100-1"/> in other languages.
In general a <pre class="code">match</pre> expression lets you select using arbitrary
<em>patterns</em>, which will be described in
<a href="case-classes-and-pattern-matching.html">Chapter 15</a>.  
The general form can wait.
For now, just consider using <pre class="code">match</pre> to select among a number
of alternatives.<a id="i-440612313-1"/><a id="i-1073471110-1"/></p>

<p>As an example, the script in <a href="builtin-control-structures.html#lst-match-with-side-effects">Listing 7.14</a> reads a food name from the argument
list and prints a companion to that food.
This <pre class="code">match</pre> expression examines <pre class="code">firstArg</pre>, which has been set to
the first argument out of the argument list.  If it is the string
<pre class="code">"salt"</pre>, it prints <pre class="code">"pepper"</pre>, while if it is the string <pre class="code">"chips"</pre>, it
prints <pre class="code">"salsa"</pre>, and so on.  The default case is specified with an
underscore (<pre class="code">_</pre>), a wildcard symbol frequently used in Scala as a placeholder
for a completely unknown value<a id="i2028498488-1"/>.</p>

<p><a id="lst-match-with-side-effects"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;firstArg&nbsp;=&nbsp;<code class="vem">if</code>&nbsp;(args.length&nbsp;&gt;&nbsp;<code class="literal">0</code>)&nbsp;args(<code class="literal">0</code>)&nbsp;<code class="vem">else</code>&nbsp;<code class="quotedstring">""</code>
  <br />  &nbsp;&nbsp;firstArg&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="quotedstring">"salt"</code>&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"pepper"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="quotedstring">"chips"</code>&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"salsa"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="quotedstring">"eggs"</code>&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"bacon"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"huh?"</code>)
  &nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</pre>


<h5>Listing 7.14 - A <pre class="code">match</pre> expression with side effects.</h5>


<p>There are a few important differences from Java's <pre class="code">switch</pre> statement.
One is that any kind of constant, as well as other things, can be used in
cases in Scala, not just the integer-type,
enum, and string constants of Java's case statements.  In
<a href="builtin-control-structures.html#lst-match-with-side-effects">Listing 7.14</a>, the alternatives are strings.  Another difference is that
there are no <pre class="code">break</pre>s<a id="i544483331-1"/> at the end of each alternative.  Instead
the <pre class="code">break</pre> is implicit, and there is no fall through from one 
alternative to the next.  The common case&mdash;not falling
through&mdash;becomes shorter, and a source of errors is avoided because
programmers can no longer fall through by accident.<a id="i1689875656-1"/></p>

<p>The most significant difference from Java's <pre class="code">switch</pre>, however, may be
that <pre class="code">match</pre> expressions result in a value.  In the
previous example, each alternative in the <pre class="code">match</pre> expression prints out
a value.  It would work just as well to yield the value rather than
print it, as shown in <a href="builtin-control-structures.html#lst-match-expression">Listing 7.15</a>.
The value that results from this <pre class="code">match</pre> expression  is stored in the
<pre class="code">friend</pre> variable.  Aside from the code getting shorter (in number
of tokens anyway), the code now disentangles two separate concerns:
first it chooses a food and then prints it.</p>

<p><a id="lst-match-expression"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;firstArg&nbsp;=&nbsp;<code class="vem">if</code>&nbsp;(!args.isEmpty)&nbsp;args(<code class="literal">0</code>)&nbsp;<code class="vem">else</code>&nbsp;<code class="quotedstring">""</code>
  <br />  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;friend&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;firstArg&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="quotedstring">"salt"</code>&nbsp;=&gt;&nbsp;<code class="quotedstring">"pepper"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="quotedstring">"chips"</code>&nbsp;=&gt;&nbsp;<code class="quotedstring">"salsa"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="quotedstring">"eggs"</code>&nbsp;=&gt;&nbsp;<code class="quotedstring">"bacon"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="quotedstring">"huh?"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <br />  &nbsp;&nbsp;println(friend)
</pre>


<h5>Listing 7.15 - A <pre class="code">match</pre> expression that yields a value.</h5>


<h3>7.6 Living without <pre class="code">break</pre> and <pre class="code">continue</pre><a id="i656795516-1"/><a id="i1665067476-1"/></h3>


<p>You may have noticed that there has been no mention of <pre class="code">break</pre> or
<pre class="code">continue</pre>.  Scala leaves out these commands because they do not mesh
well with function literals, a feature described in the next chapter.  It is
clear what <pre class="code">continue</pre> means inside a <pre class="code">while</pre> loop, but what would it
mean inside a function literal?  While Scala supports both imperative and
functional styles of programming, in this case it leans slightly
towards functional programming in exchange for simplifying the
language.
Do not worry, though.  There are many ways to program without <pre class="code">break</pre>
and <pre class="code">continue</pre>, and if you take advantage
of function literals, those alternatives can often be
shorter than the original code.</p>

<p>The simplest approach is to replace every <pre class="code">continue</pre> by an <pre class="code">if</pre> and
every <pre class="code">break</pre> by a boolean variable.  The boolean variable indicates whether the
enclosing <pre class="code">while</pre> loop should continue.  For example, suppose you are
searching through an argument list for a string that ends with
"<pre class="code">.scala</pre>" but does not start with a hyphen.  In Java you could&mdash;if
you were quite fond of <pre class="code">while</pre> loops, <pre class="code">break</pre>, and <pre class="code">continue</pre>&mdash;write the following:</p>

<pre>
  int&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;This&nbsp;is&nbsp;Java
  boolean&nbsp;foundIt&nbsp;=&nbsp;false;
  while&nbsp;(i&nbsp;&lt;&nbsp;args.length)&nbsp;{
  &nbsp;&nbsp;if&nbsp;(args[i].startsWith("-"))&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;i&nbsp;+&nbsp;1;
  &nbsp;&nbsp;&nbsp;&nbsp;continue;
  &nbsp;&nbsp;}
  &nbsp;&nbsp;if&nbsp;(args[i].endsWith(".scala"))&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;foundIt&nbsp;=&nbsp;true;
  &nbsp;&nbsp;&nbsp;&nbsp;break;
  &nbsp;&nbsp;}
  &nbsp;&nbsp;i&nbsp;=&nbsp;i&nbsp;+&nbsp;1;
  }
</pre>


<p>To transliterate this Java code directly to Scala, instead of doing an <pre class="code">if</pre> and
then a <pre class="code">continue</pre>, you could write an <pre class="code">if</pre> that surrounds the entire
remainder of the <pre class="code">while</pre> loop.  To get rid of the <pre class="code">break</pre>, you would
normally add a boolean variable indicating whether to keep going, but
in this case you can reuse <pre class="code">foundIt</pre>.  Using both of these tricks,
the code ends up looking as shown in <a href="builtin-control-structures.html#lst-looping-without">Listing 7.16</a>.</p>

<p><a id="lst-looping-without"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;i&nbsp;=&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;foundIt&nbsp;=&nbsp;<code class="vem">false</code>
  <br />  &nbsp;&nbsp;<code class="vem">while</code>&nbsp;(i&nbsp;&lt;&nbsp;args.length&nbsp;&amp;&amp;&nbsp;!foundIt)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(!args(i).startsWith(<code class="quotedstring">"-"</code>))&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(args(i).endsWith(<code class="quotedstring">".scala"</code>))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foundIt&nbsp;=&nbsp;<code class="vem">true</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;i&nbsp;+&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;}
</pre>


<h5>Listing 7.16 - Looping without <pre class="code">break</pre> or <pre class="code">continue</pre>.</h5>


<p>This Scala code in <a href="builtin-control-structures.html#lst-looping-without">Listing 7.16</a> is quite similar to the original Java code.  
All the basic pieces are still there and in the
same order. There are two reassignable variables and a <pre class="code">while</pre> loop. Inside the loop, there is a test that <pre class="code">i</pre> is less than <pre class="code">args.length</pre>, a check for
<pre class="code">"-"</pre>, and a check for <pre class="code">".scala"</pre>.</p>

<p>If you wanted to get rid of the <pre class="code">var</pre>s in <a href="builtin-control-structures.html#lst-looping-without">Listing 7.16</a>, one
approach you could try is to rewrite the
loop as a recursive function.  You could, for example, define a <pre class="code">searchFrom</pre> function that takes an integer as an
input, searches forward from there, and then returns the index of the
desired argument.  Using this technique the code would look as shown in <a href="builtin-control-structures.html#lst-recursive-approach">Listing 7.17</a>:</p>

<p><a id="lst-recursive-approach"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;searchFrom(i:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(i&nbsp;&gt;=&nbsp;args.length)&nbsp;-<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;<code class="vem">if</code>&nbsp;(args(i).startsWith(<code class="quotedstring">"-"</code>))&nbsp;searchFrom(i&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;<code class="vem">if</code>&nbsp;(args(i).endsWith(<code class="quotedstring">".scala"</code>))&nbsp;i
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;searchFrom(i&nbsp;+&nbsp;<code class="literal">1</code>)
  <br />  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;i&nbsp;=&nbsp;searchFrom(<code class="literal">0</code>)
</pre>


<h5>Listing 7.17 - A recursive alternative to looping with <pre class="code">var</pre>s.</h5>


<p>The version in <a href="builtin-control-structures.html#lst-recursive-approach">Listing 7.17</a> gives a human-meaningful name to what the function does,
and it uses recursion to substitute for looping.  Each <pre class="code">continue</pre> is
replaced by a recursive call with <pre class="code">i</pre>&nbsp;<pre class="code">+</pre>&nbsp;<pre class="code">1</pre> as the argument,
effectively skipping to the next integer.  Many people find this style
of programming easier to understand, once they get used to the
recursion.</p>

<div class="note">
<h4>Note</h4>


<p>The Scala compiler will not actually emit
a recursive function for the code shown in <a href="builtin-control-structures.html#lst-recursive-approach">Listing 7.17</a>.  Because all of the recursive calls
are in <em>tail-call</em> position, the compiler will generate
code similar to a <pre class="code">while</pre> loop.  Each recursive call will be
implemented as a jump back to the beginning of the function. Tail-call optimization is discussed in <a href="functions-and-closures.html#sec-tail-recursion">Section 8.9</a>.</p>

</div>


<p>If after all this discussion you still feel the need to use <pre class="code">break</pre>,
there's help in Scala's standard library. Class <pre class="code">Breaks</pre><a id="i1129777612-1"/> in package <pre class="code">scala.util.control</pre> offers a <pre class="code">break</pre> method,<a id="i1125528421-1"/> which can be
used to exit an enclosing block that's marked with
<pre class="code">breakable</pre>.<a id="i168968267-1"/> Here is an example how this library-supplied <pre class="code">break</pre>
method could be applied:</p>

<pre>
  <code class="vem">import</code>&nbsp;scala.util.control.Breaks._
  <code class="vem">import</code>&nbsp;java.io._
  <br />  <code class="vem">val</code>&nbsp;in&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">BufferedReader</code>(<code class="vem">new</code>&nbsp;<code class="typename">InputStreamReader</code>(System.in))
  <br />  breakable&nbsp;{
  &nbsp;&nbsp;<code class="vem">while</code>&nbsp;(<code class="vem">true</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"?&nbsp;"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(in.readLine()&nbsp;==&nbsp;<code class="quotedstring">""</code>)&nbsp;break
  &nbsp;&nbsp;}
  }
</pre>


<p>This will repeatedly read non-empty lines from the standard input.
Once the user enters an empty line, control flow exits from the enclosing <pre class="code">breakable</pre>, and with it the while loop.</p>

<p>The <pre class="code">Breaks</pre> class implements <pre class="code">break</pre> by throwing an exception that is caught by an enclosing application of the <pre class="code">breakable</pre>
method. Therefore, the call to <pre class="code">break</pre> does not need to be
in the same method as the call to <pre class="code">breakable</pre>.</p>

<h3 id="sec-variable-scope">7.7 Variable scope</h3>


<p>Now that you've seen Scala's built-in<a id="i46504593-1"/><a id="i-250564140-1"/>
control structures, we'll use them in this section to explain how scoping works in Scala.</p>

<div class="pointofinterest">
<h3>Fast track for Java programmers</h3>


<p>If you're a Java programmer, you'll
find that Scala's scoping rules are almost identical to Java's.
One difference between Java and Scala is that Scala allows you to define variables of the
same name in nested scopes. So if you're a Java programmer, you may wish to at least skim this section.</p>

</div>


<p>Variable declarations in Scala programs have a <em>scope</em> that defines where
you can use the name.
The most common example of scoping is that curly braces generally introduce a new<a id="i-1385018222-1"/><a id="i32772000-1"/>
scope, so anything defined inside curly braces leaves scope after the
final closing brace.<a href="builtin-control-structures.html#footnotemain7-4">[4]</a>
As an illustration, consider the function shown in <a href="builtin-control-structures.html#lst-first-multi-table">Listing 7.18</a>.</p>

<p><a id="lst-first-multi-table"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;printMultiTable()&nbsp;=&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;i&nbsp;=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;only&nbsp;i&nbsp;in&nbsp;scope&nbsp;here</code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">while</code>&nbsp;(i&nbsp;&lt;=&nbsp;<code class="literal">10</code>)&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;j&nbsp;=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;both&nbsp;i&nbsp;and&nbsp;j&nbsp;in&nbsp;scope&nbsp;here</code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">while</code>&nbsp;(j&nbsp;&lt;=&nbsp;<code class="literal">10</code>)&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;prod&nbsp;=&nbsp;(i&nbsp;*&nbsp;j).toString
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;i,&nbsp;j,&nbsp;and&nbsp;prod&nbsp;in&nbsp;scope&nbsp;here</code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;k&nbsp;=&nbsp;prod.length
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;i,&nbsp;j,&nbsp;prod,&nbsp;and&nbsp;k&nbsp;in&nbsp;scope&nbsp;here</code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">while</code>&nbsp;(k&nbsp;&lt;&nbsp;<code class="literal">4</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<code class="quotedstring">"&nbsp;"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;+=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(prod)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;+=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;i&nbsp;and&nbsp;j&nbsp;still&nbsp;in&nbsp;scope;&nbsp;prod&nbsp;and&nbsp;k&nbsp;out&nbsp;of&nbsp;scope</code>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;+=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;i&nbsp;still&nbsp;in&nbsp;scope;&nbsp;j,&nbsp;prod,&nbsp;and&nbsp;k&nbsp;out&nbsp;of&nbsp;scope</code>
  &nbsp;&nbsp;}
</pre>


<h5>Listing 7.18 - Variable scoping when printing a multiplication table.</h5>


<p>The <pre class="code">printMultiTable</pre> function shown in <a href="builtin-control-structures.html#lst-first-multi-table">Listing 7.18</a> prints out a multiplication table.<a href="builtin-control-structures.html#footnotemain7-5">[5]</a>  The
first statement of this function introduces a variable named <pre class="code">i</pre> and
initializes it to the integer 1.  You can then use the name <pre class="code">i</pre>
for the remainder of the function.</p>

<p>The next statement in <pre class="code">printMultiTable</pre> is a <pre class="code">while</pre> loop:</p>

<pre>
  <code class="vem">while</code>&nbsp;(i&nbsp;&lt;=&nbsp;<code class="literal">10</code>)&nbsp;{
  <br />  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;j&nbsp;=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;...
  }
</pre>


<p>You can use <pre class="code">i</pre> here because it is still in scope. In the first
statement inside that <pre class="code">while</pre> loop, you introduce another variable, this
time named <pre class="code">j</pre>, and again initialize it to 1.  Because the variable
<pre class="code">j</pre> was defined inside the open curly brace of the <pre class="code">while</pre> loop, it can
be used only within that <pre class="code">while</pre> loop. If you were to attempt to do
something with <pre class="code">j</pre> after the closing curly brace of this <pre class="code">while</pre> loop,
after the comment that says <pre class="code">j</pre>, <pre class="code">prod</pre>, and <pre class="code">k</pre> are out of
scope, your program would not compile.</p>

<p>All variables defined in this example&mdash;<pre class="code">i</pre>, <pre class="code">j</pre>, <pre class="code">prod</pre>, and
<pre class="code">k</pre>&mdash;are <em>local variables</em>.<a id="i1400207106-1"/><a id="i40385448-1"/>
Such
variables are "local" to the 
function in which they are defined. Each time a function is invoked, a
new set of its local variables is used.</p>

<p>Once a variable is defined, you can't define a new variable with the same name in
the same scope. For example, the following script with two variables named <pre class="code">a</pre> in the same scope would not compile:</p>

<pre>
  <code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;<code class="literal">1</code>
  <code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;<code class="literal">2</code>&nbsp;<code class="comment">//&nbsp;Does&nbsp;not&nbsp;compile</code>
  println(a)
</pre>


<p>You can, on the other hand, define a variable in an inner scope that
has the same name as a variable in an outer scope. The following script
would compile and run:</p>

<pre>
  <code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;<code class="literal">1</code>;
  {
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;<code class="literal">2</code>&nbsp;<code class="comment">//&nbsp;Compiles&nbsp;just&nbsp;fine</code>
  &nbsp;&nbsp;println(a)
  }
  println(a)
</pre>


<p>When executed, the script shown previously would print 2 then 1, because the <pre class="code">a</pre> defined
inside the curly braces is a different variable, which is in scope only until the
closing curly brace.<a href="builtin-control-structures.html#footnotemain7-6">[6]</a> One difference to note between Scala and Java
is that Java will not let you create a variable in an inner scope that has
the same name as a variable in an outer scope. In a Scala program, an inner variable is
said to <em>shadow</em> a like-named outer variable, because the outer variable
becomes invisible in the inner scope.<a id="i1857790361-1"/><a id="i-1451425665-1"/><a id="i-141883422-1"/></p>

<p>You might have already noticed something that looks like shadowing 
in the interpreter:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;<code class="literal">1</code>
  <code class="output">a:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;<code class="literal">2</code>
  <code class="output">a:&nbsp;Int&nbsp;=&nbsp;2</code>
  <br />  scala&gt;&nbsp;println(a)
  <code class="output">2</code>
</pre>


<p>In the interpreter, you can reuse variable names
to your heart's content. Among other things, this allows you to change your mind if
you made a mistake when you defined a variable the first time in the interpreter. 
You can do this because conceptually the interpreter creates a new nested scope
for each new statement you type in. Thus, you could visualize the previous
interpreted code like this:</p>

<pre>
  <code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;<code class="literal">1</code>;
  {
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;<code class="literal">2</code>;
  &nbsp;&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(a)
  &nbsp;&nbsp;}
  }
</pre>


<p>This code will compile and run as a Scala script, and like the code typed into the interpreter,
will print 2. Keep in mind that such code can be very confusing to readers, because variable names
adopt new meanings in nested scopes.
It is usually better to choose a new, meaningful variable name rather than
to shadow an outer variable.</p>

<h3 id="sec-refactoring-imperative-code">7.8 Refactoring imperative-style code</h3>


<p>To help you gain insight into the functional style, in this section we'll refactor the imperative approach
to printing a multiplication table shown in<a id="i892284799-1"/>
<a href="builtin-control-structures.html#lst-first-multi-table">Listing 7.18</a>.<a id="i-2064017764-1"/><a id="i-496550431-1"/> Our functional alternative is
shown in <a href="builtin-control-structures.html#lst-second-multi-table">Listing 7.19</a>.</p>

<p><a id="lst-second-multi-table"/></p>

<pre>
  &nbsp;&nbsp;<code class="comment">//&nbsp;Returns&nbsp;a&nbsp;row&nbsp;as&nbsp;a&nbsp;sequence</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;makeRowSeq(row:&nbsp;<code class="typename">Int</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(col&nbsp;&lt;-&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">10</code>)&nbsp;<code class="vem">yield</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;prod&nbsp;=&nbsp;(row&nbsp;*&nbsp;col).toString
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;padding&nbsp;=&nbsp;<code class="quotedstring">"&nbsp;"</code>&nbsp;*&nbsp;(<code class="literal">4</code>&nbsp;-&nbsp;prod.length)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding&nbsp;+&nbsp;prod
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<code class="comment">//&nbsp;Returns&nbsp;a&nbsp;row&nbsp;as&nbsp;a&nbsp;string</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;makeRow(row:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;makeRowSeq(row).mkString
  <br />  &nbsp;&nbsp;<code class="comment">//&nbsp;Returns&nbsp;table&nbsp;as&nbsp;a&nbsp;string&nbsp;with&nbsp;one&nbsp;row&nbsp;per&nbsp;line</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;multiTable()&nbsp;=&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;tableSeq&nbsp;=&nbsp;<code class="comment">//&nbsp;a&nbsp;sequence&nbsp;of&nbsp;row&nbsp;strings</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(row&nbsp;&lt;-&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">10</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;makeRow(row)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;tableSeq.mkString(<code class="quotedstring">"\n"</code>)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 7.19 - A functional way to create a multiplication table.</h5>


<p>The imperative style reveals itself in <a href="builtin-control-structures.html#lst-first-multi-table">Listing 7.18</a> in two ways. First, invoking
<pre class="code">printMultiTable</pre> has a side effect: printing a multiplication table to the standard output. In
<a href="builtin-control-structures.html#lst-second-multi-table">Listing 7.19</a>, we refactored the function so that it returns the multiplication table
as a string. Since the function no longer prints, we renamed it <pre class="code">multiTable</pre>.
As mentioned previously, one advantage of side-effect-free functions is they are easier to unit test.<a id="i-2030836876-2"/><a id="i808305838-1"/> To
test <pre class="code">printMultiTable</pre>, you would need to somehow redefine <pre class="code">print</pre> and <pre class="code">println</pre> so you could check the 
output for correctness. You could test <pre class="code">multiTable</pre> more easily by checking its string result.</p>

<p>The other telltale sign of the imperative style in <pre class="code">printMultiTable</pre> is its <pre class="code">while</pre> loop
and <pre class="code">var</pre>s. By contrast, the <pre class="code">multiTable</pre> function 
uses <pre class="code">val</pre>s, <pre class="code">for</pre> expressions, <a href="glossary.html#g-59832310"><em>helper functions</em></a>, and calls to <pre class="code">mkString</pre>.</p>

<p>We factored out the two helper functions, <pre class="code">makeRow</pre> and <pre class="code">makeRowSeq</pre>, to make the code easier
to read. Function <pre class="code">makeRowSeq</pre> uses a <pre class="code">for</pre> expression whose
generator iterates through column numbers 1 through 10. 
The body of this <pre class="code">for</pre> calculates the product of row and column, determines the 
padding needed for the product, and yields the result of concatenating the padding and product strings.
The result of the <pre class="code">for</pre> expression will be a sequence (some
subclass of <pre class="code">scala.Seq</pre>) containing these yielded strings as elements.
The other helper function, <pre class="code">makeRow</pre>, simply invokes <pre class="code">mkString</pre> on the result returned by <pre class="code">makeRowSeq</pre>. <pre class="code">mkString</pre> will concatenate the strings in the sequence and return them as one string.</p>

<p>The <pre class="code">multiTable</pre> method first initializes <pre class="code">tableSeq</pre> with the result of a <pre class="code">for</pre> expression whose generator
iterates through row numbers 1 to 10, and for each calls <pre class="code">makeRow</pre> to get the string for that row. This string is
yielded; thus the result of this <pre class="code">for</pre> expression will be a sequence of row strings. The only remaining task is to convert the sequence of strings into a single string. The call to <pre class="code">mkString</pre> accomplishes this, and because we pass <pre class="code">"\n"</pre>, we get an end of line character inserted between each string. If you pass the string returned by
<pre class="code">multiTable</pre> to <pre class="code">println</pre>, you'll see the same output that's produced by calling <pre class="code">printMultiTable</pre>.</p>

<div style="page-break-after:always"/>


<div style="text-align: center">


<p><pre class="code">&nbsp;1&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10</pre><br />
<pre class="code">&nbsp;2&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;10&nbsp;&nbsp;12&nbsp;&nbsp;14&nbsp;&nbsp;16&nbsp;&nbsp;18&nbsp;&nbsp;20</pre><br />
<pre class="code">&nbsp;3&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;12&nbsp;&nbsp;15&nbsp;&nbsp;18&nbsp;&nbsp;21&nbsp;&nbsp;24&nbsp;&nbsp;27&nbsp;&nbsp;30</pre><br />
<pre class="code">&nbsp;4&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;12&nbsp;&nbsp;16&nbsp;&nbsp;20&nbsp;&nbsp;24&nbsp;&nbsp;28&nbsp;&nbsp;32&nbsp;&nbsp;36&nbsp;&nbsp;40</pre><br />
<pre class="code">&nbsp;5&nbsp;&nbsp;10&nbsp;&nbsp;15&nbsp;&nbsp;20&nbsp;&nbsp;25&nbsp;&nbsp;30&nbsp;&nbsp;35&nbsp;&nbsp;40&nbsp;&nbsp;45&nbsp;&nbsp;50</pre><br />
<pre class="code">&nbsp;6&nbsp;&nbsp;12&nbsp;&nbsp;18&nbsp;&nbsp;24&nbsp;&nbsp;30&nbsp;&nbsp;36&nbsp;&nbsp;42&nbsp;&nbsp;48&nbsp;&nbsp;54&nbsp;&nbsp;60</pre><br />
<pre class="code">&nbsp;7&nbsp;&nbsp;14&nbsp;&nbsp;21&nbsp;&nbsp;28&nbsp;&nbsp;35&nbsp;&nbsp;42&nbsp;&nbsp;49&nbsp;&nbsp;56&nbsp;&nbsp;63&nbsp;&nbsp;70</pre><br />
<pre class="code">&nbsp;8&nbsp;&nbsp;16&nbsp;&nbsp;24&nbsp;&nbsp;32&nbsp;&nbsp;40&nbsp;&nbsp;48&nbsp;&nbsp;56&nbsp;&nbsp;64&nbsp;&nbsp;72&nbsp;&nbsp;80</pre><br />
<pre class="code">&nbsp;9&nbsp;&nbsp;18&nbsp;&nbsp;27&nbsp;&nbsp;36&nbsp;&nbsp;45&nbsp;&nbsp;54&nbsp;&nbsp;63&nbsp;&nbsp;72&nbsp;&nbsp;81&nbsp;&nbsp;90</pre><br />
<pre class="code">10&nbsp;&nbsp;20&nbsp;&nbsp;30&nbsp;&nbsp;40&nbsp;&nbsp;50&nbsp;&nbsp;60&nbsp;&nbsp;70&nbsp;&nbsp;80&nbsp;&nbsp;90&nbsp;100</pre><br /></p>

</div>


<h3>7.9 Conclusion</h3>


<p>Scala's built-in control structures are minimal, but they do the job.
They act much like their imperative equivalents, but because they tend
to result in a value, they support a functional style, too.  Just as
important, they are careful in what they omit, thus leaving room for
one of Scala's most powerful features, the function literal, which will be
described in the next chapter.</p>

<hr/>
<h4>Footnotes for Chapter 7:</h4>


<p><a id="footnotemain7-1"/>[1] The <pre class="code">gcd</pre> function shown in <a href="builtin-control-structures.html#lst-gcd-recursive">Listing 7.4</a> uses the same approach used by the like-named function, first shown in 
<a href="functional-objects.html#lst-private-members">Listing 6.3</a>, to calculate greatest common divisors for class <pre class="code">Rational</pre>. The main difference is that instead of <pre class="code">Int</pre>s the <pre class="code">gcd</pre> of
<a href="builtin-control-structures.html#lst-gcd-recursive">Listing 7.4</a> works with <pre class="code">Long</pre>s.</p>

<p><a id="footnotemain7-2"/>[2] To be precise, the expression to the right of the <pre class="code">&lt;-</pre> symbol in a <pre class="code">for</pre> expression can be any type that has certain methods (in this case <pre class="code">foreach</pre>) with appropriate signatures. Details on how the Scala compiler processes <pre class="code">for</pre> expressions are described in <a href="for-expressions-revisited.html">Chapter 23</a>.</p>

<p><a id="footnotemain7-3"/>[3] Although
you must always surround the <pre class="code">case</pre> statements of a <pre class="code">catch</pre> clause in parentheses, 
<pre class="code">try</pre> and <pre class="code">finally</pre> do not require parentheses if they contain only one expression.
For example, you could write: <pre class="code">try</pre>&nbsp;<pre class="code">t()</pre>&nbsp;<pre class="code">catch</pre>&nbsp;<pre class="code">{</pre>&nbsp;<pre class="code">case</pre>&nbsp;<pre class="code">e:</pre>&nbsp;<pre class="code">Exception</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">...</pre>&nbsp;<pre class="code">}</pre>&nbsp;<pre class="code">finally</pre>&nbsp;<pre class="code">f()</pre>.</p>

<p><a id="footnotemain7-4"/>[4] There are a few exceptions to this rule because in Scala you can sometimes use curly braces in place of parentheses.
One example of this kind of curly-brace use is the alternative <pre class="code">for</pre> expression
syntax described in <a href="builtin-control-structures.html#sec-for-expressions">Section 7.3</a>.</p>

<p><a id="footnotemain7-5"/>[5] The
<pre class="code">printMultiTable</pre> function shown in <a href="builtin-control-structures.html#lst-first-multi-table">Listing 7.18</a> is written in an imperative style. We'll refactor it into a functional style in the next section.</p>

<p><a id="footnotemain7-6"/>[6] By the way, the semicolon is required in this case
after the first definition of <pre class="code">a</pre> because Scala's semicolon inference mechanism will
not place one there.</p>

<div style="page-break-after:always"/>


<div style="page-break-after:always"/>

</body>
</html>
