<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8"/>
    <title>Programming in Scala, 3rd Edition</title>

    <link rel="stylesheet" type="text/css" href="book.css" />
  </head>
<body>
<h2><a id="chap-control-abstraction">Chapter 9</a></h2>
<h1>Control Abstraction</h1>


<p>In <a href="builtin-control-structures.html">Chapter 7</a>, we pointed out that Scala doesn't have
many built-in control abstractions because it gives you the ability to create your
own. In the previous chapter, you learned about function values. In this chapter, we'll
show you how to apply function values to create new control abstractions. Along the way, 
you'll also learn about currying and by-name parameters.</p>

<h3 id="sec-reducing-code-dup">9.1 Reducing code duplication</h3>


<p>All functions are separated into common parts, which are the same<a id="i14092899-2"/><a id="i-1950695486-2"/>
in every invocation of the function, and non-common parts, which may vary
from one function invocation to the next. The common parts are in the body of the function, while the
non-common parts must be supplied via arguments.
When you use a function value as an argument, the non-common part of the
algorithm is itself some other algorithm!
At each invocation of such a function, you can pass in a
different function value as an argument, and the invoked function will, at times of
its choosing, invoke the passed function value.  These <em>higher-order functions</em>&mdash;functions
that take functions as parameters&mdash;give
you extra opportunities to condense and simplify code<a id="i1069366433-1"/><a id="i319271759-1"/>.</p>

<p>One benefit of higher-order functions is they enable you to create
control abstractions that allow you to reduce code duplication.
For example, suppose you are writing a file browser,
and you want to provide an API that allows users to search for files matching some
criterion.  First, you add a facility to search for files whose names
end in a particular string. This would enable your users to find, for example, 
all files with a "<span class="texttt">.scala</span>" extension. You could provide
such an API by defining a public <pre class="code">filesEnding</pre> method inside a singleton object like
this:</p>

<pre>
  <code class="vem">object</code>&nbsp;<code class="typename">FileMatcher</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;filesHere&nbsp;=&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">java.io.File</code>(<code class="quotedstring">"."</code>)).listFiles
  <br />  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;filesEnding(query:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere;&nbsp;<code class="vem">if</code>&nbsp;file.getName.endsWith(query))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;file
  }
</pre>


<p>The <pre class="code">filesEnding</pre> method obtains the list of all files in the current directory
using the private helper method <pre class="code">filesHere</pre>, then filters them based on whether each file name
ends with the user-specified query. Given <pre class="code">filesHere</pre> is private, the <pre class="code">filesEnding</pre> method
is the only accessible method defined in 
<pre class="code">FileMatcher</pre>, the API you provide to your users.</p>

<p>So far so good, and there is no repeated code yet.  Later on, though,
you decide to let people search based on any part of the file name.
This is good for when your users cannot remember if they named a file
<span class="texttt">phb-important.doc</span>, <span class="texttt">stupid-phb-report.doc</span>,
<span class="texttt">may2003salesdoc.phb</span>, or something entirely different; they just know that "phb" appears in the name somewhere.  You go 
back to work and add this function to your <pre class="code">FileMatcher</pre> API:</p>

<pre>
  <code class="vem">def</code>&nbsp;filesContaining(query:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere;&nbsp;<code class="vem">if</code>&nbsp;file.getName.contains(query))
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;file
</pre>


<p>This function works just like <pre class="code">filesEnding</pre>.  It searches <pre class="code">filesHere</pre>,
checks the name, and returns the file if the name matches.  The only
difference is that this function uses <pre class="code">contains</pre> instead of
<pre class="code">endsWith</pre>.</p>

<p>The months go by, and the program becomes more successful.
Eventually, you give in to the requests of a few power users who want
to search based on regular expressions.  These sloppy guys have
immense directories with thousands of files, and they would like to do
things like find all "pdf" files that have "oopsla" in the title
somewhere.  To support them, you write this function:</p>

<pre>
  <code class="vem">def</code>&nbsp;filesRegex(query:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere;&nbsp;<code class="vem">if</code>&nbsp;file.getName.matches(query))
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;file
</pre>


<p>Experienced programmers will notice all of this repetition and wonder
if it can be factored into a common helper function.  Doing it the obvious way
does not work, however.  You would like to be able to do the
following:</p>

<pre>
  <code class="vem">def</code>&nbsp;filesMatching(query:&nbsp;<code class="typename">String</code>,&nbsp;<i>method</i>)&nbsp;=
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere;&nbsp;<code class="vem">if</code>&nbsp;file.getName.<i>method</i>(query))
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;file
</pre>


<p>This approach would work in some dynamic languages,
but Scala does not allow pasting together code
at runtime like this.  So what do you do?</p>

<p>Function values provide an answer.<a id="i2141458026-2"/>  While you cannot pass around a method name
as a value, you can get the same effect by passing around a function value
that calls the method for you.  In this case, you could add a
<pre class="code">matcher</pre> parameter to the method whose sole purpose is to check a
file name against a query:</p>

<pre>
  <code class="vem">def</code>&nbsp;filesMatching(query:&nbsp;<code class="typename">String</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;matcher:&nbsp;(<code class="typename">String</code>,&nbsp;<code class="typename">String</code>)&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>)&nbsp;=&nbsp;{
  <br />  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere;&nbsp;<code class="vem">if</code>&nbsp;matcher(file.getName,&nbsp;query))
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;file
  }
</pre>


<p>In this version of the method, the <pre class="code">if</pre> clause now uses <pre class="code">matcher</pre> to
check the file name against the query.  Precisely what this check does
depends on what is specified as the matcher.  Take a look, now, at the type
of <pre class="code">matcher</pre> itself.  It is a function, and thus has a <pre class="code">=&gt;</pre> in the
type.  This function takes two string arguments&mdash;the file name and the
query&mdash;and returns a boolean, so the type of this function is
<pre class="code">(String,</pre>&nbsp;<pre class="code">String)</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">Boolean</pre>.</p>

<p>Given this new <pre class="code">filesMatching</pre> helper method, you can simplify the three
searching methods by having them call the helper method, passing in an
appropriate function:</p>

<pre>
  <code class="vem">def</code>&nbsp;filesEnding(query:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;filesMatching(query,&nbsp;_.endsWith(_))
  <br />  <code class="vem">def</code>&nbsp;filesContaining(query:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;filesMatching(query,&nbsp;_.contains(_))
  <br />  <code class="vem">def</code>&nbsp;filesRegex(query:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;filesMatching(query,&nbsp;_.matches(_))
</pre>


<p>The function literals shown in this example use the placeholder syntax, introduced in the previous chapter,
which may not as yet feel very natural to you.<a id="i1101169360-1"/><a id="i788093512-2"/><a id="i-383997826-2"/><a id="i603770043-2"/>
So here's a clarification of how placeholders are used: The function literal <pre class="code">_.endsWith(_)</pre>, used in the <pre class="code">filesEnding</pre> method,
means the same thing as:</p>

<pre>
  (fileName:&nbsp;<code class="typename">String</code>,&nbsp;query:&nbsp;<code class="typename">String</code>)&nbsp;=&gt;&nbsp;fileName.endsWith(query)
</pre>


<p>Because <pre class="code">filesMatching</pre> takes a function that requires two <pre class="code">String</pre> arguments, you need not specify the types of the arguments; you could just write <pre class="code">(fileName,</pre>&nbsp;<pre class="code">query)</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">fileName.endsWith(query)</pre>. Since the parameters are each used only once in the body of the function (<i>i.e.</i>, the first parameter, <pre class="code">fileName</pre>, is used first in the body, and the second parameter, <pre class="code">query</pre>, is used second), you can use
the placeholder syntax: <pre class="code">_.endsWith(_)</pre>. The first underscore is a placeholder for the first parameter, the file name, and the second underscore a
placeholder for the second parameter, the query string.</p>

<p>This code is already simplified, but it can actually be even shorter.
Notice that the query gets passed to <pre class="code">filesMatching</pre>, but
<pre class="code">filesMatching</pre> does nothing with the query except to pass it back to
the passed <pre class="code">matcher</pre> function.  This passing back and forth is unnecessary because the
caller already knew the query to begin with!  You might as well remove the query parameter from <pre class="code">filesMatching</pre> and <pre class="code">matcher</pre>, thus
simplifying the code as shown in <a href="control-abstraction.html#lst-closures-reduce">Listing 9.1</a>.</p>

<p><a id="lst-closures-reduce"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">FileMatcher</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;filesHere&nbsp;=&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">java.io.File</code>(<code class="quotedstring">"."</code>)).listFiles
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;filesMatching(matcher:&nbsp;<code class="typename">String</code>&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere;&nbsp;<code class="vem">if</code>&nbsp;matcher(file.getName))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;file
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;filesEnding(query:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filesMatching(_.endsWith(query))
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;filesContaining(query:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filesMatching(_.contains(query))
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;filesRegex(query:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filesMatching(_.matches(query))
  &nbsp;&nbsp;}
</pre>


<h5>Listing 9.1 - Using closures to reduce code duplication.</h5>


<p>This example demonstrates the way in which first-class functions can help you eliminate code duplication<a id="i532436688-1"/>
where it would be very difficult to do so without them. In Java, for
example, you could create an interface containing a method that takes one <pre class="code">String</pre> and returns
a <pre class="code">Boolean</pre>, then create and pass anonymous inner class instances that implement this
interface to <pre class="code">filesMatching</pre>. Although this approach would remove the code duplication you are
trying to eliminate, it would, at the same time, add as much or more new code. Thus the benefit is
not worth the cost, and you may as well live with the duplication.</p>

<p>Moreover, this example demonstrates how closures can help you reduce
code duplication<a id="i1093320088-2"/>.
The function literals used in the previous example, such as <pre class="code">_.endsWith(_)</pre> and <pre class="code">_.contains(_)</pre>, are
instantiated at runtime into function values that are <em>not</em> closures because they don't capture any free variables. Both
variables used in the expression, <pre class="code">_.endsWith(_)</pre>, for example, are represented by
underscores, which means they are taken from arguments to the function. Thus, <pre class="code">_.endsWith(_)</pre>
uses two bound variables, and no free variables. By contrast, the function literal <pre class="code">_.endsWith(query)</pre>, used
in the most recent example, contains one bound variable, the argument represented by the underscore,
and one free variable named <pre class="code">query</pre>. It is only because Scala supports closures that you were
able to remove the <pre class="code">query</pre> parameter from <pre class="code">filesMatching</pre> in the most recent example, thereby simplifying the code
even further.</p>

<h3>9.2 Simplifying client code</h3>


<p>The previous example demonstrated that higher-order functions can
help reduce code duplication as you implement an API.  Another important use
of higher-order functions is to put them in an API itself to make client
code more concise. A good example is provided by the special-purpose
looping methods of Scala's collection types.<a href="control-abstraction.html#footnotemain9-1">[1]</a>  
Many of these are listed in
<a href="next-steps-in-scala.html#tab-listmethods">Table 3.1</a> in
<a href="next-steps-in-scala.html">Chapter 3</a>, but take a look at just one
example for now to see why these methods are so useful.</p>

<p>Consider <pre class="code">exists</pre>, a method that determines whether a passed value
is contained in a collection<a id="i1794232640-1"/>.  You could, of course, search for an
element by having a <pre class="code">var</pre> initialized to false, looping through
the collection checking each item, and setting the <pre class="code">var</pre> to true if you
find what you are looking for. Here's a method that uses this
approach to determine whether a passed <pre class="code">List</pre> contains a negative number:</p>

<pre>
  <code class="vem">def</code>&nbsp;containsNeg(nums:&nbsp;<code class="typename">List[Int]</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;exists&nbsp;=&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(num&nbsp;&lt;-&nbsp;nums)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(num&nbsp;&lt;&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;=&nbsp;<code class="vem">true</code>
  &nbsp;&nbsp;exists
  }
</pre>


<p>If you define this method in the interpreter, you can call it like this:</p>

<pre>
  scala&gt;&nbsp;containsNeg(<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">4</code>))
  <code class="output">res0:&nbsp;Boolean&nbsp;=&nbsp;false</code>
  <br />  scala&gt;&nbsp;containsNeg(<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;-<code class="literal">3</code>,&nbsp;<code class="literal">4</code>))
  <code class="output">res1:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>


<p>A more concise way to define the method, though, is by calling the higher-order function <pre class="code">exists</pre> on the
passed <pre class="code">List</pre>, like this:</p>

<pre>
  <code class="vem">def</code>&nbsp;containsNeg(nums:&nbsp;<code class="typename">List[Int]</code>)&nbsp;=&nbsp;nums.exists(_&nbsp;&lt;&nbsp;<code class="literal">0</code>)
</pre>


<p>This version of <pre class="code">containsNeg</pre> yields the same results as the previous:</p>

<pre>
  scala&gt;&nbsp;containsNeg(<code class="typename">Nil</code>)
  <code class="output">res2:&nbsp;Boolean&nbsp;=&nbsp;false</code>
  <br />  scala&gt;&nbsp;containsNeg(<code class="typename">List</code>(<code class="literal">0</code>,&nbsp;-<code class="literal">1</code>,&nbsp;-<code class="literal">2</code>))
  <code class="output">res3:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>


<p>The <pre class="code">exists</pre> method represents a control abstraction.
It is a special-purpose looping construct provided by the Scala
library, rather than built into the Scala language like <pre class="code">while</pre> or
<pre class="code">for</pre>. In the previous section, the higher-order function, <pre class="code">filesMatching</pre>, 
reduces code duplication in the implementation of the <pre class="code">object</pre> <pre class="code">FileMatcher</pre>. The <pre class="code">exists</pre> method provides a similar
benefit, but because <pre class="code">exists</pre> is public in Scala's collections API, the code duplication it reduces is 
client code of that API. If <pre class="code">exists</pre> didn't exist, and you wanted to write a <pre class="code">containsOdd</pre> method to test whether a list contains odd numbers,
you might
write it like this:</p>

<pre>
  <code class="vem">def</code>&nbsp;containsOdd(nums:&nbsp;<code class="typename">List[Int]</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;exists&nbsp;=&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(num&nbsp;&lt;-&nbsp;nums)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(num&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">2</code>&nbsp;==&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;=&nbsp;<code class="vem">true</code>
  &nbsp;&nbsp;exists
  }
</pre>


<p>If you compare the body of <pre class="code">containsNeg</pre> with that of <pre class="code">containsOdd</pre>, you'll find that everything is repeated except
the test condition of an <pre class="code">if</pre> expression. Using <pre class="code">exists</pre>, you could write this instead:</p>

<pre>
  <code class="vem">def</code>&nbsp;containsOdd(nums:&nbsp;<code class="typename">List[Int]</code>)&nbsp;=&nbsp;nums.exists(_&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">2</code>&nbsp;==&nbsp;<code class="literal">1</code>)
</pre>


<p>The body of the code in this version is again identical to the body of the corresponding <pre class="code">containsNeg</pre> method (the version that
uses <pre class="code">exists</pre>), except the condition for which to search is different. Yet the amount of code duplication is much smaller because all of the looping infrastructure
is factored out into the <pre class="code">exists</pre> method itself.</p>

<p>There are many other looping methods in Scala's standard library.
As with <pre class="code">exists</pre>, they can often shorten your code if you recognize
opportunities to use them.</p>

<h3 id="sec-currying">9.3 Currying</h3>


<p>In Chapter 1, we said that Scala allows you to create new control abstractions that "feel like native language support."
Although the examples you've seen so far are indeed control abstractions, it is unlikely anyone would mistake them
for native language support.
To understand how to make control abstractions that feel more like language extensions, you first need to understand the
functional programming technique called <a href="glossary.html#g575993339"><em>currying</em></a>.<a id="i575993339-1"/></p>

<p>A curried function is applied to multiple argument lists, instead of just one. <a href="control-abstraction.html#lst-plain-old-function">Listing 9.2</a> shows a regular, non-curried function, which
adds two <pre class="code">Int</pre> parameters, <pre class="code">x</pre> and <pre class="code">y</pre>.</p>

<p><a id="lst-plain-old-function"/></p>

<pre>
  &nbsp;&nbsp;scala&gt;&nbsp;<code class="vem">def</code>&nbsp;plainOldSum(x:&nbsp;<code class="typename">Int</code>,&nbsp;y:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;x&nbsp;+&nbsp;y
  <code class="output">&nbsp;&nbsp;plainOldSum:&nbsp;(x:&nbsp;Int,&nbsp;y:&nbsp;Int)Int</code>
  <br />  &nbsp;&nbsp;scala&gt;&nbsp;plainOldSum(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">&nbsp;&nbsp;res4:&nbsp;Int&nbsp;=&nbsp;3</code>
</pre>


<h5>Listing 9.2 - Defining and invoking a "plain old" function.</h5>


<p>By contrast, <a href="control-abstraction.html#lst-curried-function">Listing 9.3</a> shows a similar function that's
curried. Instead of one list
of two <pre class="code">Int</pre> parameters, you apply this
function to two lists of one <pre class="code">Int</pre> parameter each.</p>

<p><a id="lst-curried-function"/></p>

<pre>
  &nbsp;&nbsp;scala&gt;&nbsp;<code class="vem">def</code>&nbsp;curriedSum(x:&nbsp;<code class="typename">Int</code>)(y:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;x&nbsp;+&nbsp;y
  <code class="output">&nbsp;&nbsp;curriedSum:&nbsp;(x:&nbsp;Int)(y:&nbsp;Int)Int</code>
  <br />  &nbsp;&nbsp;scala&gt;&nbsp;curriedSum(<code class="literal">1</code>)(<code class="literal">2</code>)
  <code class="output">&nbsp;&nbsp;res5:&nbsp;Int&nbsp;=&nbsp;3</code>
</pre>


<h5>Listing 9.3 - Defining and invoking a curried function.</h5>


<p>What's happening here is that when you invoke <pre class="code">curriedSum</pre>, you actually get two traditional function invocations back to back. 
The first function invocation takes a single <pre class="code">Int</pre> parameter named <pre class="code">x</pre>, and returns a function value for the 
second function. This second function takes the <pre class="code">Int</pre> parameter <pre class="code">y</pre>. Here's a function named <pre class="code">first</pre> that does in spirit
what the first traditional function invocation of <pre class="code">curriedSum</pre> would do:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;first(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;(y:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;y
  <code class="output">first:&nbsp;(x:&nbsp;Int)Int&nbsp;=&gt;&nbsp;Int</code>
</pre>


<p>Applying the first function to <pre class="code">1</pre>&mdash;in other words, invoking the first function and passing in <pre class="code">1</pre>&mdash;yields the second function:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;second&nbsp;=&nbsp;first(<code class="literal">1</code>)
  <code class="output">second:&nbsp;Int&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function1&gt;</code>
</pre>


<p>Applying the second function to <pre class="code">2</pre> yields the result:</p>

<pre>
  scala&gt;&nbsp;second(<code class="literal">2</code>)
  <code class="output">res6:&nbsp;Int&nbsp;=&nbsp;3</code>
</pre>


<p>These <pre class="code">first</pre> and <pre class="code">second</pre> functions are just an illustration of the currying process.
They are not directly connected to the <pre class="code">curriedSum</pre> function. 
Nevertheless, there is a way to get an actual reference to <pre class="code">curriedSum</pre>'s "second" function. You can use
the placeholder notation to use <pre class="code">curriedSum</pre> in a partially applied
function expression, like this:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;onePlus&nbsp;=&nbsp;curriedSum(<code class="literal">1</code>)_
  <code class="output">onePlus:&nbsp;Int&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function1&gt;</code>
</pre>


<p>The underscore in <pre class="code">curriedSum(1)_</pre> is a placeholder for the second
parameter list.<a href="control-abstraction.html#footnotemain9-2">[2]</a><a id="i-877041491-1"/>  The result is a reference to a function
that, when invoked, adds one to its sole <pre class="code">Int</pre> argument and returns the result:</p>

<pre>
  scala&gt;&nbsp;onePlus(<code class="literal">2</code>)
  <code class="output">res7:&nbsp;Int&nbsp;=&nbsp;3</code>
</pre>


<p>And here's how you'd get a function that adds two to its sole <pre class="code">Int</pre> argument:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;twoPlus&nbsp;=&nbsp;curriedSum(<code class="literal">2</code>)_
  <code class="output">twoPlus:&nbsp;Int&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function1&gt;</code>
  <br />  scala&gt;&nbsp;twoPlus(<code class="literal">2</code>)
  <code class="output">res8:&nbsp;Int&nbsp;=&nbsp;4</code>
</pre>


<h3 id="sec-control-structures">9.4 Writing new control structures</h3>


<p>In languages with first-class functions, you can effectively make new 
control structures even though the syntax of the language is fixed.
All you need to do is create methods that take functions as
arguments.</p>

<p>For example, here is the "twice" control structure, which repeats an
operation two times and returns the result:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;twice(op:&nbsp;<code class="typename">Double</code>&nbsp;=&gt;&nbsp;<code class="typename">Double</code>,&nbsp;x:&nbsp;<code class="typename">Double</code>)&nbsp;=&nbsp;op(op(x))
  <code class="output">twice:&nbsp;(op:&nbsp;Double&nbsp;=&gt;&nbsp;Double,&nbsp;x:&nbsp;Double)Double</code>
  <br />  scala&gt;&nbsp;twice(_&nbsp;+&nbsp;<code class="literal">1</code>,&nbsp;<code class="literal">5</code>)
  <code class="output">res9:&nbsp;Double&nbsp;=&nbsp;7.0</code>
</pre>


<p>The type
of <pre class="code">op</pre> in this example is <pre class="code">Double</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">Double</pre>, which means it 
is a function that takes one <pre class="code">Double</pre> as an argument and returns
another <pre class="code">Double</pre>.</p>

<p>Any time you find a control pattern repeated in multiple parts of your
code, you should think about implementing it as a new control
structure.  
Earlier in the chapter you saw <pre class="code">filesMatching</pre>, a very
specialized control pattern.
Consider now a more widely used coding pattern:
open a resource,
operate on it, and then close the resource. You can capture this 
in a control
abstraction using a
method like the following: <a id="exa-first-with-print-writer"/></p>

<pre>
  <code class="vem">def</code>&nbsp;withPrintWriter(file:&nbsp;<code class="typename">File</code>,&nbsp;op:&nbsp;<code class="typename">PrintWriter</code>&nbsp;=&gt;&nbsp;<code class="typename">Unit</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;writer&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PrintWriter</code>(file)
  &nbsp;&nbsp;<code class="vem">try</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;op(writer)
  &nbsp;&nbsp;}&nbsp;<code class="vem">finally</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;writer.close()
  &nbsp;&nbsp;}
  }
</pre>


<p>Given such a method, you can use it like this:</p>

<pre>
  withPrintWriter(
  &nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">File</code>(<code class="quotedstring">"date.txt"</code>),
  &nbsp;&nbsp;writer&nbsp;=&gt;&nbsp;writer.println(<code class="vem">new</code>&nbsp;<code class="typename">java.util.Date</code>)
  )
</pre>


<p>The advantage of using this method is that it's
<pre class="code">withPrintWriter</pre>, not user code, that assures the file is closed at the end.
So it's impossible to forget to close the file.
This technique is called the <em>loan pattern</em>, because a control-abstraction
function, such as <pre class="code">withPrintWriter</pre>, opens a resource and
"loans" it to a function.<a id="i-531276704-2"/><a id="i850457101-2"/><a id="i193663324-2"/> For instance, <pre class="code">withPrintWriter</pre> in the previous example loans a
<pre class="code">PrintWriter</pre> to the function, <pre class="code">op</pre>. When the function completes,
it signals that it no longer needs the "borrowed" resource. The resource is
then closed in a <pre class="code">finally</pre> block, to ensure it is indeed closed, regardless of whether the 
function completes by returning normally or throwing an exception.</p>

<p>One way in which you can make the client code look a bit more like a built-in 
control structure is to use curly braces instead of parentheses to surround
the argument list. In any method invocation in Scala in which you're passing in exactly one argument, you can opt to use curly braces to surround the argument instead of parentheses.<a id="i-2010619769-1"/><a id="i798707221-1"/><a id="i-1201222106-1"/></p>

<p>For example, instead of:</p>

<pre>
  scala&gt;&nbsp;println(<code class="quotedstring">"Hello,&nbsp;world!"</code>)
  <code class="output">Hello,&nbsp;world!</code>
</pre>


<p>You could write:</p>

<pre>
  scala&gt;&nbsp;println&nbsp;{&nbsp;<code class="quotedstring">"Hello,&nbsp;world!"</code>&nbsp;}
  <code class="output">Hello,&nbsp;world!</code>
</pre>


<p>In the second example, you used curly braces instead of parentheses to surround the
arguments to <pre class="code">println</pre>. This curly braces technique will work, however, only if
you're passing in one argument. Here's an attempt at violating that rule:<a id="i724160184-1"/></p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;g&nbsp;=&nbsp;<code class="quotedstring">"Hello,&nbsp;world!"</code>
  <code class="output">g:&nbsp;String&nbsp;=&nbsp;Hello,&nbsp;world!</code>
  <br />  scala&gt;&nbsp;g.substring&nbsp;{&nbsp;<code class="literal">7</code>,&nbsp;<code class="literal">9</code>&nbsp;}
  <code class="output">&lt;console&gt;:1:&nbsp;error:&nbsp;';'&nbsp;expected&nbsp;but&nbsp;','&nbsp;found.</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.substring&nbsp;{&nbsp;7,&nbsp;9&nbsp;}</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>


<p>Because you are attempting to pass in two arguments to <pre class="code">substring</pre>, you get an error when you try to
surround those arguments with curly braces. Instead, you'll need to use parentheses:</p>

<pre>
  scala&gt;&nbsp;g.substring(<code class="literal">7</code>,&nbsp;<code class="literal">9</code>)
  <code class="output">res12:&nbsp;String&nbsp;=&nbsp;wo</code>
</pre>


<p>The purpose of this ability to substitute curly braces for parentheses for passing in
one argument is to enable client programmers to write function literals
between curly braces. This
can make a method call feel more like a control abstraction.
Take the <pre class="code">withPrintWriter</pre> method defined previously as an example.
In its most recent form, <pre class="code">withPrintWriter</pre> takes two arguments, so you can't use
curly braces. Nevertheless, because the function passed to <pre class="code">withPrintWriter</pre>
is the last argument in the list, you can use currying to pull the first argument, the <pre class="code">File</pre>, 
into a separate argument list. This will leave the function as the lone parameter
of the second argument list. <a href="control-abstraction.html#lst-loan-pattern">Listing 9.4</a> shows how you'd need to redefine <pre class="code">withPrintWriter</pre>.</p>

<p><a id="lst-loan-pattern"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;withPrintWriter(file:&nbsp;<code class="typename">File</code>)(op:&nbsp;<code class="typename">PrintWriter</code>&nbsp;=&gt;&nbsp;<code class="typename">Unit</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;writer&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PrintWriter</code>(file)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">try</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;op(writer)
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<code class="vem">finally</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writer.close()
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 9.4 - Using the loan pattern to write to a file.</h5>


<p>The new version differs from the old one only in that there are now two parameter 
lists with one parameter each instead of one parameter list with two parameters. 
Look between the two parameters. In the
previous version of <pre class="code">withPrintWriter</pre>, shown  <a href="control-abstraction.html#exa-first-with-print-writer">here</a>, you see ...<pre class="code">File,</pre>&nbsp;<pre class="code">op</pre>.... But in this
version, you see ...<pre class="code">File)(op</pre>....
Given the above definition, you can call the method with a more
pleasing syntax:</p>

<pre>
  <code class="vem">val</code>&nbsp;file&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">File</code>(<code class="quotedstring">"date.txt"</code>)
  <br />  withPrintWriter(file)&nbsp;{&nbsp;writer&nbsp;=&gt;
  &nbsp;&nbsp;writer.println(<code class="vem">new</code>&nbsp;<code class="typename">java.util.Date</code>)
  }
</pre>


<p>In this example, the first argument list, which contains one <pre class="code">File</pre> argument,
is written surrounded by parentheses. The second argument list, which contains
one function argument, is surrounded by curly braces.</p>

<h3 id="sec-by-name-parameters">9.5 By-name parameters</h3>


<p>The <pre class="code">withPrintWriter</pre> method shown in the previous section differs
from built-in control structures of the language, such as <pre class="code">if</pre>
and <pre class="code">while</pre>, in that the code between the curly braces takes an argument.
The function passed to <pre class="code">withPrintWriter</pre> requires one argument of type <pre class="code">PrintWriter</pre>.
This argument shows up as the "<pre class="code">writer</pre>&nbsp;<pre class="code">=&gt;</pre>" in:</p>

<pre>
  withPrintWriter(file)&nbsp;{&nbsp;writer&nbsp;=&gt;
  &nbsp;&nbsp;writer.println(<code class="vem">new</code>&nbsp;<code class="typename">java.util.Date</code>)
  }
</pre>


<p>But what if you want to implement something more like
<pre class="code">if</pre> or <pre class="code">while</pre>, where there is no value to pass into the
code between the curly braces? To help with such situations, Scala provides by-name
parameters.<a id="i-1931276111-1"/><a id="i-2031769303-1"/></p>

<p>As a concrete example, suppose you want to implement an assertion construct
called <pre class="code">myAssert</pre>.<a href="control-abstraction.html#footnotemain9-3">[3]</a>
The <pre class="code">myAssert</pre> function will take a function value as input and 
consult a flag to decide what to do.  If the flag is set, 
<pre class="code">myAssert</pre> will invoke the passed function and verify that it returns <pre class="code">true</pre>.  If the
flag is turned off, <pre class="code">myAssert</pre> will quietly do nothing at all.</p>

<p>Without using by-name parameters, you could write <pre class="code">myAssert</pre> like this:</p>

<pre>
  <code class="vem">var</code>&nbsp;assertionsEnabled&nbsp;=&nbsp;<code class="vem">true</code>
  <br />  <code class="vem">def</code>&nbsp;myAssert(predicate:&nbsp;()&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>)&nbsp;=
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(assertionsEnabled&nbsp;&amp;&amp;&nbsp;!predicate())
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">AssertionError</code>
</pre>


<p>The definition is fine, but using it is a little bit awkward:</p>

<pre>
  myAssert(()&nbsp;=&gt;&nbsp;<code class="literal">5</code>&nbsp;&gt;&nbsp;<code class="literal">3</code>)
</pre>


<p>You would really prefer to leave out the empty parameter list and <pre class="code">=&gt;</pre> symbol in the function literal and
write the code like this:</p>

<pre>
  myAssert(<code class="literal">5</code>&nbsp;&gt;&nbsp;<code class="literal">3</code>)&nbsp;<code class="comment">//&nbsp;Won't&nbsp;work,&nbsp;because&nbsp;missing&nbsp;()&nbsp;=&gt;&nbsp;</code>
</pre>


<p>By-name parameters exist precisely so that you can do this.  To
make a by-name parameter, you give the parameter a type starting with <pre class="code">=&gt;</pre>
instead of <pre class="code">()</pre>&nbsp;<pre class="code">=&gt;</pre>. For example, you could change
<pre class="code">myAssert</pre>'s <pre class="code">predicate</pre> parameter into a by-name parameter by changing its type,
"<pre class="code">()</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">Boolean</pre>", into "<pre class="code">=&gt;</pre>&nbsp;<pre class="code">Boolean</pre>". <a href="control-abstraction.html#lst-by-name-parameter">Listing 9.5</a> shows how
that would look:</p>

<p><a id="lst-by-name-parameter"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;byNameAssert(predicate:&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(assertionsEnabled&nbsp;&amp;&amp;&nbsp;!predicate)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">AssertionError</code>
</pre>


<h5>Listing 9.5 - Using a by-name parameter.</h5>


<p>Now you can leave out the empty parameter in the property you want to
assert.  The result is that using <pre class="code">byNameAssert</pre> looks exactly like using
a built-in control structure:</p>

<pre>
  byNameAssert(<code class="literal">5</code>&nbsp;&gt;&nbsp;<code class="literal">3</code>)
</pre>


<p>A by-name type, in which the empty parameter list, <pre class="code">()</pre>, is left out, is only allowed for parameters.
There is no such thing as a by-name variable or a by-name field.</p>

<p>Now, you may be wondering why you couldn't simply write <pre class="code">myAssert</pre> using
a plain old <pre class="code">Boolean</pre> for the type of its parameter, like this:</p>

<pre>
  <code class="vem">def</code>&nbsp;boolAssert(predicate:&nbsp;<code class="typename">Boolean</code>)&nbsp;=
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(assertionsEnabled&nbsp;&amp;&amp;&nbsp;!predicate)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">AssertionError</code>
</pre>


<p>This formulation is also legal, of course, and the code using this version of 
<pre class="code">boolAssert</pre> would still look exactly as before:</p>

<pre>
  boolAssert(<code class="literal">5</code>&nbsp;&gt;&nbsp;<code class="literal">3</code>)
</pre>


<p>Nevertheless, one difference exists between these two approaches
that is important to note. Because the 
type of <pre class="code">boolAssert</pre>'s parameter is <pre class="code">Boolean</pre>, the expression
inside the parentheses in <pre class="code">boolAssert(5</pre>&nbsp;<pre class="code">&gt;</pre>&nbsp;<pre class="code">3)</pre> is evaluated <em>before</em> the call to
<pre class="code">boolAssert</pre>. The expression <pre class="code">5</pre>&nbsp;<pre class="code">&gt;</pre>&nbsp;<pre class="code">3</pre> yields <pre class="code">true</pre>, which is passed to <pre class="code">boolAssert</pre>.
By contrast, because the type of <pre class="code">byNameAssert</pre>'s <pre class="code">predicate</pre> parameter is <pre class="code">=&gt;</pre>&nbsp;<pre class="code">Boolean</pre>,
the expression inside the parentheses in <pre class="code">byNameAssert(5</pre>&nbsp;<pre class="code">&gt;</pre>&nbsp;<pre class="code">3)</pre> is <em>not</em> evaluated
before the call to <pre class="code">byNameAssert</pre>. Instead a function value will be created whose
<pre class="code">apply</pre> method will evaluate <pre class="code">5</pre>&nbsp;<pre class="code">&gt;</pre>&nbsp;<pre class="code">3</pre>, and this function value will be
passed to <pre class="code">byNameAssert</pre>.</p>

<p>The difference between the two approaches, therefore, is that if assertions
are disabled, you'll see any side effects that the expression inside the
parentheses may have in <pre class="code">boolAssert</pre>, but not in <pre class="code">byNameAssert</pre>. For example,
if assertions are disabled, attempting to assert on "<pre class="code">x</pre>&nbsp;<pre class="code">/</pre>&nbsp;<pre class="code">0</pre>&nbsp;<pre class="code">==</pre>&nbsp;<pre class="code">0</pre>"
will yield an exception in <pre class="code">boolAssert</pre>'s case:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;x&nbsp;=&nbsp;<code class="literal">5</code>
  <code class="output">x:&nbsp;Int&nbsp;=&nbsp;5</code>
  <br />  scala&gt;&nbsp;<code class="vem">var</code>&nbsp;assertionsEnabled&nbsp;=&nbsp;<code class="vem">false</code>
  <code class="output">assertionsEnabled:&nbsp;Boolean&nbsp;=&nbsp;false</code>
  <br />  scala&gt;&nbsp;boolAssert(x&nbsp;/&nbsp;<code class="literal">0</code>&nbsp;==&nbsp;<code class="literal">0</code>)
  <code class="output">java.lang.ArithmeticException:&nbsp;/&nbsp;by&nbsp;zero</code>
  <code class="output">&nbsp;&nbsp;...&nbsp;33&nbsp;elided</code>
</pre>


<p>But attempting to assert on the same code in <pre class="code">byNameAssert</pre>'s case will <em>not</em> yield an exception:</p>

<pre>
  scala&gt;&nbsp;byNameAssert(x&nbsp;/&nbsp;<code class="literal">0</code>&nbsp;==&nbsp;<code class="literal">0</code>)
</pre>


<h3>9.6 Conclusion</h3>


<p>This chapter has shown you how to build on Scala's rich function
support to build control abstractions.  You can use functions within
your code to factor out common control patterns, and you can take
advantage of higher-order functions in the Scala library to
reuse control patterns that are common across all programmers' code.
We also discussed how to use currying and by-name
parameters so that your own higher-order functions can be used
with a concise syntax.</p>

<p>In the previous chapter and this one, you have seen quite a lot of
information about functions.  The next few chapters will go back to
discussing more object-oriented features of the language.</p>

<hr/>
<h4>Footnotes for Chapter 9:</h4>


<p><a id="footnotemain9-1"/>[1] These
special-purpose looping methods are defined in trait <pre class="code">Traversable</pre>,
which is extended by <pre class="code">List</pre>, <pre class="code">Set</pre>, and <pre class="code">Map</pre>. See <a href="working-with-other-collections.html">Chapter 17</a> for a discussion.</p>

<p><a id="footnotemain9-2"/>[2] In the previous chapter, when the placeholder notation
was used on traditional methods, like <pre class="code">println</pre>&nbsp;<pre class="code">_</pre>, you had to leave a space between the name and the underscore. In this case you don't, because
whereas <pre class="code">println_</pre> is a legal identifier in Scala, <pre class="code">curriedSum(1)_</pre> is
not.</p>

<p><a id="footnotemain9-3"/>[3] You'll call this <pre class="code">myAssert</pre>, not <pre class="code">assert</pre>, because Scala provides an
<pre class="code">assert</pre> of its own, which will be described in <a href="assertions-and-tests.html#sec-assert">Section 14.1</a>.</p>

<div style="page-break-after:always"/>


<div style="page-break-after:always"/>

</body>
</html>
