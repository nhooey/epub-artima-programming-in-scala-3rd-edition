<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8"/>
    <title>Programming in Scala, 3rd Edition</title>

    <link rel="stylesheet" type="text/css" href="book.css" />
  </head>
<body>
<h2><a id="chap-extractors">Chapter 26</a></h2>
<h1>Extractors</h1>


<p>By now you have probably grown accustomed to the concise way data can
be decomposed and analyzed using pattern matching<a id="i-83872229-1"/>. This chapter shows
you how to generalize this concept further.  Until now, constructor
patterns were linked to case classes. For instance, <pre class="code">Some(x)</pre> is a
valid pattern because <pre class="code">Some</pre> is a case class.  Sometimes you might wish
that you could write patterns like this without creating an associated
case class. In fact, you might wish to be able to create your own
kinds of patterns. Extractors give you a way to do so<a id="i751564495-1"/>.
This chapter explains what extractors are and how you can use them to
define patterns that are decoupled from an object's representation.</p>

<h3>26.1 An example: extracting email addresses</h3>


<p>To illustrate the problem extractors solve, imagine that you need to analyze
strings that represent email addresses. Given a string,
you want to decide whether it is an email address or not, and, if it
is, you want to access the user and domain parts of the address.
The traditional way to do this uses three helper functions:</p>

<pre>
  <code class="vem">def</code>&nbsp;isEMail(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Boolean</code>
  <code class="vem">def</code>&nbsp;domain(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">String</code>
  <code class="vem">def</code>&nbsp;user(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">String</code>
</pre>


<p>With these functions, you could parse a given string <pre class="code">s</pre> as
follows:</p>

<pre>
  <code class="vem">if</code>&nbsp;(isEMail(s))&nbsp;println(user(s)&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;AT&nbsp;"</code>&nbsp;+&nbsp;domain(s))
  <code class="vem">else</code>&nbsp;println(<code class="quotedstring">"not&nbsp;an&nbsp;email&nbsp;address"</code>)
</pre>


<p>This works, but is kind of clumsy. 
What's more, things would become more complicated if you combined several 
such tests. 
For instance you might want to find two successive strings in a list that
are both email addresses with the same user. You can try this yourself with the
access functions defined previously to see what would be involved.</p>

<p>You saw already in <a href="case-classes-and-pattern-matching.html">Chapter 15</a>
that pattern matching is ideal for attacking problems like this.
Let's assume for the moment that you could match a string with a pattern:</p>

<pre>
  <code class="typename">EMail</code>(user,&nbsp;domain)
</pre>


<p>The pattern would match if the string contained an embedded
at sign (<pre class="code">@</pre>). In that case it would bind variable <pre class="code">user</pre> to the part
of the string before the <pre class="code">@</pre> and variable <pre class="code">domain</pre> 
to the part after it. Postulating a pattern like this, the previous expression 
could be written more clearly like this:</p>

<pre>
  s&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">EMail</code>(user,&nbsp;domain)&nbsp;=&gt;&nbsp;println(user&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;AT&nbsp;"</code>&nbsp;+&nbsp;domain)
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"not&nbsp;an&nbsp;email&nbsp;address"</code>)
  }
</pre>


<p>The more complicated problem of finding two successive email addresses 
with the same user part would translate to the following pattern:</p>

<pre>
  ss&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">EMail</code>(u1,&nbsp;d1)&nbsp;::&nbsp;<code class="typename">EMail</code>(u2,&nbsp;d2)&nbsp;::&nbsp;_&nbsp;<code class="vem">if</code>&nbsp;(u1&nbsp;==&nbsp;u2)&nbsp;=&gt;&nbsp;...
  &nbsp;&nbsp;...
  }
</pre>


<p>This is much more legible than anything that could be written with access functions.
However, the problem is that strings are not case
classes;
they do not have a representation that conforms to <pre class="code">EMail(user,</pre>&nbsp;<pre class="code">domain)</pre>.
This is where Scala's extractors come in: they let you define new patterns
for pre-existing types, where the pattern need not follow the 
internal representation of the type.</p>

<h3>26.2 Extractors</h3>


<p>An extractor in Scala is an object that has a method called
<pre class="code">unapply</pre> as one of its members<a id="i1869714895-1"/>.  The purpose of that <pre class="code">unapply</pre>
method is to match a value and take it apart. Often, the extractor
object also defines a dual method <pre class="code">apply</pre> for building values, but
this is not required.<a id="i-649058493-1"/> As an example, <a href="extractors.html#lst-email-extractor">Listing 26.1</a> shows an extractor object for
email addresses: 
<a id="lst-email-extractor"/></p>

<pre>
  <code class="vem">object</code>&nbsp;<code class="typename">EMail</code>&nbsp;{
  <br />  &nbsp;&nbsp;<code class="comment">//&nbsp;The&nbsp;injection&nbsp;method&nbsp;(optional)</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(user:&nbsp;<code class="typename">String</code>,&nbsp;domain:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;user&nbsp;+&nbsp;<code class="quotedstring">"@"</code>&nbsp;+&nbsp;domain
  <br />  &nbsp;&nbsp;<code class="comment">//&nbsp;The&nbsp;extraction&nbsp;method&nbsp;(mandatory)</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;unapply(str:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Option[(String,&nbsp;String)]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;parts&nbsp;=&nbsp;str&nbsp;split&nbsp;<code class="quotedstring">"@"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(parts.length&nbsp;==&nbsp;<code class="literal">2</code>)&nbsp;<code class="typename">Some</code>(parts(<code class="literal">0</code>),&nbsp;parts(<code class="literal">1</code>))&nbsp;<code class="vem">else</code>&nbsp;<code class="typename">None</code>
  &nbsp;&nbsp;}
  }
</pre>


<h5>Listing 26.1 - The <pre class="code">EMail</pre> string extractor object.</h5>


<p>This object defines both <pre class="code">apply</pre> and <pre class="code">unapply</pre> methods. 
The <pre class="code">apply</pre> method has the same meaning as always: it turns <pre class="code">EMail</pre> into 
an object that can be applied to arguments in parentheses in the same way a method is applied.
So you can write <pre class="code">EMail("John",</pre>&nbsp;<pre class="code">"epfl.ch")</pre>
to construct the string <pre class="code">"John@epfl.ch"</pre>. To make this more explicit, 
you could also let <pre class="code">EMail</pre> inherit from Scala's function type, like this:</p>

<pre>
  <code class="vem">object</code>&nbsp;<code class="typename">EMail</code>&nbsp;<code class="vem">extends</code>&nbsp;((<code class="typename">String</code>,&nbsp;<code class="typename">String</code>)&nbsp;=&gt;&nbsp;<code class="typename">String</code>)&nbsp;{&nbsp;...&nbsp;}
</pre>


<div class="note">
<h4>Note</h4>


<p>The "<pre class="code">(String,</pre>&nbsp;<pre class="code">String)</pre>&nbsp;<pre class="code">=&gt;</pre>&nbsp;<pre class="code">String</pre>" portion of the previous object declaration
means the same as <pre class="code">Function2[String,</pre>&nbsp;<pre class="code">String,</pre>&nbsp;<pre class="code">String]</pre>, which declares an abstract
<pre class="code">apply</pre> method that <pre class="code">EMail</pre> implements. As a result of this declaration, you could, for example, pass <pre class="code">EMail</pre>
to a method expecting a <pre class="code">Function2[String,</pre>&nbsp;<pre class="code">String,</pre>&nbsp;<pre class="code">String]</pre>.</p>

</div>


<p>The <pre class="code">unapply</pre> method is what turns <pre class="code">EMail</pre> into an extractor. 
In a sense, it reverses the construction process of <pre class="code">apply</pre>. Where <pre class="code">apply</pre> 
takes two strings and forms an email address string out of them, 
<pre class="code">unapply</pre> takes an email address and returns potentially two strings: 
the user and the domain of the address. But <pre class="code">unapply</pre> must also 
handle the case where the given string is not an email address. 
That's why <pre class="code">unapply</pre> returns an <pre class="code">Option</pre>-type over pairs of strings.
Its result is either <pre class="code">Some(user,</pre>&nbsp;<pre class="code">domain)</pre> if the string <pre class="code">str</pre> is an 
email address with the given <pre class="code">user</pre> and <pre class="code">domain</pre> parts,<a href="extractors.html#footnotemain26-1">[1]</a> or <pre class="code">None</pre>, if
<pre class="code">str</pre> is not an email address. Here are some examples:</p>

<pre>
  unapply(<code class="quotedstring">"John@epfl.ch"</code>)&nbsp;&nbsp;<code class="rm"><em>equals</em></code>&nbsp;&nbsp;<code class="typename">Some</code>(<code class="quotedstring">"John"</code>,&nbsp;<code class="quotedstring">"epfl.ch"</code>)
  unapply(<code class="quotedstring">"John&nbsp;Doe"</code>)&nbsp;&nbsp;<code class="rm"><em>equals</em></code>&nbsp;&nbsp;<code class="typename">None</code>
</pre>


<p>Now, whenever pattern matching 
encounters a pattern referring to an extractor object, it invokes the
extractor's <pre class="code">unapply</pre> method on the selector expression.
For instance, executing the code:</p>

<pre>
  selectorString&nbsp;<code class="vem">match</code>&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">EMail</code>(user,&nbsp;domain)&nbsp;=&gt;&nbsp;...&nbsp;}
</pre>


<p>would lead to the call:</p>

<pre>
  EMail.unapply(selectorString)
</pre>


<p>As you saw previously, this call to <pre class="code">EMail.unapply</pre> will return either
<pre class="code">None</pre><a id="i2129711991-1"/> or
<pre class="code">Some(u,</pre>&nbsp;<pre class="code">d)</pre><a id="i-467709668-1"/>, for some values <pre class="code">u</pre> for the user part of the address
and <pre class="code">d</pre> for the domain part. In the <pre class="code">None</pre> case, the pattern does not
match, and the system tries another pattern or fails with a
<pre class="code">MatchError</pre> exception.<a id="i-2067503209-1"/> In the <pre class="code">Some(u,</pre>&nbsp;<pre class="code">d)</pre> case, the pattern matches and its variables
are bound to the elements of the returned value.  In the previous match,
<pre class="code">user</pre> would be bound to <pre class="code">u</pre> and <pre class="code">domain</pre> would be bound to <pre class="code">d</pre>.</p>

<p>In the <pre class="code">EMail</pre> pattern matching example, the type <pre class="code">String</pre> of the
selector expression, <pre class="code">selectorString</pre>, conformed to <pre class="code">unapply</pre>'s argument type
(which in the example was also <pre class="code">String</pre>).  This is quite common, but
not necessary. It would also be possible to use the <pre class="code">EMail</pre> extractor
to match selector expressions for more general types.
For instance, to find out whether an arbitrary value
<pre class="code">x</pre> was an email address string, you could write:</p>

<pre>
  <code class="vem">val</code>&nbsp;x:&nbsp;<code class="typename">Any</code>&nbsp;=&nbsp;...
  x&nbsp;<code class="vem">match</code>&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">EMail</code>(user,&nbsp;domain)&nbsp;=&gt;&nbsp;...&nbsp;}
</pre>


<p>Given this code, the pattern matcher will first check whether the given
value <pre class="code">x</pre> conforms to <pre class="code">String</pre>, the parameter type of <pre class="code">EMail</pre>'s unapply method. If it
does conform, the value is cast to <pre class="code">String</pre> and pattern matching proceeds as before.
If it does not conform, the pattern fails immediately.</p>

<p>In object <pre class="code">EMail</pre>, the <pre class="code">apply</pre> method is called an <span style="font-style:italic">injection</span>, because it
takes some arguments and yields an element of a given set (in our
case: the set of strings that are email addresses).<a id="i2031936124-1"/><a id="i1478477936-1"/> The <pre class="code">unapply</pre>
method is called an <span style="font-style:italic">extraction</span>, because it takes an element of the same
set and extracts some of its parts (in our case: the user and domain
substrings)<a id="i-1101999489-1"/>.  Injections and extractions are often grouped together in
one object, because then you can use the object's name for both a
constructor and a pattern, which simulates the convention for pattern
matching with case classes. However, it is also possible to define an
extraction in an object without a corresponding injection. The object
itself is called an <span style="font-style:italic">extractor</span>, regardless of whether or not
it has an <pre class="code">apply</pre> method.</p>

<p>If an injection method is included, it should be the dual to the extraction method. 
For instance, a call of:</p>

<pre>
  EMail.unapply(EMail.apply(user,&nbsp;domain))
</pre>


<p>should return:</p>

<pre>
  <code class="typename">Some</code>(user,&nbsp;domain)
</pre>


<p><i>i.e.</i>, the same sequence of arguments wrapped in a <pre class="code">Some</pre>. 
Going in the other direction means running first the <pre class="code">unapply</pre> 
and then the <pre class="code">apply</pre>, as shown in the following code:</p>

<pre>
  EMail.unapply(obj)&nbsp;<code class="vem">match</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Some</code>(u,&nbsp;d)&nbsp;=&gt;&nbsp;EMail.apply(u,&nbsp;d)&nbsp;
  }
</pre>


<p>In that code, if the match on <pre class="code">obj</pre> succeeds, you'd expect to get back that same
object from the <pre class="code">apply</pre>.
These two conditions for the duality of <pre class="code">apply</pre> and <pre class="code">unapply</pre> are good design principles.
They are not enforced by Scala, but it's recommended to keep to them
when designing your extractors.</p>

<h3>26.3 Patterns with zero or one variables</h3>


<p>The <pre class="code">unapply</pre> method of the previous example returned a pair of
element values in the success case. This is easily generalized to
patterns of more than two variables. To bind <pre class="code">N</pre> variables, an
<pre class="code">unapply</pre> would return an <pre class="code">N</pre>-element tuple, wrapped in a <pre class="code">Some</pre>.</p>

<p>The case where a pattern binds just one variable is treated
differently, however. There is no one-tuple in Scala. To return
just one pattern element, the <pre class="code">unapply</pre> method simply wraps the
element itself in a <pre class="code">Some</pre>.
For example, the extractor object shown in <a href="extractors.html#lst-twice-extractor">Listing 26.2</a> defines <pre class="code">apply</pre>
and <pre class="code">unapply</pre> for strings that consist of the same substring appearing twice in a row:
<a id="lst-twice-extractor"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Twice</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;s&nbsp;+&nbsp;s
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;unapply(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Option[String]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;length&nbsp;=&nbsp;s.length&nbsp;/&nbsp;<code class="literal">2</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;half&nbsp;=&nbsp;s.substring(<code class="literal">0</code>,&nbsp;length)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(half&nbsp;==&nbsp;s.substring(length))&nbsp;<code class="typename">Some</code>(half)&nbsp;<code class="vem">else</code>&nbsp;<code class="typename">None</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 26.2 - The <pre class="code">Twice</pre> string extractor object.</h5>


<p>It's also possible that an extractor pattern does not bind any
variables. In that case the corresponding <pre class="code">unapply</pre> method returns a
boolean&mdash;<pre class="code">true</pre> for success and <pre class="code">false</pre> for failure. For instance,
the extractor object shown in <a href="extractors.html#lst-uppercase-extractor">Listing 26.3</a> characterizes strings consisting of all 
uppercase characters:</p>

<p><a id="lst-uppercase-extractor"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">UpperCase</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;unapply(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;s.toUpperCase&nbsp;==&nbsp;s
  &nbsp;&nbsp;}
</pre>


<h5>Listing 26.3 - The <pre class="code">UpperCase</pre> string extractor object.</h5>


<p>This time, the extractor only defines an <pre class="code">unapply</pre>, but not an <pre class="code">apply</pre>.
It would make no sense to define an <pre class="code">apply</pre>, as there's nothing to construct.</p>

<p>The following <pre class="code">userTwiceUpper</pre> function applies all previously defined extractors
together in its pattern matching code:</p>

<pre>
  <code class="vem">def</code>&nbsp;userTwiceUpper(s:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;s&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">EMail</code>(<code class="typename">Twice</code>(x&nbsp;@&nbsp;<code class="typename">UpperCase</code>()),&nbsp;domain)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"match:&nbsp;"</code>&nbsp;+&nbsp;x&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;in&nbsp;domain&nbsp;"</code>&nbsp;+&nbsp;domain
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"no&nbsp;match"</code>
  }
</pre>


<p>The first pattern of this function matches strings that are
email addresses whose user part consists of two occurrences of the same string in
uppercase letters. For instance:</p>

<pre>
  scala&gt;&nbsp;userTwiceUpper(<code class="quotedstring">"DIDI@hotmail.com"</code>)
  <code class="output">res0:&nbsp;String&nbsp;=&nbsp;match:&nbsp;DI&nbsp;in&nbsp;domain&nbsp;hotmail.com</code>
  <br />  scala&gt;&nbsp;userTwiceUpper(<code class="quotedstring">"DIDO@hotmail.com"</code>)
  <code class="output">res1:&nbsp;String&nbsp;=&nbsp;no&nbsp;match</code>
  <br />  scala&gt;&nbsp;userTwiceUpper(<code class="quotedstring">"didi@hotmail.com"</code>)
  <code class="output">res2:&nbsp;String&nbsp;=&nbsp;no&nbsp;match</code>
</pre>


<p>Note that <pre class="code">UpperCase</pre> in function <pre class="code">userTwiceUpper</pre> takes an empty parameter
list. This cannot be omitted as otherwise the match would test for
equality with the object <pre class="code">UpperCase</pre>!
Note also that, even though <pre class="code">UpperCase()</pre> itself does not bind any variables,
it is still possible to associate a variable with the whole pattern matched
by it. To do this, you use the standard scheme of variable binding explained in 
<a href="case-classes-and-pattern-matching.html#sec-var-binding">Section 15.2</a>: the form <pre class="code">x @ UpperCase()</pre> associates the
variable <pre class="code">x</pre> with the pattern matched by <pre class="code">UpperCase()</pre>. For instance, in the first <pre class="code">userTwiceUpper</pre> invocation
 above, <pre class="code">x</pre> was bound to <pre class="code">"DI"</pre>, because that was the value against which
the <pre class="code">UpperCase()</pre> pattern was matched.</p>

<h3>26.4 Variable argument extractors</h3>


<p>The previous extraction methods for email addresses all returned a 
fixed number of element values. Sometimes, this is not flexible enough.
For example, you might want to match on a string representing a domain
name, so that every part of the domain is kept in a different sub-pattern.
This would let you express patterns such as the following:</p>

<pre>
  dom&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Domain</code>(<code class="quotedstring">"org"</code>,&nbsp;<code class="quotedstring">"acm"</code>)&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"acm.org"</code>)
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Domain</code>(<code class="quotedstring">"com"</code>,&nbsp;<code class="quotedstring">"sun"</code>,&nbsp;<code class="quotedstring">"java"</code>)&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"java.sun.com"</code>)
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Domain</code>(<code class="quotedstring">"net"</code>,&nbsp;_*)&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"a&nbsp;.net&nbsp;domain"</code>)
  }
</pre>


<p>In this example things were arranged so that domains are 
expanded in reverse order&mdash;from the top-level domain down to
the sub-domains. This was done so that you could better profit 
from sequence patterns. You saw in <a href="case-classes-and-pattern-matching.html#sec-pat-sequences">Section 15.2</a>
that a sequence wildcard pattern, <pre class="code">_*</pre><a id="i-563003136-1"/>, at the end of an argument list 
matches any remaining elements in a sequence. This feature is more useful
if the top-level domain comes first, because then you can use 
sequence wildcards to match sub-domains of arbitrary depth.</p>

<p>The question remains how an extractor can support <span style="font-style:italic">vararg
matching</span><a id="i1383700270-1"/><a id="i1018791428-1"/><a id="i-1008880962-1"/> as shown in the previous example, where patterns can have a varying number of sub-patterns.
The <pre class="code">unapply</pre> methods encountered so far are not sufficient, because
they each return a fixed number of sub-elements in the success case.
To handle this case, Scala lets you define a different extraction method specifically
for vararg matching. This method is called
<pre class="code">unapplySeq</pre><a id="i1953385690-1"/>. To see how it is
written, have a look at the <pre class="code">Domain</pre> extractor, shown in <a href="extractors.html#lst-domain-extractor">Listing 26.4</a>:
<a id="lst-domain-extractor"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Domain</code>&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;The&nbsp;injection&nbsp;method&nbsp;(optional)</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(parts:&nbsp;<code class="typename">String</code>*):&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.reverse.mkString(<code class="quotedstring">"."</code>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;The&nbsp;extraction&nbsp;method&nbsp;(mandatory)</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;unapplySeq(whole:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Option[Seq[String]]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Some</code>(whole.split(<code class="quotedstring">"\\."</code>).reverse)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 26.4 - The <pre class="code">Domain</pre> string extractor object.</h5>


<p>The <pre class="code">Domain</pre> object defines an <pre class="code">unapplySeq</pre> method that
first splits the string into parts separated by periods. 
This is done using Java's <pre class="code">split</pre> method on strings, which takes a
regular expression
as its argument.  The result of <pre class="code">split</pre> is an array of substrings.
The result of <pre class="code">unapplySeq</pre> is then that array with all elements reversed
and wrapped in a <pre class="code">Some</pre>.</p>

<p>The result type of an <pre class="code">unapplySeq</pre> must conform to
<pre class="code">Option[Seq[T]]</pre>, where the element type <pre class="code">T</pre> is arbitrary. 
As you saw in <a href="working-with-other-collections.html#sec-sequences">Section 17.1</a>, <pre class="code">Seq</pre> is an important class
in Scala's collection hierarchy. It's a common superclass of several
classes describing different kinds of sequences: <pre class="code">List</pre>s, <pre class="code">Array</pre>s, <pre class="code">WrappedString</pre>, and several others.</p>

<p>For symmetry, <pre class="code">Domain</pre> also has an <pre class="code">apply</pre> method that builds a
domain string from a variable argument parameter of domain parts starting with the
top-level domain. As always, the <pre class="code">apply</pre> method is optional.</p>

<p>You can use the <pre class="code">Domain</pre> extractor to get more detailed information
out of email strings. For instance, to search for an email address named "tom" in some "<pre class="code">.com</pre>"
domain, you could write the following function:</p>

<pre>
  <code class="vem">def</code>&nbsp;isTomInDotCom(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;s&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">EMail</code>(<code class="quotedstring">"tom"</code>,&nbsp;<code class="typename">Domain</code>(<code class="quotedstring">"com"</code>,&nbsp;_*))&nbsp;=&gt;&nbsp;<code class="vem">true</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  }
</pre>


<p>This gives the expected results:</p>

<pre>
  scala&gt;&nbsp;isTomInDotCom(<code class="quotedstring">"tom@sun.com"</code>)
  <code class="output">res3:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br />  scala&gt;&nbsp;isTomInDotCom(<code class="quotedstring">"peter@sun.com"</code>)
  <code class="output">res4:&nbsp;Boolean&nbsp;=&nbsp;false</code>
  <br />  scala&gt;&nbsp;isTomInDotCom(<code class="quotedstring">"tom@acm.org"</code>)
  <code class="output">res5:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>


<p>It's also possible to return some fixed elements from an <pre class="code">unapplySeq</pre>
together with the variable part. This is expressed by returning all
elements in a tuple, where the variable part comes last, as usual.
As an example, <a href="extractors.html#lst-expanded-email-extractor">Listing 26.5</a> shows a new extractor for emails where the 
domain part is already expanded into a sequence:
<a id="lst-expanded-email-extractor"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">ExpandedEMail</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;unapplySeq(email:&nbsp;<code class="typename">String</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<code class="typename">Option[(String,&nbsp;Seq[String])]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;parts&nbsp;=&nbsp;email&nbsp;split&nbsp;<code class="quotedstring">"@"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(parts.length&nbsp;==&nbsp;<code class="literal">2</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Some</code>(parts(<code class="literal">0</code>),&nbsp;parts(<code class="literal">1</code>).split(<code class="quotedstring">"\\."</code>).reverse)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">None</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>


<h5>Listing 26.5 - The <pre class="code">ExpandedEMail</pre> extractor object.</h5>


<p>The <pre class="code">unapplySeq</pre> method in <pre class="code">ExpandedEMail</pre> returns an optional value
of a pair (a <pre class="code">Tuple2</pre>). The first element of the pair is the user part. The second element
is a sequence of names representing the domain.  You can match on
this as usual:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;s&nbsp;=&nbsp;<code class="quotedstring">"tom@support.epfl.ch"</code>
  <code class="output">s:&nbsp;String&nbsp;=&nbsp;tom@support.epfl.ch</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">ExpandedEMail</code>(name,&nbsp;topdom,&nbsp;subdoms&nbsp;@&nbsp;_*)&nbsp;=&nbsp;s
  <code class="output">name:&nbsp;String&nbsp;=&nbsp;tom</code>
  <code class="output">topdom:&nbsp;String&nbsp;=&nbsp;ch</code>
  <code class="output">subdoms:&nbsp;Seq[String]&nbsp;=&nbsp;WrappedArray(epfl,&nbsp;support)</code>
</pre>


<h3>26.5 Extractors and sequence patterns</h3>


<p>You saw in <a href="case-classes-and-pattern-matching.html#sec-pat-sequences">Section 15.2</a> that
you can access the elements of a list or an array using sequence patterns such as:</p>

<pre>
  <code class="typename">List</code>()
  <code class="typename">List</code>(x,&nbsp;y,&nbsp;_*)
  <code class="typename">Array</code>(x,&nbsp;<code class="literal">0</code>,&nbsp;<code class="literal">0</code>,&nbsp;_)
</pre>


<p>In fact, these sequence patterns are all implemented using extractors in the standard Scala library.
For instance, patterns of the form <pre class="code">List(...)</pre> are possible because the <pre class="code">scala.List</pre> companion object
is an extractor that defines an <pre class="code">unapplySeq</pre> method. <a href="extractors.html#lst-lists-unapply-seq">Listing 26.6</a> shows the relevant definitions:
<a id="lst-lists-unapply-seq"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;scala
  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">List</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply[T](elems:&nbsp;T*)&nbsp;=&nbsp;elems.toList
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;unapplySeq[T](x:&nbsp;<code class="typename">List[T]</code>):&nbsp;<code class="typename">Option[Seq[T]]</code>&nbsp;=&nbsp;<code class="typename">Some</code>(x)
  &nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;
  &nbsp;&nbsp;}
</pre>


<h5>Listing 26.6 - An extractor that defines an <pre class="code">unapplySeq</pre> method.</h5>


<p>The <pre class="code">List</pre> object contains an <pre class="code">apply</pre> method that takes 
a variable number of arguments.<a id="i19484993-3"/><a id="i1305057997-3"/> That's what lets you
write expressions such as:</p>

<pre>
  <code class="typename">List</code>()
  <code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
</pre>


<p>It also contains an <pre class="code">unapplySeq</pre> method that returns all elements
of the list as a sequence. That's what supports <pre class="code">List(...)</pre> patterns.
Very similar definitions exist in the object <pre class="code">scala.Array</pre>. These support
analogous injections and extractions for arrays.</p>

<h3>26.6 Extractors versus case classes</h3>


<p>Even though they are very useful, case classes have one shortcoming:
they expose the concrete representation of data. This means that the name
of the class in a constructor pattern corresponds to the concrete
representation type of the selector
object. If a match against<a id="i-910914787-1"/>:</p>

<pre>
  <code class="vem">case</code>&nbsp;C(...)
</pre>


<p>succeeds, you know that the selector expression is 
an instance of class <pre class="code">C</pre>.</p>

<p>Extractors break this link between data representations and
patterns. You have seen in the examples in this section that they
enable patterns that have nothing to do with the data type of the
object that's selected on. This property is called <span style="font-style:italic">representation
independence</span>.<a id="i886727311-1"/> In open systems of large size,
representation independence is very important because it allows you to
change an implementation type used in a set of components without
affecting clients of these components.</p>

<p>If your component had defined and exported a set of case classes,
you'd be stuck with them because client code could already contain
pattern matches against these case classes. Renaming some case classes
or changing the class hierarchy would affect client code. Extractors
do not share this problem, because they represent a layer of
indirection between a data representation and the way it is viewed by
clients. You could still change a concrete representation of a type,
as long as you update all your extractors with it.</p>

<p>Representation independence is an important advantage of extractors
over case classes. On the other hand, case classes also have some
advantages of their own over extractors. First, they are much easier
to set up and to define, and they require less code. Second, they
usually lead to more efficient pattern matches than extractors,<a id="i-2031931761-1"/>
because the Scala compiler can optimize patterns over case classes
much better than patterns over extractors. This is because
the mechanisms of case classes are fixed, whereas an <pre class="code">unapply</pre> or
<pre class="code">unapplySeq</pre> method in an extractor could do almost anything.  Third,
if your case classes inherit from a <pre class="code">sealed</pre> base
class<a id="i-1485759717-2"/>, the
Scala compiler will check your pattern matches for exhaustiveness and
will complain if some combination of possible values is not covered by
a pattern. No such exhaustiveness checks are available for extractors.</p>

<p>So which of the two methods should you prefer for your pattern
matches?  It depends. If you write code for a closed application, case
classes are usually preferable because of their advantages in
conciseness, speed and static checking. If you decide to change your
class hierarchy later, the application needs to be refactored, but
this is usually not a problem.  On the other hand, if you need to
expose a type to unknown clients, extractors might be preferable
because they maintain representation independence.</p>

<p>Fortunately, you need not decide right away. You could always start
with case classes and then, if the need arises, change to
extractors. Because patterns over extractors and patterns over case
classes look exactly the same in Scala, pattern matches in your clients
will continue to work.</p>

<p>Of course, there are also situations where it's clear from the start
that the structure of your patterns does not match the representation
type of your data. The email addresses discussed in this chapter were
one such example. In that case, extractors are the only possible
choice.</p>

<h3>26.7 Regular expressions</h3>


<p>One particularly useful application area of extractors are
regular expressions.<a id="i1678705239-1"/>  Like Java, Scala provides regular expressions through a
library, but extractors make it much nicer to interact with
them.</p>

<h4>Forming regular expressions</h4>


<p>Scala inherits its regular expression syntax from Java, which in turn
inherits most of the features of Perl.<a id="i389811529-2"/> We assume you know that syntax already; if
not, there are many accessible tutorials, starting with the Javadoc
documentation of class <pre class="code">java.util.regex.Pattern</pre>. 
Here are just some examples that should be enough as refreshers:<br /></p>

<table style="border-collapse: collapse">
<tr>
  <td>
    <pre class="code">ab?</pre>
  </td>
  <td>
    An `<pre class="code">a</pre>', possibly followed by a `<pre class="code">b</pre>'.
  </td>
</tr>
<tr>
  <td>
    [1em]
<pre class="code">\d+</pre>
  </td>
  <td>
    A number consisting of one or more digits represented by <pre class="code">\d</pre>.
  </td>
</tr>
</table>


<table style="border-collapse: collapse">
<tr>
  <td>
    <pre class="code">[a-dA-D]\w*</pre>
  </td>
  <td>
    A word starting with a letter between <pre class="code">a</pre> and <pre class="code">d</pre> in lower or upper case, followed
by a sequence of zero or more "word characters" denoted by <pre class="code">\w</pre>. (A
word character is a letter, digit, or underscore.)
  </td>
</tr>
<tr>
  <td>
    [1em]
<pre class="code">(-)?(\d+)(\.\d*)?</pre>
  </td>
  <td>
    A number consisting of an optional minus sign, followed
by one or more digits, optionally followed by a period and zero or
more digits. The number contains three <span style="font-style:italic">groups</span>, <i>i.e.</i>, the minus
sign, the part before the decimal point, and the fractional part
including the decimal point. Groups are enclosed in parentheses.
  </td>
</tr>
</table>


<p>Scala's regular expression class resides in package
<pre class="code">scala.util.matching</pre>.</p>

<pre>
  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.util.matching.Regex
</pre>


<p>A new regular expression value is created by passing a string to the
<pre class="code">Regex</pre> constructor<a id="i78839847-1"/>. 
For instance:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Decimal</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Regex</code>(<code class="quotedstring">"(-)?(\\d+)(\\.\\d*)?"</code>)
  <code class="output">Decimal:&nbsp;scala.util.matching.Regex&nbsp;=&nbsp;(-)?(\d+)(\.\d*)?</code>
</pre>


<p>Note that, compared to the regular expression for decimal numbers given previously,
every backslash appears twice in the string above. This is because in 
Java and Scala a single backslash is an escape
character in a string literal, not a regular character that shows up
in the string.  So instead of `<pre class="code">\</pre>' you need to write `<pre class="code">\\</pre>' to get a
single backslash in the string.</p>

<p>If a regular expression contains many backslashes this might be a bit
painful to write and to read. Scala's raw strings provide an
alternative.<a id="i-2061400628-1"/><a id="i-1493588176-2"/>  As you saw in <a href="basic-types-and-operations.html#sec-literals">Section 5.2</a>,
a raw string is a sequence of characters between triple
quotes. The difference between a raw and a normal string is that all
characters in a raw string appear exactly as they are typed. This
includes backslashes, which are not treated as escape characters. So
you could write equivalently and somewhat more legibly:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Decimal</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Regex</code>(<code class="quotedstring">"""(-)?(\d+)(\.\d*)?"""</code>)
  <code class="output">Decimal:&nbsp;scala.util.matching.Regex&nbsp;=&nbsp;(-)?(\d+)(\.\d*)?</code>
</pre>


<p>As you can see from the interpreter's output, the generated result
value for <pre class="code">Decimal</pre> is exactly the same as before.</p>

<p>Another, even shorter way to write a regular expression in Scala is
this:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Decimal</code>&nbsp;=&nbsp;<code class="quotedstring">"""(-)?(\d+)(\.\d*)?"""</code>.r
  <code class="output">Decimal:&nbsp;scala.util.matching.Regex&nbsp;=&nbsp;(-)?(\d+)(\.\d*)?</code>
</pre>


<p>In other words, simply append a <pre class="code">.r</pre> to a string to obtain a
regular expression.<a id="i-208750214-1"/><a id="i1128222747-1"/> This is possible because there is
a method named <pre class="code">r</pre>
in class <pre class="code">StringOps</pre>, which converts a string to a
regular expression.
The method is defined as shown in <a href="extractors.html#lst-the-r-method">Listing 26.7</a>:
<a id="lst-the-r-method"/></p>

<pre>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;scala.runtime
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.util.matching.Regex
  <br />  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">StringOps</code>(self:&nbsp;<code class="typename">String</code>)&nbsp;...&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;...
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;r&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Regex</code>(self)
  &nbsp;&nbsp;}
</pre>


<h5>Listing 26.7 - How the <pre class="code">r</pre> method is defined in <pre class="code">StringOps</pre>.</h5>


<h4>Searching for regular expressions</h4>


<p>You can search for occurrences of a regular expression in a string using
several different operators<a id="i945174444-1"/><a id="i1535162589-1"/><a id="i1068388242-1"/>:</p>

<p><pre class="code">regex</pre>&nbsp;<pre class="code">findFirstIn</pre>&nbsp;<pre class="code">str</pre></p>

<p><br />
Finds first occurrence of regular expression
<pre class="code">regex</pre> in string <pre class="code">str</pre>, returning the result in an <pre class="code">Option</pre> type.</p>

<p><pre class="code">regex</pre>&nbsp;<pre class="code">findAllIn</pre>&nbsp;<pre class="code">str</pre></p>

<p><br />
Finds all occurrences of regular expression
<pre class="code">regex</pre> in string <pre class="code">str</pre>, returning the results in an <pre class="code">Iterator</pre>.</p>

<p><pre class="code">regex</pre>&nbsp;<pre class="code">findPrefixOf</pre>&nbsp;<pre class="code">str</pre></p>

<p><br />
Finds an occurrence of regular expression
<pre class="code">regex</pre> at the start of string <pre class="code">str</pre>, returning the result in an
<pre class="code">Option</pre> type.</p>

<p><br />
For instance, you could define the input sequence below and then
search decimal numbers in it:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Decimal</code>&nbsp;=&nbsp;<code class="quotedstring">"""(-)?(\d+)(\.\d*)?"""</code>.r
  <code class="output">Decimal:&nbsp;scala.util.matching.Regex&nbsp;=&nbsp;(-)?(\d+)(\.\d*)?</code>
  <br />  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;input&nbsp;=&nbsp;<code class="quotedstring">"for&nbsp;-1.0&nbsp;to&nbsp;99&nbsp;by&nbsp;3"</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">input:&nbsp;String&nbsp;=&nbsp;for&nbsp;-1.0&nbsp;to&nbsp;99&nbsp;by&nbsp;3</code>
  <br />  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(s&nbsp;&lt;-&nbsp;<code class="typename">Decimal</code>&nbsp;findAllIn&nbsp;input)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(s)
  <code class="output">-1.0</code>
  <code class="output">99</code>
  <code class="output">3</code>
  <br />  scala&gt;&nbsp;<code class="typename">Decimal</code>&nbsp;findFirstIn&nbsp;input
  <code class="output">res7:&nbsp;Option[String]&nbsp;=&nbsp;Some(-1.0)</code>
  <br />  scala&gt;&nbsp;<code class="typename">Decimal</code>&nbsp;findPrefixOf&nbsp;input
  <code class="output">res8:&nbsp;Option[String]&nbsp;=&nbsp;None</code>
</pre>


<h4>Extracting with regular expressions</h4>


<p>What's more, every regular expression in Scala defines an
extractor. The extractor is used to identify substrings that are
matched by the groups of the regular expression. For instance, you
could decompose a decimal number string as follows:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Decimal</code>(sign,&nbsp;integerpart,&nbsp;decimalpart)&nbsp;=&nbsp;<code class="quotedstring">"-1.23"</code>&nbsp;&nbsp;
  <code class="output">sign:&nbsp;String&nbsp;=&nbsp;-</code>
  <code class="output">integerpart:&nbsp;String&nbsp;=&nbsp;1</code>
  <code class="output">decimalpart:&nbsp;String&nbsp;=&nbsp;.23</code>
</pre>


<p>In this example, the pattern, <pre class="code">Decimal(...)</pre>, is used in a <pre class="code">val</pre> definition, as described in
<a href="case-classes-and-pattern-matching.html#sec-patterns-everywhere">Section 15.7</a>.
What happens here is that the <pre class="code">Decimal</pre> regular expression value
defines an <pre class="code">unapplySeq</pre> method. That method matches every string that
corresponds to the regular expression syntax for decimal numbers. If
the string matches, the parts that correspond to the three groups
in the regular expression <pre class="code">(-)?(\d+)(\.\d*)?</pre> are returned as
elements of the pattern and are then matched by the three pattern
variables <pre class="code">sign</pre>, <pre class="code">integerpart</pre>, and <pre class="code">decimalpart</pre>. If a group
is missing, the element value is set to <pre class="code">null</pre>, as can be seen in the
following example:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Decimal</code>(sign,&nbsp;integerpart,&nbsp;decimalpart)&nbsp;=&nbsp;<code class="quotedstring">"1.0"</code>
  <code class="output">sign:&nbsp;String&nbsp;=&nbsp;null</code>
  <code class="output">integerpart:&nbsp;String&nbsp;=&nbsp;1</code>
  <code class="output">decimalpart:&nbsp;String&nbsp;=&nbsp;.0</code>
</pre>


<p>It's also possible to mix extractors with regular expression searches
in a <pre class="code">for</pre> expression<a id="i1523429976-1"/>. For instance, the following expression decomposes
all decimal numbers it finds in the <pre class="code">input</pre> string:</p>

<pre>
  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(<code class="typename">Decimal</code>(s,&nbsp;i,&nbsp;d)&nbsp;&lt;-&nbsp;<code class="typename">Decimal</code>&nbsp;findAllIn&nbsp;input)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"sign:&nbsp;"</code>&nbsp;+&nbsp;s&nbsp;+&nbsp;<code class="quotedstring">",&nbsp;integer:&nbsp;"</code>&nbsp;+
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;+&nbsp;<code class="quotedstring">",&nbsp;decimal:&nbsp;"</code>&nbsp;+&nbsp;d)
  <code class="output">sign:&nbsp;-,&nbsp;integer:&nbsp;1,&nbsp;decimal:&nbsp;.0</code>
  <code class="output">sign:&nbsp;null,&nbsp;integer:&nbsp;99,&nbsp;decimal:&nbsp;null</code>
  <code class="output">sign:&nbsp;null,&nbsp;integer:&nbsp;3,&nbsp;decimal:&nbsp;null</code>
</pre>


<h3>26.8 Conclusion</h3>


<p>In this chapter you saw how to generalize pattern matching
with extractors. Extractors let you define your own kinds of patterns,
which need not correspond to the type of the expressions you select
on. This gives you more flexibility in the kinds of patterns you can
use for matching. In effect it's like having different possible
views on the same data. It also gives you a layer between a type's
representation and the way clients view it. This lets you do pattern
matching while maintaining representation independence, a property
which is very useful in large software systems.</p>

<p>Extractors are one more element in your tool box that let you define
flexible library abstractions. They are used heavily in Scala's
libraries, for instance, to enable convenient regular expression
matching.</p>

<hr/>
<h4>Footnotes for Chapter 26:</h4>


<p><a id="footnotemain26-1"/>[1] As demonstrated here, where <pre class="code">Some</pre> is applied to the tuple, <pre class="code">(user,</pre>&nbsp;<pre class="code">domain)</pre>,
you can
leave off one pair of parentheses when passing a tuple to a function that takes a single argument. Thus, <pre class="code">Some(user,</pre>&nbsp;<pre class="code">domain)</pre> means the same as <pre class="code">Some((user,</pre>&nbsp;<pre class="code">domain))</pre>.</p>

<div style="page-break-after:always"/>


<div style="page-break-after:always"/>

</body>
</html>
